//==============================================================================
// Constants
//==============================================================================

// Temporary constants, to be deleted if implemented in C++

extern const int cNumResourceTypes = 3; // Gold, food, wood.
extern const float baselineHandicap =
    1.0; // This is the handicap given to cDifficultyHard.  Our intent is to ship with this at 1.0,
         // meaning that hard has no handicap advantage or penalty.
         // All other difficulty levels will be adjusted relative to this constant.  This means that
         // we can gradually reduce this number as the AI's competence increases, and all the difficulty levels will
         // respond.
extern int gMaxPop = 200; // Absolute hard limit pop cap for game...will be set lower on some difficulty levels
extern int cMaxSettlersPerFarm = 10;
extern int cMaxSettlersPerPlantation = 10;

// Start mode constants.
extern const int cStartModeScenarioNoTC = 0;  // Scenario, wait for aiStart unit, then play without a TC
extern const int cStartModeScenarioTC = 1;    // Scenario, wait for aiStart unit, then play with starting TC
extern const int cStartModeScenarioWagon = 2; // Scenario, wait for aiStart unit, then start TC build plan.
extern const int cStartModeBoat = 3; // RM or GC game, with a caravel start.  Wait to unload, then start TC build plan.
extern const int cStartModeLandTC = 4;    // RM or GC game, starting with a TC...just go.
extern const int cStartModeLandWagon = 5; // RM or GC game, starting with a wagon.  Explore, start TC build plan.

extern const int cMinResourcePerGatherer = 200; // When our supply gets below this level, start farming/plantations.

//==============================================================================
// Unused Global Variables that are not in any loader either
//==============================================================================
extern int gFarmBaseID = -1; // Current operating bases for each resource
extern int gFoodBaseID = -1;
extern int gGoldBaseID = -1;
extern int gWoodBaseID = -1;
extern int gNextFarmBaseID = -1; // Overflow operating bases for each resource
extern int gNextFoodBaseID = -1;
extern int gNextGoldBaseID = -1;
extern int gNextWoodBaseID = -1;
extern int gPrevFarmBaseID = -1; // Phasing-out bases for each resource
extern int gPrevFoodBaseID = -1;
extern int gPrevGoldBaseID = -1;
extern int gPrevWoodBaseID = -1;
extern bool gEarlyEconPhase = true; // Used to indicate that we're in a special startup econ phase, i.e. almost all food
                                    // for most civs. This is turned off when we decide it's time to go military, i.e
                                    // when we build a barracks or get attacked or reach age 2.
extern bool gGoldEmergency =
    false; // Set this true if we need a gold mine, and don't have enough wood.  Overrides econ to 100% wood.
extern int gTowerEscrowID = -1;
extern int gTransportUnit = cUnitTypeAbstractWarShip; // hard coded ship type for now
extern int gWaterTransportUnitMaintainPlan = -1;      // The plan that maintains all the ships
extern bool gWaterMap = false;                        // True when we are on a water map
extern int gNumberQueuedFoodPaddies = 0;
extern int gNumberQueuedGoldPaddies = 0;
extern int gNuggetMessagePercentage = 100;
extern int gPrimaryNavyUnit = -1;  // Main water unit type
extern int gSecndaryNavyUnit = -1; // Secondary water unit type
extern int gTertiaryNavyUnit = -1; // Tertiary water unit type
extern int gNumNavyUnitTypes = -1; // How many water unit types do we want to train?
extern int gcVPTypeAny = 0;
extern int gcVPTypeNative = cVPNative;
extern int gcVPTypeSecret = cVPSecret;
extern int gcVPTypeTrade = cVPTrade;

//==============================================================================
// Econ variables
//==============================================================================
extern int gDefaultDeck = -1;       // Home city deck used by each AI

extern bool gTimeToFarm = false;         // Set true when we start to run out of cheap early food.
extern bool gTimeForPlantations = false; // Set true when we start to run out of mine-able gold.

// Not really sure if these need to be a global variables.
extern float gTSFactorDistance = -200.0; // negative is good
extern float gTSFactorPoint = 5.0;       // positive is good
extern float gTSFactorTimeToDone = 0.0;  // positive is good
extern float gTSFactorBase = 100.0;      // positive is good
extern float gTSFactorDanger = -10.0;    // negative is good

extern int gEconUnit = cUnitTypeSettler;  // Economy unit, different per civ.
extern int gHouseUnit = cUnitTypeHouse;   // Housing unit, different per civ.
extern int gTowerUnit = cUnitTypeOutpost; // Tower unit, blockhouse for Russians
extern int gFarmUnit = cUnitTypeMill;     // Will be unitTypeFarm for natives and unitTypeypRicePaddy for Asians and unitTypedeField for Africans.
extern int gPlantationUnit = cUnitTypePlantation; // Will be unitTypeFarm for natives and unitTypeypRicePaddy for Asians and unitTypedeField for Africans.
extern int gLivestockPenUnit = cUnitTypeLivestockPen; // The Asians all have different ones.
extern int gCoveredWagonUnit = cUnitTypeCoveredWagon; // The Asians have a different type.
extern int gMarketUnit = cUnitTypeMarket;             // The Asians have a different type.
extern int gDockUnit = cUnitTypeDock;                 // The Asians have a different type.

extern bool gFlagChosen = false; // need to make sure they only build one

extern int gLastTribSentTime = 0;

extern int gEconUpgradePlan = -1;

extern int gVPEscrowID = -1;      // Used to reserve resources for accelerator building.
extern int gUpgradeEscrowID = -1; // Used to reserve ships for age upgrades

extern int gTCBuildPlanID = -1;

extern int gStartMode = -1; // See start mode constants, above.  This variable is set
                            // in main() and is used to decide which cascades of rules
                            // should be used to start the AI.

extern bool gGoodFishingMap = false; // Set in init(), can be overridden in postInit() if desired.  True indicates that
                                     // fishing is a good idea on this map.
extern int gFishingPlan = -1;        // Plan ID for main fishing plan.
extern int gFishingBoatMaintainPlan = -1;       // Fishing boats to maintain
extern int gFishingUnit = cUnitTypeFishingBoat; // Fishing Boat
extern bool gTimeToFish = false;                // Set to true when we want to start fishing.

extern int gHerdPlanID = -1;

extern int gSettlerMaintainPlan = -1; // Main plan to control settler population

extern int gWaterExplorePlan = -1;                    // Plan ID for ocean exploration plan

extern int gNavyDefendPlan = -1;
extern int gNavyAttackPlan = -1;

extern vector gTCSearchVector = cInvalidVector; // Used to define the center of the TC building placement search.
extern int gTCStartTime = 10000;                // Used to define when the TC build plan can go active.  In ms.

extern int gAgeUpResearchPlan =
    -1; // Plan used to send politician from HC, used to detect if an age upgrade is in progress.

extern int gAgeUpTime = 0;     // Time we entered this age
extern int gAgeUpPlanTime = 0; // Time to plan for next age up.

extern int gFeedGoldTo = -1; // If set, this indicates which player we need to be supplying with regular gold shipments.
extern int gFeedWoodTo = -1; // See commsHandler and monitorFeeding rule.
extern int gFeedFoodTo = -1;

extern const int cForwardBaseStateNone = -1;    // None exists, none in progress
extern const int cForwardBaseStateBuilding = 0; // Fort wagon exists, but no fort yet.
extern const int cForwardBaseStateActive = 1;   // Base is active, defend and train plans there.
extern int gForwardBaseState = cForwardBaseStateNone;
extern int gForwardBaseID = -1;                      // Set when state goes to Active
extern vector gForwardBaseLocation = cInvalidVector; // Set when state goes to 'building' or earlier.
extern int gForwardBaseBuildPlan = -1;
extern int gForwardBaseUpTime = -600000;
extern bool gForwardBaseShouldDefend = false;

extern int gNativeDancePlan = -1;
extern int gNumberFoodPaddies = 0; // Used in calcs but never set to anything else than 0.
extern int gNumberGoldPaddies = 0; // Used in calcs but never set to anything else than 0.

extern bool gEarlyHunts = false;
extern int gResourceNeeds = -1;
extern int gExtraResourceNeeds = -1;
extern bool gLowOnResources = false;
extern bool gExcessResources = true;

extern int gGatherPlanPriorityHunt = 80;
extern int gGatherPlanPriorityBerry = 81;
extern int gGatherPlanPriorityMill = 82;
extern int gGatherPlanPriorityWood = 81;
extern int gGatherPlanPriorityMine = 78;
extern int gGatherPlanPriorityEstate = 83;
extern int gGatherPlanPriorityFish = 20;
extern int gGatherPlanPriorityWhale = 19;

extern int gGatherPlanNumHuntPlans = 0;
extern int gGatherPlanNumBerryPlans = 0;
extern int gGatherPlanNumMillPlans = 0;
extern int gGatherPlanNumWoodPlans = 0;
extern int gGatherPlanNumMinePlans = 0;
extern int gGatherPlanNumEstatePlans = 0;
extern int gGatherPlanNumFishPlans = 0;
extern int gGatherPlanNumWhalePlans = 0;

extern int gAdjustBreakdownAttempts = -1;
extern bool gDisableWoods = false;              // Disable wood gathering and buy wood with gold from the market.
extern float gGoldPercentageToBuyForWood = 0.0; // Percentage of gold to buy for wood.

//==============================================================================
// Military variables
//==============================================================================
extern int gLandDefendPlan0 = -1; // Primary land defend plan
extern int gLandReservePlan = -1; // Reserve defend plan, gathers units for use in the next military mission
// extern int  gWaterDefendPlan0 = -1;    // Primary water defend plan

extern bool gDefenseReflex = false; // Set true when a defense reflex is overriding normal ops.
extern bool gDefenseReflexPaused =
    false; // Set true when we're in a defense reflex, but overwhelmed, so we're hiding to rebuild an army.
extern int gDefenseReflexBaseID = -1;                  // Set to the base ID that we're defending in this emergency
extern vector gDefenseReflexLocation = cInvalidVector; // Location we're defending in this emergency
extern int gDefenseReflexTimeout = 0;

extern int gLandUnitPicker = -1;         // Picks the best land military units to train.
extern int gMainAttackGoal = -1;         // Attack goal monitors opportunities, launches missions.
extern int gLandMilUnitUpgradePlan = -1; // The plan ID of the most recent unit upgrade plan
extern int gArtilleryMaintainPlan = -1;  // Manual plan to force building of some siege.

extern int gCaravelMaintain = -1; // Maintain plans for naval units.
extern int gGalleonMaintain = -1;
extern int gFrigateMaintain = -1;
extern int gMonitorMaintain = -1;
extern int gWaterExploreMaintain = -1;

extern int gCaravelUnit = cUnitTypeCaravel; // Will be Galley for Ottomans
extern int gGalleonUnit = cUnitTypeGalleon; // Will be Fluyt for Dutch
extern int gFrigateUnit = cUnitTypeFrigate; // Will be Tekkousen for Japanese
extern int gMonitorUnit = cUnitTypeMonitor; // Will be Ironclad for Americans

extern bool gNavyMap = false; // Setting this false prevents navies
extern const int cNavyModeOff = 0;
// extern const int cNavyModeExplore = 1;
extern const int cNavyModeActive = 2;
extern int gNavyMode = cNavyModeOff; // Tells us whether we're making no navy, just an exploring ship, or a full navy.
extern vector gNavyVec = cInvalidVector; // The center of the navy's operations.

extern int gPrimaryArmyUnit = -1;  // Main land unit type
extern int gSecondaryArmyUnit = -1; // Secondary land unit type
extern int gTertiaryArmyUnit = -1; // Tertiary land unit type
extern int gNumArmyUnitTypes = 3;  // How many land unit types do we want to train?

extern int gGoodArmyPop =
    -1; // This number is updated by the pop manager, to give a ballpark feel for the pop count needed to create a
        // credible attack army.  It is based on military pop allowed and game time, and is very sensitive to difficulty
        // level. This is used by the strategyMaster rule to help decide when certain mission types make sense.  For
        // example, if your available military pop is only 1/2 of gGoodArmyPop, a base attack would be foolish, but
        // villager raiding or claiming a VP site might be good choices.

extern int gUnitPickSource = cOpportunitySourceAutoGenerated; // Indicates who decides which units are being
                                                              // trained...self, trigger, or ally player.
extern int gUnitPickPlayerID = -1; // If the source is cOpportunitySourceAllyRequest, this will hold the player ID.

extern int gMostRecentAllyOpportunityID =
    -1; // Which opportunity (if any) was created by an ally?  (Only one at a time allowed.)
extern int gMostRecentTriggerOpportunityID =
    -1; // Which opportunity (if any) was created by a trigger?  (Only one at a time allowed.)

// How do we get rid of all these missions?
extern int gLastClaimMissionTime = -1;
extern int gLastClaimTradeMissionTime = -1;
extern int gLastClaimNativeMissionTime = -1;
extern int gLastAttackMissionTime = -1;
extern int gLastDefendMissionTime = -1;
extern int gClaimMissionInterval =
    600000; // 10 minutes.  This variable indicates how long it takes for claim opportunities to score their maximum.
            // Typically, a new one will launch before this time.
extern int gClaimTradeMissionInterval = 300000;  // 5 minutes.
extern int gClaimNativeMissionInterval = 600000; // 10 minutes.

extern int gAttackMissionInterval =
    180000; // 2-3 minutes depending on difficulty level.  Suppresses attack scores (linearly) for 2-3 minutes after one
            // launches.  Attacks will usually happen before this period is over.
extern int gDefendMissionInterval =
    300000;                        // 5 minutes.   Makes the AI less likely to do another defend right after doing one.
extern bool gDelayAttacks = false; // Can be used on low difficulty levels to prevent attacks before the AI is attacked.
                                   // (AI is defend-only until this variable is set false.
extern int gCommAttackDefendBaseID = -1;  // The base to attack or defend given by flare.
extern int gNumEnemies = -1; 		// Used to pick a target to attack.
extern int gArrayEnemyPlayerIDs = -1; // Used to pick a target to attack.
extern int gStartingPosDistances = -1; // Used to sort enemies from closest to furthest away for target picking in FFA.

extern int  gLandPrimaryArmyUnit = -1;     // Main land unit type
extern int  gLandSecondaryArmyUnit = -1;    // Secondary land unit type
extern int  gLandTertiaryArmyUnit = -1;    // Tertiary land unit type
extern int  gAbstractArtilleryUnit = cUnitTypeFalconet;
extern int  gAbstractAssassinUnit = cUnitTypexpSpy;
extern int  gAbstractCounterArtilleryUnit = cUnitTypeCulverin;
extern int gInitialStrategy = -1;
extern int gBarracksUnit = cUnitTypeBarracks;
extern int gStableUnit = cUnitTypeStable;
extern int gArtilleryDepotUnit = cUnitTypeArtilleryDepot;
extern int gSiegeWeaponUnit = cUnitTypeMortar;
extern int gExplorerUnit = cUnitTypeExplorer;
extern int gBaseAttackPlan = -1;
extern vector gBaseAttackLocation = cInvalidVector;
extern bool gJapaneseIsAlly = false;  //this globle varible is used to determine when for AI players to cease hunting if Japanese is in ally's team, for AI's villagers always try to hunt animals at a shrine. 
extern bool gJapaneseIsEnemy = false;
extern bool gIndianIsAlly = false;
extern vector gHousePosition = cInvalidVector;
extern int  gTowerWagonUnit = cUnitTypeOutpostWagon;
extern int  gWallnonp = -1;				
extern int  gAgeUpPriority = -1;				
//==============================================================================
// Other global variables
//==============================================================================
extern bool gSPC = false;             // Set true in main if this is an spc or campaign game
extern int gExplorerControlPlan = -1; // Defend plan set up to control the explorer's location
extern int gLandExplorePlan = -1;     // Primary land exploration

extern int gMainBase = -1;

extern bool gIAmCaptain = false;
extern int gCaptainPlayerNumber = -1;

extern int gResignType = -1; // Reason for AI requesting permission to resign

extern bool gBuildWalls = false; // Global indicating if we're walling up or not.
extern int gNumTowers = -1;      // How many towers do we want to build?
extern int gPrevNumTowers = -1;  // Set when a command is received, to allow resetting when a cancel is received.

extern bool gIsMonopolyRunning = false; // Set true while a monopoly countdown is in effect.
extern int gMonopolyTeam = -1;          // TeamID of team that will win if the monopoly timer completes.
extern int gMonopolyEndTime = -1;       // Gametime when current monopoly should end

extern bool gIsKOTHRunning = false; // Set true while a KOTH countdown is in effect.
extern int gKOTHTeam = -1;          // TeamID of team that will win if the KOTH timer completes.

extern const float PI = 3.1415926;

extern int gIslandExploreTransportScoutID = -1;
extern const int cRevolutionMilitary = 1;
extern const int cRevolutionEconomic = 2;
extern const int cRevolutionFinland = 4;
extern int gRevolutionType = 0;
extern vector gTorpPosition = cInvalidVector;
extern int gTorpPositionsToAvoid = -1;
extern int gMilitaryBuildings = -1;
extern int gArmyUnitBuildings = -1;
extern int gArmyUnitMaintainPlans = -1;
extern bool gIslandMap = false;                   // Does this map have lands with waters in between?
extern bool gStartOnDifferentIslands = false;     // Does this map have players starting on different islands?
extern int gDifficultyExpert = cDifficultyExpert; // Equivalent of expert difficulty, hard for SPC content.
extern int gFullGranaries = -1;                   // List of granaries surrounded by fields
extern int gFieldGranaryID = -1;                  // The current granary chosen to build a field nearby
extern int gQueuedBuildPlans = -1;

// Hausa
extern const int cAllianceBerbersIndex = 0;
extern const int cAllianceHausaIndex = 1;
extern const int cAllianceSonghaiIndex = 2;
extern const int cAllianceAkanIndex = 3;
extern const int cAllianceBritishIndex = 4;

// Ethiopia
extern const int cAllianceSomalisIndex = 0;
extern const int cAlliancePortugueseIndex = 1;
extern const int cAllianceSudaneseIndex = 2;
extern const int cAllianceJesuitIndex = 3;
extern const int cAllianceOromoIndex = 4;

//==============================================================================
// Function forward declarations.
//
// Used in loader file to override default values, called at start of main()
mutable void preInit(void) {}

// Used in loader file to override initialization decisions, called at end of main()
mutable void postInit(void) {}

mutable void econMaster(int mode = -1, int value = -1) {}
mutable void shipGrantedHandler(int parm = -1) {}
mutable int initUnitPicker(string name = "BUG", int numberTypes = 1, int minUnits = 10, int maxUnits = 20,
                           int minPop = -1, int maxPop = -1, int numberBuildings = 1, bool guessEnemyUnitType = false)
{
   return (-1);
}

mutable void setUnitPickerCommon(int upID = -1) {}
mutable void setUnitPickerPreference(int upID = -1) {}
mutable void endDefenseReflex(void) {}
mutable void selectTowerBuildPlanPosition(int buildPlan = -1, int baseID = -1) {}
mutable void selectShrineBuildPlanPosition(int planID = -1, int baseID = -1) {}
mutable void selectTorpBuildPlanPosition(int planID = -1, int baseID = -1) {}
mutable void selectTCBuildPlanPosition(int buildPlan = -1, int baseID = -1) {}
mutable void selectTradingLodgeBuildPlanPosition(int buildPlan = -1, int baseID = -1) {}
mutable float getBaseEnemyStrength(int baseID = -1) { return (0.0); }
mutable float getPointAllyStrength(vector loc = cInvalidVector) { return (0.0); }
mutable float getBaseValue(int baseID = -1) { return (0.0); }
mutable float getPointValue(vector loc = cInvalidVector, int relation = cPlayerRelationEnemyNotGaia) { return (0.0); }
mutable float getPlanStrength(int planID = -1) { return (0.0); }
mutable float getUnitListStrength(int unitList = -1) { return (0.0); }
mutable float getUnitListValue(int unitList = -1) { return (0.0); }
mutable void transportShipmentArrive(int techID = -1) {}
mutable void addUnitsToMilitaryPlan(int planID = -1) {}
mutable float getMilitaryUnitStrength(int puid = -1) { return (0.0); }
mutable bool selectFieldBuildPlanPosition(int planID = -1, int baseID = -1) { return (false); }
mutable void selectMountainMonasteryBuildPlanPosition(int planID = -1, int baseID = -1) {}
mutable void selectGranaryBuildPlanPosition(int planID = -1, int baseID = -1) {}
mutable void selectClosestBuildPlanPosition(int planID = -1, int baseID = -1) {}

//==============================================================================
// Global Arrays
//==============================================================================

extern int gMapNames = -1; // An array of random map names, so we can store ID numbers in player histories

extern int gTargetSettlerCounts = -1; // How many settlers do we want per age?

extern int gConsulateTechs = -1;     // List of all the consulate techs
extern int gConsulateTechsSize = -1; // Size of the list of all the consulate techs

extern int gAsianWonders = -1; // List of wonders for the asian civs

extern int gAge2PoliticianList = -1; // List of Age 2 European politicians
extern int gAge3PoliticianList = -1; // List of Age 3 European politicians
extern int gAge4PoliticianList = -1; // List of Age 4 European politicians
extern int gAge5PoliticianList = -1; // List of Age 5 European politicians

extern int gAge2WonderList = -1; // List of Age 2 Asian age-up wonders
extern int gAge3WonderList = -1; // List of Age 3 Asian age-up wonders
extern int gAge4WonderList = -1; // List of Age 4 Asian age-up wonders
extern int gAge5WonderList = -1; // List of Age 5 Asian age-up wonders

extern int gAge2WonderTechList = -1; // List of Age 2 Asian age-up technologies
extern int gAge3WonderTechList = -1; // List of Age 3 Asian age-up technologies
extern int gAge4WonderTechList = -1; // List of Age 4 Asian age-up technologies
extern int gAge5WonderTechList = -1; // List of Age 5 Asian age-up technologies

extern int gRevolutionList = -1; // List of Revolutions

extern int gAgeUpPoliticians = -1;      // Array of available age-up politicians
extern int gPoliticianScores = -1;      // Array used to calculate "scores" for different European politicians
extern int gNatCouncilScores = -1;      // Array used to calculate "scores" for different native council members
extern int gAsianWonderScores = -1;     // Array used to calculate "scores" for different Asian wonders
extern int gAfricanAlliances = -1;      // Array used to select from the different African alliances
extern int gAfricanAlliancesAgedUpWith = 1; // Array of Alliances we've aged up with so far this game.
extern int gAfricanAlliancesUpgrades = 1;   // Array of statuses of upgrades gained via Alliances. True is researched false is not researched.

//==============================================================================
/* initArrays()
   Initialize all global arrays here, to make it easy to find var type and size.
*/
//==============================================================================
void initArrays(void)
{
   gMapNames = xsArrayCreateString(165, "", "Map names");
   xsArraySetString(gMapNames, 0, "afatlas");
   xsArraySetString(gMapNames, 1, "afatlaslarge");
   xsArraySetString(gMapNames, 2, "afdarfur");
   xsArraySetString(gMapNames, 3, "afdarfurlarge");
   xsArraySetString(gMapNames, 4, "afdunes");
   xsArraySetString(gMapNames, 5, "afduneslarge");
   xsArraySetString(gMapNames, 6, "afgold coast");
   xsArraySetString(gMapNames, 7, "afgold coastlarge");
   xsArraySetString(gMapNames, 8, "afgreat rift");
   xsArraySetString(gMapNames, 9, "afgreat riftlarge");
   xsArraySetString(gMapNames, 10, "afhighlands");
   xsArraySetString(gMapNames, 11, "afhighlandslarge");
   xsArraySetString(gMapNames, 12, "afhorn");
   xsArraySetString(gMapNames, 13, "afhornlarge");
   xsArraySetString(gMapNames, 14, "afivorycoast");
   xsArraySetString(gMapNames, 15, "afivorycoastlarge");
   xsArraySetString(gMapNames, 16, "aflakechad");
   xsArraySetString(gMapNames, 17, "aflakechadlarge");
   xsArraySetString(gMapNames, 18, "afnigerdelta");
   xsArraySetString(gMapNames, 19, "afnigerdeltalarge");
   xsArraySetString(gMapNames, 20, "afniger river");
   xsArraySetString(gMapNames, 21, "afniger riverlarge");
   xsArraySetString(gMapNames, 22, "afnile valley");
   xsArraySetString(gMapNames, 23, "afnile valleylarge");
   xsArraySetString(gMapNames, 24, "afpeppercoast");
   xsArraySetString(gMapNames, 25, "afpeppercoastlarge");
   xsArraySetString(gMapNames, 26, "afsahel");
   xsArraySetString(gMapNames, 27, "afsahellarge");
   xsArraySetString(gMapNames, 28, "afsavanna");
   xsArraySetString(gMapNames, 29, "afsavannalarge");
   xsArraySetString(gMapNames, 30, "afsiwaoasis");
   xsArraySetString(gMapNames, 31, "afsiwaoasislarge");
   xsArraySetString(gMapNames, 32, "afsudd");
   xsArraySetString(gMapNames, 33, "afsuddlarge");
   xsArraySetString(gMapNames, 34, "afswahilicoast");
   xsArraySetString(gMapNames, 35, "afswahilicoastlarge");
   xsArraySetString(gMapNames, 36, "aftassili");
   xsArraySetString(gMapNames, 37, "aftassililarge");
   xsArraySetString(gMapNames, 38, "aftripolitania");
   xsArraySetString(gMapNames, 39, "aftripolitanialarge");
   xsArraySetString(gMapNames, 40, "alaska");
   xsArraySetString(gMapNames, 41, "alaskalarge");
   xsArraySetString(gMapNames, 42, "amazonia");
   xsArraySetString(gMapNames, 43, "amazonialarge");
   xsArraySetString(gMapNames, 44, "andes upper");
   xsArraySetString(gMapNames, 45, "andes upperlarge");
   xsArraySetString(gMapNames, 46, "andes");
   xsArraySetString(gMapNames, 47, "andeslarge");
   xsArraySetString(gMapNames, 48, "araucania");
   xsArraySetString(gMapNames, 49, "araucanialarge");
   xsArraySetString(gMapNames, 50, "arctic territories");
   xsArraySetString(gMapNames, 51, "arctic territorieslarge");
   xsArraySetString(gMapNames, 52, "bahia");
   xsArraySetString(gMapNames, 53, "bahialarge");
   xsArraySetString(gMapNames, 54, "baja california");
   xsArraySetString(gMapNames, 55, "baja californialarge");
   xsArraySetString(gMapNames, 56, "bayou");
   xsArraySetString(gMapNames, 57, "bayoularge");
   xsArraySetString(gMapNames, 58, "bengal");
   xsArraySetString(gMapNames, 59, "bengallarge");
   xsArraySetString(gMapNames, 60, "borneo");
   xsArraySetString(gMapNames, 61, "borneolarge");
   xsArraySetString(gMapNames, 62, "california");
   xsArraySetString(gMapNames, 63, "californialarge");
   xsArraySetString(gMapNames, 64, "caribbean");
   xsArraySetString(gMapNames, 65, "caribbeanlarge");
   xsArraySetString(gMapNames, 66, "carolina");
   xsArraySetString(gMapNames, 67, "carolinalarge");
   xsArraySetString(gMapNames, 68, "cascade range");
   xsArraySetString(gMapNames, 69, "cascade rangelarge");
   xsArraySetString(gMapNames, 70, "central plain");
	xsArraySetString(gMapNames, 71, "central plainlarge");
   xsArraySetString(gMapNames, 72, "ceylon");
   xsArraySetString(gMapNames, 73, "ceylonlarge");
   xsArraySetString(gMapNames, 74, "colorado");
   xsArraySetString(gMapNames, 75, "coloradolarge");
   xsArraySetString(gMapNames, 76, "dakota");
   xsArraySetString(gMapNames, 77, "dakotalarge");
   xsArraySetString(gMapNames, 78, "deccan");
   xsArraySetString(gMapNames, 79, "deccanLarge");
   xsArraySetString(gMapNames, 80, "fertile crescent");
   xsArraySetString(gMapNames, 81, "fertile crescentlarge");
   xsArraySetString(gMapNames, 82, "florida");
   xsArraySetString(gMapNames, 83, "floridalarge");
   xsArraySetString(gMapNames, 84, "gran chaco");
   xsArraySetString(gMapNames, 85, "gran chacolarge");
   xsArraySetString(gMapNames, 86, "great lakes");
   xsArraySetString(gMapNames, 87, "greak lakesLarge");
   xsArraySetString(gMapNames, 88, "great plains");
   xsArraySetString(gMapNames, 89, "great plainslarge");
   xsArraySetString(gMapNames, 90, "himalayas");
   xsArraySetString(gMapNames, 91, "himalayaslarge");
   xsArraySetString(gMapNames, 92, "himalayasupper");
   xsArraySetString(gMapNames, 93, "himalayasupperlarge");
   xsArraySetString(gMapNames, 94, "hispaniola");
   xsArraySetString(gMapNames, 95, "hispaniolalarge");
   xsArraySetString(gMapNames, 96, "hokkaido");
   xsArraySetString(gMapNames, 97, "hokkaidolarge");
   xsArraySetString(gMapNames, 98, "honshu");
   xsArraySetString(gMapNames, 99, "honshularge");
   xsArraySetString(gMapNames, 100, "honshuregicide");
   xsArraySetString(gMapNames, 101, "honshuregicidelarge");
   xsArraySetString(gMapNames, 102, "indochina");
   xsArraySetString(gMapNames, 103, "indochinalarge");
   xsArraySetString(gMapNames, 104, "indonesia");
   xsArraySetString(gMapNames, 105, "indonesialarge");
   xsArraySetString(gMapNames, 106, "kamchatka");
   xsArraySetString(gMapNames, 107, "kamchatkalarge");
   xsArraySetString(gMapNames, 108, "korea");
   xsArraySetString(gMapNames, 109, "korealarge");
   xsArraySetString(gMapNames, 110, "malaysia");
   xsArraySetString(gMapNames, 111, "malaysialarge");
   xsArraySetString(gMapNames, 112, "manchuria");
   xsArraySetString(gMapNames, 113, "manchurialarge");
   xsArraySetString(gMapNames, 114, "mexico");
   xsArraySetString(gMapNames, 115, "mexicolarge");
   xsArraySetString(gMapNames, 116, "minasgerais");
   xsArraySetString(gMapNames, 117, "minasgeraislarge");
   xsArraySetString(gMapNames, 118, "mongolia");
   xsArraySetString(gMapNames, 119, "mongolialarge");
   xsArraySetString(gMapNames, 120, "new england");
	xsArraySetString(gMapNames, 121, "new englandlarge");
   xsArraySetString(gMapNames, 122, "northwest territory");
   xsArraySetString(gMapNames, 123, "northwest territorylarge");
   xsArraySetString(gMapNames, 124, "orinoco");
   xsArraySetString(gMapNames, 125, "orinocolarge");
   xsArraySetString(gMapNames, 126, "ozarks");
   xsArraySetString(gMapNames, 127, "ozarkslarge");
   xsArraySetString(gMapNames, 128, "painted desert");
   xsArraySetString(gMapNames, 129, "painted desertlarge");
   xsArraySetString(gMapNames, 130, "pampas sierras");
   xsArraySetString(gMapNames, 131, "pampas sierraslarge");
   xsArraySetString(gMapNames, 132, "pampas");
   xsArraySetString(gMapNames, 133, "pampas large");
   xsArraySetString(gMapNames, 134, "parallel rivers");
   xsArraySetString(gMapNames, 135, "parallel riverslarge");
   xsArraySetString(gMapNames, 136, "patagonia");
   xsArraySetString(gMapNames, 137, "patagonialarge");
   xsArraySetString(gMapNames, 138, "plymouth");
   xsArraySetString(gMapNames, 139, "plymouthlarge");
   xsArraySetString(gMapNames, 140, "punjab");
	xsArraySetString(gMapNames, 141, "punjablarge");
   xsArraySetString(gMapNames, 142, "rockies");
   xsArraySetString(gMapNames, 143, "rockieslarge");
   xsArraySetString(gMapNames, 144, "saguenay");
   xsArraySetString(gMapNames, 145, "saguenaylarge");
   xsArraySetString(gMapNames, 146, "siberia");
   xsArraySetString(gMapNames, 147, "siberialarge");
   xsArraySetString(gMapNames, 148, "silkroad");
   xsArraySetString(gMapNames, 149, "silkroadlarge");
   xsArraySetString(gMapNames, 150, "sonora");
   xsArraySetString(gMapNames, 151, "sonoralarge");
   xsArraySetString(gMapNames, 152, "texas");
   xsArraySetString(gMapNames, 153, "texaslarge");
   xsArraySetString(gMapNames, 154, "unknown");
   xsArraySetString(gMapNames, 155, "unknownlarge");
   xsArraySetString(gMapNames, 156, "yellow riverdry");
   xsArraySetString(gMapNames, 157, "yellow riverdrylarge");
   xsArraySetString(gMapNames, 158, "yucatan");
   xsArraySetString(gMapNames, 159, "yucatanlarge");
   xsArraySetString(gMapNames, 160, "yukon");
	xsArraySetString(gMapNames, 161, "yukonlarge");
	// List above is up to date for the October 2021 patch.

   gTargetSettlerCounts = xsArrayCreateInt(cAge5 + 1, 0, "Target Settler Counts");
   xsArraySetInt(gTargetSettlerCounts, cAge1, 20);
   xsArraySetInt(gTargetSettlerCounts, cAge2, 45);
   xsArraySetInt(gTargetSettlerCounts, cAge3, 99);
   xsArraySetInt(gTargetSettlerCounts, cAge4, 99);
   xsArraySetInt(gTargetSettlerCounts, cAge5, 99);
   
   gArrayEnemyPlayerIDs = xsArrayCreateInt(cNumberPlayers - 2, -1, "Enemy Player IDs");
   gStartingPosDistances = xsArrayCreateFloat(cNumberPlayers, 0.0, "Player Starting Position Distances");
	vector startLoc = kbGetPlayerStartingPosition(cMyID);

   for (i = 1; < cNumberPlayers)
      xsArraySetFloat(gStartingPosDistances, i, xsVectorLength(startLoc - kbGetPlayerStartingPosition(i)));
   
   // BHG: JFR: if we are in deathmatch we dont want to research the consulate tech that takes us to age 5
   if (aiGetGameMode() == cGameModeDeathmatch)
   {
      gConsulateTechsSize = 32;
   }
   else
   {
      gConsulateTechsSize = 33;
   }
   //...BHG: JFR:

   gConsulateTechs = xsArrayCreateInt(40, 0, "Consulate Tech IDs");
   xsArraySetInt(gConsulateTechs, 0, cTechypConsulateBritishBrigade);
   xsArraySetInt(gConsulateTechs, 1, cTechypConsulateBritishLifeGuards);
   xsArraySetInt(gConsulateTechs, 2, cTechypConsulateBritishRedcoats);
   xsArraySetInt(gConsulateTechs, 3, cTechypConsulateBritishRogersRangers);
   xsArraySetInt(gConsulateTechs, 4, cTechypConsulateDutchBrigade);
   xsArraySetInt(gConsulateTechs, 5, cTechypConsulateFrenchBrigade);
   xsArraySetInt(gConsulateTechs, 6, cTechypConsulateFrenchCoinCrates);
   xsArraySetInt(gConsulateTechs, 7, cTechypConsulateFrenchFoodCrates);
   xsArraySetInt(gConsulateTechs, 8, cTechypConsulateFrenchHotAirBalloonsPreq);
   xsArraySetInt(gConsulateTechs, 9, cTechypConsulateFrenchWoodCrates);
   xsArraySetInt(gConsulateTechs, 10, cTechypConsulateGermansBrigade);
   xsArraySetInt(gConsulateTechs, 11, cTechypConsulateGermansCoinTrickle);
   xsArraySetInt(gConsulateTechs, 12, cTechypConsulateGermansFoodTrickle);
   xsArraySetInt(gConsulateTechs, 13, cTechypConsulateGermansWoodTrickle);
   xsArraySetInt(gConsulateTechs, 14, cTechypConsulateJapaneseKoujou);
   xsArraySetInt(gConsulateTechs, 15, cTechypConsulateJapaneseMilitaryRickshaw);
   xsArraySetInt(gConsulateTechs, 16, cTechypConsulateJapaneseMasterTraining);
   xsArraySetInt(gConsulateTechs, 17, cTechypConsulateOttomansBrigade);
   xsArraySetInt(gConsulateTechs, 18, cTechypConsulateOttomansGunpowderSiege);
   xsArraySetInt(gConsulateTechs, 19, cTechypConsulateOttomansInfantrySpeed);
   xsArraySetInt(gConsulateTechs, 20, cTechypConsulateOttomansSettlerCombat);
   xsArraySetInt(gConsulateTechs, 21, cTechypConsulatePortugueseBrigade);
   xsArraySetInt(gConsulateTechs, 22, cTechypConsulatePortugueseExpeditionaryFleet);
   xsArraySetInt(gConsulateTechs, 23, cTechypConsulatePortugueseExplorationFleet);
   xsArraySetInt(gConsulateTechs, 24, cTechypConsulatePortugueseFishingFleet);
   xsArraySetInt(gConsulateTechs, 25, cTechypConsulateRussianBrigade);
   xsArraySetInt(gConsulateTechs, 26, cTechypConsulateRussianFactoryWagon);
   xsArraySetInt(gConsulateTechs, 27, cTechypConsulateRussianFortWagon);
   xsArraySetInt(gConsulateTechs, 28, cTechypConsulateSpanishBrigade);
   xsArraySetInt(gConsulateTechs, 29, cTechypConsulateSpanishEnhancedProfits);
   xsArraySetInt(gConsulateTechs, 30, cTechypConsulateSpanishFasterShipments);
   xsArraySetInt(gConsulateTechs, 31, cTechypConsulateSpanishMercantilism);
   // BHG: JFR: if we are in deatmatch we dont want to research the consulate tech that takes us to age 5...
   if (aiGetGameMode() != cGameModeDeathmatch)
   {
      xsArraySetInt(gConsulateTechs, 32, cTechypConsulateJapaneseMeijiRestoration);
   }
   //...BHG: JFR:

   gAsianWonders = xsArrayCreateInt(5, 0, "Wonder Age IDs");
   int wonderchoice = aiRandInt(4);
if ((cMyCiv == cCivJapanese) || (cMyCiv == cCivSPCJapanese) || (cMyCiv == cCivSPCJapaneseEnemy))
   {
			xsArraySetInt(gAsianWonders, 0, cUnitTypeypWJToshoguShrine2);
            xsArraySetInt(gAsianWonders, 1, cUnitTypeypWJToriiGates3);
            xsArraySetInt(gAsianWonders, 2, cUnitTypeypWJGoldenPavillion4);
            xsArraySetInt(gAsianWonders, 3, cUnitTypeypWJShogunate5);
			/*											
      // Giant Buddha, Golden Pavillion, Shogunate, Torii Gates, Toshogu Shrine
      if (btRushBoom > 0)
      {
         if (wonderchoice == 0)
         {
            xsArraySetInt(gAsianWonders, 0, cUnitTypeypWJGoldenPavillion2);
            xsArraySetInt(gAsianWonders, 1, cUnitTypeypWJToshoguShrine3);
            xsArraySetInt(gAsianWonders, 2, cUnitTypeypWJShogunate4);
            xsArraySetInt(gAsianWonders, 3, cUnitTypeypWJToriiGates5);
         }
         else if (wonderchoice == 1)
         {
            xsArraySetInt(gAsianWonders, 0, cUnitTypeypWJToshoguShrine2);
            xsArraySetInt(gAsianWonders, 1, cUnitTypeypWJGoldenPavillion3);
            xsArraySetInt(gAsianWonders, 2, );
            xsArraySetInt(gAsianWonders, 3, cUnitTypeypWJToriiGates5);
         }
         else if (wonderchoice == 2)
         {
            xsArraySetInt(gAsianWonders, 0, cUnitTypeypWJToshoguShrine2);
            xsArraySetInt(gAsianWonders, 1, cUnitTypeypWJShogunate3);
            xsArraySetInt(gAsianWonders, 2, cUnitTypeypWJGoldenPavillion4);
            xsArraySetInt(gAsianWonders, 3, cUnitTypeypWJGiantBuddha5);
         }
         else
         {
            xsArraySetInt(gAsianWonders, 0, cUnitTypeypWJToriiGates2);
            xsArraySetInt(gAsianWonders, 1, cUnitTypeypWJToshoguShrine3);
            xsArraySetInt(gAsianWonders, 2, cUnitTypeypWJGoldenPavillion4);
            xsArraySetInt(gAsianWonders, 3, cUnitTypeypWJShogunate5);
         }
      }
      else
      {
         if (wonderchoice == 0)
         {
            xsArraySetInt(gAsianWonders, 0, cUnitTypeypWJToshoguShrine2);
            xsArraySetInt(gAsianWonders, 1, cUnitTypeypWJGiantBuddha3);
            xsArraySetInt(gAsianWonders, 2, cUnitTypeypWJGoldenPavillion4);
            xsArraySetInt(gAsianWonders, 3, cUnitTypeypWJToriiGates5);
         }
         else if (wonderchoice == 1)
         {
            xsArraySetInt(gAsianWonders, 0, cUnitTypeypWJToshoguShrine2);
            xsArraySetInt(gAsianWonders, 1, cUnitTypeypWJGoldenPavillion3);
            xsArraySetInt(gAsianWonders, 2, cUnitTypeypWJShogunate4);
            xsArraySetInt(gAsianWonders, 3, cUnitTypeypWJToriiGates5);
         }
         else if (wonderchoice == 2)
         {
            xsArraySetInt(gAsianWonders, 0, cUnitTypeypWJToshoguShrine2);
            xsArraySetInt(gAsianWonders, 1, cUnitTypeypWJGoldenPavillion3);
            xsArraySetInt(gAsianWonders, 2, cUnitTypeypWJShogunate4);
            xsArraySetInt(gAsianWonders, 3, cUnitTypeypWJGiantBuddha5);
         }
         else
         {
            xsArraySetInt(gAsianWonders, 0, cUnitTypeypWJToshoguShrine2);
            xsArraySetInt(gAsianWonders, 1, cUnitTypeypWJGoldenPavillion3);
            xsArraySetInt(gAsianWonders, 2, cUnitTypeypWJGiantBuddha4);
            xsArraySetInt(gAsianWonders, 3, cUnitTypeypWJShogunate5);
         }
      }*/
   }
   if ((cMyCiv == cCivChinese) || (cMyCiv == cCivSPCChinese))
   {
      // Confucian Academy, Porcelain Tower, Summer Palace, Temple of Heaven, White Pagoda
      if (btRushBoom > 0)
      {
         if (wonderchoice == 0)
         {
            xsArraySetInt(gAsianWonders, 0, cUnitTypeypWCSummerPalace2);
            xsArraySetInt(gAsianWonders, 1, cUnitTypeypWCPorcelainTower3);
            xsArraySetInt(gAsianWonders, 2, cUnitTypeypWCConfucianAcademy4);
            xsArraySetInt(gAsianWonders, 3, cUnitTypeypWCTempleOfHeaven5);
         }
         else if (wonderchoice == 1)
         {
            xsArraySetInt(gAsianWonders, 0, cUnitTypeypWCSummerPalace2);
            xsArraySetInt(gAsianWonders, 1, cUnitTypeypWCConfucianAcademy3);
            xsArraySetInt(gAsianWonders, 2, cUnitTypeypWCPorcelainTower4);
            xsArraySetInt(gAsianWonders, 3, cUnitTypeypWCTempleOfHeaven5);
         }
         else if (wonderchoice == 2)
         {
            xsArraySetInt(gAsianWonders, 0, cUnitTypeypWCConfucianAcademy2);
            xsArraySetInt(gAsianWonders, 1, cUnitTypeypWCSummerPalace3);
            xsArraySetInt(gAsianWonders, 2, cUnitTypeypWCPorcelainTower4);
            xsArraySetInt(gAsianWonders, 3, cUnitTypeypWCWhitePagoda5);
         }
         else
         {
            xsArraySetInt(gAsianWonders, 0, cUnitTypeypWCSummerPalace2);
            xsArraySetInt(gAsianWonders, 1, cUnitTypeypWCConfucianAcademy3);
            xsArraySetInt(gAsianWonders, 2, cUnitTypeypWCWhitePagoda4);
            xsArraySetInt(gAsianWonders, 3, cUnitTypeypWCPorcelainTower5);
         }
      }
      else
      {
         if (wonderchoice == 0)
         {
            xsArraySetInt(gAsianWonders, 0, cUnitTypeypWCSummerPalace2);
            xsArraySetInt(gAsianWonders, 1, cUnitTypeypWCConfucianAcademy3);
            xsArraySetInt(gAsianWonders, 2, cUnitTypeypWCPorcelainTower4);
            xsArraySetInt(gAsianWonders, 3, cUnitTypeypWCTempleOfHeaven5);
         }
         else if (wonderchoice == 1)
         {
            xsArraySetInt(gAsianWonders, 0, cUnitTypeypWCSummerPalace2);
            xsArraySetInt(gAsianWonders, 1, cUnitTypeypWCConfucianAcademy3);
            xsArraySetInt(gAsianWonders, 2, cUnitTypeypWCPorcelainTower4);
            xsArraySetInt(gAsianWonders, 3, cUnitTypeypWCWhitePagoda5);
         }
         else if (wonderchoice == 2)
         {
            xsArraySetInt(gAsianWonders, 0, cUnitTypeypWCSummerPalace2);
            xsArraySetInt(gAsianWonders, 1, cUnitTypeypWCConfucianAcademy3);
            xsArraySetInt(gAsianWonders, 2, cUnitTypeypWCTempleOfHeaven4);
            xsArraySetInt(gAsianWonders, 3, cUnitTypeypWCPorcelainTower5);
         }
         else
         {
            xsArraySetInt(gAsianWonders, 0, cUnitTypeypWCSummerPalace2);
            xsArraySetInt(gAsianWonders, 1, cUnitTypeypWCPorcelainTower3);
            xsArraySetInt(gAsianWonders, 2, cUnitTypeypWCConfucianAcademy4);
            xsArraySetInt(gAsianWonders, 3, cUnitTypeypWCWhitePagoda5);
         }
      }
   }
   if ((cMyCiv == cCivIndians) || (cMyCiv == cCivSPCIndians))
   {
      // Agra Fort, Charminar Gate, Karni Mata, Taj Mahal, Tower of Victory
      if (btRushBoom > 0)
      {
         if (wonderchoice == 0)
         {
            xsArraySetInt(gAsianWonders, 0, cUnitTypeypWIAgraFort2);
            xsArraySetInt(gAsianWonders, 1, cUnitTypeypWICharminarGate3);
            xsArraySetInt(gAsianWonders, 2, cUnitTypeypWIKarniMata4);
            xsArraySetInt(gAsianWonders, 3, cUnitTypeypWITajMahal5);
         }
         else if (wonderchoice == 1)
         {
            xsArraySetInt(gAsianWonders, 0, cUnitTypeypWIAgraFort2);
            xsArraySetInt(gAsianWonders, 1, cUnitTypeypWIKarniMata3);
            xsArraySetInt(gAsianWonders, 2, cUnitTypeypWICharminarGate4);
            xsArraySetInt(gAsianWonders, 3, cUnitTypeypWITajMahal5);
         }
         else if (wonderchoice == 2)
         {
            xsArraySetInt(gAsianWonders, 0, cUnitTypeypWIAgraFort2);
            xsArraySetInt(gAsianWonders, 1, cUnitTypeypWIKarniMata3);
            xsArraySetInt(gAsianWonders, 2, cUnitTypeypWICharminarGate4);
            xsArraySetInt(gAsianWonders, 3, cUnitTypeypWITajMahal5);
         }
         else
         {
            xsArraySetInt(gAsianWonders, 0, cUnitTypeypWIKarniMata2);
            xsArraySetInt(gAsianWonders, 1, cUnitTypeypWICharminarGate3);
            xsArraySetInt(gAsianWonders, 2, cUnitTypeypWITowerOfVictory4);
            xsArraySetInt(gAsianWonders, 3, cUnitTypeypWITajMahal5);
         }
      }
      else
      {
         if (wonderchoice == 0)
         {
            xsArraySetInt(gAsianWonders, 0, cUnitTypeypWIAgraFort2);
            xsArraySetInt(gAsianWonders, 1, cUnitTypeypWIKarniMata3);
            xsArraySetInt(gAsianWonders, 2, cUnitTypeypWICharminarGate4);
            xsArraySetInt(gAsianWonders, 3, cUnitTypeypWITowerOfVictory5);
         }
         else if (wonderchoice == 1)
         {
            xsArraySetInt(gAsianWonders, 0, cUnitTypeypWIAgraFort2);
            xsArraySetInt(gAsianWonders, 1, cUnitTypeypWIKarniMata3);
            xsArraySetInt(gAsianWonders, 2, cUnitTypeypWITajMahal4);
            xsArraySetInt(gAsianWonders, 3, cUnitTypeypWITowerOfVictory5);
         }
         else if (wonderchoice == 2)
         {
            xsArraySetInt(gAsianWonders, 0, cUnitTypeypWIAgraFort2);
            xsArraySetInt(gAsianWonders, 1, cUnitTypeypWIKarniMata3);
            xsArraySetInt(gAsianWonders, 2, cUnitTypeypWICharminarGate4);
            xsArraySetInt(gAsianWonders, 3, cUnitTypeypWITajMahal5);
         }
         else
         {
            xsArraySetInt(gAsianWonders, 0, cUnitTypeypWIKarniMata2);
            xsArraySetInt(gAsianWonders, 1, cUnitTypeypWICharminarGate3);
            xsArraySetInt(gAsianWonders, 2, cUnitTypeypWITajMahal4);
            xsArraySetInt(gAsianWonders, 3, cUnitTypeypWITowerOfVictory5);
         }
      }
   }
   

   gAge2PoliticianList = xsArrayCreateInt(19, 0, "Age 2 Politician List");
   xsArraySetInt(gAge2PoliticianList, 0, cTechPoliticianGovernor);
   xsArraySetInt(gAge2PoliticianList, 1, cTechPoliticianQuartermaster);
   xsArraySetInt(gAge2PoliticianList, 2, cTechPoliticianNaturalist);
   xsArraySetInt(gAge2PoliticianList, 3, cTechPoliticianBishop);
   xsArraySetInt(gAge2PoliticianList, 4, cTechPoliticianPhilosopherPrince);
   // xsArraySetInt(gAge2PoliticianList, 5, cTechPoliticianBishopGerman);
   xsArraySetInt(gAge2PoliticianList, 5, cTechDEPoliticianLogisticianColonialBritish);
   xsArraySetInt(gAge2PoliticianList, 6, cTechDEPoliticianKnightColonial);
   xsArraySetInt(gAge2PoliticianList, 7, cTechDEPoliticianLogisticianColonialDutch);
   xsArraySetInt(gAge2PoliticianList, 8, cTechDEPoliticianLogisticianFrench);
   xsArraySetInt(gAge2PoliticianList, 9, cTechDEPoliticianLogisticianGerman);
   xsArraySetInt(gAge2PoliticianList, 10, cTechDEPoliticianLogisticianPortuguese);
   xsArraySetInt(gAge2PoliticianList, 11, cTechDEPoliticianLogisticianColonialRussian);
   xsArraySetInt(gAge2PoliticianList, 12, cTechDEPoliticianLogisticianSpanish);
   xsArraySetInt(gAge2PoliticianList, 13, cTechDEPoliticianLogisticianSwedish);
   xsArraySetInt(gAge2PoliticianList, 14, cTechDEPoliticianFederalMassachusetts);
   xsArraySetInt(gAge2PoliticianList, 15, cTechDEPoliticianFederalVirginia);
   xsArraySetInt(gAge2PoliticianList, 16, cTechDEPoliticianFederalDelaware);
   xsArraySetInt(gAge2PoliticianList, 17, cTechDEPoliticianFederalPennsylvania);
   xsArraySetInt(gAge2PoliticianList, 18, cTechDEPoliticianFederalRhodeIsland);

   gAge3PoliticianList = xsArrayCreateInt(29, 0, "Age 3 Politician List");
   xsArraySetInt(gAge3PoliticianList, 0, cTechPoliticianSergeantSpanish);
   xsArraySetInt(gAge3PoliticianList, 1, cTechPoliticianMohawk);
   xsArraySetInt(gAge3PoliticianList, 2, cTechPoliticianPirate);
   xsArraySetInt(gAge3PoliticianList, 3, cTechPoliticianAdventurerSpanish);
   xsArraySetInt(gAge3PoliticianList, 4, cTechPoliticianAdmiral);
   xsArraySetInt(gAge3PoliticianList, 5, cTechPoliticianExiledPrince);
   xsArraySetInt(gAge3PoliticianList, 6, cTechPoliticianMarksman);
   xsArraySetInt(gAge3PoliticianList, 7, cTechPoliticianAdmiralOttoman);
   xsArraySetInt(gAge3PoliticianList, 8, cTechPoliticianAdventurerBritish);
   xsArraySetInt(gAge3PoliticianList, 9, cTechPoliticianScout);
   xsArraySetInt(gAge3PoliticianList, 10, cTechPoliticianScoutRussian);
   xsArraySetInt(gAge3PoliticianList, 11, cTechPoliticianAdventurerRussian);
   xsArraySetInt(gAge3PoliticianList, 12, cTechPoliticianSergeantGerman);
   xsArraySetInt(gAge3PoliticianList, 13, cTechPoliticianMarksmanPortuguese);
   xsArraySetInt(gAge3PoliticianList, 14, cTechPoliticianMarksmanOttoman);
   xsArraySetInt(gAge3PoliticianList, 15, cTechPoliticianSergeantDutch);
   xsArraySetInt(gAge3PoliticianList, 16, cTechPoliticianBishopFortress);
   xsArraySetInt(gAge3PoliticianList, 17, cTechDEPoliticianInventorFortress);
   xsArraySetInt(gAge3PoliticianList, 18, cTechDEPoliticianPapalGuardBritish);
   xsArraySetInt(gAge3PoliticianList, 19, cTechDEPoliticianMercContractorFortressDutch);
   xsArraySetInt(gAge3PoliticianList, 20, cTechDEPoliticianMercContractorFortressOttoman);
   xsArraySetInt(gAge3PoliticianList, 21, cTechDEPoliticianMercContractorFortressPortuguese);
   xsArraySetInt(gAge3PoliticianList, 22, cTechDEPoliticianMarksmanSwedish);
   xsArraySetInt(gAge3PoliticianList, 23, cTechDEPoliticianInventorFortress);
   xsArraySetInt(gAge3PoliticianList, 24, cTechDEPoliticianFederalIndiana);
   xsArraySetInt(gAge3PoliticianList, 25, cTechDEPoliticianFederalMaryland);
   xsArraySetInt(gAge3PoliticianList, 26, cTechDEPoliticianFederalNewHampshire);
   xsArraySetInt(gAge3PoliticianList, 27, cTechDEPoliticianFederalTennessee);
   xsArraySetInt(gAge3PoliticianList, 28, cTechDEPoliticianFederalKentucky);

   gAge4PoliticianList = xsArrayCreateInt(38, 0, "Age 4 Politician List");
   xsArraySetInt(gAge4PoliticianList, 0, cTechPoliticianEngineer);
   xsArraySetInt(gAge4PoliticianList, 1, cTechPoliticianTycoon);
   xsArraySetInt(gAge4PoliticianList, 2, cTechPoliticianMusketeerSpanish);
   xsArraySetInt(gAge4PoliticianList, 3, cTechPoliticianCavalierSpanish);
   xsArraySetInt(gAge4PoliticianList, 4, cTechPoliticianGrandVizier);
   xsArraySetInt(gAge4PoliticianList, 5, cTechPoliticianWarMinisterSpanish);
   xsArraySetInt(gAge4PoliticianList, 6, cTechPoliticianViceroyBritish);
   xsArraySetInt(gAge4PoliticianList, 7, cTechPoliticianMusketeerBritish);
   xsArraySetInt(gAge4PoliticianList, 8, cTechPoliticianCavalierFrench);
   xsArraySetInt(gAge4PoliticianList, 9, cTechPoliticianMusketeerFrench);
   xsArraySetInt(gAge4PoliticianList, 10, cTechPoliticianWarMinisterRussian);
   xsArraySetInt(gAge4PoliticianList, 11, cTechPoliticianCavalierRussian);
   xsArraySetInt(gAge4PoliticianList, 12, cTechPoliticianMusketeerRussian);
   xsArraySetInt(gAge4PoliticianList, 13, cTechPoliticianCavalierGerman);
   xsArraySetInt(gAge4PoliticianList, 14, cTechPoliticianViceroyGerman);
   xsArraySetInt(gAge4PoliticianList, 15, cTechPoliticianEngineerPortuguese);
   xsArraySetInt(gAge4PoliticianList, 16, cTechPoliticianViceroyPortuguese);
   xsArraySetInt(gAge4PoliticianList, 17, cTechPoliticianMusketeerPortuguese);
   xsArraySetInt(gAge4PoliticianList, 18, cTechPoliticianCavalierDutch);
   xsArraySetInt(gAge4PoliticianList, 19, cTechPoliticianCavalierOttoman);
   xsArraySetInt(gAge4PoliticianList, 20, cTechPoliticianMusketeerDutch);
   xsArraySetInt(gAge4PoliticianList, 21, cTechPoliticianViceroyDutch);
   xsArraySetInt(gAge4PoliticianList, 22, cTechPoliticianTycoonAct3);
   xsArraySetInt(gAge4PoliticianList, 23, cTechPoliticianWarMinisterAct3);
   xsArraySetInt(gAge4PoliticianList, 24, cTechDEPoliticianLogistician);
   xsArraySetInt(gAge4PoliticianList, 25, cTechDEPoliticianPapalGuard);
   xsArraySetInt(gAge4PoliticianList, 26, cTechDEPoliticianLogisticianOttoman);
   xsArraySetInt(gAge4PoliticianList, 27, cTechDEPoliticianPapalGuardPortuguese);
   xsArraySetInt(gAge4PoliticianList, 28, cTechDEPoliticianLogisticianRussian);
   xsArraySetInt(gAge4PoliticianList, 29, cTechDEPoliticianPapalGuardSpanish);
   xsArraySetInt(gAge4PoliticianList, 30, cTechDEPoliticianMusketeerSwedish);
   xsArraySetInt(gAge4PoliticianList, 31, cTechDEPoliticianCavalierSwedish);
   xsArraySetInt(gAge4PoliticianList, 32, cTechDEPoliticianPapalGuardSwedish);
   xsArraySetInt(gAge4PoliticianList, 33, cTechDEPoliticianFederalCalifornia);
   xsArraySetInt(gAge4PoliticianList, 34, cTechDEPoliticianFederalVermont);
   xsArraySetInt(gAge4PoliticianList, 35, cTechDEPoliticianFederalSouthCarolina);
   xsArraySetInt(gAge4PoliticianList, 36, cTechDEPoliticianFederalNewJersey);
   xsArraySetInt(gAge4PoliticianList, 37, cTechDEPoliticianFederalOhio);

   gAge5PoliticianList = xsArrayCreateInt(13, 0, "Age 5 Politician List");
   xsArraySetInt(gAge5PoliticianList, 0, cTechPoliticianPresidente);
   xsArraySetInt(gAge5PoliticianList, 1, cTechPoliticianGeneral);
   xsArraySetInt(gAge5PoliticianList, 2, cTechPoliticianGeneralBritish);
   xsArraySetInt(gAge5PoliticianList, 3, cTechPoliticianGeneralOttoman);
   xsArraySetInt(gAge5PoliticianList, 4, cTechPoliticianGeneralSkirmisher);
   xsArraySetInt(gAge5PoliticianList, 5, cTechDEPoliticianMercContractor);
   xsArraySetInt(gAge5PoliticianList, 6, cTechDEPoliticianInventor);
   xsArraySetInt(gAge5PoliticianList, 7, cTechDEPoliticianKnight);
   xsArraySetInt(gAge5PoliticianList, 8, cTechDEPoliticianFederalFlorida);
   xsArraySetInt(gAge5PoliticianList, 9, cTechDEPoliticianFederalConnecticut);
   xsArraySetInt(gAge5PoliticianList, 10, cTechDEPoliticianFederalIllinois);
   xsArraySetInt(gAge5PoliticianList, 11, cTechDEPoliticianFederalNewYork);
   xsArraySetInt(gAge5PoliticianList, 12, cTechDEPoliticianFederalTexas);

   gAge2WonderList = xsArrayCreateInt(15, 0, "Age 2 Wonder List");
   xsArraySetInt(gAge2WonderList, 0, cUnitTypeypWCConfucianAcademy2);
   xsArraySetInt(gAge2WonderList, 1, cUnitTypeypWCPorcelainTower2);
   xsArraySetInt(gAge2WonderList, 2, cUnitTypeypWCSummerPalace2);
   xsArraySetInt(gAge2WonderList, 3, cUnitTypeypWCTempleOfHeaven2);
   xsArraySetInt(gAge2WonderList, 4, cUnitTypeypWCWhitePagoda2);
   xsArraySetInt(gAge2WonderList, 5, cUnitTypeypWIAgraFort2);
   xsArraySetInt(gAge2WonderList, 6, cUnitTypeypWICharminarGate2);
   xsArraySetInt(gAge2WonderList, 7, cUnitTypeypWIKarniMata2);
   xsArraySetInt(gAge2WonderList, 8, cUnitTypeypWITajMahal2);
   xsArraySetInt(gAge2WonderList, 9, cUnitTypeypWITowerOfVictory2);
   xsArraySetInt(gAge2WonderList, 10, cUnitTypeypWJGiantBuddha2);
   xsArraySetInt(gAge2WonderList, 11, cUnitTypeypWJGoldenPavillion2);
   xsArraySetInt(gAge2WonderList, 12, cUnitTypeypWJShogunate2);
   xsArraySetInt(gAge2WonderList, 13, cUnitTypeypWJToriiGates2);
   xsArraySetInt(gAge2WonderList, 14, cUnitTypeypWJToshoguShrine2);

   gAge3WonderList = xsArrayCreateInt(15, 0, "Age 3 Wonder List");
   xsArraySetInt(gAge3WonderList, 0, cUnitTypeypWCConfucianAcademy3);
   xsArraySetInt(gAge3WonderList, 1, cUnitTypeypWCPorcelainTower3);
   xsArraySetInt(gAge3WonderList, 2, cUnitTypeypWCSummerPalace3);
   xsArraySetInt(gAge3WonderList, 3, cUnitTypeypWCTempleOfHeaven3);
   xsArraySetInt(gAge3WonderList, 4, cUnitTypeypWCWhitePagoda3);
   xsArraySetInt(gAge3WonderList, 5, cUnitTypeypWIAgraFort3);
   xsArraySetInt(gAge3WonderList, 6, cUnitTypeypWICharminarGate3);
   xsArraySetInt(gAge3WonderList, 7, cUnitTypeypWIKarniMata3);
   xsArraySetInt(gAge3WonderList, 8, cUnitTypeypWITajMahal3);
   xsArraySetInt(gAge3WonderList, 9, cUnitTypeypWITowerOfVictory3);
   xsArraySetInt(gAge3WonderList, 10, cUnitTypeypWJGiantBuddha3);
   xsArraySetInt(gAge3WonderList, 11, cUnitTypeypWJGoldenPavillion3);
   xsArraySetInt(gAge3WonderList, 12, cUnitTypeypWJShogunate3);
   xsArraySetInt(gAge3WonderList, 13, cUnitTypeypWJToriiGates3);
   xsArraySetInt(gAge3WonderList, 14, cUnitTypeypWJToshoguShrine3);

   gAge4WonderList = xsArrayCreateInt(15, 0, "Age 4 Wonder List");
   xsArraySetInt(gAge4WonderList, 0, cUnitTypeypWCConfucianAcademy4);
   xsArraySetInt(gAge4WonderList, 1, cUnitTypeypWCPorcelainTower4);
   xsArraySetInt(gAge4WonderList, 2, cUnitTypeypWCSummerPalace4);
   xsArraySetInt(gAge4WonderList, 3, cUnitTypeypWCTempleOfHeaven4);
   xsArraySetInt(gAge4WonderList, 4, cUnitTypeypWCWhitePagoda4);
   xsArraySetInt(gAge4WonderList, 5, cUnitTypeypWIAgraFort4);
   xsArraySetInt(gAge4WonderList, 6, cUnitTypeypWICharminarGate4);
   xsArraySetInt(gAge4WonderList, 7, cUnitTypeypWIKarniMata4);
   xsArraySetInt(gAge4WonderList, 8, cUnitTypeypWITajMahal4);
   xsArraySetInt(gAge4WonderList, 9, cUnitTypeypWITowerOfVictory4);
   xsArraySetInt(gAge4WonderList, 10, cUnitTypeypWJGiantBuddha4);
   xsArraySetInt(gAge4WonderList, 11, cUnitTypeypWJGoldenPavillion4);
   xsArraySetInt(gAge4WonderList, 12, cUnitTypeypWJShogunate4);
   xsArraySetInt(gAge4WonderList, 13, cUnitTypeypWJToriiGates4);
   xsArraySetInt(gAge4WonderList, 14, cUnitTypeypWJToshoguShrine4);

   gAge5WonderList = xsArrayCreateInt(15, 0, "Age 5 Wonder List");
   xsArraySetInt(gAge5WonderList, 0, cUnitTypeypWCConfucianAcademy5);
   xsArraySetInt(gAge5WonderList, 1, cUnitTypeypWCPorcelainTower5);
   xsArraySetInt(gAge5WonderList, 2, cUnitTypeypWCSummerPalace5);
   xsArraySetInt(gAge5WonderList, 3, cUnitTypeypWCTempleOfHeaven5);
   xsArraySetInt(gAge5WonderList, 4, cUnitTypeypWCWhitePagoda5);
   xsArraySetInt(gAge5WonderList, 5, cUnitTypeypWIAgraFort5);
   xsArraySetInt(gAge5WonderList, 6, cUnitTypeypWICharminarGate5);
   xsArraySetInt(gAge5WonderList, 7, cUnitTypeypWIKarniMata5);
   xsArraySetInt(gAge5WonderList, 8, cUnitTypeypWITajMahal5);
   xsArraySetInt(gAge5WonderList, 9, cUnitTypeypWITowerOfVictory5);
   xsArraySetInt(gAge5WonderList, 10, cUnitTypeypWJGiantBuddha5);
   xsArraySetInt(gAge5WonderList, 11, cUnitTypeypWJGoldenPavillion5);
   xsArraySetInt(gAge5WonderList, 12, cUnitTypeypWJShogunate5);
   xsArraySetInt(gAge5WonderList, 13, cUnitTypeypWJToriiGates5);
   xsArraySetInt(gAge5WonderList, 14, cUnitTypeypWJToshoguShrine5);

   gAge2WonderTechList = xsArrayCreateInt(15, 0, "Age 2 WonderTech List");
   xsArraySetInt(gAge2WonderTechList, 0, cTechYPWonderChineseConfucianAcademy2);
   xsArraySetInt(gAge2WonderTechList, 1, cTechYPWonderChinesePorcelainTower2);
   xsArraySetInt(gAge2WonderTechList, 2, cTechYPWonderChineseSummerPalace2);
   xsArraySetInt(gAge2WonderTechList, 3, cTechYPWonderChineseTempleOfHeaven2);
   xsArraySetInt(gAge2WonderTechList, 4, cTechYPWonderChineseWhitePagoda2);
   xsArraySetInt(gAge2WonderTechList, 5, cTechYPWonderIndianAgra2);
   xsArraySetInt(gAge2WonderTechList, 6, cTechYPWonderIndianCharminar2);
   xsArraySetInt(gAge2WonderTechList, 7, cTechYPWonderIndianKarniMata2);
   xsArraySetInt(gAge2WonderTechList, 8, cTechYPWonderIndianTajMahal2);
   xsArraySetInt(gAge2WonderTechList, 9, cTechYPWonderIndianTowerOfVictory2);
   xsArraySetInt(gAge2WonderTechList, 10, cTechYPWonderJapaneseGiantBuddha2);
   xsArraySetInt(gAge2WonderTechList, 11, cTechYPWonderJapaneseGoldenPavillion2);
   xsArraySetInt(gAge2WonderTechList, 12, cTechYPWonderJapaneseShogunate2);
   xsArraySetInt(gAge2WonderTechList, 13, cTechYPWonderJapaneseToriiGates2);
   xsArraySetInt(gAge2WonderTechList, 14, cTechYPWonderJapaneseToshoguShrine2);

   gAge3WonderTechList = xsArrayCreateInt(15, 0, "Age 3 WonderTech List");
   xsArraySetInt(gAge3WonderTechList, 0, cTechYPWonderChineseConfucianAcademy3);
   xsArraySetInt(gAge3WonderTechList, 1, cTechYPWonderChinesePorcelainTower3);
   xsArraySetInt(gAge3WonderTechList, 2, cTechYPWonderChineseSummerPalace3);
   xsArraySetInt(gAge3WonderTechList, 3, cTechYPWonderChineseTempleOfHeaven3);
   xsArraySetInt(gAge3WonderTechList, 4, cTechYPWonderChineseWhitePagoda3);
   xsArraySetInt(gAge3WonderTechList, 5, cTechYPWonderIndianAgra3);
   xsArraySetInt(gAge3WonderTechList, 6, cTechYPWonderIndianCharminar3);
   xsArraySetInt(gAge3WonderTechList, 7, cTechYPWonderIndianKarniMata3);
   xsArraySetInt(gAge3WonderTechList, 8, cTechYPWonderIndianTajMahal3);
   xsArraySetInt(gAge3WonderTechList, 9, cTechYPWonderIndianTowerOfVictory3);
   xsArraySetInt(gAge3WonderTechList, 10, cTechYPWonderJapaneseGiantBuddha3);
   xsArraySetInt(gAge3WonderTechList, 11, cTechYPWonderJapaneseGoldenPavillion3);
   xsArraySetInt(gAge3WonderTechList, 12, cTechYPWonderJapaneseShogunate3);
   xsArraySetInt(gAge3WonderTechList, 13, cTechYPWonderJapaneseToriiGates3);
   xsArraySetInt(gAge3WonderTechList, 14, cTechYPWonderJapaneseToshoguShrine3);

   gAge4WonderTechList = xsArrayCreateInt(15, 0, "Age 4 WonderTech List");
   xsArraySetInt(gAge4WonderTechList, 0, cTechYPWonderChineseConfucianAcademy4);
   xsArraySetInt(gAge4WonderTechList, 1, cTechYPWonderChinesePorcelainTower4);
   xsArraySetInt(gAge4WonderTechList, 2, cTechYPWonderChineseSummerPalace4);
   xsArraySetInt(gAge4WonderTechList, 3, cTechYPWonderChineseTempleOfHeaven4);
   xsArraySetInt(gAge4WonderTechList, 4, cTechYPWonderChineseWhitePagoda4);
   xsArraySetInt(gAge4WonderTechList, 5, cTechYPWonderIndianAgra4);
   xsArraySetInt(gAge4WonderTechList, 6, cTechYPWonderIndianCharminar4);
   xsArraySetInt(gAge4WonderTechList, 7, cTechYPWonderIndianKarniMata4);
   xsArraySetInt(gAge4WonderTechList, 8, cTechYPWonderIndianTajMahal4);
   xsArraySetInt(gAge4WonderTechList, 9, cTechYPWonderIndianTowerOfVictory4);
   xsArraySetInt(gAge4WonderTechList, 10, cTechYPWonderJapaneseGiantBuddha4);
   xsArraySetInt(gAge4WonderTechList, 11, cTechYPWonderJapaneseGoldenPavillion4);
   xsArraySetInt(gAge4WonderTechList, 12, cTechYPWonderJapaneseShogunate4);
   xsArraySetInt(gAge4WonderTechList, 13, cTechYPWonderJapaneseToriiGates4);
   xsArraySetInt(gAge4WonderTechList, 14, cTechYPWonderJapaneseToshoguShrine4);

   gAge5WonderTechList = xsArrayCreateInt(15, 0, "Age 5 WonderTech List");
   xsArraySetInt(gAge5WonderTechList, 0, cTechYPWonderChineseConfucianAcademy5);
   xsArraySetInt(gAge5WonderTechList, 1, cTechYPWonderChinesePorcelainTower5);
   xsArraySetInt(gAge5WonderTechList, 2, cTechYPWonderChineseSummerPalace5);
   xsArraySetInt(gAge5WonderTechList, 3, cTechYPWonderChineseTempleOfHeaven5);
   xsArraySetInt(gAge5WonderTechList, 4, cTechYPWonderChineseWhitePagoda5);
   xsArraySetInt(gAge5WonderTechList, 5, cTechYPWonderIndianAgra5);
   xsArraySetInt(gAge5WonderTechList, 6, cTechYPWonderIndianCharminar5);
   xsArraySetInt(gAge5WonderTechList, 7, cTechYPWonderIndianKarniMata5);
   xsArraySetInt(gAge5WonderTechList, 8, cTechYPWonderIndianTajMahal5);
   xsArraySetInt(gAge5WonderTechList, 9, cTechYPWonderIndianTowerOfVictory5);
   xsArraySetInt(gAge5WonderTechList, 10, cTechYPWonderJapaneseGiantBuddha5);
   xsArraySetInt(gAge5WonderTechList, 11, cTechYPWonderJapaneseGoldenPavillion5);
   xsArraySetInt(gAge5WonderTechList, 12, cTechYPWonderJapaneseShogunate5);
   xsArraySetInt(gAge5WonderTechList, 13, cTechYPWonderJapaneseToriiGates5);
   xsArraySetInt(gAge5WonderTechList, 14, cTechYPWonderJapaneseToshoguShrine5);

   gRevolutionList = xsArrayCreateInt(20, 0, "Revolution List");
   xsArraySetInt(gRevolutionList, 0, cTechDERevolutionHaiti);
   xsArraySetInt(gRevolutionList, 1, cTechDERevolutionEgypt);
   xsArraySetInt(gRevolutionList, 2, cTechDERevolutionFinland);
   xsArraySetInt(gRevolutionList, 3, cTechDERevolutionRomania);
   xsArraySetInt(gRevolutionList, 4, cTechDERevolutionPeru);
   xsArraySetInt(gRevolutionList, 5, cTechDERevolutionBrazil);
   xsArraySetInt(gRevolutionList, 6, cTechDERevolutionArgentina);
   xsArraySetInt(gRevolutionList, 7, cTechDERevolutionUSA);
   xsArraySetInt(gRevolutionList, 8, cTechDERevolutionCanadaFrench);
   xsArraySetInt(gRevolutionList, 9, cTechDERevolutionCanadaBritish);
   xsArraySetInt(gRevolutionList, 10, cTechDERevolutionIndonesia);
   xsArraySetInt(gRevolutionList, 11, cTechDERevolutionBarbaryStates);
   xsArraySetInt(gRevolutionList, 12, cTechDERevolutionHungaryRussian);
   xsArraySetInt(gRevolutionList, 13, cTechDERevolutionHungaryOttoman);
   xsArraySetInt(gRevolutionList, 14, cTechDERevolutionHungaryGerman);
   xsArraySetInt(gRevolutionList, 15, cTechDERevolutionMexico);
   xsArraySetInt(gRevolutionList, 16, cTechDERevolutionColombia);
   xsArraySetInt(gRevolutionList, 17, cTechDERevolutionColombiaPortuguese);
   xsArraySetInt(gRevolutionList, 18, cTechDERevolutionChile);
   xsArraySetInt(gRevolutionList, 19, cTechDERevolutionSouthAfrica);

   gAgeUpPoliticians = xsArrayCreateInt(10, 0, "Ageup Politicians");
   gPoliticianScores = xsArrayCreateInt(10, 0, "European Politicians");
   gNatCouncilScores = xsArrayCreateInt(6, 0, "Native Council");
   gAsianWonderScores = xsArrayCreateInt(6, 0, "Asian Wonders");
   gAfricanAlliances = xsArrayCreateInt(8, 0, "African Alliances");
	gAfricanAlliancesAgedUpWith = xsArrayCreateBool(5, false, "African Alliances Aged Up With");
	gAfricanAlliancesUpgrades = xsArrayCreateBool(5, true, "African Alliances Upgrades"); // Default to true and set to false when we actually age-up with the Alliance.
   gResourceNeeds = xsArrayCreateFloat(3, 0.0, "Resource Needs");
   gExtraResourceNeeds = xsArrayCreateFloat(3, 0.0, "Extra Resource Needs");
   if (cMyCiv == cCivDESwedish)
      gTorpPositionsToAvoid = xsArrayCreateVector(1, cInvalidVector, "Torp Positions To Avoid");
   if (cMyCiv == cCivXPAztec)
   {
      gMilitaryBuildings = xsArrayCreateInt(3, -1, "Military Buildings");
      xsArraySetInt(gMilitaryBuildings, 0, cUnitTypeWarHut);
      xsArraySetInt(gMilitaryBuildings, 1, cUnitTypeNoblesHut);
      xsArraySetInt(gMilitaryBuildings, 2, cUnitTypeNativeEmbassy);
   }
   else if (cMyCiv == cCivXPIroquois)
   {
      gMilitaryBuildings = xsArrayCreateInt(3, -1, "Military Buildings");
      xsArraySetInt(gMilitaryBuildings, 0, cUnitTypeWarHut);
      xsArraySetInt(gMilitaryBuildings, 1, cUnitTypeCorral);
      xsArraySetInt(gMilitaryBuildings, 2, cUnitTypeArtilleryDepot);
      xsArraySetInt(gMilitaryBuildings, 3, cUnitTypeNativeEmbassy);
   }
   else if (cMyCiv == cCivXPSioux)
   {
      gMilitaryBuildings = xsArrayCreateInt(2, -1, "Military Buildings");
      xsArraySetInt(gMilitaryBuildings, 0, cUnitTypeWarHut);
      xsArraySetInt(gMilitaryBuildings, 1, cUnitTypeCorral);
      xsArraySetInt(gMilitaryBuildings, 2, cUnitTypeNativeEmbassy);
   }
   else if (cMyCiv == cCivDEInca)
   {
      gMilitaryBuildings = xsArrayCreateInt(2, -1, "Military Buildings");
      xsArraySetInt(gMilitaryBuildings, 0, cUnitTypeWarHut);
      xsArraySetInt(gMilitaryBuildings, 1, cUnitTypedeKallanka);
      xsArraySetInt(gMilitaryBuildings, 2, cUnitTypeNativeEmbassy);
   }
   else if (cMyCiv == cCivChinese || cMyCiv == cCivSPCChinese)
   {
      gMilitaryBuildings = xsArrayCreateInt(3, -1, "Military Buildings");
      xsArraySetInt(gMilitaryBuildings, 0, cUnitTypeypWarAcademy);
      xsArraySetInt(gMilitaryBuildings, 1, cUnitTypeypCastle);
      xsArraySetInt(gMilitaryBuildings, 2, cUnitTypeypMonastery);
   }
   else if (cMyCiv == cCivIndians || cMyCiv == cCivSPCIndians)
   {
      gMilitaryBuildings = xsArrayCreateInt(4, -1, "Military Buildings");
      xsArraySetInt(gMilitaryBuildings, 0, cUnitTypeYPBarracksIndian);
      xsArraySetInt(gMilitaryBuildings, 1, cUnitTypeypCaravanserai);
      xsArraySetInt(gMilitaryBuildings, 2, cUnitTypeypCastle);
      xsArraySetInt(gMilitaryBuildings, 3, cUnitTypeypMonastery);
   }
   else if (cMyCiv == cCivJapanese || cMyCiv == cCivSPCJapanese || cMyCiv == cCivSPCJapaneseEnemy)
   {
      gMilitaryBuildings = xsArrayCreateInt(5, -1, "Military Buildings");
      xsArraySetInt(gMilitaryBuildings, 0, cUnitTypeypBarracksJapanese);
      xsArraySetInt(gMilitaryBuildings, 1, cUnitTypeypStableJapanese);
      xsArraySetInt(gMilitaryBuildings, 2, cUnitTypeypCastle);
      xsArraySetInt(gMilitaryBuildings, 3, cUnitTypeypMonastery);
      xsArraySetInt(gMilitaryBuildings, 4, cUnitTypeypChurch);
   }
   else if (cMyCiv == cCivDEHausa || cMyCiv == cCivDEEthiopians)
   {
      gMilitaryBuildings = xsArrayCreateInt(2, -1, "Military Buildings");
      xsArraySetInt(gMilitaryBuildings, 0, cUnitTypedeWarCamp);
      xsArraySetInt(gMilitaryBuildings, 1, cUnitTypedeTower);
   }
   else if (cMyCiv == cCivRussians)
   {
      gMilitaryBuildings = xsArrayCreateInt(5, -1, "Military Buildings");
      xsArraySetInt(gMilitaryBuildings, 0, cUnitTypeBlockhouse);
      xsArraySetInt(gMilitaryBuildings, 1, cUnitTypeStable);
      xsArraySetInt(gMilitaryBuildings, 2, cUnitTypeArtilleryDepot);
      xsArraySetInt(gMilitaryBuildings, 3, cUnitTypedeTavern);
      xsArraySetInt(gMilitaryBuildings, 4, cUnitTypeChurch);
   }
   else
   {
      gMilitaryBuildings = xsArrayCreateInt(5, -1, "Military Buildings");
      xsArraySetInt(gMilitaryBuildings, 0, cUnitTypeBarracks);
      xsArraySetInt(gMilitaryBuildings, 1, cUnitTypeStable);
      xsArraySetInt(gMilitaryBuildings, 2, cUnitTypeArtilleryDepot);
      xsArraySetInt(gMilitaryBuildings, 3, cUnitTypedeTavern);
      xsArraySetInt(gMilitaryBuildings, 4, cUnitTypeChurch);
   }
   gArmyUnitBuildings = xsArrayCreateInt(gNumArmyUnitTypes, -1, "Army Unit Buildings");
   gArmyUnitMaintainPlans = xsArrayCreateInt(gNumArmyUnitTypes, -1, "Army Unit Maintain Plans");
   gFullGranaries = xsArrayCreateInt(20, -1, "Full Granaries");
   gAdjustBreakdownAttempts = xsArrayCreateInt(3, 1, "Resource Breakdown Adjust Attempts");
   gQueuedBuildPlans = xsArrayCreateInt(5, -1, "Queued build plans");
}

//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
// Algorithms
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
vector rotateByReferencePoint(vector refPoint = cInvalidVector, vector vec = cInvalidVector, float angle = 0.0)
{
   if ((refPoint == cInvalidVector) || (vec == cInvalidVector))
      return (cInvalidVector);

   float x = xsVectorGetX(vec);
   float z = xsVectorGetZ(vec);
   vector finalLocation = cInvalidVector;
   finalLocation = xsVectorSet(x * cos(angle) - z * sin(angle) + xsVectorGetX(refPoint), 0.0,
                               x * sin(angle) + z * cos(angle) + xsVectorGetZ(refPoint));
   return (finalLocation);
}

void randomShuffleIntArray(int array = -1, int size = 0)
{
   int i = size - 1;
   int j = 0;
   int temp = 0;
   while (i >= 0)
   {
      j = aiRandInt(i + 1);
      temp = xsArrayGetInt(array, i);
      xsArraySetInt(array, i, xsArrayGetInt(array, j));
      xsArraySetInt(array, j, temp);
      i = i - 1;
   }
}

//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
// Utility functions
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
void sendChatToAllies(string text = "")
{
   int player = -1;

   for (player = 0; < cNumberPlayers)
   {
      if ((player != cMyID) && (kbIsPlayerAlly(player) == true))
         aiChat(player, text);
   }
}

bool civIsNative(void)
{
   if ((cMyCiv == cCivXPAztec) || (cMyCiv == cCivXPIroquois) || (cMyCiv == cCivXPSioux) || (cMyCiv == cCivDEInca))
      return (true);

   return (false);
}

bool civIsAsian(void)
{
   if ((cMyCiv == cCivJapanese) || (cMyCiv == cCivChinese) || (cMyCiv == cCivIndians) || (cMyCiv == cCivSPCIndians) ||
       (cMyCiv == cCivSPCChinese) || (cMyCiv == cCivSPCJapanese) || (cMyCiv == cCivSPCJapaneseEnemy))
      return (true);

   return (false);
}

bool civIsAfrican(void)
{
   if ((cMyCiv == cCivDEEthiopians) || (cMyCiv == cCivDEHausa))
      return (true);

   return (false);
}

bool civIsEuropean(void) { return (civIsNative() == false && civIsAsian() == false && civIsAfrican() == false); }

bool civIsDEciv(void)
{
   if ((cMyCiv == cCivDEInca) || (cMyCiv == cCivDESwedish) || (cMyCiv == cCivDEAmericans) ||
       (cMyCiv == cCivDEEthiopians) || (cMyCiv == cCivDEHausa))
      return (true);

   return (false);
}

int getSettlerShortfall()
{ // How many more Settlers do we currently want?
   int retVal = 0;
   float villTarget = xsArrayGetInt(gTargetSettlerCounts, kbGetAge()); // How many we want to have this age
   float villCount = kbUnitCount(cMyID, gEconUnit, cUnitStateABQ);     // How many we have

   retVal = villTarget - villCount;

   return (retVal);
}

bool agingUp()
{
   int planState = cPlanStateResearch;
   if (civIsAsian() == true)
      planState = cPlanStateBuild;
   return (aiPlanGetState(gAgeUpResearchPlan) == planState);
}

bool mapIsIsland(void)
{
	if ((cRandomMapName == "amazonia") || (cRandomMapName == "caribbean") || (cRandomMapName == "Ceylon"))
		return(true);
	return(false);
}

int getWonderToBuild(int the_age = -1)
{
   if ((cMyCiv == cCivJapanese) || (cMyCiv == cCivSPCJapanese) || (cMyCiv == cCivSPCJapanese))
   {
      // Giant Buddha, Golden Pavillion, Shogunate, Torii Gates, Toshogu Shrine
      // age2
      if (the_age == cAge2)
      {
			return (cUnitTypeypWJToshoguShrine2);
		}
		//age3
		else if (the_age == cAge3)
		{
			return (cUnitTypeypWJToriiGates3);
		}
		//age4
		else if (the_age == cAge4)
		{
			return (cUnitTypeypWJGoldenPavillion4);
		}
		//age5
		else if (the_age == cAge5)
		{
			return (cUnitTypeypWJShogunate5);
      }
   }
   if ((cMyCiv == cCivChinese) || (cMyCiv == cCivSPCChinese))
   {
      // age2
      if (the_age == cAge2)
      {
         return (cUnitTypeypWCSummerPalace2);
      }
      // age3
      else if (the_age == cAge3)
      {
         return (cUnitTypeypWCConfucianAcademy3);
      }
      // age4
      else if (the_age == cAge4)
      {
         return (cUnitTypeypWCWhitePagoda4);
      }
      // age5
      else if (the_age == cAge5)
      {
         return (cUnitTypeypWCPorcelainTower5);
      }
   }
   if ((cMyCiv == cCivIndians) || (cMyCiv == cCivSPCIndians))
   {
      // age2
      if (the_age == cAge2)
      {
         return (cUnitTypeypWIAgraFort2);
      }
      // age3
      else if (the_age == cAge3)
      {
         return (cUnitTypeypWICharminarGate3);
      }
      // age4
      else if (the_age == cAge4)
      {
         return (cUnitTypeypWIKarniMata4);
      }
      // age5
      else if (the_age == cAge5)
      {
         return (cUnitTypeypWITajMahal5);
      }
   }

   return (-1);
}

int getPreferredWonderToBuild(int the_age = -1)
{
   if (the_age == cAge2)
   {
      return (xsArrayGetInt(gAsianWonders, 0));
   }
   // age3
   else if (the_age == cAge3)
   {
      return (xsArrayGetInt(gAsianWonders, 1));
   }
   // age4
   else if (the_age == cAge4)
   {
      return (xsArrayGetInt(gAsianWonders, 2));
   }
   // age5
   else if (the_age == cAge5)
   {
      if (aiGetGameMode() == cGameModeDeathmatch)
      {
         return (-1); // BHG:CGN: don't try to get to age 5 in a deathmatch game
      }
      return (xsArrayGetInt(gAsianWonders, 3));
   }
   return (-1);
}

bool agingUpTo(int nextAge = -1)
{
   bool retVal = false;
   if ((kbGetAge() + 1 == nextAge) && ((aiPlanGetState(gAgeUpResearchPlan) == cPlanStateResearch) || (aiPlanGetState(gAgeUpResearchPlan) == cPlanStateBuild)))
      retVal = true;
   return(retVal);
}

bool agingUpToOrAbove(int Age = -1)
{
   bool retVal = false;
   if ((kbGetAge() == Age - 1) && ((aiPlanGetState(gAgeUpResearchPlan) == cPlanStateResearch) || (aiPlanGetState(gAgeUpResearchPlan) == cPlanStateBuild)))
      retVal = true;
   if (kbGetAge() >= Age)
      retVal = true;

   return(retVal);
}

//==============================================================================
/* createOpportunity(type, targetType, targetID, targetPlayerID, source)

   A wrapper function for aiCreateOpportunity(), to permit centralized tracking
   of the most recently created ally-generated and trigger-generated
   opportunities.  This info is needed so that a cancel command can
   efficiently deactivate the previous (and possibly current) opportunity before
   creating the new one.
*/
//==============================================================================
int createOpportunity(int type = -1, int targetType = -1, int targetID = -1, int targetPlayerID = -1, int source = -1)
{
   int oppID = aiCreateOpportunity(type, targetType, targetID, targetPlayerID, source);
   if (source == cOpportunitySourceAllyRequest)
      gMostRecentAllyOpportunityID = oppID; // Remember which ally opp we're doing
   else if (source == cOpportunitySourceTrigger)
      gMostRecentTriggerOpportunityID = oppID;

   return (oppID);
}

//==============================================================================
/* sendStatement(player, commPromptID, vector)

  Sends a chat statement, but first checks the control variables and updates the
  "ok to chat" state.   This is a gateway for routine "ambience" personality chats.
  Another function will be written as a gateway for strategic communications, i.e.
  requests for defence, tribute, joint operations, etc.  That one will be controlled by
  the cvOkToChat variable.

  If vector is not cInvalidVector, it will be added as a flare
*/
//==============================================================================
bool sendStatement(int playerIDorRelation = -1, int commPromptID = -1, vector vec = cInvalidVector)
{
   aiEcho("<<<<<SEND STATEMENT to player " + playerIDorRelation + ", commPromptID = " + commPromptID + ", vector " +
          vec + ">>>>>");
   // Routine "ambience" chats are not allowed
   if (cvOkToTaunt == false)
   {
      // Failed, no chat sent
      // Make sure the C++ side knows about it
      aiCommsAllowChat(false);
      return (false);
   }

   // If we got this far, it's OK.
   aiCommsAllowChat(true);

   // It's a player ID, not a relation.
   if (playerIDorRelation < 100)
   {
      int playerID = playerIDorRelation;
      aiEcho("<<<<<Sending chat prompt " + commPromptID + " to player " + playerID + " with vector " + vec + ">>>>>");
      if (vec == cInvalidVector)
         aiCommsSendStatement(playerID, commPromptID);
      else
         aiCommsSendStatementWithVector(playerID, commPromptID, vec);
   }
   else // Then it's a player relation
   {
      int player = -1;
      for (player = 1; < cNumberPlayers)
      {
         bool send = false;
         switch (playerIDorRelation)
         {
         case cPlayerRelationAny:
         {
            send = true;
            break;
         }
         case cPlayerRelationSelf:
         {
            if (player == cMyID)
               send = true;
            break;
         }
         case cPlayerRelationAlly:
         {
            send = kbIsPlayerAlly(player);

            // Don't talk to myself, even though I am my ally.
            if (player == cMyID)
               send = false;
            break;
         }
         case cPlayerRelationEnemy:
         {
            send = kbIsPlayerEnemy(player);
            break;
         }
         case cPlayerRelationEnemyNotGaia:
         {
            send = kbIsPlayerEnemy(player);
            break;
         }
         }
         if (send == true)
         {
            aiEcho("<<<<<Sending chat prompt " + commPromptID + " to player " + player + " with vector " + vec +
                   ">>>>>");
            if (vec == cInvalidVector)
               aiCommsSendStatement(player, commPromptID);
            else
               aiCommsSendStatementWithVector(player, commPromptID, vec);
         }
      }
   }
   return (true);
}

//==============================================================================
// Plan Chat functions
//
//==============================================================================

// Set the attack plan to trigger a message and optional flare when the plan reaches the specified state.
// See the event handler below.
bool setPlanChat(int plan = -1, int state = -1, int prompt = -1, int player = -1, vector flare = cInvalidVector)
{

   // State -1 could be valid for action on plan termination
   if ((plan < 0) || (prompt < 0) || (player < 0))
      return (false);

   aiPlanSetEventHandler(plan, cPlanEventStateChange, "planStateEventHandler");

   aiPlanAddUserVariableInt(plan, 0, "Key State", 1);
   aiPlanAddUserVariableInt(plan, 1, "Prompt ID", 1);
   aiPlanAddUserVariableInt(plan, 2, "Send To", 1);
   aiPlanAddUserVariableVector(plan, 3, "Flare Vector", 1);

   aiPlanSetUserVariableInt(plan, 0, 0, state);
   aiPlanSetUserVariableInt(plan, 1, 0, prompt);
   aiPlanSetUserVariableInt(plan, 2, 0, player);
   aiPlanSetUserVariableVector(plan, 3, 0, flare);

   return (true);
}

void planStateEventHandler(int planID = -1)
{
   aiEcho("    Plan " + aiPlanGetName(planID) + " is now in state " + aiPlanGetState(planID));

   // Plan planID has changed states.  Get its state, compare to target, issue chat if it matches
   int state = aiPlanGetUserVariableInt(planID, 0, 0);
   int prompt = aiPlanGetUserVariableInt(planID, 1, 0);
   int player = aiPlanGetUserVariableInt(planID, 2, 0);
   vector flare = aiPlanGetUserVariableVector(planID, 3, 0);

   if (aiPlanGetState(planID) == state)
   {
      // We have a winner, send the chat statement
      sendStatement(player, prompt, flare);
      // clearPlanChat(index);
   }
}

void tcPlacedEventHandler(int planID = -1)
{
   // Check the state of the TC build plan.
   // Fire an ally chat if the state is "build"
   if (aiPlanGetState(planID) == cPlanStateBuild)
   {
      vector loc = kbBuildingPlacementGetResultPosition(aiPlanGetVariableInt(planID, cBuildPlanBuildingPlacementID, 0));
      sendStatement(cPlayerRelationAlly, cAICommPromptToAllyIWillBuildTC, loc);
      aiEcho("Sending TC placement chat at location " + loc);
      gTCBuildPlanID = -1;
   }
}

//==============================================================================
// distance
//
// Will return a float with the 3D distance between two vectors
//==============================================================================
float distance(vector v1 = cInvalidVector, vector v2 = cInvalidVector)
{
   vector delta = v1 - v2;
   return (xsVectorLength(delta));
}

//==============================================================================
bool arraySortIntComp(int a = -1, int b = -1) { return(a < b); }
//==============================================================================
// arraySortInt
//==============================================================================
void arraySortInt(int arrayID = -1, int begin = 0, int end = -1, bool(int, int) comp = arraySortIntComp)
{
	int j = 0;
	int key = 0;

	if (end < 0)
      end = xsArrayGetSize(arrayID);

	for (i = begin + 1; < end)
	{
		key = xsArrayGetInt(arrayID, i);
		j = i - 1;
		while((j >= 0) && (comp(xsArrayGetInt(arrayID, j), key) == false))
		{
			xsArraySetInt(arrayID, j + 1, xsArrayGetInt(arrayID, j));
			j--;
		}
		xsArraySetInt(arrayID, j + 1, key);
	}
}

//==============================================================================
// getUnit
//
// Will return a random unit matching the parameters
//==============================================================================
int getUnit(int unitTypeID = -1, int playerRelationOrID = cMyID, int state = cUnitStateAlive)
{
   int count = -1;
   static int unitQueryID = -1;

   // If we don't have the query yet, create one.
   if (unitQueryID < 0)
   {
      unitQueryID = kbUnitQueryCreate("miscGetUnitQuery");
   }

   // Define a query to get all matching units
   if (unitQueryID != -1)
   {
      if (playerRelationOrID > 1000) // Too big for player ID number
      {
         kbUnitQuerySetPlayerID(unitQueryID, -1); // Clear the player ID, so playerRelation takes precedence.
         kbUnitQuerySetPlayerRelation(unitQueryID, playerRelationOrID);
      }
      else
      {
         kbUnitQuerySetPlayerRelation(unitQueryID, -1);
         kbUnitQuerySetPlayerID(unitQueryID, playerRelationOrID);
      }
      kbUnitQuerySetUnitType(unitQueryID, unitTypeID);
      kbUnitQuerySetState(unitQueryID, state);
      kbUnitQuerySetIgnoreKnockedOutUnits(unitQueryID, true);
   }
   else
      return (-1);

   kbUnitQueryResetResults(unitQueryID);
   int numberFound = kbUnitQueryExecute(unitQueryID);
   if (numberFound > 0)
      return (kbUnitQueryGetResult(unitQueryID, aiRandInt(numberFound))); // Return a random dude(tte)
   return (-1);
}

//==============================================================================
// createSimpleUnitQuery
//==============================================================================
int createSimpleUnitQuery(int unitTypeID = -1, int playerRelationOrID = cMyID, int state = cUnitStateAlive,
                          vector position = cInvalidVector, float radius = -1.0)
{
   static int unitQueryID = -1;

   // If we don't have the query yet, create one.
   if (unitQueryID < 0)
   {
      unitQueryID = kbUnitQueryCreate("miscSimpleUnitQuery");
   }

   // Define a query to get all matching units
   if (unitQueryID != -1)
   {
      if (playerRelationOrID > 1000) // Too big for player ID number
      {
         kbUnitQuerySetPlayerID(unitQueryID, -1); // Clear the player ID, so playerRelation takes precedence.
         kbUnitQuerySetPlayerRelation(unitQueryID, playerRelationOrID);
      }
      else
      {
         kbUnitQuerySetPlayerRelation(unitQueryID, -1);
         kbUnitQuerySetPlayerID(unitQueryID, playerRelationOrID);
      }
      kbUnitQuerySetUnitType(unitQueryID, unitTypeID);
      kbUnitQuerySetState(unitQueryID, state);
      kbUnitQuerySetPosition(unitQueryID, position);
      kbUnitQuerySetMaximumDistance(unitQueryID, radius);
      kbUnitQuerySetIgnoreKnockedOutUnits(unitQueryID, true);
   }
   else
      return (-1);

   kbUnitQueryResetResults(unitQueryID);
   return (unitQueryID);
}

//==============================================================================
// getGaiaUnitCount
//
// Query unit count from gaia's perspective, use with caution to avoid cheating.
//==============================================================================
int getGaiaUnitCount(int unitTypeID = -1, int state = cUnitStateAlive, vector position = cInvalidVector,
                     float radius = -1.0)
{
   static int unitQueryID = -1;

   xsSetContextPlayer(0);

   // If we don't have the query yet, create one.
   if (unitQueryID < 0)
   {
      unitQueryID = kbUnitQueryCreate("miscGaiaUnitQuery");
   }

   // Define a query to get all matching units
   if (unitQueryID != -1)
   {
      kbUnitQuerySetPlayerRelation(unitQueryID, -1);
      kbUnitQuerySetPlayerID(unitQueryID, 0);
      kbUnitQuerySetUnitType(unitQueryID, unitTypeID);
      kbUnitQuerySetState(unitQueryID, state);
      kbUnitQuerySetPosition(unitQueryID, position);
      kbUnitQuerySetMaximumDistance(unitQueryID, radius);
      kbUnitQuerySetIgnoreKnockedOutUnits(unitQueryID, true);
   }
   else
   {
      xsSetContextPlayer(cMyID);
      return (0);
   }

   kbUnitQueryResetResults(unitQueryID);

   int numberFound = kbUnitQueryExecute(unitQueryID);
   xsSetContextPlayer(cMyID);
   return (numberFound);
}

//==============================================================================
// createSimpleAttackGoal
//==============================================================================
int createSimpleAttackGoal(string name = "BUG", int attackPlayerID = -1, int unitPickerID = -1, int repeat = -1,
                           int minAge = -1, int maxAge = -1, int baseID = -1, bool allowRetreat = false)
{
   aiEcho("CreateSimpleAttackGoal:  Name=" + name + ", AttackPlayerID=" + attackPlayerID + ".");
   aiEcho("  UnitPickerID=" + unitPickerID + ", Repeat=" + repeat + ", baseID=" + baseID + ".");
   aiEcho("  MinAge=" + minAge + ", maxAge=" + maxAge + ", allowRetreat=" + allowRetreat + ".");

   // Create the goal.
   int goalID = aiPlanCreate(name, cPlanGoal);
   if (goalID < 0)
      return (-1);

   // Priority.
   aiPlanSetDesiredPriority(goalID, 1);
   // Attack player ID.
   if (attackPlayerID >= 0)
      aiPlanSetVariableInt(goalID, cGoalPlanAttackPlayerID, 0, attackPlayerID);
   else
      aiPlanSetVariableBool(goalID, cGoalPlanAutoUpdateAttackPlayerID, 0, true);
   // Base.
   if (baseID >= 0)
      aiPlanSetBaseID(goalID, baseID);
   else
      aiPlanSetVariableBool(goalID, cGoalPlanAutoUpdateBase, 0, true);
   // Attack.
   aiPlanSetAttack(goalID, true);
   aiPlanSetVariableInt(goalID, cGoalPlanGoalType, 0, cGoalPlanGoalTypeAttack);
   aiPlanSetVariableInt(goalID, cGoalPlanAttackStartFrequency, 0, 1);

   // Military.
   aiPlanSetMilitary(goalID, true);
   aiPlanSetEscrowID(goalID, cMilitaryEscrowID);
   // Ages.
   aiPlanSetVariableInt(goalID, cGoalPlanMinAge, 0, minAge);
   aiPlanSetVariableInt(goalID, cGoalPlanMaxAge, 0, maxAge);
   // Repeat.
   aiPlanSetVariableInt(goalID, cGoalPlanRepeat, 0, repeat);
   // Unit Picker.
   aiPlanSetVariableInt(goalID, cGoalPlanUnitPickerID, 0, unitPickerID);
   // Retreat.
   if (kbGetAge() < cvMaxAge)
   aiPlanSetVariableBool(goalID, cGoalPlanAllowRetreat, 0, allowRetreat);
   // Handle maps where the enemy player is usually on a diff island.
   if (gStartOnDifferentIslands == true)
   {
      aiPlanSetVariableBool(goalID, cGoalPlanSetAreaGroups, 0, true);
      aiPlanSetVariableInt(goalID, cGoalPlanAttackRoutePatternType, 0, cAttackPlanAttackRoutePatternRandom);
   }
   // Done.
   return (goalID);
}

//==============================================================================
// getUnitByTech
//
// Will return a random unit matching the parameters
//==============================================================================
int getUnitByTech(int unitTypeID = -1, int TechID = -1)
{
   int count = -1;
   static int unitQueryID = -1;

   // If we don't have the query yet, create one.
   if (unitQueryID < 0)
   {
      unitQueryID = kbUnitQueryCreate("miscGetUnitByTechQuery");
   }

   // Define a query to get all matching units
   if (unitQueryID != -1)
   {
      kbUnitQuerySetPlayerID(unitQueryID, cMyID);
      kbUnitQuerySetPlayerRelation(unitQueryID, -1);
      kbUnitQuerySetUnitType(unitQueryID, unitTypeID);
      kbUnitQuerySetTechID(unitQueryID, TechID);
      kbUnitQuerySetState(unitQueryID, cUnitStateAlive);
      kbUnitQuerySetIgnoreKnockedOutUnits(unitQueryID, true);
   }
   else
      return (-1);

   kbUnitQueryResetResults(unitQueryID);
   int numberFound = kbUnitQueryExecute(unitQueryID);
   if (numberFound > 0)
      return (kbUnitQueryGetResult(unitQueryID, aiRandInt(numberFound)));
   return (-1);
}

//==============================================================================
// getUnitByLocation
//
// Will return a random unit matching the parameters
//==============================================================================
int getUnitByLocation(int unitTypeID = -1, int playerRelationOrID = cMyID, int state = cUnitStateAlive,
                      vector location = cInvalidVector, float radius = 20.0)
{
   int count = -1;
   static int unitQueryID = -1;

   // If we don't have the query yet, create one.
   if (unitQueryID < 0)
   {
      unitQueryID = kbUnitQueryCreate("miscGetUnitLocationQuery");
   }

   // Define a query to get all matching units
   if (unitQueryID != -1)
   {
      if (playerRelationOrID > 1000) // Too big for player ID number
      {
         kbUnitQuerySetPlayerID(unitQueryID, -1);
         kbUnitQuerySetPlayerRelation(unitQueryID, playerRelationOrID);
      }
      else
      {
         kbUnitQuerySetPlayerRelation(unitQueryID, -1);
         kbUnitQuerySetPlayerID(unitQueryID, playerRelationOrID);
      }
      kbUnitQuerySetUnitType(unitQueryID, unitTypeID);
      kbUnitQuerySetState(unitQueryID, state);
      kbUnitQuerySetPosition(unitQueryID, location);
      kbUnitQuerySetMaximumDistance(unitQueryID, radius);
      kbUnitQuerySetIgnoreKnockedOutUnits(unitQueryID, true);
   }
   else
      return (-1);

   kbUnitQueryResetResults(unitQueryID);
   int numberFound = kbUnitQueryExecute(unitQueryID);
   if (numberFound > 0)
      return (kbUnitQueryGetResult(unitQueryID, aiRandInt(numberFound))); // Return a random dude(tte)
   return (-1);
}

//==============================================================================
// getClosestUnitByLocation
//
// Will return a random unit matching the parameters
//==============================================================================
int getClosestUnitByLocation(int unitTypeID = -1, int playerRelationOrID = cMyID, int state = cUnitStateAlive,
                             vector location = cInvalidVector, float radius = 20.0)
{
   int count = -1;
   static int unitQueryID = -1;

   // If we don't have the query yet, create one.
   if (unitQueryID < 0)
   {
      unitQueryID = kbUnitQueryCreate("miscGetUnitLocationQuery");
   }

   // Define a query to get all matching units
   if (unitQueryID != -1)
   {
      if (playerRelationOrID > 1000) // Too big for player ID number
      {
         kbUnitQuerySetPlayerID(unitQueryID, -1);
         kbUnitQuerySetPlayerRelation(unitQueryID, playerRelationOrID);
      }
      else
      {
         kbUnitQuerySetPlayerRelation(unitQueryID, -1);
         kbUnitQuerySetPlayerID(unitQueryID, playerRelationOrID);
      }
      kbUnitQuerySetUnitType(unitQueryID, unitTypeID);
      kbUnitQuerySetState(unitQueryID, state);
      kbUnitQuerySetPosition(unitQueryID, location);
      kbUnitQuerySetMaximumDistance(unitQueryID, radius);
      kbUnitQuerySetIgnoreKnockedOutUnits(unitQueryID, true);
      kbUnitQuerySetAscendingSort(unitQueryID, true);
   }
   else
      return (-1);

   kbUnitQueryResetResults(unitQueryID);
   int numberFound = kbUnitQueryExecute(unitQueryID);
   if (numberFound > 0)
      return (kbUnitQueryGetResult(unitQueryID, 0)); // Return the first unit
   return (-1);
}

//==============================================================================
// getUnitCountByLocation
//
// Returns the number of matching units in the point/radius specified
//==============================================================================
int getUnitCountByLocation(int unitTypeID = -1, int playerRelationOrID = cMyID, int state = cUnitStateAlive,
                           vector location = cInvalidVector, float radius = 20.0)
{
   int count = -1;
   static int unitQueryID = -1;

   // If we don't have the query yet, create one.
   if (unitQueryID < 0)
   {
      unitQueryID = kbUnitQueryCreate("miscGetUnitLocationQuery");
   }

   // Define a query to get all matching units
   if (unitQueryID != -1)
   {
      if (playerRelationOrID > 1000) // Too big for player ID number
      {
         kbUnitQuerySetPlayerID(unitQueryID, -1);
         kbUnitQuerySetPlayerRelation(unitQueryID, playerRelationOrID);
      }
      else
      {
         kbUnitQuerySetPlayerRelation(unitQueryID, -1);
         kbUnitQuerySetPlayerID(unitQueryID, playerRelationOrID);
      }
      kbUnitQuerySetUnitType(unitQueryID, unitTypeID);
      kbUnitQuerySetState(unitQueryID, state);
      kbUnitQuerySetPosition(unitQueryID, location);
      kbUnitQuerySetMaximumDistance(unitQueryID, radius);
      kbUnitQuerySetIgnoreKnockedOutUnits(unitQueryID, true);
   }
   else
      return (-1);

   kbUnitQueryResetResults(unitQueryID);
   return (kbUnitQueryExecute(unitQueryID));
}

//==============================================================================
// getUnitCountByTactic
//==============================================================================
int getUnitCountByTactic(int unitTypeID = -1, int playerRelationOrID = cMyID, int state = cUnitStateAlive,
                         int tacticID = -1)
{
   int count = 0;
   static int unitQueryID = -1;

   // If we don't have the query yet, create one.
   if (unitQueryID < 0)
   {
      unitQueryID = kbUnitQueryCreate("tacticUnitQuery");
      kbUnitQuerySetIgnoreKnockedOutUnits(unitQueryID, true);
   }

   // Define a query to get all matching units
   if (unitQueryID != -1)
   {
      if (playerRelationOrID > 1000) // Too big for player ID number
      {
         kbUnitQuerySetPlayerID(unitQueryID, -1);
         kbUnitQuerySetPlayerRelation(unitQueryID, playerRelationOrID);
      }
      else
      {
         kbUnitQuerySetPlayerRelation(unitQueryID, -1);
         kbUnitQuerySetPlayerID(unitQueryID, playerRelationOrID);
      }
      kbUnitQuerySetUnitType(unitQueryID, unitTypeID);
      kbUnitQuerySetState(unitQueryID, state);
      // kbUnitQuerySetPosition(unitQueryID, location);
      // kbUnitQuerySetMaximumDistance(unitQueryID, radius);
   }
   else
      return (0);

   kbUnitQueryResetResults(unitQueryID);
   int numberFound = kbUnitQueryExecute(unitQueryID);
   for (i = 0; < numberFound)
   {
      if (aiUnitGetTactic(kbUnitQueryGetResult(unitQueryID, i)) == tacticID)
         count = count + 1;
   }

   return (count);
}

//==============================================================================
// getPlayerArmyHPs
//
// Queries all land military units.
// Totals hitpoints (ideal if considerHealth false, otherwise actual.)
// Returns total
//==============================================================================
float getPlayerArmyHPs(int playerID = -1, bool considerHealth = false)
{
   int queryID = -1; // Will recreate each time, as changing player trashes existing query settings.

   if (playerID <= 0)
      return (-1.0);

   queryID = kbUnitQueryCreate("getStrongestEnemyArmyHPs");
   kbUnitQuerySetIgnoreKnockedOutUnits(queryID, true);
   kbUnitQuerySetPlayerID(queryID, playerID, true);
   kbUnitQuerySetUnitType(queryID, cUnitTypeLogicalTypeLandMilitary);
   kbUnitQuerySetState(queryID, cUnitStateAlive);
   kbUnitQueryResetResults(queryID);
   kbUnitQueryExecute(queryID);

   return (kbUnitQueryGetUnitHitpoints(queryID, considerHealth));
}

//==============================================================================
/* sigmoid(float base, float adjustment, float floor, float ceiling)

   Used to adjust a number up or down in a sigmoid fashion, so that it
   grows very slowly at values near the bottom of the range, quickly near
   the center, and slowly near the upper limit.

   Used with the many 0..1 range variables, this lets us adjust them up
   or down by arbitrary "percentages" while retaining the 0..1 boundaries.
   That is, a 50% "boost" (1.5 adjustment) to a .9 score gives .933, while a


   Base is the number to be adjusted.
   Adjustment of 1.0 means 100%, i.e. stay where you are.
   Adjustment of 2.0 means to move it up by the LESSER movement of:
      Doubling the (base-floor) amount, or
      Cutting the (ceiling-base) in half (mul by 1/2.0).

   With a default floor of 0 and ceiling of 1, it gives these results:
      sigmoid(.1, 2.0) = .2
      sigmoid(.333, 2.0) = .667, upper and lower adjustments equal
      sigmoid(.8, 2.0) = .9, adjusted up 50% (1/2.0) of the headroom.
      sigmoid(.1, 5.0) = .50 (5x base, rather than moving up to .82)
      sigmoid(.333, 5.0) = .866, (leaving 1/5 of the .667 headroom)
      sigmoid(.8, 5.0) = .96 (leaving 1/5 of the .20 headroom)

   Adjustments of less than 1.0 (neutral) do the opposite...they move the
   value DOWN by the lesser movement of:
      Increasing headroom by a factor of 1/adjustment, or
      Decreasing footroom by multiplying by adjustment.
      sigmoid(.1, .5) = .05   (footroom*adjustment)
      sigmoid(.667, .5) = .333  (footroom*adjustment) = (headroom doubled)
      sigmoid(.8, .2) = .16 (footroom*0.2)

   Not intended for base < 0.  Ceiling must be > floor.  Must have floor <= base <= ceiling.
*/
//==============================================================================
float sigmoid(float base = -1.0 /*required*/, float adjust = 1.0, float floor = 0.0, float ceiling = 1.0)
{
   float retVal = -1.0;
   if (base < 0.0)
      return (retVal);
   if (ceiling <= floor)
      return (retVal);
   if (base < floor)
      return (retVal);
   if (base > ceiling)
      return (retVal);

   float footroom = base - floor;
   float headroom = ceiling - base;

   float footBasedNewValue = 0.0; // This will be the value created by adjusting the footroom, i.e.
                                  // increasing a small value.
   float headBasedNewValue = 0.0; // This will be the value created by adjusting the headroom, i.e.
                                  // increasing a value that's closer to ceiling than floor.

   if (adjust > 1.0)
   { // Increasing
      footBasedNewValue = floor + (footroom * adjust);
      headBasedNewValue = ceiling - (headroom / adjust);

      // Pick the value that resulted in the smaller net movement
      if ((footBasedNewValue - base) < (headBasedNewValue - base))
         retVal = footBasedNewValue; // The foot adjustment gave the smaller move.
      else
         retVal = headBasedNewValue; // The head adjustment gave the smaller move
   }
   else
   { // Decreasing
      footBasedNewValue = floor + (footroom * adjust);
      headBasedNewValue = ceiling - (headroom / adjust);

      // Pick the value that resulted in the smaller net movement
      if ((base - footBasedNewValue) < (base - headBasedNewValue))
         retVal = footBasedNewValue; // The foot adjustment gave the smaller move.
      else
         retVal = headBasedNewValue; // The head adjustment gave the smaller move
   }

   aiEcho("sigmoid(" + base + ", " + adjust + ", " + floor + ", " + ceiling + ") is " + retVal);
   return (retVal);
}

//==============================================================================
// createSimpleResearchPlan
//==============================================================================
int createSimpleResearchPlan(int techID = -1, int buildingID = -1, int escrowID = cRootEscrowID, int pri = 50)
{
   int planID = aiPlanCreate("Simple Research Plan, " + kbGetTechName(techID), cPlanResearch);
   if (planID < 0)
      aiEcho("Failed to create simple research plan for " + kbGetTechName(techID));
   else
   {
      aiPlanSetVariableInt(planID, cResearchPlanTechID, 0, techID);
      aiPlanSetVariableInt(planID, cResearchPlanBuildingID, 0, buildingID);
      aiPlanSetDesiredPriority(planID, pri);
      aiPlanSetEscrowID(planID, escrowID);
      aiPlanSetActive(planID);
		aiEcho("Created a Simple Research Plan for: " + kbGetTechName(techID) + " with plan number: " + planID);
   }

   return (planID);
}

//==============================================================================
// createNativeResearchPlan
//==============================================================================
int createNativeResearchPlan(int tacticID = cTacticNormal, int pri = 50, int need = 1, int want = 5, int max = 10)
{
   int buildingID = getUnit(cUnitTypeCommunityPlaza);
   int planID = -1;

   if (buildingID == -1)
   {
      // aiEcho("createNativeResearchPlan aborting: no community plaza.");
      return (-1);
   }

   aiEcho("Creating native research plan for tactic ID " + tacticID);
   planID = aiPlanCreate("NativeResearch " + tacticID, cPlanNativeResearch);

   if (planID < 0)
   {
      aiEcho("Failed to create simple research plan for " + tacticID);
      return (-1);
   }
   else
   {
      // TODO: Change tactic ID based on power you want and remove use of tech ID
      aiPlanSetVariableInt(planID, cNativeResearchPlanTacticID, 0, tacticID);
      aiPlanSetVariableInt(planID, cNativeResearchPlanBuildingID, 0, buildingID);
      aiPlanSetDesiredPriority(planID, pri);
      // aiPlanSetEscrowID(planID, escrowID);
      aiPlanAddUnitType(planID, gEconUnit, need, want, max);
      aiPlanSetActive(planID);
   }
   return (planID);
}

//==============================================================================
// chooseConsulateFlag
//==============================================================================
void chooseConsulateFlag()
{
   int consulatePlanID = -1;
   int randomizer = aiRandInt(100); // 0-99
   int flag_button_id = -1;
   int upgradePlanID = -1;

   if ((cMyCiv == cCivChinese) || (cMyCiv == cCivSPCChinese))
   {
	   flag_button_id = cTechypBigConsulateFrench;
	   
			if (kbTechGetStatus(cTechypBigConsulateFrench) == cTechStatusActive)
	   {
       if ((kbTechGetStatus(cTechypConsulateFrenchWoodCrates) == cTechStatusObtainable) ||
	   (kbTechGetStatus(cTechypConsulateFrenchCoinCrates) == cTechStatusObtainable) ||
       (kbTechGetStatus(cTechypConsulateFrenchFoodCrates) == cTechStatusObtainable))
	   return;
	   else
	   {
      createSimpleResearchPlan(cTechypBigSequester, getUnit(cUnitTypeypConsulate), cEconomyEscrowID, 50);
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypBigSequesterFrench);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechypBigSequesterFrench, getUnit(cUnitTypeypConsulate), cEconomyEscrowID, 50);
	  flag_button_id = cTechypBigConsulateGermans;
		}
	   }
	   
			if (kbTechGetStatus(cTechypBigConsulateGermans) == cTechStatusActive)
	   {
		if ((kbTechGetStatus(cTechypConsulateGermansFoodTrickle) == cTechStatusObtainable) ||
	   (kbTechGetStatus(cTechypConsulateGermansWoodTrickle) == cTechStatusObtainable) ||
       (kbTechGetStatus(cTechypConsulateGermansCoinTrickle) == cTechStatusObtainable))
	   return;
	   else
	   {
      createSimpleResearchPlan(cTechypBigSequester, getUnit(cUnitTypeypConsulate), cEconomyEscrowID, 50);
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypBigSequesterGermans);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechypBigSequesterGermans, getUnit(cUnitTypeypConsulate), cEconomyEscrowID, 50);
	   flag_button_id = cTechypBigConsulateRussians;
		}
	   }
	   
			if (kbTechGetStatus(cTechypBigConsulateRussians) == cTechStatusActive)
	   {
	   if ((kbTechGetStatus(cTechypConsulateRussianFortWagon) == cTechStatusObtainable) ||
	   (kbTechGetStatus(cTechypConsulateRussianFactoryWagon) == cTechStatusObtainable) ||
       (kbTechGetStatus(cTechypConsulateRussianOutpostWagon) == cTechStatusObtainable))
	   return;
       else
		{
      createSimpleResearchPlan(cTechypBigSequester, getUnit(cUnitTypeypConsulate), cEconomyEscrowID, 50);
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypBigSequesterRussians);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechypBigSequesterRussians, getUnit(cUnitTypeypConsulate), cEconomyEscrowID, 50);
       flag_button_id = cTechypBigConsulateBritish;
		}
	   }
   }
	   
   if ((cMyCiv == cCivIndians) || (cMyCiv == cCivSPCIndians))
   {
	   /*
	   if (kbUnitCount(cMyID, cUnitTypeHomeCityWaterSpawnFlag) > 0)
      {
       flag_button_id = cTechypBigConsulatePortuguese;
	   
			if (kbTechGetStatus(cTechypBigConsulatePortuguese) == cTechStatusActive)
	   {
	   if (kbTechGetStatus(cTechypConsulatePortugueseFishingFleet) == cTechStatusObtainable)
       return;
	   else
	   {
      createSimpleResearchPlan(cTechypBigSequester, getUnit(cUnitTypeypConsulate), cEconomyEscrowID, 50);
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypBigSequesterPortuguese);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechypBigSequesterPortuguese, getUnit(cUnitTypeypConsulate), cEconomyEscrowID, 50);
	  flag_button_id = cTechypBigConsulateOttomans;
		}
	  }
	  }
	  else
		  */
	   flag_button_id = cTechypBigConsulateOttomans;
   
			if (kbTechGetStatus(cTechypBigConsulateOttomans) == cTechStatusActive)
	   {
       if (kbTechGetStatus(cTechypConsulateOttomansInfantrySpeed) == cTechStatusObtainable)
	   return;
	   else
	   {
      createSimpleResearchPlan(cTechypBigSequester, getUnit(cUnitTypeypConsulate), cEconomyEscrowID, 50);
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypBigSequesterOttomans);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechypBigSequesterOttomans, getUnit(cUnitTypeypConsulate), cEconomyEscrowID, 50);
	  flag_button_id = cTechypBigConsulateFrench;
		}
	   }
	   
			if (kbTechGetStatus(cTechypBigConsulateFrench) == cTechStatusActive)
	   {
       if ((kbTechGetStatus(cTechypConsulateFrenchWoodCrates) == cTechStatusObtainable) ||
	   (kbTechGetStatus(cTechypConsulateFrenchCoinCrates) == cTechStatusObtainable) ||
       (kbTechGetStatus(cTechypConsulateFrenchFoodCrates) == cTechStatusObtainable))
	   return;
	   else
	   {
      createSimpleResearchPlan(cTechypBigSequester, getUnit(cUnitTypeypConsulate), cEconomyEscrowID, 50);
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypBigSequesterFrench);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechypBigSequesterFrench, getUnit(cUnitTypeypConsulate), cEconomyEscrowID, 50);
	  flag_button_id = cTechypBigConsulateBritish;
		}
	   }
   }

   if ((cMyCiv == cCivJapanese) || (cMyCiv == cCivSPCJapanese))
   {
	   /*
	  if (kbUnitCount(cMyID, cUnitTypeHomeCityWaterSpawnFlag) > 0)
      {
       flag_button_id = cTechypBigConsulatePortuguese;
	   
			if (kbTechGetStatus(cTechypBigConsulatePortuguese) == cTechStatusActive)
	   {
	   if (kbTechGetStatus(cTechypConsulatePortugueseFishingFleet) == cTechStatusObtainable)
       return;
	   else
	   {
      createSimpleResearchPlan(cTechypBigSequester, getUnit(cUnitTypeypConsulate), cEconomyEscrowID, 50);
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypBigSequesterPortuguese);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechypBigSequesterPortuguese, getUnit(cUnitTypeypConsulate), cEconomyEscrowID, 50);
	  flag_button_id = cTechypBigConsulateSpanish;
		}
	  }
	  }
	  else
		  */
	   flag_button_id = cTechypBigConsulateSpanish;
   
			if (kbTechGetStatus(cTechypBigConsulateSpanish) == cTechStatusActive)
	   {
			if ((kbTechGetStatus(cTechypConsulateSpanishFasterShipments) == cTechStatusObtainable) ||
	   (kbTechGetStatus(cTechypConsulateSpanishMercantilism) == cTechStatusObtainable) ||
       (kbTechGetStatus(cTechypConsulateSpanishEnhancedProfits) == cTechStatusObtainable))
	   return;
	   else
	   {
      createSimpleResearchPlan(cTechypBigSequester, getUnit(cUnitTypeypConsulate), cEconomyEscrowID, 50);
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypBigSequesterSpanish);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechypBigSequesterSpanish, getUnit(cUnitTypeypConsulate), cEconomyEscrowID, 50);
	  flag_button_id = cTechypBigConsulateDutch;
		}
	   }
	   
			if (kbTechGetStatus(cTechypBigConsulateDutch) == cTechStatusActive)
	   {
	   if ((kbTechGetStatus(cTechypConsulateDutchArsenalWagon) == cTechStatusObtainable) ||
	   (kbTechGetStatus(cTechypConsulateDutchSaloonWagon) == cTechStatusObtainable) ||
	   (kbTechGetStatus(cTechypConsulateDutchLivestockPenWagon) == cTechStatusObtainable) ||
       (kbTechGetStatus(cTechypConsulateDutchChurchWagon) == cTechStatusObtainable))
	   return;
	   else
	   {
      createSimpleResearchPlan(cTechypBigSequester, getUnit(cUnitTypeypConsulate), cEconomyEscrowID, 50);
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypBigSequesterDutch);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechypBigSequesterDutch, getUnit(cUnitTypeypConsulate), cEconomyEscrowID, 50);
	  flag_button_id = cTechypBigConsulateJapanese;
		}
	   }
   }

   if (kbTechGetStatus(flag_button_id) == cTechStatusObtainable)
   {
      consulatePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, flag_button_id);
      if (consulatePlanID < 0)
      {
         aiEcho("************Consulate Flag************");
         aiEcho("Our Consulate flag is: " + kbGetTechName(flag_button_id));
         aiEcho("Randomizer value: " + randomizer);
         createSimpleResearchPlan(flag_button_id, getUnit(cUnitTypeypConsulate), cEconomyEscrowID, 40);
         gFlagChosen = true;
      }
   }
}

/*void setConsulateArmyPreference() 
{
  if (kbUnitCount(cMyID, cUnitTypeypConsulate, cUnitStateAlive) < 1) 
	
  {  return;  }
  
  if (kbTechGetStatus(cTechypBigConsulatePortuguese) == cTechStatusActive) 
  {
    if (kbGetAge() == cAge2)
	{
    kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateArmyPortuguese1, 0.1);
	}
    if (kbGetAge() < cAge5)
	{
    kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateArmyPortuguese2, 0.5);
	}
    kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateArmyPortuguese3, 1.0);
  }
  
  if (kbTechGetStatus(cTechypBigConsulateDutch) == cTechStatusActive) 
  {
    if (kbGetAge() == cAge2)
	{
    kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateArmyDutch1, 0.1);
	}
    if (kbGetAge() < cAge5)
	{
    kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateArmyDutch2, 0.5);
	}
    kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateArmyDutch3, 1.0);
  }
  
  if (kbTechGetStatus(cTechypBigConsulateRussians) == cTechStatusActive) {
    if (kbGetAge() == cAge2)
	{
    kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateArmyRussian1, 0.5);
	}
    if (kbGetAge() < cAge5)
	{
    kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateArmyRussian2, 0.5);
	}
    kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateArmyRussian3, 1.0);
  }
  
  if (kbTechGetStatus(cTechypBigConsulateSpanish) == cTechStatusActive) {
    if (kbGetAge() == cAge2)
	{
    //kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateArmySpanish1, 0.0);
	}
    if (kbGetAge() < cAge5)
	{
    kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateArmySpanish2, 0.5);
	}
    kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateArmySpanish3, 1.0);
  }
  
  if (kbTechGetStatus(cTechypBigConsulateBritish) == cTechStatusActive) {
    if (kbGetAge() == cAge2)
	{
    kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateArmyBritish1, 0.1);
	}
    if (kbGetAge() < cAge5)
	{
    kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateArmyBritish2, 0.5);
	}
    kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateArmyBritish3, 1.0);      
  }
  
  if (kbTechGetStatus(cTechypBigConsulateFrench) == cTechStatusActive) {
    //kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateArmyFrench1, 0.0);
    //kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateArmyFrench2, 0.0);
    kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateArmyFrench3, 1.0); 
  }
  
  if (kbTechGetStatus(cTechypBigConsulateGermans) == cTechStatusActive) {
    if (kbGetAge() == cAge2)
	{
    //kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateArmyGerman1, 0.0);
	}
    if (kbGetAge() < cAge5)
	{
    kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateArmyGerman2, 0.5);
	}
    kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateArmyGerman3, 1.0); 
  }
  
  if (kbTechGetStatus(cTechypBigConsulateOttomans) == cTechStatusActive) {
    if (kbGetAge() == cAge2)
	{
    kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateArmyOttoman1, 0.1);
	}
    if (kbGetAge() < cAge5)
	{
    kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateArmyOttoman2, 0.5);
	}
    kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateArmyOttoman3, 1.0);
  }
  //if (kbTechGetStatus(cTechypBigConsulateJapanese) == cTechStatusActive) {
    //kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateYamabushi, 0.1);
    //kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateShinobi, 0.3);
    //kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateNinja, 0.1);
    //kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateRonin, 1.0);
  //}
}
*/
void setStandardArmyPreference() 
{ 
   //kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypexpColonialMilitia, 0.5);
   kbUnitPickSetPreferenceFactor(gLandUnitPicker, gLandPrimaryArmyUnit, 0.5);
   kbUnitPickSetPreferenceFactor(gLandUnitPicker, gLandSecondaryArmyUnit, 0.3);
	
																		 
	
   kbUnitPickSetPreferenceFactor(gLandUnitPicker, gLandTertiaryArmyUnit, 0.2);
   //kbUnitPickSetPreferenceFactor(gLandUnitPicker, gAbstractArtilleryUnit, 0.1);
   //if (kbGetAge() >= cAge4)
   //{
   ////kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractNativeWarrior, 0.5); 
   //}   
}

//==============================================================================
// createSimpleTrainPlan
//==============================================================================
int createSimpleTrainPlan(int puid = -1, int number = 1, int escrowID = -1, int baseID = -1, int batchSize = 1)
{
   // Create a the plan name.
   string planName = "Simple";
   planName = planName + kbGetProtoUnitName(puid) + "Train";
   int planID = aiPlanCreate(planName, cPlanTrain);
   if (planID < 0)
      return (-1);

   // Escrow.
   aiPlanSetEscrowID(planID, escrowID);
   // Unit type.
   aiPlanSetVariableInt(planID, cTrainPlanUnitType, 0, puid);
   // Number.
   aiPlanSetVariableInt(planID, cTrainPlanNumberToTrain, 0, number);
   // Batch size
   aiPlanSetVariableInt(planID, cTrainPlanBatchSize, 0, batchSize);

   // If we have a base ID, use it.
   if (baseID >= 0)
   {
      aiPlanSetBaseID(planID, baseID);
      aiPlanSetVariableVector(planID, cTrainPlanGatherPoint, 0, kbBaseGetMilitaryGatherPoint(cMyID, baseID));
   }

   aiPlanSetActive(planID);

   // Done.
   return (planID);
}

//==============================================================================
// createSimpleMaintainPlan
//==============================================================================
int createSimpleMaintainPlan(int puid = -1, int number = 1, bool economy = true, int baseID = -1, int batchSize = 1)
{
   // Create a the plan name.
   string planName = "Military";
   if (economy == true)
      planName = "Economy";
   planName = planName + kbGetProtoUnitName(puid) + "Maintain";
   int planID = aiPlanCreate(planName, cPlanTrain);
   if (planID < 0)
      return (-1);

   // Economy or Military.
   if (economy == true)
      aiPlanSetEconomy(planID, true);
   else
      aiPlanSetMilitary(planID, true);
   // Unit type.
   aiPlanSetVariableInt(planID, cTrainPlanUnitType, 0, puid);
   // Number.
   aiPlanSetVariableInt(planID, cTrainPlanNumberToMaintain, 0, number);
   // Batch size
   aiPlanSetVariableInt(planID, cTrainPlanBatchSize, 0, batchSize);

   // If we have a base ID, use it.
   if (baseID >= 0)
   {
      aiPlanSetBaseID(planID, baseID);
      if (economy == false)
         aiPlanSetVariableVector(planID, cTrainPlanGatherPoint, 0, kbBaseGetMilitaryGatherPoint(cMyID, baseID));
   }

   //   aiPlanSetVariableBool(planID, cTrainPlanUseHomeCityShipments, 0, true);

   aiPlanSetActive(planID);

   // Done.
   return (planID);
}

//==============================================================================
// findWagonToBuild
//==============================================================================
int findWagonToBuild(int puid = -1)
{
	if (kbProtoUnitAvailable(puid) == false) // Safeguard against assigning Wagons to build plans for buildings in the next age because that will glitch out.
		return (-1);

   int builderType = -1;

   switch (puid)
   {
   case cUnitTypeypRicePaddy:
   {
      if (kbUnitCount(cMyID, cUnitTypeYPRicePaddyWagon, cUnitStateAlive) > 0)
         builderType = cUnitTypeYPRicePaddyWagon;
      break;
   }
   case cUnitTypeypTradeMarketAsian:
   {
      if (kbUnitCount(cMyID, cUnitTypeypMarketWagon, cUnitStateAlive) > 0)
         builderType = cUnitTypeypMarketWagon;
      break;
   }
   case cUnitTypeypShrineJapanese:
   {
      if (kbUnitCount(cMyID, cUnitTypeypShrineWagon, cUnitStateAlive) > 0)
         builderType = cUnitTypeypShrineWagon;
      break;
   }
   case cUnitTypeYPLivestockPenAsian:
   {
      if (kbUnitCount(cMyID, cUnitTypedeLivestockPenWagonJapanese, cUnitStateAlive) > 0)
         builderType = cUnitTypedeLivestockPenWagonJapanese;
      break;
   }
   case cUnitTypeypMonastery:
   {
      if (kbUnitCount(cMyID, cUnitTypeYPMonasteryWagon, cUnitStateAlive) > 0)
         builderType = cUnitTypeYPMonasteryWagon;
      break;
   }
   case cUnitTypeypBerryBuilding:
   {
      if (kbUnitCount(cMyID, cUnitTypeYPBerryWagon1, cUnitStateAlive) > 0)
         builderType = cUnitTypeYPBerryWagon1;
      break;
   }
   case cUnitTypeTradingPost:
   {
      if (kbUnitCount(cMyID, cUnitTypeypTradingPostWagon, cUnitStateAlive) > 0)
         builderType = cUnitTypeypTradingPostWagon;
      else if (kbUnitCount(cMyID, cUnitTypedeTradingPostWagon, cUnitStateAlive) > 0)
         builderType = cUnitTypedeTradingPostWagon;
		else if (kbUnitCount(cMyID, cUnitTypedeRedSeaWagon, cUnitStateAlive) > 0)
         builderType = cUnitTypedeRedSeaWagon;
      break;
   }
   case cUnitTypeypBarracksJapanese:
   {
      if (kbUnitCount(cMyID, cUnitTypeYPMilitaryRickshaw, cUnitStateAlive) > 0)
         builderType = cUnitTypeYPMilitaryRickshaw;
      break;
   }
   case cUnitTypeypStableJapanese:
   {
      if (kbUnitCount(cMyID, cUnitTypeYPMilitaryRickshaw, cUnitStateAlive) > 0)
         builderType = cUnitTypeYPMilitaryRickshaw;
      else if (kbUnitCount(cMyID, cUnitTypeYPStableWagon, cUnitStateAlive) > 0)
         builderType = cUnitTypeYPStableWagon;
      break;
   }
   case cUnitTypeypCaravanserai:
   {
      if (kbUnitCount(cMyID, cUnitTypeYPStableWagon, cUnitStateAlive) > 0)
         builderType = cUnitTypeYPStableWagon;
      break;
   }
   case cUnitTypeypWarAcademy:
   {
      if (kbUnitCount(cMyID, cUnitTypeYPStableWagon, cUnitStateAlive) > 0)
         builderType = cUnitTypeYPStableWagon;
      break;
   }
   case cUnitTypeypDojo:
   {
      if (kbUnitCount(cMyID, cUnitTypeYPDojoWagon, cUnitStateAlive) > 0)
         builderType = cUnitTypeYPDojoWagon;
      break;
   }
   case cUnitTypeypSacredField:
   {
      if (kbUnitCount(cMyID, cUnitTypeYPSacredFieldWagon, cUnitStateAlive) > 0)
         builderType = cUnitTypeYPSacredFieldWagon;
      break;
   }
   case cUnitTypeDock:
   {
      if (kbUnitCount(cMyID, cUnitTypeYPDockWagon, cUnitStateAlive) > 0)
         builderType = cUnitTypeYPDockWagon;
      break;
   }
   case cUnitTypeYPDockAsian:
   {
      if (kbUnitCount(cMyID, cUnitTypeYPDockWagon, cUnitStateAlive) > 0)
         builderType = cUnitTypeYPDockWagon;
      break;
   }
   case cUnitTypeBank:
   {
      if (cMyCiv == cCivDutch && kbUnitCount(cMyID, cUnitTypeBankWagon, cUnitStateAlive) > 0)
         builderType = cUnitTypeBankWagon;
      break;
   }
   case cUnitTypeOutpost:
   {
      if (kbUnitCount(cMyID, cUnitTypeOutpostWagon, cUnitStateAlive) > 0)
         builderType = cUnitTypeOutpostWagon;
      break;
   }
   case cUnitTypeBlockhouse:
   {
      if (cMyCiv == cCivRussians)
      {
         if (kbUnitCount(cMyID, cUnitTypeOutpostWagon, cUnitStateAlive) > 0)
            builderType = cUnitTypeOutpostWagon;
         else if (kbUnitCount(cMyID, cUnitTypedeMilitaryWagon, cUnitStateAlive) > 0)
            builderType = cUnitTypedeMilitaryWagon;
      }
      else if ((civIsAsian() == true || (gRevolutionType & cRevolutionFinland) == cRevolutionFinland) &&
               kbUnitCount(cMyID, cUnitTypeypBlockhouseWagon, cUnitStateAlive) > 0)
         builderType = cUnitTypeypBlockhouseWagon;
      break;
   }
   case cUnitTypeWarHut:
   {
      if (kbUnitCount(cMyID, cUnitTypeWarHutTravois, cUnitStateAlive) > 0)
         builderType = cUnitTypeWarHutTravois;
      else if (kbUnitCount(cMyID, cUnitTypeOutpostWagon, cUnitStateAlive) > 0)
         builderType = cUnitTypeOutpostWagon;
      else if (kbUnitCount(cMyID, cUnitTypedeBuilderInca, cUnitStateAlive) > 0)
         builderType = cUnitTypedeBuilderInca;
      else if (kbUnitCount(cMyID, cUnitTypeYPStableWagon, cUnitStateAlive) > 0)
         builderType = cUnitTypeYPStableWagon;
      break;
   }
   case cUnitTypeNoblesHut:
   {
      if (kbUnitCount(cMyID, cUnitTypeNoblesHutTravois, cUnitStateAlive) > 0)
         builderType = cUnitTypeNoblesHutTravois;
      break;
   }
   case cUnitTypeCorral:
   {
      if (kbUnitCount(cMyID, cUnitTypeYPStableWagon, cUnitStateAlive) > 0)
         builderType = cUnitTypeYPStableWagon;
      break;
   }
   case cUnitTypeypCastle:
   {
      if (kbUnitCount(cMyID, cUnitTypeYPCastleWagon, cUnitStateAlive) > 0)
         builderType = cUnitTypeYPCastleWagon;
      break;
   }
   case cUnitTypeFactory:
   {
      if (kbUnitCount(cMyID, cUnitTypeFactoryWagon, cUnitStateAlive) > 0)
         builderType = cUnitTypeFactoryWagon;
      break;
   }
   case cUnitTypeypVillage:
   {
      if (kbUnitCount(cMyID, cUnitTypeYPVillageWagon, cUnitStateAlive) > 0)
         builderType = cUnitTypeYPVillageWagon;
      break;
   }
   case cUnitTypeypGroveBuilding:
   {
      if (kbUnitCount(cMyID, cUnitTypeYPGroveWagon, cUnitStateAlive) > 0)
         builderType = cUnitTypeYPGroveWagon;
      break;
   }
   case cUnitTypeypArsenalAsian:
   {
      if (kbUnitCount(cMyID, cUnitTypeypArsenalWagon, cUnitStateAlive) > 0)
         builderType = cUnitTypeypArsenalWagon;
      break;
   }
   case cUnitTypeypBankAsian:
   {
      if (kbUnitCount(cMyID, cUnitTypeypBankWagon, cUnitStateAlive) > 0)
         builderType = cUnitTypeypBankWagon;
      break;
   }
   case cUnitTypeypChurch:
   {
      if (kbUnitCount(cMyID, cUnitTypeypChurchWagon, cUnitStateAlive) > 0)
         builderType = cUnitTypeypChurchWagon;
      break;
   }
   case cUnitTypeFarm:
   {
      if (kbUnitCount(cMyID, cUnitTypeFarmTravois, cUnitStateAlive) > 0)
         builderType = cUnitTypeFarmTravois;
      else if (kbUnitCount(cMyID, cUnitTypedeBuilderInca, cUnitStateAlive) > 0)
         builderType = cUnitTypedeBuilderInca;
      break;
   }
   case cUnitTypedeKallanka:
   {
      if (kbUnitCount(cMyID, cUnitTypedeKallankaTravois, cUnitStateAlive) > 0)
         builderType = cUnitTypedeKallankaTravois;
      else
      if (kbUnitCount(cMyID, cUnitTypedeBuilderInca, cUnitStateAlive) > 0)
         builderType = cUnitTypedeBuilderInca;
      break;
   }
   case cUnitTypedeIncaStronghold:
   {
      if (kbUnitCount(cMyID, cUnitTypedeIncaStrongholdTravois, cUnitStateAlive) > 0)
         builderType = cUnitTypedeIncaStrongholdTravois;
      break;
   }
   case cUnitTypedeTorp:
   {
      if (kbUnitCount(cMyID, cUnitTypedeTorpWagon, cUnitStateAlive) > 0)
         builderType = cUnitTypedeTorpWagon;
      break;
   }
   case cUnitTypedeTorpGeneric:
   {
      if (kbUnitCount(cMyID, cUnitTypedeTorpWagon, cUnitStateAlive) > 0)
         builderType = cUnitTypedeTorpWagon;
      break;
   }
   case cUnitTypedeMineCopperBuildable:
   {
      if (kbUnitCount(cMyID, cUnitTypedeProspectorWagon, cUnitStateAlive) > 0)
         builderType = cUnitTypedeProspectorWagon;
      break;
   }
   case cUnitTypedeMineGoldBuildable:
   {
      if (kbUnitCount(cMyID, cUnitTypedeProspectorWagonGold, cUnitStateAlive) > 0)
         builderType = cUnitTypedeProspectorWagonGold;
      break;
   }
   case cUnitTypedeREVMineDiamondBuildable:
   {
      if (kbUnitCount(cMyID, cUnitTypedeREVProspectorWagon, cUnitStateAlive) > 0)
         builderType = cUnitTypedeREVProspectorWagon;
      break;
   }
	case cUnitTypedeMineSilverBuildable:
   {
      if (kbUnitCount(cMyID, cUnitTypedeProspectorWagonSilver, cUnitStateAlive) > 0)
         builderType = cUnitTypedeProspectorWagonSilver;
      break;
   }
   case cUnitTypeMill:
   {
      if (kbUnitCount(cMyID, cUnitTypedeHomesteadWagon, cUnitStateAlive) > 0)
         builderType = cUnitTypedeHomesteadWagon;
      else if (kbUnitCount(cMyID, cUnitTypeDEMillWagon, cUnitStateAlive) > 0)
         builderType = cUnitTypeDEMillWagon;
      break;
   }
   case cUnitTypePlantation:
   {
      if (kbUnitCount(cMyID, cUnitTypedeHomesteadWagon, cUnitStateAlive) > 0)
         builderType = cUnitTypedeHomesteadWagon;
      else if (kbUnitCount(cMyID, cUnitTypedePlantationWagon, cUnitStateAlive) > 0)
         builderType = cUnitTypedePlantationWagon;
      break;
   }
   case cUnitTypeLivestockPen:
   {
      if (kbUnitCount(cMyID, cUnitTypedeHomesteadWagon, cUnitStateAlive) > 0)
         builderType = cUnitTypedeHomesteadWagon;
      break;
   }
   case cUnitTypeStable:
   {
      if (kbUnitCount(cMyID, cUnitTypedeMilitaryWagon, cUnitStateAlive) > 0)
         builderType = cUnitTypedeMilitaryWagon;
      else if (kbUnitCount(cMyID, cUnitTypeYPStableWagon, cUnitStateAlive) > 0)
         builderType = cUnitTypeYPStableWagon;
      break;
   }
   case cUnitTypeArtilleryDepot:
   {
      if (kbUnitCount(cMyID, cUnitTypedeMilitaryWagon, cUnitStateAlive) > 0)
         builderType = cUnitTypedeMilitaryWagon;
      break;
   }
   case cUnitTypeArsenal:
   {
      if (kbUnitCount(cMyID, cUnitTypeypArsenalWagon, cUnitStateAlive) > 0)
         builderType = cUnitTypeypArsenalWagon;
      break;
   }
   case cUnitTypeTownCenter:
   {
      if (kbUnitCount(cMyID, gCoveredWagonUnit, cUnitStateAlive) > 0)
         builderType = gCoveredWagonUnit;
      else if (kbUnitCount(cMyID, cUnitTypedeBuilderKingdom, cUnitStateAlive) > 0)
         builderType = cUnitTypedeBuilderKingdom;
      break;
   }
   case cUnitTypedeFurTrade:
   {
      if (kbUnitCount(cMyID, cUnitTypedeFurTradeTravois, cUnitStateAlive) > 0)
         builderType = cUnitTypedeFurTradeTravois;
      break;
   }
   case cUnitTypeFortFrontier:
   {
      if (kbUnitCount(cMyID, cUnitTypeFortWagon, cUnitStateAlive) > 0)
         builderType = cUnitTypeFortWagon;
      break;
   }
   case cUnitTypeLonghouse:
   {
      if (kbUnitCount(cMyID, cUnitTypexpBuilderStart, cUnitStateAlive) > 0)
         builderType = cUnitTypexpBuilderStart;
      break;
   }
   case cUnitTypedeStateCapitol:
   {
      if (cMyCiv == cCivDEAmericans && kbUnitCount(cMyID, cUnitTypedeStateCapitolWagon, cUnitStateAlive) > 0)
         builderType = cUnitTypedeStateCapitolWagon;
      break;
   }
   case cUnitTypeSaloon:
   {
      if (kbTechGetStatus(cTechDEHCArkansasPost) == cTechStatusActive &&
          kbUnitCount(cMyID, cUnitTypedeTradingPostWagon, cUnitStateAlive) > 0)
         builderType = cUnitTypedeTradingPostWagon;
      break;
   }
   case cUnitTypeChurch:
   {
      if (kbUnitCount(cMyID, cUnitTypeypChurchWagon, cUnitStateAlive) > 0)
         builderType = cUnitTypeypChurchWagon;
      else if (kbTechGetStatus(cTechDEHCArkansasPost) == cTechStatusActive &&
               kbUnitCount(cMyID, cUnitTypedeTradingPostWagon, cUnitStateAlive) > 0)
         builderType = cUnitTypedeTradingPostWagon;
      break;
   }
   case cUnitTypeMarket:
   {
      if (kbTechGetStatus(cTechDEHCArkansasPost) == cTechStatusActive &&
          kbUnitCount(cMyID, cUnitTypedeTradingPostWagon, cUnitStateAlive) > 0)
         builderType = cUnitTypedeTradingPostWagon;
      break;
   }
   case cUnitTypedeLivestockMarket:
   {
      if (kbUnitCount(cMyID, cUnitTypedeBuilderAfrican, cUnitStateAlive) > 0)
         builderType = cUnitTypedeBuilderAfrican;
      else if (kbUnitCount(cMyID, cUnitTypedeLivestockMarketWagon, cUnitStateAlive) > 0)
         builderType = cUnitTypedeLivestockMarketWagon;
      else if (kbUnitCount(cMyID, cUnitTypedeBuilderHausa, cUnitStateAlive) > 0)
         builderType = cUnitTypedeBuilderHausa;
		else if (kbUnitCount(cMyID, cUnitTypedeRedSeaWagon, cUnitStateAlive) > 0)
         builderType = cUnitTypedeRedSeaWagon;
      break;
   }
   case cUnitTypedeWarCamp:
   {
      if (kbUnitCount(cMyID, cUnitTypedeCampWagon, cUnitStateAlive) > 0)
         builderType = cUnitTypedeCampWagon;
      else if (kbUnitCount(cMyID, cUnitTypedeBuilderHausa, cUnitStateAlive) > 0)
         builderType = cUnitTypedeBuilderHausa;
		else if (kbUnitCount(cMyID, cUnitTypedeRedSeaWagon, cUnitStateAlive) > 0)
         builderType = cUnitTypedeRedSeaWagon;
      break;
   }
   case cUnitTypedeTower:
   {
      if (kbUnitCount(cMyID, cUnitTypedeTowerBuilder, cUnitStateAlive) > 0)
         builderType = cUnitTypedeTowerBuilder;
      else if (kbUnitCount(cMyID, cUnitTypedeCampWagon, cUnitStateAlive) > 0)
         builderType = cUnitTypedeCampWagon;
      else if (kbUnitCount(cMyID, cUnitTypeOutpostWagon, cUnitStateAlive) > 0)
         builderType = cUnitTypeOutpostWagon;
		else if (kbUnitCount(cMyID, cUnitTypedeRedSeaWagon, cUnitStateAlive) > 0)
         builderType = cUnitTypedeRedSeaWagon;
      break;
   }
   case cUnitTypedeMountainMonastery:
   {
      if (kbUnitCount(cMyID, cUnitTypedeMountainMonasteryBuilder, cUnitStateAlive) > 0)
         builderType = cUnitTypedeMountainMonasteryBuilder;
      break;
   }
   case cUnitTypedePort:
   {
      if (kbUnitCount(cMyID, cUnitTypedeBuilderHausa, cUnitStateAlive) > 0)
         builderType = cUnitTypedeBuilderHausa;
		else if (kbUnitCount(cMyID, cUnitTypedeRedSeaWagon, cUnitStateAlive) > 0)
         builderType = cUnitTypedeRedSeaWagon;
      break;
   }
   case cUnitTypedeUniversity:
   {
      if (kbUnitCount(cMyID, cUnitTypedeUniversityBuilder, cUnitStateAlive) > 0)
         builderType = cUnitTypedeUniversityBuilder;
      else if (kbUnitCount(cMyID, cUnitTypedeBuilderKingdom, cUnitStateAlive) > 0)
         builderType = cUnitTypedeBuilderKingdom;
      break;
   }
   case cUnitTypedePalace:
   {
      if (kbUnitCount(cMyID, cUnitTypedeBuilderKingdom, cUnitStateAlive) > 0)
         builderType = cUnitTypedeBuilderKingdom;
		else if (kbUnitCount(cMyID, cUnitTypedePalaceBuilder, cUnitStateAlive) > 0)
         builderType = cUnitTypedePalaceBuilder;
      break;
   }
	case cUnitTypeNativeEmbassy:
      {
			if (kbUnitCount(cMyID, cUnitTypedeEmbassyTravois, cUnitStateAlive) > 0)
				builderType = cUnitTypedeEmbassyTravois;
         break;
      }
   }
	
	// Do all the checks before we want to return an Empire Wars Wagon to a plan.
	if (builderType == -1 && aiGetGameMode() == cGameModeEmpireWars && 
	(kbUnitCostPerResource(puid, cResourceGold) +
	kbUnitCostPerResource(puid, cResourceWood) +
	kbUnitCostPerResource(puid, cResourceFood)) > 100) // Prevent EW Wagons being used for cheap buildings, Houses mainly.
	{
		int ewImperialWagonQuery = createSimpleUnitQuery(cUnitTypedeImperialWagon);
		int numResults = kbUnitQueryExecute(ewImperialWagonQuery);
		if (numResults > 0)
		{
			for (i = 0; < numResults)
			{
				if (kbUnitGetPlanID(kbUnitQueryGetResult(ewImperialWagonQuery, i)) < 0)
				{
					if (kbProtoUnitCanTrain(cUnitTypedeImperialWagon, puid) == true)
					{
						builderType = cUnitTypedeImperialWagon;
						return (builderType);
					}
				}
			}
		}	
	}
	return (builderType);
}

//==============================================================================
// addBuilderToPlan
//==============================================================================
bool addBuilderToPlan(int planID = -1, int puid = -1, int numberBuilders = 1)
{
   int builderType = findWagonToBuild(puid);
   if (builderType >= 0)
   {
      aiPlanAddUnitType(planID, builderType, 1, 1, 1);
      return (true);
   }

   if ((gRevolutionType & cRevolutionMilitary) == cRevolutionMilitary && (gRevolutionType & cRevolutionFinland) == 0)
      return (false);

      int heroQuery = createSimpleUnitQuery(cUnitTypeHero, cMyID, cUnitStateAlive);
      int numberFound = 0;
	  
   if (puid == cUnitTypeTownCenter)
   {
      // US hero cannot build town centers.
      if (cMyCiv != cCivDEAmericans)
         numberFound = kbUnitQueryExecute(heroQuery);

      if (numberBuilders > 1)
      {
         if (numberFound > 0)
         {
            aiPlanAddUnitType(planID, cUnitTypeHero, 1, 1, 1);
            numberBuilders = numberBuilders - 1;
         }

         if (numberBuilders > 0)
            aiPlanAddUnitType(planID, gEconUnit, numberBuilders, numberBuilders, numberBuilders);
      }
      else
      {
         numberBuilders = round(kbProtoUnitGetBuildPoints(puid) / 30.0);

         if (numberFound > 0)
         {
            aiPlanAddUnitType(planID, cUnitTypeHero, 1, 1, 1);
            numberBuilders = numberBuilders - 1;
         }

         if (numberBuilders > 0)
            aiPlanAddUnitType(planID, gEconUnit, 1, numberBuilders, numberBuilders);
      }
   }
   else
	   if ((puid == cUnitTypeTradingPost) && (gSPC == false))
   {

      // US hero cannot build town centers.
         numberFound = kbUnitQueryExecute(heroQuery);

         if (numberFound > 0)
         {
            aiPlanAddUnitType(planID, cUnitTypeHero, 1, 1, 1);
         }
      else
      {
            aiPlanAddUnitType(planID, gEconUnit, 1, numberBuilders, numberBuilders);
      }
   }
   else
   {
      if ((cMyCiv == cCivGermans) && (kbUnitCount(cMyID, cUnitTypeSettlerWagon, cUnitStateAlive) > 0))
      {
         builderType = cUnitTypeSettlerWagon;
         numberBuilders = (numberBuilders + 1) / 2;
      }
      else
         builderType = gEconUnit;
   
   if (puid == cUnitTypeYPLivestockPenAsian)
   {
      if ((kbUnitCount(cMyID, cUnitTypedeLivestockPenWagonJapanese, cUnitStateAlive) < 1) 
		  && (kbUnitCount(cMyID, cUnitTypeYPLivestockPenAsian, cUnitStateABQ) < 1))
      {
         aiPlanAddUnitType(planID, gEconUnit, 1, 1, 1);
	  }
   }
	else
   if (puid == cUnitTypeypShrineJapanese)
   {
   static int monkQuery = -1;
	   
	if (monkQuery < 0)
   {
      monkQuery = kbUnitQueryCreate("Monk query for shrine placement");
      kbUnitQuerySetPlayerID(monkQuery, cMyID);
      kbUnitQuerySetUnitType(monkQuery, cUnitTypeAbstractJapaneseMonk);
      kbUnitQuerySetIgnoreKnockedOutUnits(monkQuery, true);
   }

   kbUnitQueryResetResults(monkQuery);
   int numberMonks = kbUnitQueryExecute(monkQuery);

         if (numberMonks > 0)// && (xsGetTime() >= 8 * 60 * 1000))
		 {
            aiPlanAddUnitType(planID, cUnitTypeAbstractJapaneseMonk, 1, 1, 1);
		 }
         else
		 {
            aiPlanAddUnitType(planID, gEconUnit, 1, 1, 1);
		 }
    }
   else
      if (numberBuilders > 1)
      {
         aiPlanAddUnitType(planID, builderType, numberBuilders, numberBuilders, numberBuilders);
      }
      else if (puid == cUnitTypedeField)
      {
         // just allocate 1 villager at max for fields.
         aiPlanAddUnitType(planID, builderType, 1, 1, 1);
      }
      else
      {
         numberBuilders = round(kbProtoUnitGetBuildPoints(puid) / 30.0);
         aiPlanAddUnitType(planID, builderType, 1, numberBuilders, numberBuilders);
      }
   }
   

   return (true);
}
//==============================================================================
//int createSimpleQuery
//==============================================================================
int createSimpleQuery(int playerRelationOrID=cMyID, int unitTypeID=-1, int state=cUnitStateAlive)
{
   static int unitQueryID=-1;
   //If we don't have the query yet, create one.
   if (unitQueryID < 0)
   {
      unitQueryID=kbUnitQueryCreate("miscGetUnitQuery");
      kbUnitQuerySetIgnoreKnockedOutUnits(unitQueryID, true);
   }

   //Define a query to get all matching units
   if (unitQueryID != -1)  //if unitQueryID=-1, query creation fails.
   {
     if (playerRelationOrID > 1000)      // Too big for player ID number
     {
	kbUnitQuerySetPlayerID(unitQueryID, -1);  // Clear the player ID, so playerRelation takes precedence.
	kbUnitQuerySetPlayerRelation(unitQueryID, playerRelationOrID);
     }
     else
     {
	kbUnitQuerySetPlayerRelation(unitQueryID, -1);
        kbUnitQuerySetPlayerID(unitQueryID, playerRelationOrID);
     }
     kbUnitQuerySetUnitType(unitQueryID, unitTypeID);
     kbUnitQuerySetState(unitQueryID, state);
   }
   return(unitQueryID);
}

//==============================================================================
// selectBuildPlanPosition
//==============================================================================
bool selectBuildPlanPosition(int planID = -1, int puid = -1, int baseID = -1)
{
   bool result = true;

   // Position.
   switch (puid)
   {
   case cUnitTypeHouse:
   {
      selectClosestBuildPlanPosition(planID, baseID);
      break;
   }
   case cUnitTypeHouseEast:
   {
      selectClosestBuildPlanPosition(planID, baseID);
      break;
   }
   case cUnitTypeHouseMed:
   {
      selectClosestBuildPlanPosition(planID, baseID);
      break;
   }
   case cUnitTypeLonghouse:
   {
      selectClosestBuildPlanPosition(planID, baseID);
      break;
   }
   case cUnitTypeHouseAztec:
   {
      selectClosestBuildPlanPosition(planID, baseID);
      break;
   }
   case cUnitTypedeHouseInca:
   {
      selectClosestBuildPlanPosition(planID, baseID);
      break;
   }
   case cUnitTypeWarHut:
   {
      selectTowerBuildPlanPosition(planID, baseID);
      break;
   }
   case cUnitTypeypVillage:
   {
      selectClosestBuildPlanPosition(planID, baseID);
      break;
   }
   case cUnitTypeypHouseIndian:
   {
      selectClosestBuildPlanPosition(planID, baseID);
      break;
   }
   case cUnitTypedeHouseAfrican:
   {
      selectClosestBuildPlanPosition(planID, baseID);
      break;
   }
   case cUnitTypeNoblesHut:
   {
      selectTowerBuildPlanPosition(planID, baseID);
      break;
   }
   case cUnitTypeypShrineJapanese:
   {
      selectShrineBuildPlanPosition(planID, baseID);
      break;
   }
   case cUnitTypeypWJToshoguShrine2:
   {
      selectShrineBuildPlanPosition(planID, baseID);
      break;
   }
   case cUnitTypeypWJToshoguShrine3:
   {
      selectShrineBuildPlanPosition(planID, baseID);
      break;
   }
   case cUnitTypeypWJToshoguShrine4:
   {
      selectShrineBuildPlanPosition(planID, baseID);
      break;
   }
   case cUnitTypeypWJToshoguShrine5:
   {
      selectShrineBuildPlanPosition(planID, baseID);
      break;
   }
   case cUnitTypedeTorp:
   {
      selectTorpBuildPlanPosition(planID, baseID);
      break;
   }
   case cUnitTypeTownCenter:
   {
      selectTCBuildPlanPosition(planID, baseID);
      break;
   }
   case cUnitTypedeFurTrade:
   {
      selectTradingLodgeBuildPlanPosition(planID, baseID);
      break;
   }
   case cUnitTypeBank:
   {
      // usually we need to defend the enemy, thus placing banks with high HP at front is the better choice.
      aiPlanSetVariableInt(planID, cBuildPlanLocationPreference, 0, cBuildingPlacementPreferenceFront);
      // Base ID.
      aiPlanSetBaseID(planID, baseID);
      break;
   }
   case gTowerUnit:
   {
      selectTowerBuildPlanPosition(planID, baseID);
      break;
   }
   case gDockUnit:
   {
      aiPlanSetVariableVector(planID, cBuildPlanDockPlacementPoint, 0,
                              kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)));  // One point at main base
      aiPlanSetVariableVector(planID, cBuildPlanDockPlacementPoint, 1, gNavyVec); // One point at water flag
      break;
   }
   case gMarketUnit:
   {
      aiPlanSetVariableInt(planID, cBuildPlanLocationPreference, 0, cBuildingPlacementPreferenceFront);
      // Base ID.
      aiPlanSetBaseID(planID, baseID);
      break;
   }
   case cUnitTypedeField:
   {
      // returns false when we couldn't find a granary to build nearby, destroy the plan and wait for the granary
      // to be built.
      result = selectFieldBuildPlanPosition(planID, baseID);
      break;
   }
   case cUnitTypedeMountainMonastery:
   {
      selectMountainMonasteryBuildPlanPosition(planID, baseID);
      break;
   }
   case cUnitTypedeGranary:
   {
      selectGranaryBuildPlanPosition(planID, baseID);
      break;
   }
   case cUnitTypeFactory:
   {
      aiPlanSetVariableInt(planID, cBuildPlanLocationPreference, 0, cBuildingPlacementPreferenceBack);
      // Base ID.
      aiPlanSetBaseID(planID, baseID);
      break;
   } 
   case cUnitTypeypDojo:
   {
      aiPlanSetVariableInt(planID, cBuildPlanLocationPreference, 0, cBuildingPlacementPreferenceBack);
      // Base ID.
      aiPlanSetBaseID(planID, baseID);
      break;
   }                      
   default:
   {
      // Base ID.
      aiPlanSetBaseID(planID, baseID);
      break;
   }
   }

   return (result);
}

//==============================================================================
// createSimpleBuildPlan
//==============================================================================
int createSimpleBuildPlan(int puid = -1, int number = 1, int pri = 100, bool economy = true, int escrowID = -1,
                          int baseID = -1, int numberBuilders = 1, int parentPlanID = -1)
{
   if (cvOkToBuild == false)
      return (-1);

   // Create the right number of plans.
   for (i = 0; < number)
   {
      int planID =
          aiPlanCreate("Simple Build Plan, " + number + " " + kbGetUnitTypeName(puid), cPlanBuild, parentPlanID);
      if (planID < 0)
         return (-1);
      // What to build
      aiPlanSetVariableInt(planID, cBuildPlanBuildingTypeID, 0, puid);

      // 3 meter separation
      aiPlanSetVariableFloat(planID, cBuildPlanBuildingBufferSpace, 0, 6.0);
      if (puid == gFarmUnit)
         aiPlanSetVariableFloat(planID, cBuildPlanBuildingBufferSpace, 0, 12.0);

      // Priority.
      aiPlanSetDesiredPriority(planID, pri);
      // Mil vs. Econ.
      if (economy == true)
         aiPlanSetMilitary(planID, false);
      else
         aiPlanSetMilitary(planID, true);
      aiPlanSetEconomy(planID, economy);
      // Escrow.
      aiPlanSetEscrowID(planID, escrowID);
      // Builders.
      if (numberBuilders > 0)
      {
			if (addBuilderToPlan(planID, puid, numberBuilders) == false)
			{
         aiPlanDestroy(planID);
         return (-1);
			}
      }

      bool queue = (i > 0);
      if (queue == false)
      {
         // Position.
         if (selectBuildPlanPosition(planID, puid, baseID) == false)
            queue = true;
      }

      if (queue == true)
      {
         // Queue this building.
         aiPlanSetActive(planID, false);
         // Save the base ID.
         aiPlanSetBaseID(planID, baseID);

         int queueSize = xsArrayGetSize(gQueuedBuildPlans);

         queue = false;

         for (j = 0; < queueSize)
         {
            if (xsArrayGetInt(gQueuedBuildPlans, j) >= 0)
               continue;
            xsArraySetInt(gQueuedBuildPlans, j, planID);
            queue = true;
            break;
         }

         if (queue == false)
         {
            xsArrayResizeInt(gQueuedBuildPlans, queueSize + 1);
            xsArraySetInt(gQueuedBuildPlans, queueSize, planID);
         }

         continue;
      }
		
		aiEcho("Created a Simple Build Plan for: " + kbGetUnitTypeName(puid) + " with plan number: " + planID);
      // Go.
      aiPlanSetActive(planID, true);
   }

   return (planID); // Only really useful if number == 1, otherwise returns last value.
}

//==============================================================================
// createLocationBuildPlan
//==============================================================================
int createLocationBuildPlan(int puid = -1, int number = 1, int pri = 100, bool economy = true, int escrowID = -1,
                            vector position = cInvalidVector, int numberBuilders = 1)
{
   if (cvOkToBuild == false)
      return (-1);
   // Create the right number of plans.
   for (i = 0; < number)
   {
      int planID = aiPlanCreate("Location Build Plan, " + number + " " + kbGetUnitTypeName(puid), cPlanBuild);
      if (planID < 0)
         return (-1);
      // What to build
      aiPlanSetVariableInt(planID, cBuildPlanBuildingTypeID, 0, puid);

      aiPlanSetVariableVector(planID, cBuildPlanCenterPosition, 0, position);
      aiPlanSetVariableFloat(planID, cBuildPlanCenterPositionDistance, 0, 30.0);

      // 3 meter separation
      aiPlanSetVariableFloat(planID, cBuildPlanBuildingBufferSpace, 0, 3.0);
      if (puid == gFarmUnit)
         aiPlanSetVariableFloat(planID, cBuildPlanBuildingBufferSpace, 0, 8.0);

      // Priority.
      aiPlanSetDesiredPriority(planID, pri);
      // Mil vs. Econ.
      if (economy == true)
         aiPlanSetMilitary(planID, false);
      else
         aiPlanSetMilitary(planID, true);
      aiPlanSetEconomy(planID, economy);
      // Escrow.
      aiPlanSetEscrowID(planID, escrowID);
      // Builders.
      if (numberBuilders > 0 && addBuilderToPlan(planID, puid, numberBuilders) == false)
      {
         aiPlanDestroy(planID);
         return (-1);
      }

      aiPlanSetVariableVector(planID, cBuildPlanInfluencePosition, 0, position);     // Influence toward position
      aiPlanSetVariableFloat(planID, cBuildPlanInfluencePositionDistance, 0, 100.0); // 100m range.
      aiPlanSetVariableFloat(planID, cBuildPlanInfluencePositionValue, 0, 200.0);    // 200 points max
      aiPlanSetVariableInt(planID, cBuildPlanInfluencePositionFalloff, 0, cBPIFalloffLinear); // Linear slope falloff
		
		aiEcho("Created a Location Build Plan for: " + kbGetUnitTypeName(puid) + " with plan number: " + planID);
      // Go.
      aiPlanSetActive(planID);
   }
   return (planID); // Only really useful if number == 1, otherwise returns last value.
}

//==============================================================================
// createRepairPlan
//==============================================================================
int createRepairPlan(int pri = 50)
{
   if (cvOkToBuild == false)
      return (-1);

   // Check if we're under attack.
   if (gDefenseReflexBaseID == kbBaseGetMainID(cMyID))
      return (-1);

   int buildingQueryID = createSimpleUnitQuery(cUnitTypeBuilding, cMyID, cUnitStateAlive);
   int buildingID = -1;
   int buildingToRepair = -1;
   int buildingTypeID = -1;
   int planID = -1;
   int i = 0;

   int numberFound = kbUnitQueryExecute(buildingQueryID);
   for (i = 0; < numberFound)
   {
      // search for important buildings
      buildingID = kbUnitQueryGetResult(buildingQueryID, i);
      buildingTypeID = kbUnitGetProtoUnitID(buildingID);
      if (buildingTypeID == cUnitTypeFortFrontier || buildingTypeID == cUnitTypeFactory ||
          buildingTypeID == cUnitTypeypDojo || buildingTypeID == cUnitTypeTownCenter ||
          buildingTypeID == cUnitTypeTradingPost)
      {
         if (kbUnitGetHealth(buildingID) < 0.75)
         {
            buildingToRepair = buildingID;
            break;
         }
      }
   }

   if (buildingToRepair == -1)
   {
      for (i = 0; < numberFound)
      {
         buildingID = kbUnitQueryGetResult(buildingQueryID, i);
         if (kbUnitGetHealth(buildingID) < 0.5)
         {
            buildingToRepair = buildingID;
            break;
         }
      }
   }

   if (buildingToRepair == -1)
   {
      // aiEcho("createRepairPlan aborting: no building to repair.");
      return (-1);
   }

   aiEcho("Creating repair plan for building ID " + buildingToRepair);
   planID = aiPlanCreate(kbGetUnitTypeName(kbUnitGetProtoUnitID(buildingToRepair)) + " Repair " + buildingToRepair,
                         cPlanRepair);

   if (planID < 0)
   {
      aiEcho("Failed to create simple repair plan for " + buildingID);
      return (-1);
   }
   else
   {
      aiPlanSetVariableInt(planID, cRepairPlanTargetID, 0, buildingToRepair);
      aiPlanSetVariableBool(planID, cRepairPlanPersistent, 0, false);
      aiPlanSetDesiredResourcePriority(planID, pri);
      // aiPlanSetEscrowID(planID, escrowID);
      aiPlanSetActive(planID);
   }
   return (planID);
}

//==============================================================================
// createTransportPlan
//==============================================================================
int createTransportPlan(vector gatherPoint = cInvalidVector, vector targetPoint = cInvalidVector, int pri = 50,
                        bool returnWhenDone = true)
{
   if (aiGetWaterMap() == false)
      return (-1);

   int shipQueryID = createSimpleUnitQuery(cUnitTypeTransport, cMyID, cUnitStateAlive);
   int numberFound = kbUnitQueryExecute(shipQueryID);
   int shipID = -1;
   float shipHitpoints = 0.0;
   int unitPlanID = -1;
   int transportID = -1;
   float transportHitpoints = 0.0;
   for (i = 0; < numberFound)
   {
      shipID = kbUnitQueryGetResult(shipQueryID, i);
      unitPlanID = kbUnitGetPlanID(shipID);
      if (unitPlanID >= 0 &&
          (aiPlanGetDesiredPriority(unitPlanID) > pri || aiPlanGetType(unitPlanID) == cPlanTransport))
         continue;
      shipHitpoints = kbUnitGetCurrentHitpoints(shipID);
      if (shipHitpoints > transportHitpoints)
      {
         transportID = shipID;
         transportHitpoints = shipHitpoints;
      }
   }

   if (transportID < 0)
      return (-1);

   int planID =
       aiPlanCreate(kbGetUnitTypeName(kbUnitGetProtoUnitID(transportID)) + " Transport Plan, ", cPlanTransport);

   if (planID < 0)
      return (-1);

   aiPlanSetVariableInt(planID, cTransportPlanTransportID, 0, transportID);
   aiPlanSetVariableInt(planID, cTransportPlanTransportTypeID, 0, kbUnitGetProtoUnitID(transportID));
   // must add the transport unit otherwise other plans might try to use this unit
   aiPlanAddUnitType(planID, kbUnitGetProtoUnitID(transportID), 1, 1, 1);
   if (aiPlanAddUnit(planID, transportID) == false)
   {
      aiPlanDestroy(planID);
      return (-1);
   }

   aiPlanSetVariableVector(planID, cTransportPlanGatherPoint, 0, gatherPoint);
   aiPlanSetVariableVector(planID, cTransportPlanTargetPoint, 0, targetPoint);
   aiPlanSetVariableBool(planID, cTransportPlanReturnWhenDone, 0, returnWhenDone);
   aiPlanSetVariableBool(planID, cTransportPlanPersistent, 0, false);
   aiPlanSetVariableBool(planID, cTransportPlanMaximizeXportMovement, 0, true);
   aiPlanSetVariableInt(planID, cTransportPlanPathType, 0, cTransportPathTypePoints);

   aiPlanSetRequiresAllNeedUnits(planID, true);
   aiPlanSetDesiredPriority(planID, pri);
   aiPlanSetActive(planID);

   return (planID);
}

extern const int cTileBlack = 1;
extern const int cTileFog = 2;
extern const int cTileVisible = 4;

//==============================================================================
// getAreaGroupTileTypePercentage
//==============================================================================
float getAreaGroupTileTypePercentage(int areaGroupID = -1, int tileType = cTileBlack)
{
   int areaID = -1;
   float numberTiles = 0.0;
   float numberTotalTiles = 0.0;
   int numberAreas = kbAreaGroupGetNumberAreas(areaGroupID);
   for (i = 0; < numberAreas)
   {
      areaID = kbAreaGroupGetAreaID(areaGroupID, i);
      if ((tileType & cTileBlack) == cTileBlack)
         numberTiles = numberTiles + kbAreaGetNumberBlackTiles(areaID);
      if ((tileType & cTileFog) == cTileFog)
         numberTiles = numberTiles + kbAreaGetNumberFogTiles(areaID);
      if ((tileType & cTileVisible) == cTileVisible)
         numberTiles = numberTiles + kbAreaGetNumberVisibleTiles(areaID);
      numberTotalTiles = numberTotalTiles + kbAreaGetNumberTiles(areaID);
   }
   return (numberTiles / numberTotalTiles);
}

//==============================================================================
// getAreaGroupNumberTiles
//==============================================================================
int getAreaGroupNumberTiles(int areaGroupID = -1)
{
   int areaID = -1;
   int numberTotalTiles = 0;
   int numberAreas = kbAreaGroupGetNumberAreas(areaGroupID);
   for (i = 0; < numberAreas)
   {
      areaID = kbAreaGroupGetAreaID(areaGroupID, i);
      numberTotalTiles = numberTotalTiles + kbAreaGetNumberTiles(areaID);
   }
   return (numberTotalTiles);
}

//==============================================================================
// createMainBase
//==============================================================================
int createMainBase(vector mainVec = cInvalidVector)
{
   aiEcho("Creating main base at " + mainVec);
   if (mainVec == cInvalidVector)
      return (-1);

   int oldMainID = kbBaseGetMainID(cMyID);
   int i = 0;

   int count = -1;
   static int unitQueryID = -1;
   int buildingID = -1;
   string buildingName = "";
   if (unitQueryID < 0)
   {
      unitQueryID = kbUnitQueryCreate("NewMainBaseBuildingQuery");
      kbUnitQuerySetIgnoreKnockedOutUnits(unitQueryID, true);
   }

   // Define a query to get all matching units
   /*if (unitQueryID != -1)
   {
      kbUnitQuerySetPlayerRelation(unitQueryID, -1);
      kbUnitQuerySetPlayerID(unitQueryID, cMyID);

      kbUnitQuerySetUnitType(unitQueryID, cUnitTypeBuilding);
      kbUnitQuerySetState(unitQueryID, cUnitStateABQ);
      kbUnitQuerySetPosition(unitQueryID, mainVec);      // Checking new base vector
      kbUnitQuerySetMaximumDistance(unitQueryID, 50.0);
   }

   kbUnitQueryResetResults(unitQueryID);
   count = kbUnitQueryExecute(unitQueryID);*/

   while (oldMainID >= 0)
   {
      aiEcho("Old main base was " + oldMainID + " at " + kbBaseGetLocation(cMyID, oldMainID));
      /*kbUnitQuerySetPosition(unitQueryID, kbBaseGetLocation(cMyID, oldMainID));      // Checking old base location
      kbUnitQueryResetResults(unitQueryID);
      count = kbUnitQueryExecute(unitQueryID);
      int unitID = -1;*/

      // Remove old base's resource breakdowns
      aiRemoveResourceBreakdown(cResourceFood, cAIResourceSubTypeEasy, oldMainID);
      aiRemoveResourceBreakdown(cResourceFood, cAIResourceSubTypeHunt, oldMainID);
      aiRemoveResourceBreakdown(cResourceFood, cAIResourceSubTypeHerdable, oldMainID);
      aiRemoveResourceBreakdown(cResourceFood, cAIResourceSubTypeHuntAggressive, oldMainID);
      aiRemoveResourceBreakdown(cResourceFood, cAIResourceSubTypeFish, oldMainID);
      aiRemoveResourceBreakdown(cResourceFood, cAIResourceSubTypeFarm, oldMainID);
      aiRemoveResourceBreakdown(cResourceWood, cAIResourceSubTypeEasy, oldMainID);
      aiRemoveResourceBreakdown(cResourceGold, cAIResourceSubTypeEasy, oldMainID);

      kbBaseDestroy(cMyID, oldMainID);
      oldMainID = kbBaseGetMainID(cMyID);
   }

   // Also destroy bases nearby that can overlap with our radius.
   count = kbBaseGetNumber(cMyID);
   for (i = 0; < count)
   {
      int baseID = kbBaseGetIDByIndex(cMyID, i);
      if (distance(kbBaseGetLocation(cMyID, baseID), mainVec) < kbBaseGetDistance(cMyID, baseID))
         kbBaseDestroy(cMyID, baseID);
   }

   int newBaseID = kbBaseCreate(cMyID, "Base" + kbBaseGetNextID(), mainVec, 50.0);
   aiEcho("New main base ID is " + newBaseID);
   if (newBaseID > -1)
   {
      // Figure out the front vector.
      vector baseFront = xsVectorNormalize(kbGetMapCenter() - mainVec);
      kbBaseSetFrontVector(cMyID, newBaseID, baseFront);
      aiEcho("Setting front vector to " + baseFront);
      // Military gather point.
      float milDist = 40.0;
      int mainAreaGroupID = kbAreaGroupGetIDByPosition(mainVec);
      while (kbAreaGroupGetIDByPosition(mainVec + (baseFront * milDist)) != mainAreaGroupID)
      {
         milDist = milDist - 5.0;
         if (milDist < 6.0)
            break;
      }
      vector militaryGatherPoint = mainVec + (baseFront * milDist);

      kbBaseSetMilitaryGatherPoint(cMyID, newBaseID, militaryGatherPoint);
      // Set the other flags.
      kbBaseSetMilitary(cMyID, newBaseID, true);
      kbBaseSetEconomy(cMyID, newBaseID, true);
      // Set the resource distance limit.

      // 200m x 200m map, assume I'm 25 meters in, I'm 150m from enemy base.  This sets the range at 80m.
      //(cMyID, newBaseID, (kbGetMapXSize() + kbGetMapZSize())/5);   // 40% of average of map x and z dimensions.
      float dist = distance(kbGetMapCenter(), kbBaseGetLocation(cMyID, newBaseID));
      // Limit our distance, don't go pass the center of the map
      if (dist < 150.0)
         kbBaseSetMaximumResourceDistance(cMyID, newBaseID, dist);
      else
         kbBaseSetMaximumResourceDistance(cMyID, newBaseID, 50.0); // down from 150, 100 led to age-2 gold starvation

      kbBaseSetSettlement(cMyID, newBaseID, true);
      // Set the main-ness of the base.
      kbBaseSetMain(cMyID, newBaseID, true);

      // Add the TC, if any.
      if (getUnit(cUnitTypeTownCenter, cMyID, cUnitStateABQ) >= 0)
         kbBaseAddUnit(cMyID, newBaseID, getUnit(cUnitTypeTownCenter, cMyID, cUnitStateABQ));
   }

   // Move the defend plan and reserve plan
   xsEnableRule("endDefenseReflexDelay"); // Delay so that new base ID will exist

   //   xsEnableRule("populateMainBase");   // Can't add units yet, they still appear to be owned by deleted base.  This
   //   rule adds a slight delay.

   return (newBaseID);
}

//==============================================================================
// getAllyCount() // Returns number of allies EXCLUDING self
//==============================================================================
int getAllyCount()
{
   int retVal = 0;

   int player = 0;
   for (player = 1; < cNumberPlayers)
   {
      if (player == cMyID)
         continue;

      if (kbIsPlayerAlly(player) == true)
         retVal = retVal + 1;
   }

   return (retVal);
}

//==============================================================================
// getEnemyCount() // Returns number of enemies excluding gaia
//==============================================================================
int getEnemyCount()
{
   int retVal = 0;

   int player = 0;
   for (player = 1; < cNumberPlayers)
   {
      if (player == cMyID)
         continue;

      if (kbIsPlayerEnemy(player) == true)
         retVal = retVal + 1;
   }

   return (retVal);
}

//==============================================================================
// arraySortFloat
/*
   Takes two arrays, the source and the target.
   Source has the original values, and is a float array.
   Target (int array) will receive the indexes into source in descending order.  For example,
   if the highest value in source is source[17] with a value of 91, then
   arraySort(source, target) will assign target[0] the value of 17, and
   source[target[0]] will be 91.

*/
//==============================================================================
bool arraySortFloat(int sourceArray = -1, int targetArray = -1)
{
   int pass = 0;
   int i = 0;
   int size = xsArrayGetSize(sourceArray);
   if (size != xsArrayGetSize(targetArray))
   {
      aiEcho("ArraySort error, source and target are not of same size.");
      return (false);
   }

   float highestScore = 1000000.0; // Highest score found on previous pass
   float highScore = -1000000.0;   // Highest score found on this pass
   int highestScoreIndex = -1;     // Which element had the high score last pass?
   int highScoreIndex = -1;        // Which element has the highest score so far this pass?
   for (pass = 0; < size)          // Sort the array
   {
      highScore = -1000000.0;
      highScoreIndex = -1;
      for (i = 0; < size) // Look for highest remaining value
      {
         if (xsArrayGetFloat(sourceArray, i) >
             highestScore) // We're over the highest score, already been selected.  Skip.
            continue;

         if ((xsArrayGetFloat(sourceArray, i) == highestScore) &&
             (highestScoreIndex >= i)) // Tie with a later one, we've been selected.  Skip.
            continue;

         if (xsArrayGetFloat(sourceArray, i) <= highScore) // We're not the highest so far on this pass, skip.
            continue;

         highScore = xsArrayGetFloat(sourceArray, i); // This is the highest score this pass
         highScoreIndex = i;                          // So remember this index
      }
      //      if(xsArrayGetString(gMissionStrings, highScoreIndex) != " ")
      //         aiEcho("        "+highScoreIndex+" "+highScore+" "+xsArrayGetString(gMissionStrings,highScoreIndex));
      xsArraySetInt(targetArray, pass, highScoreIndex);
      highestScore = highScore; // Save this for next pass
      highestScoreIndex = highScoreIndex;
   }
   return (true);
}

//==============================================================================
// getRandomPlayerByRelation
/*
   Returns a randomly selected ally or enemy.

*/
//==============================================================================
int getRandomPlayerByRelation(int playerRelation = -1)
{
   int retVal = -1;
   int matchCount = -1;  // I.e. there are 3 matching players
   int matchIndex = -1;  // Used for traversal
   int playerToGet = -1; // i.e. get the 2nd matching player

   // Get a count of matching players
   matchCount = 0;
   for (matchIndex = 1; < cNumberPlayers)
   {
      if ((playerRelation == cPlayerRelationAlly) && (kbIsPlayerAlly(matchIndex) == true) &&
          (kbHasPlayerLost(matchIndex) == false))
         matchCount = matchCount + 1;
      if (((playerRelation == cPlayerRelationEnemy) || (playerRelation == cPlayerRelationEnemyNotGaia)) &&
          (kbIsPlayerEnemy(matchIndex) == true) && (kbHasPlayerLost(matchIndex) == false))
         matchCount = matchCount + 1;
      if ((playerRelation == cPlayerRelationSelf) && (cMyID == matchIndex) && (kbHasPlayerLost(matchIndex) == false))
         matchCount = matchCount + 1;
   }

   if (matchCount < 1)
      return (-1);

   playerToGet = aiRandInt(matchCount) + 1; // If there are 3 matches, return 1, 2 or 3

   // Traverse the list again, and get the matching player.
   matchCount = 0;
   for (matchIndex = 1; < cNumberPlayers)
   {
      if ((playerRelation == cPlayerRelationAlly) && (kbIsPlayerAlly(matchIndex) == true) &&
          (kbHasPlayerLost(matchIndex) == false))
         matchCount = matchCount + 1;
      if (((playerRelation == cPlayerRelationEnemy) || (playerRelation == cPlayerRelationEnemyNotGaia)) &&
          (kbIsPlayerEnemy(matchIndex) == true) && (kbHasPlayerLost(matchIndex) == false))
         matchCount = matchCount + 1;
      if ((playerRelation == cPlayerRelationSelf) && (cMyID == matchIndex) && (kbHasPlayerLost(matchIndex) == false))
         matchCount = matchCount + 1;

      if (matchCount == playerToGet)
      {
         retVal = matchIndex; // Save this player's number
         break;
      }
   }

   return (retVal);
}

//==============================================================================
// getTeamPosition
/*
   Returns the player's position in his/her team, i.e. in a 123 vs 456 game,
   player 5's team position is 2, player 3 is 3, player 4 is 1.

   Excludes resigned players.

*/
//==============================================================================
int getTeamPosition(int playerID = -1)
{
   int index = -1;       // Used for traversal
   int playerToGet = -1; // i.e. get the 2nd matching playe

   // Traverse list of players, increment when we find a teammate, return when we find my number.
   int retVal = 0; // Zero if I don't exist...
   for (index = 1; < cNumberPlayers)
   {
      if ((kbHasPlayerLost(index) == false) && (kbGetPlayerTeam(playerID) == kbGetPlayerTeam(index)))
         retVal = retVal + 1; // That's another match

      if (index == playerID)
         return (retVal);
   }
   return (-1);
}

//==============================================================================
// getEnemyPlayerByTeamPosition
/*
   Returns the ID of the Nth player on the enemy team, returns -1 if
   there aren't that many players.

   Excludes resigned players.
*/

int getEnemyPlayerByTeamPosition(int position = -1)
{

   int matchCount = 0;
   int index = -1;       // Used for traversal
   int playerToGet = -1; // i.e. get the 2nd matching playe

   // Traverse list of players, return when we find the matching player
   for (index = 1; < cNumberPlayers)
   {
      if ((kbHasPlayerLost(index) == false) && (kbGetPlayerTeam(cMyID) != kbGetPlayerTeam(index)))
         matchCount = matchCount + 1; // Enemy player, add to the count

      if (matchCount == position)
         return (index);
   }
   return (-1);
}

//==============================================================================
// getClosestVPSite
/*
   Returns the VPSiteID of the closest VP Site that matches the parms.
   -1 means don't care, everything matches.
   To get the closest site that has been claimed (building or complete) by an enemy,
   use cVPStateAny with playerRelationOrID set to cPlayerRelationEnemy.  (Unbuilt ones have gaia ownership)
*/
//==============================================================================
int getClosestVPSite(vector location = cInvalidVector, int type = cVPAll, int state = cVPStateAny,
                     int playerRelationOrID = -1)
{
   int retVal = -1;
   int vpList = kbVPSiteQuery(type, playerRelationOrID, state);
   vector siteLocation = cInvalidVector;
   int count = xsArrayGetSize(vpList);
   int index = 0;
   int siteID = 0;
   float dist = 0.0;
   float minDist = 100000.0;

   for (index = 0; < count)
   {
      siteID = xsArrayGetInt(vpList, index);
      siteLocation = kbVPSiteGetLocation(siteID);
      dist = distance(location, siteLocation);
      if (dist < minDist)
      {
         retVal = siteID; // Remember this one.
         minDist = dist;
      }
   }

   return (retVal);
}

//==============================================================================
// chooseAttackPlayerID
/*
   Given a point/radius, look for enemy units, and choose the owner of one
   as an appropriate player to attack.

   If none found, return mostHatedEnemy.
*/
//==============================================================================
int chooseAttackPlayerID(vector point = cInvalidVector, float radius = 50.0)
{
   int retVal = aiGetMostHatedPlayerID();
   static int queryID = -1;

   if (point == cInvalidVector)
      return (retVal);

   if (queryID < 0)
   {
      queryID = kbUnitQueryCreate("Choose attack player");
      kbUnitQuerySetPlayerRelation(queryID, cPlayerRelationEnemyNotGaia); // Any enemy units in point/radius
      kbUnitQuerySetIgnoreKnockedOutUnits(queryID, true);
      kbUnitQuerySetUnitType(queryID, cUnitTypeUnit);
      kbUnitQuerySetState(queryID, cUnitStateAlive);
   }
   kbUnitQuerySetPosition(queryID, point);
   kbUnitQuerySetMaximumDistance(queryID, radius);
   kbUnitQueryResetResults(queryID);
   int count = kbUnitQueryExecute(queryID);
   int index = 0;
   int unitID = 0;
   for (index = 0; < count)
   {
      unitID = kbUnitQueryGetResult(queryID, index);
      if (kbUnitGetPlayerID(unitID) > 0) // Not Gaia
      {
         retVal = kbUnitGetPlayerID(unitID); // Owner of first (random) non-gaia unit
         break;
      }
   }

   return (retVal);
}

//==============================================================================
// updategAfricanAlliancesAgedUpWith
//==============================================================================
void updategAfricanAlliancesAgedUpWith()
{
	int currentAge = kbGetAge();
	
	switch (currentAge)
	{
	case cAge2:
	{
		if (cMyCiv == cCivDEHausa)
		{
			if (kbTechGetStatus(cTechDEAllegianceBerber2) == cTechStatusActive)
			{
				xsArraySetBool(gAfricanAlliancesAgedUpWith, cAllianceBerbersIndex, true);
				xsArraySetBool(gAfricanAlliancesUpgrades, cAllianceBerbersIndex, false);
			}
			else if (kbTechGetStatus(cTechDEAllegianceHausa2) == cTechStatusActive)
			{
				xsArraySetBool(gAfricanAlliancesAgedUpWith, cAllianceHausaIndex, true);
				xsArraySetBool(gAfricanAlliancesUpgrades, cAllianceHausaIndex, false);
			}
			else if (kbTechGetStatus(cTechDEAllegianceSonghai2) == cTechStatusActive)
			{
				xsArraySetBool(gAfricanAlliancesAgedUpWith, cAllianceSonghaiIndex, true);
				xsArraySetBool(gAfricanAlliancesUpgrades, cAllianceSonghaiIndex, false);
			}
			break;
		}
		else
		{
			if (kbTechGetStatus(cTechDEAllegianceSomali2) == cTechStatusActive)
			{
				xsArraySetBool(gAfricanAlliancesAgedUpWith, cAllianceSomalisIndex, true);
				xsArraySetBool(gAfricanAlliancesUpgrades, cAllianceSomalisIndex, false);
			}
			else if (kbTechGetStatus(cTechDEAllegiancePortuguese2) == cTechStatusActive)
			{
				xsArraySetBool(gAfricanAlliancesAgedUpWith, cAlliancePortugueseIndex, true);
				xsArraySetBool(gAfricanAlliancesUpgrades, cAlliancePortugueseIndex, false);
				xsEnableRule("arsenalUpgradeMonitor");
			}
			else if (kbTechGetStatus(cTechDEAllegianceSudanese2) == cTechStatusActive)
			{
				xsArraySetBool(gAfricanAlliancesAgedUpWith, cAllianceSudaneseIndex, true);
				xsArraySetBool(gAfricanAlliancesUpgrades, cAllianceSudaneseIndex, false);
			}
			break;
		}
	}
	case cAge3:
	{
		if (cMyCiv == cCivDEHausa)
		{
			if (kbTechGetStatus(cTechDEAllegianceBerber3) == cTechStatusActive)
			{
				xsArraySetBool(gAfricanAlliancesAgedUpWith, cAllianceBerbersIndex, true);
				xsArraySetBool(gAfricanAlliancesUpgrades, cAllianceBerbersIndex, false);
			}
			else if (kbTechGetStatus(cTechDEAllegianceHausa3) == cTechStatusActive)
			{
				xsArraySetBool(gAfricanAlliancesAgedUpWith, cAllianceHausaIndex, true);
				xsArraySetBool(gAfricanAlliancesUpgrades, cAllianceHausaIndex, false);
			}
			else if (kbTechGetStatus(cTechDEAllegianceSonghai3) == cTechStatusActive)
			{
				xsArraySetBool(gAfricanAlliancesAgedUpWith, cAllianceSonghaiIndex, true);
				xsArraySetBool(gAfricanAlliancesUpgrades, cAllianceSonghaiIndex, false);
			}
			else if (kbTechGetStatus(cTechDEAllegianceAkan3) == cTechStatusActive)
			{
				xsArraySetBool(gAfricanAlliancesAgedUpWith, cAllianceAkanIndex, true);
				xsArraySetBool(gAfricanAlliancesUpgrades, cAllianceAkanIndex, false);
			}
			break;
		}
		else
		{
			if (kbTechGetStatus(cTechDEAllegianceSomali3) == cTechStatusActive)
			{
				xsArraySetBool(gAfricanAlliancesAgedUpWith, cAllianceSomalisIndex, true);
				xsArraySetBool(gAfricanAlliancesUpgrades, cAllianceSomalisIndex, false);
			}
			else if (kbTechGetStatus(cTechDEAllegiancePortuguese3) == cTechStatusActive)
			{
				xsArraySetBool(gAfricanAlliancesAgedUpWith, cAlliancePortugueseIndex, true);
				xsArraySetBool(gAfricanAlliancesUpgrades, cAlliancePortugueseIndex, false);
				xsEnableRule("arsenalUpgradeMonitor");
			}
			else if (kbTechGetStatus(cTechDEAllegianceSudanese3) == cTechStatusActive)
			{
				xsArraySetBool(gAfricanAlliancesAgedUpWith, cAllianceSudaneseIndex, true);
				xsArraySetBool(gAfricanAlliancesUpgrades, cAllianceSudaneseIndex, false);
			}
			else if (kbTechGetStatus(cTechDEAllegianceJesuit3) == cTechStatusActive)
			{
				xsArraySetBool(gAfricanAlliancesAgedUpWith, cAllianceJesuitIndex, true);
				xsArraySetBool(gAfricanAlliancesUpgrades, cAllianceJesuitIndex, false);
			}
			break;
		}		
	}
	case cAge4:
	{
		if (cMyCiv == cCivDEHausa)
		{
			if (kbTechGetStatus(cTechDEAllegianceBerber4) == cTechStatusActive)
			{
				xsArraySetBool(gAfricanAlliancesAgedUpWith, cAllianceBerbersIndex, true);
				xsArraySetBool(gAfricanAlliancesUpgrades, cAllianceBerbersIndex, false);
			}
			else if (kbTechGetStatus(cTechDEAllegianceHausa4) == cTechStatusActive)
			{
				xsArraySetBool(gAfricanAlliancesAgedUpWith, cAllianceHausaIndex, true);
				xsArraySetBool(gAfricanAlliancesUpgrades, cAllianceHausaIndex, false);
			}
			else if (kbTechGetStatus(cTechDEAllegianceSonghai4) == cTechStatusActive)
			{
				xsArraySetBool(gAfricanAlliancesAgedUpWith, cAllianceSonghaiIndex, true);
				xsArraySetBool(gAfricanAlliancesUpgrades, cAllianceSonghaiIndex, false);
			}
			else if (kbTechGetStatus(cTechDEAllegianceAkan4) == cTechStatusActive)
			{
				xsArraySetBool(gAfricanAlliancesAgedUpWith, cAllianceAkanIndex, true);
				xsArraySetBool(gAfricanAlliancesUpgrades, cAllianceAkanIndex, false);
			}
			break;
		}
		else
		{
			if (kbTechGetStatus(cTechDEAllegianceSomali4) == cTechStatusActive)
			{
				xsArraySetBool(gAfricanAlliancesAgedUpWith, cAllianceSomalisIndex, true);
				xsArraySetBool(gAfricanAlliancesUpgrades, cAllianceSomalisIndex, false);
			}
			else if (kbTechGetStatus(cTechDEAllegiancePortuguese4) == cTechStatusActive)
		   {
				xsArraySetBool(gAfricanAlliancesAgedUpWith, cAlliancePortugueseIndex, true);
				xsArraySetBool(gAfricanAlliancesUpgrades, cAlliancePortugueseIndex, false);
				xsEnableRule("arsenalUpgradeMonitor");
			}
			else if (kbTechGetStatus(cTechDEAllegianceSudanese4) == cTechStatusActive)
			{
				xsArraySetBool(gAfricanAlliancesAgedUpWith, cAllianceSudaneseIndex, true);
				xsArraySetBool(gAfricanAlliancesUpgrades, cAllianceSudaneseIndex, false);
			}
			else if (kbTechGetStatus(cTechDEAllegianceJesuit4) == cTechStatusActive)
			{
				xsArraySetBool(gAfricanAlliancesAgedUpWith, cAllianceJesuitIndex, true);
				xsArraySetBool(gAfricanAlliancesUpgrades, cAllianceJesuitIndex, false);
			}
			else if (kbTechGetStatus(cTechDEAllegianceOromo4) == cTechStatusActive)
			{
				xsArraySetBool(gAfricanAlliancesAgedUpWith, cAllianceOromoIndex, true);
				xsArraySetBool(gAfricanAlliancesUpgrades, cAllianceOromoIndex, false);
			}
			break;
		}	
	}
	case cAge5:
	{
		if (cMyCiv == cCivDEHausa)
		{
			if (kbTechGetStatus(cTechDEAllegianceBerber5) == cTechStatusActive)
			{
				xsArraySetBool(gAfricanAlliancesAgedUpWith, cAllianceBerbersIndex, true);
				xsArraySetBool(gAfricanAlliancesUpgrades, cAllianceBerbersIndex, false);
			}
			else if (kbTechGetStatus(cTechDEAllegianceHausa5) == cTechStatusActive)
			{
				xsArraySetBool(gAfricanAlliancesAgedUpWith, cAllianceHausaIndex, true);
				xsArraySetBool(gAfricanAlliancesUpgrades, cAllianceHausaIndex, false);
			}
			else if (kbTechGetStatus(cTechDEAllegianceSonghai5) == cTechStatusActive)
			{
				xsArraySetBool(gAfricanAlliancesAgedUpWith, cAllianceSonghaiIndex, true);
				xsArraySetBool(gAfricanAlliancesUpgrades, cAllianceSonghaiIndex, false);
			}
			else if (kbTechGetStatus(cTechDEAllegianceAkan5) == cTechStatusActive)
			{
				xsArraySetBool(gAfricanAlliancesAgedUpWith, cAllianceAkanIndex, true);
				xsArraySetBool(gAfricanAlliancesUpgrades, cAllianceAkanIndex, false);
			}
			else if (kbTechGetStatus(cTechDEAllegianceBritish5) == cTechStatusActive) // We don't get any upgrades from the British so don't set the bool to false.
				xsArraySetBool(gAfricanAlliancesAgedUpWith, cAllianceBritishIndex, true);
			break;
		}
		else if (cMyCiv == cCivDEEthiopians)
		{
			if (kbTechGetStatus(cTechDEAllegianceSomali5) == cTechStatusActive)
			{
				xsArraySetBool(gAfricanAlliancesAgedUpWith, cAllianceSomalisIndex, true);
				xsArraySetBool(gAfricanAlliancesUpgrades, cAllianceSomalisIndex, false);
			}
			else if (kbTechGetStatus(cTechDEAllegiancePortuguese5) == cTechStatusActive)
			{
				xsArraySetBool(gAfricanAlliancesAgedUpWith, cAlliancePortugueseIndex, true);
				xsArraySetBool(gAfricanAlliancesUpgrades, cAlliancePortugueseIndex, false);
				xsEnableRule("arsenalUpgradeMonitor");
			}
			else if (kbTechGetStatus(cTechDEAllegianceSudanese5) == cTechStatusActive)
			{
				xsArraySetBool(gAfricanAlliancesAgedUpWith, cAllianceSudaneseIndex, true);
				xsArraySetBool(gAfricanAlliancesUpgrades, cAllianceSudaneseIndex, false);
			}
			else if (kbTechGetStatus(cTechDEAllegianceJesuit5) == cTechStatusActive)
			{
				xsArraySetBool(gAfricanAlliancesAgedUpWith, cAllianceJesuitIndex, true);
				xsArraySetBool(gAfricanAlliancesUpgrades, cAllianceJesuitIndex, false);
			}
			else if (kbTechGetStatus(cTechDEAllegianceOromo5) == cTechStatusActive)
			{
				xsArraySetBool(gAfricanAlliancesAgedUpWith, cAllianceOromoIndex, true);
				xsArraySetBool(gAfricanAlliancesUpgrades, cAllianceOromoIndex, false);
			}
			break;
		}	
	}
	}
}

//==============================================================================
// isProtoUnitAffordable
//
// Returns whether the unit is affordable by also considering resource crates we have.
//==============================================================================
bool isProtoUnitAffordable(int puid = -1)
{
   int crateQuery = createSimpleUnitQuery(cUnitTypeAbstractResourceCrate, cMyID, cUnitStateAlive);
   int numberFound = kbUnitQueryExecute(crateQuery);
   for (resource = cResourceGold; <= cResourceFood)
   {
      float total = kbResourceGet(resource);
      for (i = 0; < numberFound)
      {
         int crateID = kbUnitQueryGetResult(crateQuery, i);
         total = total + kbUnitGetResourceAmount(crateID, resource) * kbGetPlayerHandicap(cMyID);
      }
      if (total < kbUnitCostPerResource(puid, resource))
         return (false);
   }
   return (true);
}

//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
// Economy
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================

//==============================================================================
/* rule econUpgrades

   Make sure we always have an econ upgrade plan running.  Go cheapest first.
*/
//==============================================================================
rule econUpgrades
inactive
group tcComplete
minInterval 30
{
   int planState = -1;
   int techToGet = -1;
   float lowestCost = 1000000.0;
   static int gatherTargets = -1;     // Array to hold the list of things we gather from, i.e. mill, tree, etc.
   static int gatherTargetTypes = -1; // Array.  If gatherTargets(x) == mill, then gatherTargetTypes(x) = cResourceFood.
   int target = -1;                   // Index used to step through arrays
   static int startTime = -1;         // Time last plan was started, to make sure we're not waiting on an obsolete tech.

   if (gatherTargets < 0) // Array not initialized
   {                      // Set up our list of target units (what we gather from) and their resource categories.
      gatherTargets = xsArrayCreateInt(8, -1, "Gather Targets");
      gatherTargetTypes = xsArrayCreateInt(8, -1, "Gather Target Types");

      xsArraySetInt(gatherTargets, 0, gFarmUnit); // Mills generate food
      xsArraySetInt(gatherTargetTypes, 0, cResourceFood);

      xsArraySetInt(gatherTargets, 1, cUnitTypeTree); // Trees generate wood
      xsArraySetInt(gatherTargetTypes, 1, cResourceWood);

      xsArraySetInt(gatherTargets, 2, cUnitTypeAbstractMine); // Mines generate gold
      xsArraySetInt(gatherTargetTypes, 2, cResourceGold);

      if ((cMyCiv != cCivJapanese) && (cMyCiv != cCivSPCJapanese) && (cMyCiv != cCivSPCJapaneseEnemy))
      {
         xsArraySetInt(gatherTargets, 3, cUnitTypeHuntable); // Huntables generate food, BHG: not for the japanese!
      }
      else
      {
         xsArraySetInt(gatherTargets, 3, cUnitTypeypBerryBuilding); // Berry bushes and cherry orchards
      }
      xsArraySetInt(gatherTargetTypes, 3, cResourceFood);

      xsArraySetInt(gatherTargets, 4, cUnitTypeBerryBush);
      xsArraySetInt(gatherTargetTypes, 4, cResourceFood);

      xsArraySetInt(gatherTargets, 5, gPlantationUnit); // Plantations generate gold
      xsArraySetInt(gatherTargetTypes, 5, cResourceGold);

      xsArraySetInt(gatherTargets, 6, cUnitTypeFish); // Fish generate food
      xsArraySetInt(gatherTargetTypes, 6, cResourceFood);

      xsArraySetInt(gatherTargets, 7, cUnitTypeAbstractWhale); // Whale generates gold
      xsArraySetInt(gatherTargetTypes, 7, cResourceGold);
   }

   planState = aiPlanGetState(gEconUpgradePlan);

   if (planState < 0)
   {                                   // Plan is done or doesn't exist
      aiPlanDestroy(gEconUpgradePlan); // Nuke the old one, if it exists
      startTime = -1;

      int techID = -1;           // The cheapest tech for the current target unit type
      float rawCost = -1.0;      // The cost of the upgrade
      float relCost = -1.0;      // The cost, relative to some estimate of the number of gatherers
      float numGatherers = -1.0; // Number of gatherers assigned to the resource type (i.e food)

      /*
         Step through the array of gather targets.  For each, calculate the cost of the upgrade
         relative to the number of gatherers that would benefit.  Choose the one with the best
         payoff.
      */
      for (target = 0; < 8)
      {
         // if (xsArrayGetInt(gatherTargets, target) < 0)   // No target specified
         //   continue;
         techID = kbTechTreeGetCheapestEconUpgrade(xsArrayGetInt(gatherTargets, target),
                                                   xsArrayGetInt(gatherTargetTypes, target));
         if (techID < 0) // No tech available for this target type
            continue;
         rawCost = kbGetTechAICost(techID);
         //Disable this check because it prevents us from researching techs made free through HC cards.
         //if (rawCost == 0.0)
         //   rawCost = -1.0;
         
         numGatherers = aiGetNumberGatherers(cUnitTypeAbstractVillager, xsArrayGetInt(gatherTargetTypes, target), -1,
                                             xsArrayGetInt(gatherTargets, target));

         // Calculate the relative cost
         switch (xsArrayGetInt(gatherTargets, target))
         {
         case cUnitTypeHuntable:
         {
            // Assume all food gatherers are hunting unless we have a mill.
            relCost = rawCost / numGatherers;
            if (kbUnitCount(cMyID, gFarmUnit, cUnitStateAlive) > 0)
               relCost = -1.0; // Do NOT get hunting dogs once we're farming
            break;
         }
         case cUnitTypeFish:
         {
            numGatherers = kbUnitCount(cMyID, gFishingUnit, cUnitStateAlive);
            if (numGatherers > 0.0)
               relCost = rawCost / numGatherers;
            else
               relCost = -1.0;
            break;
         }
         default: // All other resources
         {
            if (numGatherers > 0.0)
               relCost = rawCost / numGatherers;
            else
               relCost = -1.0;
            break;
         }
         }

         // We now have the relative cost for the cheapest tech that gathers from this target type.
         // See if it's > 0, and the cheapest so far.  If so, save the stats, as long as it's obtainable.

         if ((techID >= 0) && (relCost < lowestCost) && (relCost >= 0.0) &&
             (kbTechGetStatus(techID) == cTechStatusObtainable))
         {
            lowestCost = relCost;
            techToGet = techID;
         }
      }

      if ((techToGet >= 0) &&
          ((lowestCost < 40.0) || // We have a tech, and it doesn't cost more than 40 per gatherer
           (aiTreatyGetEnd() > xsGetTime() + 10 * 60 * 1000))) // Keep researching economy upgrades during treaty.
      {

         // If a plan has been running for 3 minutes...
         if ((startTime > 0) && (xsGetTime() > (startTime + 180000)))
         {
            // If it's still the tech we want, reset the start time counter and quit out.  Otherwise, kill it.
            if (aiPlanGetVariableInt(gEconUpgradePlan, cProgressionPlanGoalTechID, 0) == techToGet)
            {
               startTime = xsGetTime();
               return;
            }
            else
            {
               aiEcho("***** Destroying econ upgrade plan # " + gEconUpgradePlan +
                      " because it has been running more than 3 minutes.");
               aiPlanDestroy(gEconUpgradePlan);
            }
         }

         // research market upgrades in age1 immediately if we can afford without tasking villagers
         if (kbGetAge() == cAge1 && kbUnitCount(cMyID, gMarketUnit, cUnitStateAlive) > 0 &&
             kbCanAffordTech(techToGet, cEconomyEscrowID) == true)
         {
            aiTaskUnitResearch(getUnit(gMarketUnit), techToGet);
            return;
         }

         // Plan doesn't exist, or we just killed it due to timeout....
         gEconUpgradePlan = aiPlanCreate("Econ upgrade tech: " + kbGetTechName(techToGet), cPlanResearch);
         aiPlanSetVariableInt(gEconUpgradePlan, cResearchPlanTechID, 0, techToGet);
         aiPlanSetDesiredPriority(gEconUpgradePlan, 92);
         aiPlanSetEscrowID(gEconUpgradePlan, cEconomyEscrowID);
         aiPlanSetBaseID(gEconUpgradePlan, kbBaseGetMainID(cMyID));
         //if ((xsGetTime() > 12 * 60 * 1000) || (btRushBoom < 0.0) || (agingUp() == true) || (kbGetAge() >= cAge3))
            aiPlanSetDesiredResourcePriority(gEconUpgradePlan, 60); // Above average
         aiPlanSetActive(gEconUpgradePlan);
         startTime = xsGetTime();

         aiEcho("                **** Creating upgrade plan for " + kbGetTechName(techToGet) + " is " +
                gEconUpgradePlan);
         // aiEcho("                **** Status for tech "+kbGetTechName(techToGet)+" is "+kbTechGetStatus(techToGet));
         // aiEcho("                **** Relative cost (score) was lowest at "+lowestCost);
      }
   }
   // Otherwise, if a plan already existed, let it run...
}

rule crateMonitor
inactive
group tcComplete
minInterval 5
{
   static int cratePlanID = -1;
   int totalNumCrates = -1;
   int closeNumCrates = -1;
   int gatherersWanted = -1;
   int planPriority = 89;
   vector mainBaseVec = cInvalidVector;

   // If we have a main base, count the number of crates in it.
   if (kbBaseGetMainID(cMyID) < 0)
      return;

   // Count available crates.
   totalNumCrates = kbUnitCount(cMyID, cUnitTypeAbstractResourceCrate, cUnitStateAlive) +
                    kbUnitCount(0, cUnitTypeAbstractResourceCrate, cUnitStateAlive);

   mainBaseVec = kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID));
   // Focus on crates in our main base.
   if ((mainBaseVec != cInvalidVector) && (totalNumCrates >= 1))
      closeNumCrates =
          getUnitCountByLocation(cUnitTypeAbstractResourceCrate, cMyID, cUnitStateAlive, mainBaseVec, 20.0) +
          getUnitCountByLocation(cUnitTypeAbstractResourceCrate, 0, cUnitStateAlive, mainBaseVec, 20.0);

   if (closeNumCrates <= 0)
   {
      gatherersWanted = 1; // One gatherer if the crates are not close to our base.
      planPriority = 84;   // Lower priority as well.
   }
   else
   {
      totalNumCrates = closeNumCrates;
      gatherersWanted = (totalNumCrates + 3) / 3; // One gatherer plus one for each three crates, capped at five.
      if (gatherersWanted > 5)
         gatherersWanted = 5;
   }

   if (totalNumCrates <= 0)
      gatherersWanted = 0;

   if (aiPlanGetState(cratePlanID) == -1)
   {
      aiEcho("Crate gather plan " + cratePlanID + " is invalid.");
      aiPlanDestroy(cratePlanID);
      cratePlanID = -1;
   }

   if (cratePlanID < 0)
   { // Initialize the plan
      cratePlanID = aiPlanCreate("Main Base Crate", cPlanGather);
      aiPlanSetBaseID(cratePlanID, kbBaseGetMainID(cMyID));
      aiPlanSetVariableInt(cratePlanID, cGatherPlanResourceUnitTypeFilter, 0, cUnitTypeAbstractResourceCrate);
      aiPlanSetVariableInt(cratePlanID, cGatherPlanResourceType, 0, cAllResources);
      // aiPlanSetVariableInt(cratePlanID, cGatherPlanFindNewResourceTimeOut, 0, 20000);
      aiPlanAddUnitType(cratePlanID, gEconUnit, gatherersWanted, gatherersWanted, gatherersWanted);
      aiPlanSetDesiredPriority(cratePlanID, planPriority);
      aiPlanSetActive(cratePlanID);
      aiEcho("Activated crate gather plan " + cratePlanID);
   }

   if (cMyCiv != cCivGermans)
   {
      aiPlanAddUnitType(cratePlanID, gEconUnit, gatherersWanted, gatherersWanted, gatherersWanted);
   }   
   else
   {
      if (kbUnitCount(cMyID, gEconUnit, cUnitStateAlive) > 0)
      {
         aiPlanAddUnitType(cratePlanID, gEconUnit, gatherersWanted, gatherersWanted, gatherersWanted);
         aiPlanAddUnitType(cratePlanID, cUnitTypeSettlerWagon, 0, 0, 0);
      }
      else
      {
         aiPlanAddUnitType(cratePlanID, gEconUnit, 0, 0, 0);
         aiPlanAddUnitType(cratePlanID, cUnitTypeSettlerWagon, (gatherersWanted + 1) / 2, (gatherersWanted + 1) / 2, (gatherersWanted + 1) / 2);
      }
   }
}

//==============================================================================
// getLowestResourceAmount
/*
   Returns the amount of the resource that's in shortest supply.
   Note:  It does not identify WHICH resource, it just returns the lowest amount.
   Food, wood and gold/coin are considered, others are not.
*/
//==============================================================================

float getLowestResourceAmount()
{
   float retVal = 1000000.0;
   if (kbResourceGet(cResourceWood) < retVal)
      retVal = kbResourceGet(cResourceWood);
   if (kbResourceGet(cResourceFood) < retVal)
      retVal = kbResourceGet(cResourceFood);
   if (kbResourceGet(cResourceGold) < retVal)
      retVal = kbResourceGet(cResourceGold);
   return (retVal);
}

//==============================================================================
// updateSettlerCounts
/*
   Set the settler maintain plan according to age and our behavior traits
*/
//==============================================================================
void updateSettlerCounts(void)
{
   int normalTarget = xsArrayGetInt(gTargetSettlerCounts, kbGetAge());
   if (kbGetAge() == cvMaxAge) // If we're capped at this age, build our full complement of villagers.
      normalTarget = xsArrayGetInt(gTargetSettlerCounts, cAge5);
   int modifiedTarget = normalTarget;

   switch (kbGetAge())
   {
   case cAge1:
   {
      modifiedTarget = normalTarget; // - (5.0 * btRushBoom);   // Rushers five less, boomers 5 more
      break;
   }
   case cAge2:
   {
      modifiedTarget = normalTarget; // + (5.0 * btRushBoom);  //  Rushers 5 more (stay in age 2 longer), boomers 5 less (go to age 3 ASAP)
      break;
   }
   case cAge3:
   {
      modifiedTarget = normalTarget; // - (10.0 * btRushBoom);  //  Boomers 10 more, i.e. boom now means 'more econ'.
      break;
   }
   case cAge4:
   {
      modifiedTarget = normalTarget; // - (10.0 * btRushBoom);
      break;
   }
   case cAge5:
   {
      modifiedTarget = normalTarget; // - (10.0 * btRushBoom);
      break;
   }
   }
   int settlerLimit = kbGetBuildLimit(cMyID, gEconUnit);
   if (modifiedTarget > settlerLimit)
      modifiedTarget = settlerLimit;
   if (cMyCiv != cCivOttomans || (gRevolutionType & cRevolutionEconomic) == cRevolutionEconomic)
      aiPlanSetVariableInt(gSettlerMaintainPlan, cTrainPlanNumberToMaintain, 0, modifiedTarget);
   else
      aiPlanSetVariableInt(gSettlerMaintainPlan, cTrainPlanNumberToMaintain, 0, 0);
   if (kbUnitCount(cMyID, gEconUnit, cUnitStateAlive) >= (modifiedTarget * 0.8))
      aiPlanSetDesiredResourcePriority(gSettlerMaintainPlan, 50);
   else
      aiPlanSetDesiredResourcePriority(gSettlerMaintainPlan, 70);
}

//==============================================================================
// updateEscrows
/*
   Set the econ/mil escrow balances based on age, personality and our current
   settler pop compared to what we want to have.

   When we lose a lot of settlers, the economy escrow is expanded and the
   military escrow is reduced until the econ recovers.
*/
//==============================================================================
void updateEscrows(void)
{
   float econPercent = 0.0;
   float milPercent = 0.0;
   // float villTarget = xsArrayGetInt(gTargetSettlerCounts, kbGetAge());  // How many we want to have this age
   float villTarget = aiPlanGetVariableInt(gSettlerMaintainPlan, cTrainPlanNumberToMaintain, 0); // How many do we want?
   float villCount = kbUnitCount(cMyID, gEconUnit, cUnitStateABQ);                               // How many do we have?
   float villRatio = 1.00;
   if (villTarget > 0.0)
      villRatio = villCount / villTarget; // Actual over desired.
   float villShortfall = 1.0 - villRatio; // 0.0 means at target, 0.3 means 30% short of target

   switch (kbGetAge())
   {
   case cAge1:
   {
         econPercent = 1.0;
		 milPercent = 0.0;
      break;
   }
   case cAge2:
   {
         econPercent = 1.0;
		 milPercent = 1.0;
      break;
   }
   case cAge3:
   {
         econPercent = 1.0;
		 milPercent = 1.0;
      break;
   }
   case cAge4:
   {
         econPercent = 1.0;
		 milPercent = 1.0;
         break;
   }
   case cAge5:
   {
         econPercent = 1.0;
		 milPercent = 1.0;
         break;
   }
   }
   if (econPercent > 1.0)
      econPercent = 1.0;
   if (kbGetAge() == cAge1)
      milPercent = 0.0;

   kbEscrowSetPercentage(cEconomyEscrowID, cResourceFood, econPercent);
   kbEscrowSetPercentage(cEconomyEscrowID, cResourceWood, econPercent / 2.0); // Leave most wood at the root
   kbEscrowSetPercentage(cEconomyEscrowID, cResourceGold, econPercent);
   kbEscrowSetPercentage(cEconomyEscrowID, cResourceFame, 0.0);
   kbEscrowSetPercentage(cEconomyEscrowID, cResourceSkillPoints, 0.0);
   kbEscrowSetCap(cEconomyEscrowID, cResourceFood, 1000); // Save for age upgrades
   kbEscrowSetCap(cEconomyEscrowID, cResourceWood, 200);
   if (kbGetAge() >= cAge3)
      kbEscrowSetCap(cEconomyEscrowID, cResourceWood, 600); // Needed for mills, plantations
   kbEscrowSetCap(cEconomyEscrowID, cResourceGold, 1000);   // Save for age upgrades
   if (cMyCiv == cCivDutch)
   {
      kbEscrowSetCap(cEconomyEscrowID, cResourceFood, 350); // Needed for banks
      kbEscrowSetCap(cEconomyEscrowID, cResourceWood, 350);
   }
   else if ((cvMaxAge > -1) && (kbGetAge() >= cvMaxAge))
   { // Not dutch, and not facing age upgrade, so reduce food/gold withholding
      kbEscrowSetCap(cEconomyEscrowID, cResourceFood, 250);
      kbEscrowSetCap(cEconomyEscrowID, cResourceWood, 250);
   }

   kbEscrowSetPercentage(cMilitaryEscrowID, cResourceFood, milPercent);
   kbEscrowSetPercentage(cMilitaryEscrowID, cResourceWood, milPercent / 2.0);
   kbEscrowSetPercentage(cMilitaryEscrowID, cResourceGold, milPercent);
   kbEscrowSetPercentage(cMilitaryEscrowID, cResourceFame, 0.0);
   kbEscrowSetPercentage(cMilitaryEscrowID, cResourceSkillPoints, 0.0);
   kbEscrowSetCap(cMilitaryEscrowID, cResourceFood, 300);
   kbEscrowSetCap(cMilitaryEscrowID, cResourceWood, 200);
   kbEscrowSetCap(cMilitaryEscrowID, cResourceGold, 300);

   kbEscrowSetPercentage(gVPEscrowID, cResourceFood, 0.0);
   //      kbEscrowSetPercentage(gVPEscrowID, cResourceWood, 0.2);
   //      kbEscrowSetPercentage(gVPEscrowID, cResourceGold, 0.15);
   kbEscrowSetPercentage(gVPEscrowID, cResourceFame, 0.0);
   kbEscrowSetPercentage(gVPEscrowID, cResourceSkillPoints, 0.0);
   kbEscrowSetCap(gVPEscrowID, cResourceFood, 0);
   kbEscrowSetCap(gVPEscrowID, cResourceWood, 300);
   kbEscrowSetCap(gVPEscrowID, cResourceGold, 200);

   kbEscrowSetPercentage(gUpgradeEscrowID, cResourceFood, 0.0);
   kbEscrowSetPercentage(gUpgradeEscrowID, cResourceWood, 0.0);
   kbEscrowSetPercentage(gUpgradeEscrowID, cResourceGold, 0.0);
   kbEscrowSetPercentage(gUpgradeEscrowID, cResourceShips, 0.0);
}

//==============================================================================
// updateGatherers
/*
   Given the desired allocation of gatherers, set the desired number
   of gatherers for each active econ base, and the breakdown between
   resources for each base.
*/
//==============================================================================
void updateGatherers(void)
{
   int i = 0;

   static int resourcePriorities = -1; // An array that holds our priorities for cResourceFood, etc.
   if (resourcePriorities < 0)         // Initialize if needed
      resourcePriorities = xsArrayCreateFloat(cNumResourceTypes, 0.0, "resourcePriorities");

   aiSetResourceGathererPercentageWeight(cRGPScript, 1.0);
   aiSetResourceGathererPercentageWeight(cRGPCost, 0.0);

   /*
      Allocate gatherers based on a weighted average of two systems.  The first system is based
      on the forecasts, ignoring current inventory, i.e. it wants to keep gatherers aligned with
      out medium-term demand, and not swing based on inventory.  The second system is based
      on forecast minus inventory, or shortfall.  This is short-term, highly reactive, and volatile.
      The former factor will be weighted more heavily when inventories are large, the latter when
      inventories are tight.  (When inventories are zero, they are the same...the second method
      reacts strongly when one resource is at or over forecast, and others are low.)
   */

   /*
   float forecastWeight = 1.0;
   float reactiveWeight = 0.0;   // reactive + forecast = 1.0
   static int forecastValues = -1;  // Array holding the relative forecast-oriented values.
   static int reactiveValues = -1;
   static int gathererPercentages = -1;

   if (forecastValues < 0)
   {
      forecastValues = xsArrayCreateFloat(cNumResourceTypes, 0.0, "forecast oriented values");
      reactiveValues = xsArrayCreateFloat(cNumResourceTypes, 0.0, "reactive values");
      gathererPercentages = xsArrayCreateFloat(cNumResourceTypes, 0.0, "gatherer percentages");
   }

   float totalForecast = 0.0;
   float totalShortfall = 0.0;
   float fcst = 0.0;
   float shortfall = 0.0;
   for (i=0; <cNumResourceTypes)
   {
      fcst = xsArrayGetFloat(gForecasts, i);
      shortfall = fcst - kbResourceGet(i);
      totalForecast = totalForecast + fcst;
      if (shortfall > 0.0)
         totalShortfall = totalShortfall + shortfall;
   }

   if (totalForecast > 0)
      reactiveWeight = totalShortfall / totalForecast;
   else
      reactiveWeight = 1.0;
   forecastWeight = 1.0 - reactiveWeight;
   // Make reactive far more important
   if (totalShortfall > (0.3 * totalForecast))  // we have a significant shortfall
   {  // If it was 40/60 reactive:forecast, this makes it 82/18.
      // 10/90 becomes 73/27;  80/20 becomes 94/6
      reactiveWeight = reactiveWeight + (0.7 * forecastWeight);
      forecastWeight = 1.0 - reactiveWeight;
   }

   // Update the arrays
   float scratch = 0.0;
   for (i=0; <cNumResourceTypes)
   {
      fcst = xsArrayGetFloat(gForecasts, i);
      shortfall = fcst - kbResourceGet(i);
      xsArraySetFloat(forecastValues, i, fcst / totalForecast);   // This resource's share of the total forecast
      if ( shortfall > 0 )
         xsArraySetFloat(reactiveValues, i, shortfall / totalShortfall);
      else
         xsArraySetFloat(reactiveValues, i, 0.0);

      scratch = xsArrayGetFloat(forecastValues, i) * forecastWeight;
      scratch = scratch + (xsArrayGetFloat(reactiveValues, i) * reactiveWeight);
      xsArraySetFloat(gathererPercentages, i, scratch);
   }
   */

   // aiEcho("Forecast values:");
   // for (i=0; < cNumResourceTypes)
   // aiEcho("    "+i+" "+xsArrayGetFloat(forecastValues, i));

   // aiEcho("Shortfall values:");
   // for (i=0; < cNumResourceTypes)
   // aiEcho("    "+i+" "+xsArrayGetFloat(reactiveValues, i));

   // aiEcho("Shortfall weight is "+reactiveWeight);

   // aiEcho("Raw gatherer percentages:");
   // for (i=0; < cNumResourceTypes)
   // aiEcho("    "+i+" "+xsArrayGetFloat(gathererPercentages, i));

   // float totalPercentages = 0.0;

   // Adjust for wood being slower to gather
   // Now resource gatherer percentage will consider different resource gather rate, this is not needed anymore
   // xsArraySetFloat(gathererPercentages, cResourceWood, xsArrayGetFloat(gathererPercentages, cResourceWood) * 1.4);

   // Normalize if not 1.0
   /*totalPercentages = 0.0;
   for(i=0; <cNumResourceTypes)
      totalPercentages = totalPercentages + xsArrayGetFloat(gathererPercentages, i);
   for(i=0; <cNumResourceTypes)
      xsArraySetFloat(gathererPercentages, i, xsArrayGetFloat(gathererPercentages, i) / totalPercentages);

   //aiEcho("Wood-adjusted gatherer percentages:");
   //for (i=0; < cNumResourceTypes)
      //aiEcho("    "+i+" "+xsArrayGetFloat(gathererPercentages, i));

   // Now, consider the effects of dedicated gatherers, like fishing boats and banks, since we need to end up with
   settler/coureur assignments to pick up the balance. float coreGatherers = kbUnitCount(cMyID, gEconUnit,
   cUnitStateAlive); coreGatherers = coreGatherers +  kbUnitCount(cMyID, cUnitTypeSettlerWagon, cUnitStateAlive); float
   goldGatherers = kbUnitCount(cMyID, cUnitTypeBank, cUnitStateAlive) * 5; float foodGatherers = kbUnitCount(cMyID,
   gFishingUnit, cUnitStateAlive); float totalGatherers = coreGatherers + goldGatherers + foodGatherers;
   //aiEcho("We have "+goldGatherers+" dedicated gold gatherers.");
   //aiEcho("We have "+foodGatherers+" dedicated food gatherers.");

   float goldWanted = totalGatherers * xsArrayGetFloat(gathererPercentages, cResourceGold);
   if (goldWanted < goldGatherers)
      goldWanted = goldGatherers;
   float foodWanted = totalGatherers * xsArrayGetFloat(gathererPercentages, cResourceFood);
   if (foodWanted < foodGatherers)
      foodWanted = foodGatherers;
   float woodWanted = totalGatherers * xsArrayGetFloat(gathererPercentages, cResourceWood);


   // What percent of our core gatherers should be on each resource?
   xsArraySetFloat(gathererPercentages, cResourceGold, (goldWanted - goldGatherers) / coreGatherers);
   xsArraySetFloat(gathererPercentages, cResourceFood, (foodWanted - foodGatherers) / coreGatherers);
   xsArraySetFloat(gathererPercentages, cResourceWood, (woodWanted) / coreGatherers);
   // Normalize
   totalPercentages = 0.0;
   for(i=0; <cNumResourceTypes)
      totalPercentages = totalPercentages + xsArrayGetFloat(gathererPercentages, i);
   for(i=0; <cNumResourceTypes)
      xsArraySetFloat(gathererPercentages, i, xsArrayGetFloat(gathererPercentages, i) / totalPercentages);

   //aiEcho("Gatherer percentages, adjusted for dedicated gatherers:");
   //for (i=0; < cNumResourceTypes)
      //aiEcho("    "+i+" "+xsArrayGetFloat(gathererPercentages, i));

   // Set the new values.
   for (i=0; <cNumResourceTypes)
      aiSetResourceGathererPercentage(i, xsArrayGetFloat(gathererPercentages, i), false, cRGPScript);

   aiNormalizeResourceGathererPercentages(cRGPScript);   // Set them to 1.0 total, just in case these don't add up.*/
}

//==============================================================================
// handleExcessResources
/*
   When we can satisfy all our plans resource requirements, do something to keep resource balanced.
*/
//==============================================================================
bool handleExcessResources()
{
   float goldAmount = kbResourceGet(cResourceGold);
   float woodAmount = kbResourceGet(cResourceWood);
   float foodAmount = kbResourceGet(cResourceFood);
   int age = kbGetAge();
   bool inAgeTransition = agingUp();

   if (inAgeTransition == true)
      age++;

   if (age == cAge1 && gAgeUpResearchPlan < 0)
   {
      xsArraySetFloat(gExtraResourceNeeds, cResourceGold, 0.0);
      xsArraySetFloat(gExtraResourceNeeds, cResourceWood, 0.0);
      xsArraySetFloat(gExtraResourceNeeds, cResourceFood, 800.0);

      return(true);
   }
   else if (age == cAge2 && inAgeTransition == true)
   {
      int ageUpPolitician = -1;
      int flags = 0;
      float goldValue = 0.0;
      float woodValue = 0.0;
      float foodValue = 0.0;

      if (aiPlanGetType(gAgeUpResearchPlan) == cPlanBuild)
      {
         ageUpPolitician = aiPlanGetVariableInt(gAgeUpResearchPlan, cBuildPlanBuildingTypeID, 0);
         ageUpPolitician = kbProtoUnitGetAssociatedTech(ageUpPolitician);
      }
      else
      {
         ageUpPolitician = aiPlanGetVariableInt(gAgeUpResearchPlan, cResearchPlanTechID, 0);
      }

      flags = kbTechGetHCCardFlags(ageUpPolitician);
      goldValue = kbTechGetHCCardValuePerResource(ageUpPolitician, cResourceGold);
      woodValue = kbTechGetHCCardValuePerResource(ageUpPolitician, cResourceWood);
      foodValue = kbTechGetHCCardValuePerResource(ageUpPolitician, cResourceFood);

      if (btRushBoom > 0.0)
      {
         // Any politician delievering gold and wood
         if ((goldValue >= 100.0 && woodValue < 100.0 && foodValue < 100.0) ||
             (goldValue < 100.0 && woodValue >= 100.0 && foodValue < 100.0))
         {
            xsArraySetFloat(gExtraResourceNeeds, cResourceGold, 0.0);
            xsArraySetFloat(gExtraResourceNeeds, cResourceWood, 0.0);
            xsArraySetFloat(gExtraResourceNeeds, cResourceFood, 600.0);
         }
         else // For everything else, gather wood to prepare for immediate building construction after aging up.
         {
            xsArraySetFloat(gExtraResourceNeeds, cResourceGold, 0.0);
            xsArraySetFloat(gExtraResourceNeeds, cResourceWood, 400.0);
            xsArraySetFloat(gExtraResourceNeeds, cResourceFood, 0.0);
         }
      }
      else
      {
         // keep gathering food for FF.
         xsArraySetFloat(gExtraResourceNeeds, cResourceGold, 0.0);
         xsArraySetFloat(gExtraResourceNeeds, cResourceWood, 0.0);
         xsArraySetFloat(gExtraResourceNeeds, cResourceFood, 800.0);
      }

      return (true);
   }
   else if (age < cAge4 && gAgeUpResearchPlan < 0)
   {
      // start gathering resources for age up.
      float ageUpGoldNeeded = 1000.0;
      float ageUpFoodNeeded = 1200.0;

      if (age == cAge3)
      {
         ageUpGoldNeeded = 1200.0;
         ageUpFoodNeeded = 2000.0;
      }

      if (goldAmount < ageUpGoldNeeded)
         xsArraySetFloat(gExtraResourceNeeds, cResourceGold, goldAmount - ageUpGoldNeeded);
      xsArraySetFloat(gExtraResourceNeeds, cResourceWood, 0.0);
      if (foodAmount < ageUpFoodNeeded)
         xsArraySetFloat(gExtraResourceNeeds, cResourceFood, foodAmount - ageUpFoodNeeded);
      // We have excess resources, so start planning for age upgrades.
      gAgeUpPlanTime = 0;
      return (true);
   }

   /*if (cvOkToTrainArmy == true)
   {
      // grab the total resource cost of military maintain plans.
      float armyGoldNeeded = 0.0 - goldAmount;
      float armyWoodNeeded = 0.0 - woodAmount;
      float armyFoodNeeded = 0.0 - foodAmount;
      int numberMaintainPlans = xsArrayGetSize(gArmyUnitMaintainPlans);

      // Add more until if we have a resource amount exceeding 1000.
      while (true)
      {
         for (i = 0; < numberMaintainPlans)
         {
            int maintainPlanID = xsArrayGetInt(gArmyUnitMaintainPlans, i);
            if (maintainPlanID < 0)
               continue;
            int numberToMaintain = aiPlanGetVariableInt(maintainPlanID, cTrainPlanNumberToMaintain, 0);
            int maintainPUID = aiPlanGetVariableInt(maintainPlanID, cTrainPlanUnitType, 0);

            armyGoldNeeded = armyGoldNeeded + kbUnitCostPerResource(maintainPUID, cResourceGold) * numberToMaintain;
            armyWoodNeeded = armyWoodNeeded + kbUnitCostPerResource(maintainPUID, cResourceWood) * numberToMaintain;
            armyFoodNeeded = armyFoodNeeded + kbUnitCostPerResource(maintainPUID, cResourceFood) * numberToMaintain;
         }

         if (armyGoldNeeded >= 1000.0 || armyWoodNeeded >= 1000.0 || armyFoodNeeded >= 1000.0)
            break;
         // Avoiding an infinite loop when there are no plans/nothing to train/units cost nothing.
         if (armyGoldNeeded <= 0.0 - goldAmount && armyWoodNeeded <= 0.0 - woodAmount &&
             armyFoodNeeded <= 0.0 - foodAmount)
            break;
      }

      if (armyGoldNeeded < 0.0)
         armyGoldNeeded = 0.0;
      if (armyWoodNeeded < 0.0)
         armyWoodNeeded = 0.0;
      if (armyFoodNeeded < 0.0)
         armyFoodNeeded = 0.0;

      if (armyGoldNeeded > 0.0 || armyWoodNeeded > 0.0 || armyFoodNeeded > 0.0)
      {
         xsArraySetFloat(gExtraResourceNeeds, cResourceGold, armyGoldNeeded);
         xsArraySetFloat(gExtraResourceNeeds, cResourceWood, armyWoodNeeded);
         xsArraySetFloat(gExtraResourceNeeds, cResourceFood, armyFoodNeeded);

         return (true);
      }
   }*/

   aiEcho("***** WARNING: UNHANDLED EXCESS RESOURCES. *****");

   return (false);
}

//==============================================================================
// updateResourceDistribution
/*
   Predict our resource needs based on plan costs and resource crates we are going
   to ship.
*/
//==============================================================================
void updateResourceDistribution(bool force = false)
{
   float planGoldNeeded = 0.0;
   float planWoodNeeded = 0.0;
   float planFoodNeeded = 0.0;
   float totalPlanGoldNeeded = 0.0;
   float totalPlanWoodNeeded = 0.0;
   float totalPlanFoodNeeded = 0.0;
   float goldAmount = 0.0;
   float woodAmount = 0.0;
   float foodAmount = 0.0;
   float goldNeeded = 0.0;
   float woodNeeded = 0.0;
   float foodNeeded = 0.0;
   float totalNeeded = 0.0;
   int planID = -1;
   int trainUnitType = -1;
   int trainCount = 0;
   int numPlans = aiPlanGetActiveCount();
   int planType = -1;
   bool reserveForVillagers = false;
   bool reserveForFishingBoats = false;
   float goldReservedRate = 0.0;
   float woodReservedRate = 0.0;
   float foodReservedRate = 0.0;
   float goldPercentage = 0.0;
   float woodPercentage = 0.0;
   float foodPercentage = 0.0;
   float lastGoldPercentage = aiGetResourcePercentage(cResourceGold);
   float lastWoodPercentage = aiGetResourcePercentage(cResourceWood);
   float lastFoodPercentage = aiGetResourcePercentage(cResourceFood);
   int planPri = 50;
   int highestPri = 50;
   int highestPriPlanID = -1;
   static int lastHighestPriPlanID = -1;
   float highestPriPlanGoldNeeded = 0.0;
   float highestPriPlanWoodNeeded = 0.0;
   float highestPriPlanFoodNeeded = 0.0;
   int numberSendingCards = aiHCGetNumberSendingCards();
   int cardIndex = -1;
   int cardFlags = 0;
   int crateQuery = createSimpleUnitQuery(cUnitTypeAbstractResourceCrate, cMyID, cUnitStateAlive);
   int numberCrates = kbUnitQueryExecute(crateQuery);
   int crateID = -1;
   float handicap = kbGetPlayerHandicap(cMyID);
   float cost = 0.0;
   float trainPoints = 0.0;
   int numberBuildingsWanted = 0;
   static int lastChangeTime = 0;
   int time = xsGetTime();

   aiSetResourceGathererPercentageWeight(cRGPScript, 1.0);
   aiSetResourceGathererPercentageWeight(cRGPCost, 0.0);

   aiEcho("updateResourceDistribution(): number plans=" + numPlans);
   for (i = 0; < numPlans)
   {
      planID = aiPlanGetIDByActiveIndex(i);
      planType = aiPlanGetType(planID);
      planPri = aiPlanGetDesiredResourcePriority(planID);
      if (planType == cPlanTrain)
      {
         trainUnitType = aiPlanGetVariableInt(planID, cTrainPlanUnitType, 0);
         trainCount = aiPlanGetVariableInt(planID, cTrainPlanNumberToMaintain, 0);
         if (trainUnitType == gEconUnit)
         {
            // Ottomans train villager automatically
            if ((cMyCiv != cCivOttomans || (gRevolutionType & cRevolutionEconomic) == cRevolutionEconomic) &&
                kbUnitCount(cMyID, gEconUnit, cUnitStateABQ) < trainCount && kbGetPop() < kbGetPopCap())
            {
               // reserve gather rate so we always have villager training at each town center
               reserveForVillagers = true;
            }
            continue;
         }
         if (trainUnitType == gFishingUnit)
         {
            if ((gRevolutionType == 0 || (gRevolutionType & cRevolutionEconomic) == cRevolutionEconomic) &&
                kbUnitCount(cMyID, gFishingUnit, cUnitStateABQ) < trainCount && kbGetPop() < kbGetPopCap())
            {
               reserveForFishingBoats = true;
            }
            continue;
         }
      }
      if (planType == cPlanTrain || planType == cPlanBuild || planType == cPlanBuildWall || planType == cPlanResearch ||
          planType == cPlanRepair)
      {
         planGoldNeeded = aiPlanGetFutureNeedsCostPerResource(planID, cResourceGold);
         planWoodNeeded = aiPlanGetFutureNeedsCostPerResource(planID, cResourceWood);
         planFoodNeeded = aiPlanGetFutureNeedsCostPerResource(planID, cResourceFood);
         totalPlanGoldNeeded = totalPlanGoldNeeded + planGoldNeeded;
         totalPlanWoodNeeded = totalPlanWoodNeeded + planWoodNeeded;
         totalPlanFoodNeeded = totalPlanFoodNeeded + planFoodNeeded;
         if (planPri > highestPri)
         {
            highestPri = planPri;
            highestPriPlanID = planID;
            highestPriPlanGoldNeeded = planGoldNeeded;
            highestPriPlanWoodNeeded = planWoodNeeded;
            highestPriPlanFoodNeeded = planFoodNeeded;
         }
         aiEcho("updateResourceDistribution(): name=" + aiPlanGetName(planID) + ", needed=(" + planGoldNeeded + ", " +
                planWoodNeeded + ", " + planFoodNeeded + ")");
      }
   }

   // Additional build plan demands because we only queue up 1 building of each type at a time.
   if (cvOkToBuild == true)
   {
      // House
      numberBuildingsWanted =
          ((5 + 15 * kbGetAge()) - (kbGetPopCap() - kbGetPop()) - 1) / kbProtoUnitGetPopCap(gHouseUnit);
      if (numberBuildingsWanted > 0)
      {
         planWoodNeeded = numberBuildingsWanted * kbUnitCostPerResource(gHouseUnit, cResourceWood);
         totalPlanWoodNeeded = totalPlanWoodNeeded + planWoodNeeded;
         aiEcho("updateResourceDistribution(): additional houses=" + numberBuildingsWanted + ", needed=(0.0, " +
                planWoodNeeded + ", 0.0)");
      }

      // Mill
      /*if (gTimeToFarm == true)
      {
         if (civIsAsian() == true || civIsAfrican() == true)
            numberBuildingsWanted =
                ((aiGetNumberDesiredGatherers(cResourceFood) + cMaxSettlersPerFarm - 1) / cMaxSettlersPerFarm) -
                (gNumberFoodPaddies + gNumberQueuedFoodPaddies);
         else
            numberBuildingsWanted = ((aiGetNumberDesiredGatherers(cResourceFood) - 1) / cMaxSettlersPerFarm) -
                                    kbUnitCount(cMyID, gFarmUnit, cUnitStateABQ);
         if (numberBuildingsWanted > 0)
         {
            planWoodNeeded = numberBuildingsWanted * kbUnitCostPerResource(gFarmUnit, cResourceWood);
            totalPlanWoodNeeded = totalPlanWoodNeeded + planWoodNeeded;
            aiEcho("updateResourceDistribution(): additional mills=" + numberBuildingsWanted + ", needed=(0.0, " +
                   planWoodNeeded + ", 0.0)");
         }
      }

      // Plantation
      if (gTimeForPlantations == true)
      {
         if (civIsAsian() == true || civIsAfrican() == true)
            numberBuildingsWanted = ((aiGetNumberDesiredGatherers(cResourceGold) + cMaxSettlersPerPlantation - 1) /
                                     cMaxSettlersPerPlantation) -
                                    (gNumberGoldPaddies + gNumberQueuedGoldPaddies);
         else
            numberBuildingsWanted = ((aiGetNumberDesiredGatherers(cResourceGold) - 1) / cMaxSettlersPerPlantation) -
                                    kbUnitCount(cMyID, gPlantationUnit, cUnitStateABQ);
         if (numberBuildingsWanted > 0)
         {
            planWoodNeeded = numberBuildingsWanted * kbUnitCostPerResource(gPlantationUnit, cResourceWood);
            totalPlanWoodNeeded = totalPlanWoodNeeded + planWoodNeeded;
            aiEcho("updateResourceDistribution(): additional plantations=" + numberBuildingsWanted + ", needed=(0.0, " +
                   planWoodNeeded + ", 0.0)");
         }
      }*/
   }

   goldAmount = kbResourceGet(cResourceGold);
   woodAmount = kbResourceGet(cResourceWood);
   foodAmount = kbResourceGet(cResourceFood);

   // Add resource amount of sending cards from HC.
   for (i = 0; < numberSendingCards)
   {
      cardIndex = aiHCGetSendingCardIndex(i);
      cardFlags = aiHCDeckGetCardFlags(gDefaultDeck, cardIndex);
      if ((cardFlags & cHCCardFlagResourceCrate) == cHCCardFlagResourceCrate)
      {
         goldAmount = goldAmount + aiHCDeckGetCardValuePerResource(gDefaultDeck, cardIndex, cResourceGold) * handicap;
         woodAmount = woodAmount + aiHCDeckGetCardValuePerResource(gDefaultDeck, cardIndex, cResourceWood) * handicap;
         foodAmount = foodAmount + aiHCDeckGetCardValuePerResource(gDefaultDeck, cardIndex, cResourceFood) * handicap;
      }
   }

   // Add resource amount of crates we have now.
   for (i = 0; < numberCrates)
   {
      crateID = kbUnitQueryGetResult(crateQuery, i);
      goldAmount = goldAmount + kbUnitGetResourceAmount(crateID, cResourceGold) * handicap;
      woodAmount = woodAmount + kbUnitGetResourceAmount(crateID, cResourceWood) * handicap;
      foodAmount = foodAmount + kbUnitGetResourceAmount(crateID, cResourceFood) * handicap;
   }

   aiEcho("updateResourceDistribution(): total=(" + totalPlanGoldNeeded + ", " + totalPlanWoodNeeded + ", " +
          totalPlanFoodNeeded + "), amount=(" + goldAmount + ", " + woodAmount + ", " + foodAmount + ")");

   // If we don't have enough resources for our highest priority plan, limit other plans' resource needs to prioritize
   // the plan first
   float actualGoldRate = aiGetActualGatherRate(cResourceGold);
   float actualWoodRate = aiGetActualGatherRate(cResourceWood);
   float actualFoodRate = aiGetActualGatherRate(cResourceFood);
   bool ignoreChange = false;

   if (highestPriPlanID == lastHighestPriPlanID)
   {
      if (goldAmount < highestPriPlanGoldNeeded ||
          woodAmount < highestPriPlanWoodNeeded ||
          foodAmount < highestPriPlanFoodNeeded)
      {
         if (time - lastChangeTime < 60000)
         {
            aiEcho("updateResourceDistribution(): Ignoring resource distribution change until we have enough resources for "+aiPlanGetName(planID));
            ignoreChange = true;        
         }
         // If one minute passed, make sure we have gatherers on the resource we need.
         else if ((goldAmount >= highestPriPlanGoldNeeded || actualGoldRate > 0.0) &&
            (woodAmount >= highestPriPlanWoodNeeded || actualWoodRate > 0.0) &&
            (foodAmount >= highestPriPlanFoodNeeded || actualFoodRate > 0.0))
         {
            aiEcho("updateResourceDistribution(): Ignoring resource distribution change until we have enough resources for "+aiPlanGetName(planID));
            ignoreChange = true; 
         }
         else
         {
            // Reset last highest pri plan so we won't be blocked by change time threshold checks.
            lastHighestPriPlanID = -1;
         }
      }
   }
   
   if (((goldAmount + actualGoldRate * 60.0) < highestPriPlanGoldNeeded ||
       (woodAmount + actualWoodRate * 60.0) < highestPriPlanWoodNeeded ||
       (foodAmount + actualFoodRate * 60.0) < highestPriPlanFoodNeeded) && ignoreChange == false)
   {
      float ratio = kbUnitCount(cMyID, gEconUnit, cUnitStateAlive) +
                    2 * kbUnitCount(cMyID, cUnitTypeSettlerWagon, cUnitStateAlive);
      ratio = ratio * handicap;

      // 1 minute income of the most needed resource gather rate
      ratio = ratio * 60.0;
      if (goldAmount < highestPriPlanGoldNeeded)
      {
         if (cMyCiv == cCivXPIroquois || cMyCiv == cCivXPSioux)
         {
            if (gTimeForPlantations == true)
               ratio = ratio * kbProtoUnitGetGatherRate(gEconUnit, gPlantationUnit) * 0.5;
            else
               ratio = ratio * kbProtoUnitGetGatherRate(gEconUnit, cUnitTypedeFurTrade) * 0.5;
         }
         else
         {
            if (gTimeForPlantations == true)
               ratio = ratio * kbProtoUnitGetGatherRate(gEconUnit, gPlantationUnit, cResourceGold) * 0.5;
            else
               ratio = ratio * kbProtoUnitGetGatherRate(gEconUnit, cUnitTypeAbstractMine) * 0.5;
         }
      }
      else if (woodAmount < highestPriPlanWoodNeeded)
      {
         ratio = ratio * kbProtoUnitGetGatherRate(gEconUnit, cUnitTypeTree);
      }
      else
      {
         if (cMyCiv == cCivJapanese || cMyCiv == cCivSPCJapanese || cMyCiv == cCivSPCJapaneseEnemy)
         {
            if (gTimeToFarm == true)
               ratio = ratio * kbProtoUnitGetGatherRate(gEconUnit, gFarmUnit, cResourceFood) * 0.5;
            else
               ratio = ratio * kbProtoUnitGetGatherRate(gEconUnit, cUnitTypeypBerryBuilding) * 0.5;
         }
         else
         {
            if (gTimeToFarm == true)
               ratio = ratio * kbProtoUnitGetGatherRate(gEconUnit, gFarmUnit, cResourceFood) * 0.5;
            else
               ratio = ratio * kbProtoUnitGetGatherRate(gEconUnit, cUnitTypeHuntable) * 0.5;
         }
      }
      ratio = ratio * kbGetPlayerHandicap(cMyID);
      ratio = ratio / (totalPlanGoldNeeded + totalPlanWoodNeeded + totalPlanFoodNeeded);

      totalPlanGoldNeeded = highestPriPlanGoldNeeded + ratio * (totalPlanGoldNeeded - highestPriPlanGoldNeeded);
      totalPlanWoodNeeded = highestPriPlanWoodNeeded + ratio * (totalPlanWoodNeeded - highestPriPlanWoodNeeded);
      totalPlanFoodNeeded = highestPriPlanFoodNeeded + ratio * (totalPlanFoodNeeded - highestPriPlanFoodNeeded);
      aiEcho("Prioritizing resource gathering for plan " + aiPlanGetName(highestPriPlanID));
   }
   else
   {
      highestPriPlanID = -1;
   }

   goldNeeded = totalPlanGoldNeeded - goldAmount;
   woodNeeded = totalPlanWoodNeeded - woodAmount;
   foodNeeded = totalPlanFoodNeeded - foodAmount;

   aiEcho("Resource needed, gold=" + goldNeeded + ", wood=" + woodNeeded + ", food=" + foodNeeded);

   xsArraySetFloat(gResourceNeeds, cResourceGold, goldNeeded);
   xsArraySetFloat(gResourceNeeds, cResourceWood, woodNeeded);
   xsArraySetFloat(gResourceNeeds, cResourceFood, foodNeeded);

   if (reserveForVillagers == true)
   {
      // reserve gather rate so we always have villager training at each town center
      if (gRevolutionType == 0 || (gRevolutionType & cRevolutionEconomic) == cRevolutionEconomic)
      {
         trainPoints = kbUnitGetTrainPoints(gEconUnit);

         cost = kbUnitCostPerResource(gEconUnit, cResourceFood);

         if (cMyCiv == cCivRussians)
            cost = cost * 3.0;
         if (cost > 0.0)
         {
            if (foodNeeded > -2.0 * cost)
               foodReservedRate = foodReservedRate + (cost / trainPoints);
            else if (foodNeeded > -1.0 * cost)
               foodReservedRate = foodReservedRate + (foodNeeded + cost) / (0.0 - cost) * (cost / trainPoints);
         }
         else
         {
            cost = kbUnitCostPerResource(gEconUnit, cResourceWood);
            if (cost > 0.0)
            {
               if (woodNeeded > -2.0 * cost)
                  woodReservedRate = woodReservedRate + (cost / trainPoints);
               else if (woodNeeded > -1.0 * cost)
                  woodReservedRate = woodReservedRate + (woodNeeded + cost) / (0.0 - cost) * (cost / trainPoints);
            }
            else
            {
               cost = kbUnitCostPerResource(gEconUnit, cResourceGold);
               if (cost > 0.0)
               {
                  if (goldNeeded > -2.0 * cost)
                     goldReservedRate = goldReservedRate + (cost / trainPoints);
                  else if (goldNeeded > -1.0 * cost)
                     goldReservedRate = goldReservedRate + (goldNeeded + cost) / (0.0 - cost) * (cost / trainPoints);
               }
            }
         }
      }
   }
   if (reserveForFishingBoats == true)
   {
      trainPoints = kbUnitGetTrainPoints(gFishingUnit);
      cost = kbUnitCostPerResource(gFishingUnit, cResourceWood);
      if (woodNeeded > -2.0 * cost)
         woodReservedRate = woodReservedRate + (cost / trainPoints);
      else if (woodNeeded > -1.0 * cost)
         woodReservedRate = woodReservedRate + (woodNeeded + cost) / (0.0 - cost) * (cost / trainPoints);
   }

   if (gDisableWoods == true)
      woodReservedRate = 0.0;

   aiSetReservedGatherRate(cResourceGold, goldReservedRate);
   aiSetReservedGatherRate(cResourceWood, woodReservedRate);
   aiSetReservedGatherRate(cResourceFood, foodReservedRate);

   if (goldNeeded < 0.0)
      goldNeeded = 0.0;
   if (woodNeeded < 0.0)
      woodNeeded = 0.0;
   if (foodNeeded < 0.0)
      foodNeeded = 0.0;

   if (cvOkToGatherGold == false)
   {
      goldNeeded = 0.0;
      totalPlanGoldNeeded = 0.0;
   }
   if (cvOkToGatherWood == false)
   {
      woodNeeded = 0.0;
      totalPlanWoodNeeded = 0.0;
   }
   if (cvOkToGatherFood == false)
   {
      foodNeeded = 0.0;
      totalPlanFoodNeeded = 0.0;
   }

   totalNeeded = goldNeeded + woodNeeded + foodNeeded;
   gExcessResources = false;

   // We have enough resource for our plans
   if (totalNeeded <= 0.0)
   {
      if (totalNeeded == 0.0)
      {
         if (handleExcessResources() == true)
         {
            goldNeeded = xsArrayGetFloat(gExtraResourceNeeds, cResourceGold);
            woodNeeded = xsArrayGetFloat(gExtraResourceNeeds, cResourceWood);
            foodNeeded = xsArrayGetFloat(gExtraResourceNeeds, cResourceFood);
            totalNeeded = goldNeeded + woodNeeded + foodNeeded;
            aiEcho("Extra resource needed, gold=" + goldNeeded + ", wood=" + woodNeeded + ", food=" + foodNeeded);
         }
         else
         {
            // We have excess resources, don't move around until we have resources in demand.
            gExcessResources = true;
            ignoreChange = true;
         }
      }
   }

   // adjust gold needed to buy wood with gold if we disabled wood gathering.
   if (gDisableWoods == true)
   {
      // amount of gold needed to buy for wood.
      woodNeeded = woodNeeded * aiGetMarketBuyCost(cResourceWood) / 100.0;
      if ((goldNeeded + woodNeeded) > 0.0)
         gGoldPercentageToBuyForWood = woodNeeded / (goldNeeded + woodNeeded);
      else
         gGoldPercentageToBuyForWood = 0.0;
      goldNeeded = goldNeeded + woodNeeded;
      woodNeeded = 0.0;
   }
   else
   {
      gGoldPercentageToBuyForWood = 0.0;
   }

   if (totalNeeded > 0.0)
   {
      goldPercentage = goldNeeded / totalNeeded;
      woodPercentage = woodNeeded / totalNeeded;
      foodPercentage = foodNeeded / totalNeeded;
   }
   else
   {
      goldPercentage = 0.334;
      woodPercentage = 0.333;
      foodPercentage = 0.333;      
   }

   float goldError = goldPercentage - lastGoldPercentage;
   float woodError = woodPercentage - lastWoodPercentage;
   float foodError = foodPercentage - lastFoodPercentage;
   
   // sum of resource percentage errors over the past few runs, if we are over gathering certain resources
   // these values will surely become larger otherwise it should not increase overtime when our resource percentages are ideal.
   static float goldIntegral = 0.0;
   static float woodIntegral = 0.0;
   static float foodIntegral = 0.0;

   goldIntegral += goldError;
   woodIntegral += woodError;
   foodIntegral += foodError;

   aiEcho("updateResourceDistribution(): resource percentage error=(" + goldError + ", " + woodError + ", " + foodError + ")");
   aiEcho("updateResourceDistribution(): resource percentage integral=(" + goldIntegral + ", " + woodIntegral + ", " + foodIntegral + ")");

   // TODO: other possible ways to reduce resource percentage changes, such as not changing military production unit types too often.
   if (ignoreChange == false)
   {
      float absError = abs(goldError) + abs(woodError) + abs(foodError);
      float absIntegral = abs(goldIntegral) + abs(woodIntegral) + abs(foodIntegral);

      int changeTimeThreshold = 30;

      // When we need more resource types, it usually indicates our distribution is more stable, thus we could increase the time threshold for changing.
      if (goldPercentage > 0.0)
         changeTimeThreshold += 30;
      if (woodPercentage > 0.0)
         changeTimeThreshold += 30;
      if (foodPercentage > 0.0)
         changeTimeThreshold += 30;
      if (changeTimeThreshold < 120)
         changeTimeThreshold = 60;

      // Let's not move around in a minute unless there are urgent plans.
      if (time - lastChangeTime < changeTimeThreshold * 1000 && (highestPriPlanID < 0 || highestPriPlanID == lastHighestPriPlanID) && absIntegral < 8.0)
      {
         aiEcho("updateResourceDistribution(): Avoid changing resource distribution too soon");
         ignoreChange = true;
      }
      // Avoid tasking villagers around if we are on low demand.
      // TODO: villagers still move around too frequently, especially when resources are far from each other.
      else if ((actualGoldRate * changeTimeThreshold >= goldNeeded) &&
         (actualWoodRate * changeTimeThreshold >= woodNeeded) &&
         (actualFoodRate * changeTimeThreshold >= foodNeeded))
      {
         aiEcho("updateResourceDistribution(): Ignoring resource distribution change due to low demand");
         ignoreChange = true;
      }
      // Avoid ignoring change when we need a certain resource, but previously not.
      // When we are over gathering a certain resource also ignore this check.
      else if ((absError < 0.5 && absIntegral < 8.0) &&
         (goldPercentage == 0.0 || lastGoldPercentage > 0.0) &&
         (woodPercentage == 0.0 || lastWoodPercentage > 0.0) &&
         (foodPercentage == 0.0 || lastFoodPercentage > 0.0))
      {
         aiEcho("updateResourceDistribution(): Ignoring small resource distribution change, absolute error =" +absError+", integral="+absIntegral);
         ignoreChange = true;
      }
   }

   // Update gather plan priorities, make sure the most needed resource has the highest priority
   if ((gRevolutionType & cRevolutionFinland) == 0)
   {
      if (goldPercentage > woodPercentage && goldPercentage > foodPercentage)
      {
         if (woodPercentage > foodPercentage)
         {  // gold > wood > food
            if (gTimeToFarm == true)
            {
               gGatherPlanPriorityHunt = 79;
               gGatherPlanPriorityBerry = 78;
               gGatherPlanPriorityMill = 80;
            }
            else
            {
               gGatherPlanPriorityHunt = 80;
               gGatherPlanPriorityBerry = 79;
               gGatherPlanPriorityMill = 78;
            }
            gGatherPlanPriorityWood = 81;
            if (gTimeForPlantations == true)
            {
               gGatherPlanPriorityMine = 82;
               gGatherPlanPriorityEstate = 83;
            }
            else
            {
               gGatherPlanPriorityMine = 83;
               gGatherPlanPriorityEstate = 82;
            }
            gGatherPlanPriorityFish = 19;
            gGatherPlanPriorityWhale = 20;
         }
         else
         { // gold > food > wood
            if (gTimeToFarm == true)
            {
               gGatherPlanPriorityHunt = 80;
               gGatherPlanPriorityBerry = 79;
               gGatherPlanPriorityMill = 81;
            }
            else
            {
               gGatherPlanPriorityHunt = 81;
               gGatherPlanPriorityBerry = 80;
               gGatherPlanPriorityMill = 79;
            }
            gGatherPlanPriorityWood = 78;
            if (gTimeForPlantations == true)
            {
               gGatherPlanPriorityMine = 82;
               gGatherPlanPriorityEstate = 83;
            }
            else
            {
               gGatherPlanPriorityMine = 83;
               gGatherPlanPriorityEstate = 82;
            }
            gGatherPlanPriorityFish = 19;
            gGatherPlanPriorityWhale = 20;
         }
      }
      else if (woodPercentage > foodPercentage)
      {
         if (goldPercentage > foodPercentage)
         { // wood > gold > food
            if (gTimeToFarm == true)
            {
               gGatherPlanPriorityHunt = 79;
               gGatherPlanPriorityBerry = 78;
               gGatherPlanPriorityMill = 80;
            }
            else
            {
               gGatherPlanPriorityHunt = 80;
               gGatherPlanPriorityBerry = 79;
               gGatherPlanPriorityMill = 78;
            }
            gGatherPlanPriorityWood = 83;
            if (gTimeForPlantations == true)
            {
               gGatherPlanPriorityMine = 81;
               gGatherPlanPriorityEstate = 82;
            }
            else
            {
               gGatherPlanPriorityMine = 82;
               gGatherPlanPriorityEstate = 81;
            }
            gGatherPlanPriorityFish = 19;
            gGatherPlanPriorityWhale = 20;
         }
         else
         { // wood > food > gold
            if (gTimeToFarm == true)
            {
               gGatherPlanPriorityHunt = 81;
               gGatherPlanPriorityBerry = 80;
               gGatherPlanPriorityMill = 82;
            }
            else
            {
               gGatherPlanPriorityHunt = 82;
               gGatherPlanPriorityBerry = 81;
               gGatherPlanPriorityMill = 80;
            }
            gGatherPlanPriorityWood = 83;
            if (gTimeForPlantations == true)
            {
               gGatherPlanPriorityMine = 78;
               gGatherPlanPriorityEstate = 79;
            }
            else
            {
               gGatherPlanPriorityMine = 79;
               gGatherPlanPriorityEstate = 78;
            }
            gGatherPlanPriorityFish = 20;
            gGatherPlanPriorityWhale = 19;
         }
      }
      else
      {
         if (goldPercentage > woodPercentage)
         { // food > gold > wood
            if (gTimeToFarm == true)
            {
               gGatherPlanPriorityHunt = 82;
               gGatherPlanPriorityBerry = 81;
               gGatherPlanPriorityMill = 83;
            }
            else
            {
               gGatherPlanPriorityHunt = 83;
               gGatherPlanPriorityBerry = 82;
               gGatherPlanPriorityMill = 81;
            }
            gGatherPlanPriorityWood = 78;
            if (gTimeForPlantations == true)
            {
               gGatherPlanPriorityMine = 79;
               gGatherPlanPriorityEstate = 80;
            }
            else
            {
               gGatherPlanPriorityMine = 80;
               gGatherPlanPriorityEstate = 79;
            }
            gGatherPlanPriorityFish = 20;
            gGatherPlanPriorityWhale = 19;
         }
         else
         { // food > wood > gold
            if (gTimeToFarm == true)
            {
               gGatherPlanPriorityHunt = 82;
               gGatherPlanPriorityBerry = 81;
               gGatherPlanPriorityMill = 83;
            }
            else
            {
               gGatherPlanPriorityHunt = 83;
               gGatherPlanPriorityBerry = 82;
               gGatherPlanPriorityMill = 81;
            }
            gGatherPlanPriorityWood = 80;
            if (gTimeForPlantations == true)
            {
               gGatherPlanPriorityMine = 78;
               gGatherPlanPriorityEstate = 79;
            }
            else
            {
               gGatherPlanPriorityMine = 79;
               gGatherPlanPriorityEstate = 78;
            }
            gGatherPlanPriorityFish = 20;
            gGatherPlanPriorityWhale = 19;
         }
      }
   }
   else
   {
      // For Finland revolution, gather plans need to be below defend plan, but higher than reserve plan.
      if (goldPercentage > woodPercentage && goldPercentage > foodPercentage)
      {
         if (woodPercentage > foodPercentage)
         { // gold > wood > food
            gGatherPlanPriorityHunt = 7;
            gGatherPlanPriorityBerry = 6;
            gGatherPlanPriorityMill = 0;
            gGatherPlanPriorityWood = 8;
            gGatherPlanPriorityMine = 9;
            gGatherPlanPriorityEstate = 0;
            gGatherPlanPriorityFish = 19;
            gGatherPlanPriorityWhale = 20;
         }
         else
         { // gold > food > wood
            gGatherPlanPriorityHunt = 8;
            gGatherPlanPriorityBerry = 7;
            gGatherPlanPriorityMill = 0;
            gGatherPlanPriorityWood = 6;
            gGatherPlanPriorityMine = 9;
            gGatherPlanPriorityEstate = 0;
            gGatherPlanPriorityFish = 19;
            gGatherPlanPriorityWhale = 20;
         }
      }
      else if (woodPercentage > foodPercentage)
      {
         if (goldPercentage > foodPercentage)
         { // wood > gold > food
            gGatherPlanPriorityHunt = 7;
            gGatherPlanPriorityBerry = 6;
            gGatherPlanPriorityMill = 0;
            gGatherPlanPriorityWood = 9;
            gGatherPlanPriorityMine = 8;
            gGatherPlanPriorityEstate = 0;
            gGatherPlanPriorityFish = 19;
            gGatherPlanPriorityWhale = 20;
         }
         else
         { // wood > food > gold
            gGatherPlanPriorityHunt = 8;
            gGatherPlanPriorityBerry = 7;
            gGatherPlanPriorityMill = 0;
            gGatherPlanPriorityWood = 9;
            gGatherPlanPriorityMine = 6;
            gGatherPlanPriorityEstate = 0;
            gGatherPlanPriorityFish = 20;
            gGatherPlanPriorityWhale = 19;
         }
      }
      else
      {
         if (goldPercentage > woodPercentage)
         { // food > gold > wood
            gGatherPlanPriorityHunt = 9;
            gGatherPlanPriorityBerry = 8;
            gGatherPlanPriorityMill = 0;
            gGatherPlanPriorityWood = 6;
            gGatherPlanPriorityMine = 7;
            gGatherPlanPriorityEstate = 0;
            gGatherPlanPriorityFish = 20;
            gGatherPlanPriorityWhale = 19;
         }
         else
         { // food > wood > gold
            gGatherPlanPriorityHunt = 9;
            gGatherPlanPriorityBerry = 8;
            gGatherPlanPriorityMill = 0;
            gGatherPlanPriorityWood = 7;
            gGatherPlanPriorityMine = 6;
            gGatherPlanPriorityEstate = 0;
            gGatherPlanPriorityFish = 20;
            gGatherPlanPriorityWhale = 19;
         }
      }
   }

   if (ignoreChange == false || force == true)
   {
      aiSetResourcePercentage(cResourceGold, false, goldPercentage);
      aiSetResourcePercentage(cResourceWood, false, woodPercentage);
      aiSetResourcePercentage(cResourceFood, false, foodPercentage);
      aiNormalizeResourcePercentages(); // Set them to 1.0 total, just in case these don't add up.*/

      aiEcho("updateResourceDistribution(): resource percentage=(" + goldPercentage + ", " + woodPercentage + ", " + foodPercentage + ")");
      aiEcho("updateResourceDistribution(): resource needed=(" + goldNeeded + ", " + woodNeeded + ", " + foodNeeded + ")");

      xsArraySetInt(gAdjustBreakdownAttempts, cResourceGold, xsArrayGetInt(gAdjustBreakdownAttempts, cResourceGold) + 1);
      xsArraySetInt(gAdjustBreakdownAttempts, cResourceWood, xsArrayGetInt(gAdjustBreakdownAttempts, cResourceWood) + 1);
      xsArraySetInt(gAdjustBreakdownAttempts, cResourceFood, xsArrayGetInt(gAdjustBreakdownAttempts, cResourceFood) + 1); 

      goldIntegral = 0.0;
      woodIntegral = 0.0;
      foodIntegral = 0.0;

      lastChangeTime = time;           
   }



   lastHighestPriPlanID = highestPriPlanID;
}

//==============================================================================
// rule resourceManager
/*
   Watch the resource balance, buy/sell imbalanced resources as needed

   In initial build phase (first 5 houses?) sell all food, buy wood with
   any gold.  Later, look for imbalances.
*/
//==============================================================================
rule resourceManager
inactive
minInterval 10
group startup
{
   bool goAgain = false;         // Set this flag if we do a buy or sell and want to quickly evaluate
   static bool fastMode = false; // Set this flag if we enter high-speed mode, clear it on leaving
   static int lastTributeRequestTime = 0;

   if (aiResourceIsLocked(cResourceGold) == true)
   {
      aiEcho("Gold is locked.");
      if (fastMode == true)
      {
         // We need to slow down.
         xsSetRuleMinIntervalSelf(10);
         aiEcho("Resource manager going to slow mode.");
         fastMode = false;
      }
      return;
   }

   if (((xsGetTime() - lastTributeRequestTime) > 300000) &&
       ((xsGetTime() - gLastTribSentTime) > 120000)) // Don't request too often, and don't request right after sending.
   {                                                 // See if we have a critical shortage of anything
      float totalResources = kbResourceGet(cResourceFood) + kbResourceGet(cResourceWood) + kbResourceGet(cResourceGold);
      if ((totalResources > 1000.0) && (kbGetAge() > cAge1))
      { // Don't request tribute if we're short on everything, just for imbalances.  And skip age 1, since we'll have
        // zero gold and mucho food.
         if (kbResourceGet(cResourceFood) < (totalResources / 10.0))
         {
            sendStatement(cPlayerRelationAlly, cAICommPromptToAllyRequestFood);
            lastTributeRequestTime = xsGetTime();
         }
         if (kbResourceGet(cResourceGold) < (totalResources / 10.0))
         {
            sendStatement(cPlayerRelationAlly, cAICommPromptToAllyRequestCoin);
            lastTributeRequestTime = xsGetTime();
         }
         if (kbResourceGet(cResourceWood) < (totalResources / 10.0))
         {
            sendStatement(cPlayerRelationAlly, cAICommPromptToAllyRequestWood);
            lastTributeRequestTime = xsGetTime();
         }
      }
   }

   // Normal imbalance rules apply
   if ((kbUnitCount(cMyID, gMarketUnit, cUnitStateAlive) > 0) && (aiResourceIsLocked(cResourceGold) == false))
   {
      if (xsArrayGetFloat(gResourceNeeds, cResourceFood) < -1000.0 &&
          xsArrayGetFloat(gResourceNeeds, cResourceGold) > 100.0 && aiResourceIsLocked(cResourceFood) == false)
      {
         aiSellResourceOnMarket(cResourceFood);
         xsArraySetFloat(gResourceNeeds, cResourceFood, xsArrayGetFloat(gResourceNeeds, cResourceFood) + 100.0);
         xsArraySetFloat(gResourceNeeds, cResourceGold,
                         xsArrayGetFloat(gResourceNeeds, cResourceGold) - aiGetMarketSellCost(cResourceFood));
         aiEcho("Selling 100 food.");
         goAgain = true;
      }
      if (xsArrayGetFloat(gResourceNeeds, cResourceWood) < -1000.0 &&
          xsArrayGetFloat(gResourceNeeds, cResourceGold) > 100.0 && aiResourceIsLocked(cResourceWood) == false)
      {
         aiSellResourceOnMarket(cResourceWood);
         xsArraySetFloat(gResourceNeeds, cResourceWood, xsArrayGetFloat(gResourceNeeds, cResourceWood) + 100.0);
         xsArraySetFloat(gResourceNeeds, cResourceGold,
                         xsArrayGetFloat(gResourceNeeds, cResourceGold) - aiGetMarketSellCost(cResourceWood));
         aiEcho("Selling 100 food.");
         goAgain = true;
      }

      if (xsArrayGetFloat(gResourceNeeds, cResourceGold) < -1000.0)
      {
         if (xsArrayGetFloat(gResourceNeeds, cResourceFood) > 100.0 && aiResourceIsLocked(cResourceFood) == false)
         {
            aiBuyResourceOnMarket(cResourceFood);
            xsArraySetFloat(gResourceNeeds, cResourceGold, xsArrayGetFloat(gResourceNeeds, cResourceGold) + 100.0);
            xsArraySetFloat(gResourceNeeds, cResourceFood,
                            xsArrayGetFloat(gResourceNeeds, cResourceFood) - aiGetMarketBuyCost(cResourceFood));
            aiEcho("Buying 100 food.");
            goAgain = true;
         }
         else if (xsArrayGetFloat(gResourceNeeds, cResourceWood) > 100.0 && aiResourceIsLocked(cResourceWood) == false)
         {
            aiBuyResourceOnMarket(cResourceWood);
            xsArraySetFloat(gResourceNeeds, cResourceGold, xsArrayGetFloat(gResourceNeeds, cResourceGold) + 100.0);
            xsArraySetFloat(gResourceNeeds, cResourceWood,
                            xsArrayGetFloat(gResourceNeeds, cResourceWood) - aiGetMarketBuyCost(cResourceWood));
            aiEcho("Buying 100 wood.");
            goAgain = true;
         }
      }
   }

   // Buy wood with gold if disabled wood gathering.
   if (gDisableWoods == true && aiResourceIsLocked(cResourceWood) == false)
   {
      static float lastTotalGoldAmount = 0.0;
      float totalGoldAmount = kbTotalResourceGet(cResourceGold);

      if ((totalGoldAmount - lastTotalGoldAmount) * gGoldPercentageToBuyForWood >= aiGetMarketBuyCost(cResourceWood))
      {
         aiBuyResourceOnMarket(cResourceWood);
         lastTotalGoldAmount = totalGoldAmount;
         aiEcho("Buying 100 wood.");
         goAgain = true;
      }
   }

   if ((goAgain == true) && (fastMode == false))
   {
      // We need to set fast mode
      xsSetRuleMinIntervalSelf(1);
      aiEcho("Going to fast mode.");
      fastMode = true;
   }
   if ((goAgain == false) && (fastMode == true))
   {
      // We need to slow down.
      xsSetRuleMinIntervalSelf(10);
      aiEcho("Resource manager going to slow mode.");
      fastMode = false;
   }
}

int findBestScoutType(void)
{
   // Decide on which unit type to use as scout
   // If possible, cheap infantry is used
   int scoutType = -1;
   if (kbUnitCount(cMyID, cUnitTypeGuardian, cUnitStateAlive) >= 1)
      scoutType = cUnitTypeGuardian;
   else if (kbUnitCount(cMyID, cUnitTypeAbstractFindScout, cUnitStateAlive) >= 1)
      scoutType = cUnitTypeAbstractFindScout;
   else if (kbUnitCount(cMyID, cUnitTypeAbstractPet, cUnitStateAlive) >= 1)
      scoutType = cUnitTypeAbstractPet;
   else if (kbUnitCount(cMyID, cUnitTypeAbstractNativeWarrior, cUnitStateAlive) >= 1)
      scoutType = cUnitTypeAbstractNativeWarrior;
   else if (kbUnitCount(cMyID, cUnitTypeCrossbowman, cUnitStateAlive) >= 1)
      scoutType = cUnitTypeCrossbowman;
   else if (kbUnitCount(cMyID, cUnitTypePikeman, cUnitStateAlive) >= 1)
      scoutType = cUnitTypePikeman;
   else if (kbUnitCount(cMyID, cUnitTypeStrelet, cUnitStateAlive) >= 1)
      scoutType = cUnitTypeStrelet;
   else if (kbUnitCount(cMyID, cUnitTypeLongbowman, cUnitStateAlive) >= 1)
      scoutType = cUnitTypeLongbowman;
   else if (kbUnitCount(cMyID, cUnitTypeMusketeer, cUnitStateAlive) >= 1)
      scoutType = cUnitTypeMusketeer;
   else if (kbUnitCount(cMyID, cUnitTypexpWarrior, cUnitStateAlive) >= 1)
      scoutType = cUnitTypexpWarrior;
   else if (kbUnitCount(cMyID, cUnitTypexpAenna, cUnitStateAlive) >= 1)
      scoutType = cUnitTypexpAenna;
   else if (kbUnitCount(cMyID, cUnitTypexpTomahawk, cUnitStateAlive) >= 1)
      scoutType = cUnitTypexpTomahawk;
   else if (kbUnitCount(cMyID, cUnitTypexpMacehualtin, cUnitStateAlive) >= 1)
      scoutType = cUnitTypexpMacehualtin;
   else if (kbUnitCount(cMyID, cUnitTypexpPumaMan, cUnitStateAlive) >= 1)
      scoutType = cUnitTypexpPumaMan;
   else if (kbUnitCount(cMyID, cUnitTypexpWarBow, cUnitStateAlive) >= 1)
      scoutType = cUnitTypexpWarBow;
   else if (kbUnitCount(cMyID, cUnitTypexpWarClub, cUnitStateAlive) >= 1)
      scoutType = cUnitTypexpWarClub;
   else if (kbUnitCount(cMyID, cUnitTypeSaloonOutlawPistol, cUnitStateAlive) >= 1)
      scoutType = cUnitTypeSaloonOutlawPistol;
   else if (kbUnitCount(cMyID, cUnitTypeSaloonOutlawRifleman, cUnitStateAlive) >= 1)
      scoutType = cUnitTypeSaloonOutlawRifleman;
   else if (kbUnitCount(cMyID, cUnitTypeJanissary, cUnitStateAlive) >= 1)
      scoutType = cUnitTypeJanissary;
   else if (kbUnitCount(cMyID, cUnitTypeypQiangPikeman, cUnitStateAlive) >= 1)
      scoutType = cUnitTypeypQiangPikeman;
   else if (kbUnitCount(cMyID, cUnitTypeypChuKoNu, cUnitStateAlive) >= 1)
      scoutType = cUnitTypeypChuKoNu;
   else if (kbUnitCount(cMyID, cUnitTypeypMonkDisciple, cUnitStateAlive) >= 1)
      scoutType = cUnitTypeypMonkDisciple;
   else if (kbUnitCount(cMyID, cUnitTypeypArquebusier, cUnitStateAlive) >= 1)
      scoutType = cUnitTypeypArquebusier;
   else if (kbUnitCount(cMyID, cUnitTypeypChangdao, cUnitStateAlive) >= 1)
      scoutType = cUnitTypeypChangdao;
   else if (kbUnitCount(cMyID, cUnitTypeypSepoy, cUnitStateAlive) >= 1)
      scoutType = cUnitTypeypSepoy;
   else if (kbUnitCount(cMyID, cUnitTypeypNatMercGurkha, cUnitStateAlive) >= 1)
      scoutType = cUnitTypeypNatMercGurkha;
   else if (kbUnitCount(cMyID, cUnitTypeypRajput, cUnitStateAlive) >= 1)
      scoutType = cUnitTypeypRajput;
   else if (kbUnitCount(cMyID, cUnitTypeypYumi, cUnitStateAlive) >= 1)
      scoutType = cUnitTypeypYumi;
   else if (kbUnitCount(cMyID, cUnitTypeypAshigaru, cUnitStateAlive) >= 1)
      scoutType = cUnitTypeypAshigaru;
   else if (kbUnitCount(cMyID, cUnitTypedeChasqui, cUnitStateAlive) >= 1)
      scoutType = cUnitTypedeChasqui;
   else if (kbUnitCount(cMyID, cUnitTypedeJungleBowman, cUnitStateAlive) >= 1)
      scoutType = cUnitTypedeJungleBowman;
   else if (kbUnitCount(cMyID, cUnitTypedeIncaRunner, cUnitStateAlive) >= 1)
      scoutType = cUnitTypedeIncaRunner;
   else if (kbUnitCount(cMyID, cUnitTypedeJavelinRider, cUnitStateAlive) >= 1)
      scoutType = cUnitTypedeJavelinRider;
   else if (kbUnitCount(cMyID, cUnitTypedeRaider, cUnitStateAlive) >= 1)
      scoutType = cUnitTypedeRaider;
   else if (kbUnitCount(cMyID, cUnitTypedeShotelWarrior, cUnitStateAlive) >= 1)
      scoutType = cUnitTypedeShotelWarrior;
   else if (kbUnitCount(cMyID, cUnitTypedeFulaWarrior, cUnitStateAlive) >= 1)
      scoutType = cUnitTypedeFulaWarrior;
   else if (kbUnitCount(cMyID, cUnitTypedeGascenya, cUnitStateAlive) >= 1)
      scoutType = cUnitTypedeGascenya;
   else if (kbUnitCount(cMyID, cUnitTypedeNeftenya, cUnitStateAlive) >= 1)
      scoutType = cUnitTypedeNeftenya;
   else
      scoutType = cUnitTypeLogicalTypeScout;
   return (scoutType);
}

int findBestHCGatherUnit(int baseID = -1)
{
   vector loc = kbBaseGetLocation(cMyID, baseID);
   float dist = kbBaseGetDistance(cMyID, baseID);
   int unitID = getUnitByLocation(cUnitTypeAbstractTownCenter, cMyID, cUnitStateAlive, loc, dist);
   if (unitID < 0)
      unitID = getUnitByLocation(cUnitTypeHCGatherPointPri1, cMyID, cUnitStateAlive, loc, dist);
   if (unitID < 0)
      unitID = getUnitByLocation(cUnitTypeHCGatherPointPri2, cMyID, cUnitStateAlive, loc, dist);
   if (unitID < 0)
      unitID = getUnitByLocation(cUnitTypeHCGatherPointPri3, cMyID, cUnitStateAlive, loc, dist);
   return(unitID);
}

vector guessEnemyLocation(int player = -1)
{
   if (player < 0)
      player = aiGetMostHatedPlayerID();
   vector position = kbGetPlayerStartingPosition(player);

   if (aiGetWorldDifficulty() >= cDifficultyHard && position != cInvalidVector)
   {
      // For higher difficulties, assuming the AI played on this map before, it should have a rough idea of the enemy
      // location.
      float xError = kbGetMapXSize() * 0.1;
      float zError = kbGetMapZSize() * 0.1;
      xsVectorSetX(position, xsVectorGetX(position) + aiRandFloat(0.0 - xError, xError));
      xsVectorSetZ(position, xsVectorGetZ(position) + aiRandFloat(0.0 - zError, zError));
   }
   else
   {
      // For lower difficulties, just simply create a mirror image of our base.
      vector myBaseLocation =
          kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)); // Main base location...need to find reflection.
      vector centerOffset = kbGetMapCenter() - myBaseLocation;
      position = kbGetMapCenter() + centerOffset;
   }

   return (position);
}

void findEnemyBase(void)
{
   if (gStartOnDifferentIslands == true)
      return (); // TODO...make a water version, look for enemy home island?

   if (cvOkToExplore == false)
      return ();

   // Create an explore plan to go there.
   vector myBaseLocation =
       kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)); // Main base location...need to find reflection.
   vector targetLocation = guessEnemyLocation();
   // TargetLocation is now a mirror image of my base.
   aiEcho("My base is at " + myBaseLocation + ", enemy base should be near " + targetLocation);
   int exploreID = aiPlanCreate("Probe Enemy Base", cPlanExplore);
   if (exploreID >= 0)
   {
      aiPlanAddUnitType(exploreID, findBestScoutType(), 1, 1, 1);
      aiPlanAddWaypoint(exploreID, targetLocation);
      aiPlanSetVariableBool(exploreID, cExplorePlanDoLoops, 0, false);
      aiPlanSetVariableBool(exploreID, cExplorePlanQuitWhenPointIsVisible, 0, true);
      aiPlanSetVariableBool(exploreID, cExplorePlanAvoidingAttackedAreas, 0, false);
      aiPlanSetVariableInt(exploreID, cExplorePlanNumberOfLoops, 0, -1);
      aiPlanSetRequiresAllNeedUnits(exploreID, true);
      aiPlanSetVariableVector(exploreID, cExplorePlanQuitWhenPointIsVisiblePt, 0, targetLocation);
      aiPlanSetDesiredPriority(exploreID, 100);
      aiPlanSetActive(exploreID);
   }
}

void selectTowerBuildPlanPosition(int buildPlan = -1, int baseID = -1)
{
   int attempt = 0;
   int numAttempts = 3 * kbGetBuildLimit(cMyID, gTowerUnit) / 2;
   vector testVec = cInvalidVector;
   static vector baseVec = cInvalidVector;
   static vector startingVec = cInvalidVector;
   int numTestVecs = 5 * kbGetBuildLimit(cMyID, gTowerUnit) / 4;
   float towerAngle = (2.0 * PI) / numTestVecs;
   float spacingDistance =
       24 * sin((PI - towerAngle) / 2.0) / sin(towerAngle); // Mid- and corner-spots on a square with 'radius'
                                                            // spacingDistance, i.e. each side is 2 * spacingDistance.
   float exclusionRadius = spacingDistance / 2.0;


   vector StartBase = kbBaseGetLocation(cMyID, baseID);

   static int towerSearch = -1;
   bool success = false;

   if ((startingVec == cInvalidVector) || (baseVec != kbBaseGetLocation(cMyID, baseID))) // Base changed
   {
      baseVec = kbBaseGetLocation(cMyID, baseID); // Start with base location
      startingVec = baseVec;
      startingVec = xsVectorSetX(startingVec, xsVectorGetX(startingVec) + spacingDistance);
      startingVec = rotateByReferencePoint(baseVec, startingVec - baseVec, aiRandInt(360) / (180.0 / PI));
   }

   for (attempt = 0; < numAttempts)
   {
      testVec = rotateByReferencePoint(baseVec, startingVec - baseVec, towerAngle * aiRandInt(numTestVecs));
      aiEcho("Testing tower location " + testVec);
      if (towerSearch < 0)
      { // init
         towerSearch = kbUnitQueryCreate("Tower placement search");
         kbUnitQuerySetPlayerRelation(towerSearch, cPlayerRelationAny);
         kbUnitQuerySetUnitType(towerSearch, gTowerUnit);
         kbUnitQuerySetState(towerSearch, cUnitStateABQ);
      }
      kbUnitQuerySetPosition(towerSearch, testVec);
      kbUnitQuerySetMaximumDistance(towerSearch, exclusionRadius);
      kbUnitQueryResetResults(towerSearch);
      if (kbUnitQueryExecute(towerSearch) < 1)
      { // Site is clear, use it
         if (kbAreaGroupGetIDByPosition(testVec) == kbAreaGroupGetIDByPosition(kbBaseGetLocation(cMyID, baseID)))
         { // Make sure it's in the same areagroup.
            success = true;
            break;
         }
      }
   }

   // We have found a location (success == true) or we need to just do a brute force placement around the TC.
   if (success == false)
      testVec = kbBaseGetLocation(cMyID, baseID);

   // Instead of base ID or areas, use a center position and falloff.
   aiPlanSetVariableVector(buildPlan, cBuildPlanCenterPosition, 0, testVec);
   if (success == true)
      aiPlanSetVariableFloat(buildPlan, cBuildPlanCenterPositionDistance, 0, exclusionRadius);
   else
      aiPlanSetVariableFloat(buildPlan, cBuildPlanCenterPositionDistance, 0, 50.0);

   // Add position influences for trees, gold, TCs.
   aiPlanSetNumberVariableValues(buildPlan, cBuildPlanInfluenceUnitTypeID, 8, true);
   aiPlanSetNumberVariableValues(buildPlan, cBuildPlanInfluenceUnitDistance, 8, true);
   aiPlanSetNumberVariableValues(buildPlan, cBuildPlanInfluenceUnitValue, 8, true);
   aiPlanSetNumberVariableValues(buildPlan, cBuildPlanInfluenceUnitFalloff, 8, true);

   aiPlanSetVariableInt(buildPlan, cBuildPlanInfluenceUnitTypeID, 0, cUnitTypeWood);
   aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluenceUnitDistance, 0, 20.0);     // 30m range.
   aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluenceUnitValue, 0, 10.0);        // 10 points per tree
   aiPlanSetVariableInt(buildPlan, cBuildPlanInfluenceUnitFalloff, 0, cBPIFalloffLinear);  // Linear slope falloff
   
   aiPlanSetVariableInt(buildPlan, cBuildPlanInfluenceUnitTypeID, 1, cUnitTypeMine);
   aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluenceUnitDistance, 1,  20.0);              // 40 meter range for gold
   aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluenceUnitValue, 1, 400.0);                // 300 points each
   aiPlanSetVariableInt(buildPlan, cBuildPlanInfluenceUnitFalloff, 1, cBPIFalloffLinear);  // Linear slope falloff
   
   aiPlanSetVariableInt(buildPlan, cBuildPlanInfluenceUnitTypeID, 2, cUnitTypeMine);
   aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluenceUnitDistance, 2, 10.0);              // 10 meter inhibition to keep some space
   aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluenceUnitValue, 2, -600.0);                // -300 points each
   aiPlanSetVariableInt(buildPlan, cBuildPlanInfluenceUnitFalloff, 2, cBPIFalloffNone);      // Cliff falloff
   
   aiPlanSetVariableInt(buildPlan, cBuildPlanInfluenceUnitTypeID, 3, cUnitTypeHuntable);
   aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluenceUnitDistance, 3, 20.0);     // 30m range.
   aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluenceUnitValue, 3, 25.0);        // 10 points per tree
   aiPlanSetVariableInt(buildPlan, cBuildPlanInfluenceUnitFalloff, 3, cBPIFalloffLinear);

   aiPlanSetVariableInt(buildPlan, cBuildPlanInfluenceUnitTypeID, 4, cUnitTypeDock);
   aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluenceUnitDistance, 4, 20.0);              // 40 meter inhibition around TCs.
   aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluenceUnitValue, 4, 300.0);                // -500 points each
   aiPlanSetVariableInt(buildPlan, cBuildPlanInfluenceUnitFalloff, 4, cBPIFalloffLinear);      // Cliff falloff
	  
   aiPlanSetVariableInt(buildPlan, cBuildPlanInfluenceUnitTypeID, 5, gTowerUnit);
   aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluenceUnitDistance, 5, 20.0);              // 40 meter inhibition around TCs.
   aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluenceUnitValue, 5, -600.0);                // -500 points each
   aiPlanSetVariableInt(buildPlan, cBuildPlanInfluenceUnitFalloff, 5, cBPIFalloffNone);      // Cliff falloff
	  
   aiPlanSetVariableInt(buildPlan, cBuildPlanInfluenceUnitTypeID, 6, cUnitTypeTownCenter);
   aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluenceUnitDistance, 6, 20.0);              // 40 meter inhibition around TCs.
   aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluenceUnitValue, 6, -600.0);                // -500 points each
   aiPlanSetVariableInt(buildPlan, cBuildPlanInfluenceUnitFalloff, 6, cBPIFalloffNone);      // Cliff falloff
   
   
	   // Weight it to prefer the general starting neighborhood
	  
      if (kbGetAge() == cAge1)
      aiPlanSetVariableVector(buildPlan, cBuildPlanInfluencePosition, 1, StartBase); // Position influence for landing position
      aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluencePositionDistance, 1, 50.0);          // 100m range.
      aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluencePositionValue, 1, 50.0);             // 300 points max
      aiPlanSetVariableInt(buildPlan, cBuildPlanInfluencePositionFalloff, 1, cBPIFalloffLinear); // Linear slope falloff
	  
	  
	   // Weight it to prefer the general starting neighborhood
      if (kbGetAge() == cAge2)
      aiPlanSetVariableVector(buildPlan, cBuildPlanInfluencePosition, 2, StartBase); // Position influence for landing position
      aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluencePositionDistance, 2, 100.0);          // 100m range.
      aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluencePositionValue, 2, 50.0);             // 300 points max
      aiPlanSetVariableInt(buildPlan, cBuildPlanInfluencePositionFalloff, 2, cBPIFalloffLinear); // Linear slope falloff
   
      if (kbGetAge() > cAge2)
      aiPlanSetVariableVector(buildPlan, cBuildPlanInfluencePosition, 2, StartBase); // Position influence for landing position
      aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluencePositionDistance, 2, 150.0);          // 100m range.
      aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluencePositionValue, 2, 50.0);             // 300 points max
      aiPlanSetVariableInt(buildPlan, cBuildPlanInfluencePositionFalloff, 2, cBPIFalloffLinear); // Linear slope falloff
   
	// Weight it to stay very close to center point.
	aiPlanSetVariableVector(buildPlan, cBuildPlanInfluencePosition, 0, testVec);    // Position influence for landing position
	aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluencePositionDistance, 0, exclusionRadius);     // 100m range.
	aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluencePositionValue, 0, 10.0);        // 10 points for center
	aiPlanSetVariableInt(buildPlan, cBuildPlanInfluencePositionFalloff, 0, cBPIFalloffLinear);  // Linear slope falloff

   aiEcho("Building plan (" + buildPlan + ") for tower at location " + testVec);
}

//==============================================================================
/*
   Tower manager

   Tries to maintain gNumTowers for the number of towers near the main base.

   If there are idle outpost wagons, use them.  If not, use villagers to build outposts.
   Russians use blockhouses via gTowerUnit.

   Placement algorithm is brain-dead simple.  Check a point that is mid-edge or a
   corner of a square around the base center.  Look for a nearby tower.  If none,
   do a tight build plan.  If there is one, try again.    If no luck, try a build
   plan that just avoids other towers.

*/
//==============================================================================
rule towerManager
inactive
minInterval 10
{
   if (cvOkToFortify == false)
   {
      return; // Oops.  I shouldn't be running.
   }

   static int towerUpgradePlan = -1;
   int towerUpgrade1 = cTechFrontierOutpost;
   int towerUpgrade2 = cTechFortifiedOutpost;
   if (cMyCiv == cCivRussians)
   {
      towerUpgrade1 = cTechFrontierBlockhouse;
      towerUpgrade2 = cTechFortifiedBlockhouse;
   }
   if (cMyCiv == cCivXPIroquois)
   {
      towerUpgrade1 = cTechStrongWarHut;
      towerUpgrade2 = cTechMightyWarHut;
   }
   if (cMyCiv == cCivXPAztec)
   {
      towerUpgrade1 = cTechStrongNoblesHut;
      towerUpgrade2 = cTechMightyNoblesHut;
   }
   if (cMyCiv == cCivXPSioux)
   {
      towerUpgrade1 = -1;
      towerUpgrade2 = -1;
   }
   if (cMyCiv == cCivDEInca)
   {
      towerUpgrade1 = cTechStrongWarHut;
      towerUpgrade2 = cTechMightyWarHut;
   }
   if (civIsAsian() == true)
   {
      towerUpgrade1 = cTechypFrontierCastle;
      towerUpgrade2 = cTechypFortifiedCastle;
   }
   if (civIsAfrican() == true)
   {
      towerUpgrade1 = cTechDESentryTower;
      towerUpgrade2 = cTechDEGuardTower;
   }

   if (towerUpgradePlan >= 0)
   {
      if ((aiPlanGetState(towerUpgradePlan) < 0) ||
          (aiPlanGetVariableInt(towerUpgradePlan, cResearchPlanBuildingID, 0) < 0))
      {
         aiPlanDestroy(towerUpgradePlan);
         towerUpgradePlan = -1; // It's dead, Jim.
         aiEcho("Invalid tower upgrade plan destroyed.");
      }
   }

   if ((kbTechGetStatus(towerUpgrade1) == cTechStatusObtainable) && (towerUpgradePlan == -1) && (towerUpgrade1 != -1))
   { // The first upgrade is available, and I'm not researching it.
      if ((kbUnitCount(cMyID, gTowerUnit, cUnitStateABQ) >= 3) && (kbGetAge() >= cAge3))
      { // I have at least 3 towers
         towerUpgradePlan = createSimpleResearchPlan(towerUpgrade1, -1, cMilitaryEscrowID, 70);
         aiPlanSetDesiredResourcePriority(towerUpgradePlan, 45);
         aiEcho("Starting research plan for first tower upgrade in plan # " + towerUpgradePlan);
      }
   }

   if ((kbTechGetStatus(towerUpgrade2) == cTechStatusObtainable) && (towerUpgradePlan == -1) && (towerUpgrade2 != -1))
   { // The second upgrade is available, and I'm not researching it.
      if ((kbUnitCount(cMyID, gTowerUnit, cUnitStateABQ) >= 4) && (kbGetAge() >= cAge4))
      { // I have at least 4 towers
         towerUpgradePlan = createSimpleResearchPlan(towerUpgrade2, -1, cMilitaryEscrowID, 70);
         aiPlanSetDesiredResourcePriority(towerUpgradePlan, 45);
         aiEcho("Starting research plan for second tower upgrade in plan # " + towerUpgradePlan);
      }
   }

   if ((kbUnitCount(cMyID, gTowerUnit, cUnitStateABQ) >= gNumTowers) &&
       (kbUnitCount(cMyID, cUnitTypeOutpostWagon, cUnitStateAlive) <= 0) &&
       (kbUnitCount(cMyID, cUnitTypeYPCastleWagon, cUnitStateAlive) <= 0))
      return; // We have enough, thank you, and no idle outpost or castle wagons.

   int towerBuildPlanID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, gTowerUnit);
   if (towerBuildPlanID >= 0)
   {
      if ((kbGetAge() == cAge1) && (agingUp() != true))
         aiPlanSetDesiredResourcePriority(towerBuildPlanID, 40);
      else
         aiPlanSetDesiredResourcePriority(towerBuildPlanID, 45);
      return; // We're already building one.
   }

   if (civIsAsian() == false)
   { // BHG: Asians have different outpost wagon types so it's ok to keep going
      if (aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeOutpost) >= 0)
         return; // We're already building one.  Weird case of civs that don't usually make towers having an outpost
                 // wagon given to them.
   }

   // Need more, not currently building any.  Need to select a builder type (settler or outpostWagon) and a location.
   int builderType = findWagonToBuild(gTowerUnit);

   if (builderType < 0)
      builderType = gEconUnit;

   int buildPlan = aiPlanCreate("Tower build plan ", cPlanBuild);
   // What to build
   if ((builderType == cUnitTypeOutpostWagon) && (civIsAsian() == false))
      aiPlanSetVariableInt(buildPlan, cBuildPlanBuildingTypeID, 0, cUnitTypeOutpost);
   else
      aiPlanSetVariableInt(buildPlan, cBuildPlanBuildingTypeID, 0, gTowerUnit);
   // Priority.
   aiPlanSetDesiredPriority(buildPlan, 85);
   // Econ, because mil doesn't get enough wood.
   aiPlanSetMilitary(buildPlan, false);
   aiPlanSetEconomy(buildPlan, true);
   // Escrow.
   aiPlanSetEscrowID(buildPlan, cEconomyEscrowID);
   // Builders.
   aiPlanAddUnitType(buildPlan, builderType, 1, 1, 1);

   selectTowerBuildPlanPosition(buildPlan);

   aiEcho("Cheapest tech for tower buildings is " + kbGetTechName(kbTechTreeGetCheapestUnitUpgrade(gTowerUnit)));
   aiEcho("Cheapest tech ID is " + kbTechTreeGetCheapestUnitUpgrade(gTowerUnit));
   aiPlanSetActive(buildPlan);
}

vector selectForwardBaseLocation(void)
{
   vector retVal = cInvalidVector;
   vector mainBaseVec = kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID));
   vector v = cInvalidVector; // Scratch variable for intermediate calcs.

   aiEcho("Selecting forward base location.");
   float distanceMultiplier =
       0.5; // Will be used to determine how far out we should put the fort on the line from our base to enemy TC.
   float dist = 0.0;
   int enemyPlayer = aiGetMostHatedPlayerID();

   int enemyTC = getUnitByLocation(cUnitTypeTownCenter, enemyPlayer, cUnitStateABQ, mainBaseVec, 500.0);
   float radius = 0.0;
   vector vec = cInvalidVector;
   vector bestLoc = cInvalidVector;
   float bestDist = 0.0;
   int enemyBuildingQuery = createSimpleUnitQuery(cUnitTypeBuilding, cPlayerRelationEnemyNotGaia, cUnitStateABQ);
   int numberFound = kbUnitQueryExecute(enemyBuildingQuery);

   if (enemyTC < 0)
   {
      v = guessEnemyLocation(enemyPlayer);
      radius = 100.0;
      if (getUnitCountByLocation(cUnitTypeLogicalTypeBuildingsNotWalls, enemyPlayer, cUnitStateAlive, v, radius) == 0)
         return(cInvalidVector);
   }
   else // enemy TC found
   {
      v = kbUnitGetPosition(enemyTC); // Vector from main base to enemy TC
      radius = 50.0 + kbBaseGetDistance(enemyPlayer, kbUnitGetBaseID(enemyTC));
   }

   // find the best location within 90 degrees.
   vec = xsVectorNormalize(mainBaseVec - v) * radius;
   for (i = 0; < 4)
   {
      vector tempLoc = rotateByReferencePoint(v, vec, aiRandFloat(0.0 - PI * 0.25, PI * 0.25));
      float maxDist = 1000.0;
      int areaID = kbAreaGetIDByPosition(tempLoc);
      // ensure we are inside the map.
      if (areaID < 0)
         continue;
      if (kbAreaGetNumberTiles(areaID) == kbAreaGetNumberBlackTiles(areaID))
         continue;
      for (j = 0; < numberFound)
      {
         int buildingID = kbUnitQueryGetResult(enemyBuildingQuery, j);
         dist = distance(kbUnitGetPosition(buildingID), tempLoc);
         if (maxDist > dist)
            maxDist = dist;
      }
      if (bestDist < maxDist)
      {
         bestLoc = tempLoc;
         bestDist = maxDist;
      }
   }

   if (bestLoc != cInvalidVector)
   {
      retVal = bestLoc;
      // Now, make sure it's on the same areagroup, back up if it isn't.
      dist = distance(mainBaseVec, retVal);
      int mainAreaGroup = kbAreaGroupGetIDByPosition(mainBaseVec);
      vector delta = mainBaseVec - retVal;
      int step = 0;
      bool siteFound = false;

      delta *= 30.0 / xsVectorLength(delta);

      if (dist > 0.0)
      {
         for (step = 0; < 9)
         {
            aiEcho("    " + retVal + " is in area group " + kbAreaGroupGetIDByPosition(retVal));
            siteFound = true;
            /*if (getUnitByLocation(cUnitTypeBuilding, cPlayerRelationEnemyNotGaia, cUnitStateABQ, retVal, 60.0) >= 0)
               continue; // DO NOT build too close to enemy buildings.
            if (getUnitByLocation(cUnitTypeTownCenter, cPlayerRelationEnemyNotGaia, cUnitStateABQ, retVal, 60.0) >= 0)
               continue; // Ditto enemy TCs.*/
            // don't build too close to any enemy building.
            if (getUnitByLocation(cUnitTypeBuilding, cPlayerRelationEnemyNotGaia, cUnitStateABQ, retVal, 60.0) >= 0)
               siteFound = false;
            else if (mainAreaGroup != kbAreaGroupGetIDByPosition(retVal))
               siteFound = false;
            else
            { // DONE!
               aiEcho("        Good location found.");
               break;
            }
            retVal = retVal + delta; // Move 1/10 of way back to main base, try again.
         }
      }
   }

   if (aiGetWorldDifficulty() < cDifficultyModerate || siteFound == false)
      retVal = cInvalidVector; // Easy and Sandbox will never forward build.
   aiEcho("    New forward base location will be " + retVal);
   return (retVal);
}

//==============================================================================
/*
   Forward base manager

Handles the planning, construction, defense and maintenance of a forward military base.

The steps involved:
1)  Choose a location
2)  Defend it and send a fort wagon to build a fort.
3)  Define it as the military base, move defend plans there, move military production there.
4)  Undo those settings if it needs to be abandoned.

*/
//==============================================================================
rule forwardBaseManager
inactive
group tcComplete
minInterval 30
{
   if ((cvOkToBuild == false) || (cvOkToBuildForts == false) || (aiTreatyActive() == true))
      return;

   int fortUnitID = -1;
   int buildingQuery = -1;
   int numberFound = 0;
   int numberMilitaryBuildings = 0;
   int buildingID = -1;

         vector location = cInvalidVector;

         //if (btOffenseDefense >= 0.0)
            location = selectForwardBaseLocation();
		
   switch (gForwardBaseState)
   {
   case cForwardBaseStateNone:
   {
      // Check if we should go to state Building
      if (kbUnitCount(cMyID, cUnitTypeFortWagon, cUnitStateAlive) > 0)
      { // Yes.
         // get the fort wagon, start a build plan, keep it defended

         if (location == cInvalidVector)
         {
            createSimpleBuildPlan(cUnitTypeFortFrontier, 1, 87, true, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
            return;
         }

         gForwardBaseLocation = location;
         gForwardBaseBuildPlan = aiPlanCreate("Fort build plan ", cPlanBuild);
         aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanBuildingTypeID, 0, cUnitTypeFortFrontier);
         aiPlanSetDesiredPriority(gForwardBaseBuildPlan, 87);
         // Military
         aiPlanSetMilitary(gForwardBaseBuildPlan, true);
         aiPlanSetEconomy(gForwardBaseBuildPlan, false);
         aiPlanSetEscrowID(gForwardBaseBuildPlan, cMilitaryEscrowID);
         aiPlanAddUnitType(gForwardBaseBuildPlan, cUnitTypeFortWagon, 1, 1, 1);

         // Instead of base ID or areas, use a center position
         aiPlanSetVariableVector(gForwardBaseBuildPlan, cBuildPlanCenterPosition, 0, location);
         aiPlanSetVariableFloat(gForwardBaseBuildPlan, cBuildPlanCenterPositionDistance, 0, 50.0);

         // Weight it to stay very close to center point.
         aiPlanSetVariableVector(gForwardBaseBuildPlan, cBuildPlanInfluencePosition, 0,
                                 location); // Position influence for center
         aiPlanSetVariableFloat(gForwardBaseBuildPlan, cBuildPlanInfluencePositionDistance, 0, 50.0); // 100m range.
         aiPlanSetVariableFloat(gForwardBaseBuildPlan, cBuildPlanInfluencePositionValue, 0,
                                100.0); // 100 points for center
         aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanInfluencePositionFalloff, 0,
                              cBPIFalloffLinear); // Linear slope falloff

         // Add position influence for nearby towers
         aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanInfluenceUnitTypeID, 0,
                              cUnitTypeFortFrontier); // Don't build anywhere near another fort.
         aiPlanSetVariableFloat(gForwardBaseBuildPlan, cBuildPlanInfluenceUnitDistance, 0, 50.0);
         aiPlanSetVariableFloat(gForwardBaseBuildPlan, cBuildPlanInfluenceUnitValue, 0, -200.0); // -20 points per fort
         aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanInfluenceUnitFalloff, 0,
                              cBPIFalloffNone); // Cliff falloff

         aiPlanSetActive(gForwardBaseBuildPlan);

         // Chat to my allies
         sendStatement(cPlayerRelationAlly, cAICommPromptToAllyIWillBuildMilitaryBase, gForwardBaseLocation);

         gForwardBaseState = cForwardBaseStateBuilding;

         aiEcho(" ");
         aiEcho("    BUILDING FORWARD BASE, MOVING DEFEND PLANS TO COVER.");
         aiEcho("    PLANNED LOCATION IS " + gForwardBaseLocation);
         aiEcho(" ");

         if (gDefenseReflex == false)
            endDefenseReflex(); // Causes it to move to the new location
      }
      break;
   }
   case cForwardBaseStateBuilding:
   {
      fortUnitID = getUnitByLocation(cUnitTypeFortFrontier, cMyID, cUnitStateAlive, gForwardBaseLocation, 100.0);
      if (fortUnitID < 0)
      {
         // check for other military buildings.
         buildingQuery =
             createSimpleUnitQuery(cUnitTypeMilitaryBuilding, cMyID, cUnitStateAlive, gForwardBaseLocation, 100.0);
         numberFound = kbUnitQueryExecute(buildingQuery);
         numberMilitaryBuildings = xsArrayGetSize(gMilitaryBuildings);
         for (i = 0; < numberFound)
         {
            buildingID = kbUnitQueryGetResult(buildingQuery, i);
            for (j = 0; < numberMilitaryBuildings)
            {
               if (kbUnitIsType(buildingID, xsArrayGetInt(gMilitaryBuildings, j)) == true)
               {
                  fortUnitID = buildingID;
                  break;
               }
            }
            if (fortUnitID >= 0)
               break;
         }
      }
      if (fortUnitID >= 0)
      { // Building exists and is complete, go to state Active
         if (kbUnitGetBaseID(fortUnitID) >= 0)
         { // Base has been created for it.
            gForwardBaseState = cForwardBaseStateActive;
            gForwardBaseID = kbUnitGetBaseID(fortUnitID);
            gForwardBaseLocation = kbUnitGetPosition(fortUnitID);
            gForwardBaseUpTime = xsGetTime();
            gForwardBaseShouldDefend = kbUnitIsType(fortUnitID, cUnitTypeFortFrontier);
            aiEcho("Forward base location is " + gForwardBaseLocation + ", Base ID is " + gForwardBaseID +
                   ", Unit ID is " + fortUnitID);
            // Tell the attack goal where to go.
            // aiPlanSetBaseID(gMainAttackGoal, gForwardBaseID);
            aiEcho(" ");
            aiEcho("    FORWARD BASE COMPLETED, GOING TO STATE ACTIVE, MOVING ATTACK GOAL.");
            aiEcho(" ");
         }
         else
         {
            aiEcho(" ");
            aiEcho("    FORT COMPLETE, WAITING FOR FORWARD BASE ID.");
            aiEcho(" ");
         }
      }
      else // Check if plan still exists. If not, go back to state 'none'.
      {
         if (aiPlanGetState(gForwardBaseBuildPlan) < 0)
         { // It failed?
            gForwardBaseState = cForwardBaseStateNone;
            gForwardBaseLocation = cInvalidVector;
            gForwardBaseID = -1;
            gForwardBaseBuildPlan = -1;
            gForwardBaseShouldDefend = false;
            aiEcho(" ");
            aiEcho("    FORWARD BASE PLAN FAILED, RETURNING TO STATE NONE.");
            aiEcho(" ");
         }
      }

      break;
   }
   case cForwardBaseStateActive:
   { // Normal state.  If fort is destroyed and base overrun, bail.
      fortUnitID = getUnitByLocation(cUnitTypeFortFrontier, cMyID, cUnitStateAlive, gForwardBaseLocation, 50.0);
      if (fortUnitID < 0)
      {
         // check for other military buildings.
         buildingQuery =
             createSimpleUnitQuery(cUnitTypeMilitaryBuilding, cMyID, cUnitStateAlive, gForwardBaseLocation, 100.0);
         numberFound = kbUnitQueryExecute(buildingQuery);
         numberMilitaryBuildings = xsArrayGetSize(gMilitaryBuildings);
         for (i = 0; < numberFound)
         {
            buildingID = kbUnitQueryGetResult(buildingQuery, i);
            for (j = 0; < numberMilitaryBuildings)
            {
               if (kbUnitIsType(buildingID, xsArrayGetInt(gMilitaryBuildings, j)) == true)
               {
                  fortUnitID = buildingID;
                  break;
               }
            }
            if (fortUnitID >= 0)
               break;
         }
      }
      if (fortUnitID < 0)
      {
         // Fort is missing, is base still OK?
         if (((gDefenseReflexBaseID == gForwardBaseID) && (gDefenseReflexPaused == true)) ||
             (kbBaseGetNumberUnits(cMyID, gForwardBaseID, cPlayerRelationSelf, cUnitTypeBuilding) <
              1)) // Forward base under attack and overwhelmed, or gone.
         {        // No, not OK.  Get outa Dodge.
            gForwardBaseState = cForwardBaseStateNone;
            gForwardBaseID = -1;
            gForwardBaseLocation = cInvalidVector;
            gForwardBaseShouldDefend = false;
            // Tell the attack goal to go back to the main base.
            // aiPlanSetBaseID(gMainAttackGoal, kbBaseGetMainID(cMyID));
            endDefenseReflex();
            aiEcho(" ");
            aiEcho("    ABANDONING FORWARD BASE, RETREATING TO MAIN BASE.");
            aiEcho(" ");
         }
      }
      break;
   }
   }
   
   if (kbUnitCount(cMyID, cUnitTypeFortWagon, cUnitStateAlive) > 0)
      { // Yes.
         // get the fort wagon, start a build plan, keep it defended
         if (location == cInvalidVector)
         {
            createSimpleBuildPlan(cUnitTypeFortFrontier, 1, 87, true, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
            return;
         }

         gForwardBaseLocation = location;
         gForwardBaseBuildPlan = aiPlanCreate("Fort build plan ", cPlanBuild);
         aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanBuildingTypeID, 0, cUnitTypeFortFrontier);
         aiPlanSetDesiredPriority(gForwardBaseBuildPlan, 87);
         // Military
         aiPlanSetMilitary(gForwardBaseBuildPlan, true);
         aiPlanSetEconomy(gForwardBaseBuildPlan, false);
         aiPlanSetEscrowID(gForwardBaseBuildPlan, cMilitaryEscrowID);
         aiPlanAddUnitType(gForwardBaseBuildPlan, cUnitTypeFortWagon, 1, 1, 1);

         // Instead of base ID or areas, use a center position
         aiPlanSetVariableVector(gForwardBaseBuildPlan, cBuildPlanCenterPosition, 0, location);
         aiPlanSetVariableFloat(gForwardBaseBuildPlan, cBuildPlanCenterPositionDistance, 0, 50.0);

         // Weight it to stay very close to center point.
         aiPlanSetVariableVector(gForwardBaseBuildPlan, cBuildPlanInfluencePosition, 0,
                                 location); // Position influence for center
         aiPlanSetVariableFloat(gForwardBaseBuildPlan, cBuildPlanInfluencePositionDistance, 0, 50.0); // 100m range.
         aiPlanSetVariableFloat(gForwardBaseBuildPlan, cBuildPlanInfluencePositionValue, 0,
                                100.0); // 100 points for center
         aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanInfluencePositionFalloff, 0,
                              cBPIFalloffLinear); // Linear slope falloff

         // Add position influence for nearby towers
         aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanInfluenceUnitTypeID, 0,
                              cUnitTypeFortFrontier); // Don't build anywhere near another fort.
         aiPlanSetVariableFloat(gForwardBaseBuildPlan, cBuildPlanInfluenceUnitDistance, 0, 50.0);
         aiPlanSetVariableFloat(gForwardBaseBuildPlan, cBuildPlanInfluenceUnitValue, 0, -200.0); // -20 points per fort
         aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanInfluenceUnitFalloff, 0,
                              cBPIFalloffNone); // Cliff falloff

         aiPlanSetActive(gForwardBaseBuildPlan);

         // Chat to my allies
         sendStatement(cPlayerRelationAlly, cAICommPromptToAllyIWillBuildMilitaryBase, gForwardBaseLocation);

         gForwardBaseState = cForwardBaseStateBuilding;

         aiEcho(" ");
         aiEcho("    BUILDING FORWARD BASE, MOVING DEFEND PLANS TO COVER.");
         aiEcho("    PLANNED LOCATION IS " + gForwardBaseLocation);
         aiEcho(" ");

         if (gDefenseReflex == false)
            endDefenseReflex(); // Causes it to move to the new location
      }
}


//==============================================================================
// deathMatchSetup, moreDMHouses, finalDMHouses, startup of the Deathmatch Game Mode.
//==============================================================================

void deathMatchSetup(void)
{ // Make a bunch of changes to get a deathmatch start
   aiEcho("RUNNING DEATHMATCH SETUP");
   // 10 houses, pronto.
   if (cMyCiv != cCivXPSioux)
      createSimpleBuildPlan(gHouseUnit, 10, 99, true, cEconomyEscrowID, kbBaseGetMainID(cMyID), 1);
   // 1 each of the main military buildings, ASAP.
   if (civIsEuropean() == true)
   {
      createSimpleBuildPlan(cUnitTypeBarracks, 1, 98, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
      createSimpleBuildPlan(cUnitTypeStable, 1, 97, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
   }
   else if (civIsAsian() == true)
   {
      if ((cMyCiv == cCivJapanese) || (cMyCiv == cCivSPCJapanese) || (cMyCiv == cCivSPCJapaneseEnemy))
      {
         createSimpleBuildPlan(cUnitTypeypBarracksJapanese, 1, 98, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
         createSimpleBuildPlan(cUnitTypeypStableJapanese, 1, 97, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
      }
      else if ((cMyCiv == cCivChinese) || (cMyCiv == cCivSPCChinese))
      {
         createSimpleBuildPlan(cUnitTypeypWarAcademy, 1, 98, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
      }
      else
      {
         createSimpleBuildPlan(cUnitTypeYPBarracksIndian, 1, 98, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
         createSimpleBuildPlan(cUnitTypeypCaravanserai, 1, 98, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
      }
      createSimpleBuildPlan(cUnitTypeypCastle, 1, 97, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
   }
   else
   {
      createSimpleBuildPlan(cUnitTypeWarHut, 1, 98, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
      if (cMyCiv == cCivXPAztec)
         createSimpleBuildPlan(cUnitTypeNoblesHut, 1, 98, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
      else
         createSimpleBuildPlan(cUnitTypeCorral, 1, 98, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
   }
   if ((civIsNative() == false) || (cMyCiv == cCivXPIroquois))
   {
      if (civIsAsian() == false)
         createSimpleBuildPlan(cUnitTypeArtilleryDepot, 1, 96, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
      else
         createSimpleBuildPlan(cUnitTypeypCastle, 1, 96, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
   }
   if (civIsAsian() == false)
   {
      gNumTowers = kbGetBuildLimit(cMyID, gTowerUnit); // Load up on towers.
   }
   else
   {
      gNumTowers = kbGetBuildLimit(cMyID, gTowerUnit); // Load up on castles.
   }
   xsEnableRule("turtleUp");
   xsEnableRule("moreDMHouses");
}

rule moreDMHouses
inactive
minInterval 90
{ // After 90 seconds, make 10 more houses
   if (cMyCiv != cCivXPSioux)
      createSimpleBuildPlan(gHouseUnit, 10, 99, true, cEconomyEscrowID, kbBaseGetMainID(cMyID), 1);
   // 1 each of the main military buildings, ASAP.
   if (civIsEuropean() == true)
   {
      createSimpleBuildPlan(cUnitTypeBarracks, 1, 98, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
      createSimpleBuildPlan(cUnitTypeStable, 1, 97, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
   }
   else if (civIsAsian() == true)
   {
      if ((cMyCiv == cCivJapanese) || (cMyCiv == cCivSPCJapanese) || (cMyCiv == cCivSPCJapaneseEnemy))
      {
         createSimpleBuildPlan(cUnitTypeypBarracksJapanese, 1, 98, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
         createSimpleBuildPlan(cUnitTypeypStableJapanese, 1, 97, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
      }
      else if ((cMyCiv == cCivChinese) || (cMyCiv == cCivSPCChinese))
      {
         createSimpleBuildPlan(cUnitTypeypWarAcademy, 1, 98, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
      }
      else
      {
         createSimpleBuildPlan(cUnitTypeYPBarracksIndian, 1, 98, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
         createSimpleBuildPlan(cUnitTypeypCaravanserai, 1, 98, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
      }
      createSimpleBuildPlan(cUnitTypeypCastle, 1, 97, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
   }
   else
   {
      createSimpleBuildPlan(cUnitTypeWarHut, 1, 98, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
      if (cMyCiv == cCivXPAztec)
         createSimpleBuildPlan(cUnitTypeNoblesHut, 1, 98, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
      else
         createSimpleBuildPlan(cUnitTypeCorral, 1, 98, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
   }
   if ((civIsNative() == false) || (cMyCiv == cCivXPIroquois))
   {
      if (civIsAsian() == false)
         createSimpleBuildPlan(cUnitTypeArtilleryDepot, 1, 96, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
      else
         createSimpleBuildPlan(cUnitTypeypCastle, 1, 96, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
   }

   xsEnableRule("finalDMHouses");
}

rule finalDMHouses
inactive
minInterval 120
{
   int count = kbUnitCount(cMyID, gHouseUnit, cUnitStateAlive);
   int max = kbGetBuildLimit(cMyID, gHouseUnit);

   count = max - count; // Count is number needed.
   if (aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, gHouseUnit) >= 0)
      count = count - 1;
   if (cMyCiv == cCivXPSioux)
      count = 0;

   if (count > 0)
      createSimpleBuildPlan(gHouseUnit, count, 99, true, cEconomyEscrowID, kbBaseGetMainID(cMyID), 1);
   // 1 each of the main military buildings, ASAP.
   if (civIsEuropean() == true)
   {
      createSimpleBuildPlan(cUnitTypeBarracks, 1, 98, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
      createSimpleBuildPlan(cUnitTypeStable, 1, 97, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
   }
   else if (civIsAsian() == true)
   {
      if ((cMyCiv == cCivJapanese) || (cMyCiv == cCivSPCJapanese) || (cMyCiv == cCivSPCJapaneseEnemy))
      {
         createSimpleBuildPlan(cUnitTypeypBarracksJapanese, 1, 98, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
         createSimpleBuildPlan(cUnitTypeypStableJapanese, 1, 97, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
      }
      else if ((cMyCiv == cCivChinese) || (cMyCiv == cCivSPCChinese))
      {
         createSimpleBuildPlan(cUnitTypeypWarAcademy, 1, 98, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
      }
      else
      {
         createSimpleBuildPlan(cUnitTypeYPBarracksIndian, 1, 98, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
         createSimpleBuildPlan(cUnitTypeypCaravanserai, 1, 98, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
      }
      createSimpleBuildPlan(cUnitTypeypCastle, 1, 97, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
   }
   else
   {
      createSimpleBuildPlan(cUnitTypeWarHut, 1, 98, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
      if (cMyCiv == cCivXPAztec)
         createSimpleBuildPlan(cUnitTypeNoblesHut, 1, 98, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
      else
         createSimpleBuildPlan(cUnitTypeCorral, 1, 98, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
   }
   if ((civIsNative() == false) || (cMyCiv == cCivXPIroquois))
   {
      if (civIsAsian() == false)
         createSimpleBuildPlan(cUnitTypeArtilleryDepot, 1, 96, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
      else
         createSimpleBuildPlan(cUnitTypeypCastle, 1, 96, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
   }

   xsDisableSelf();
}

//==============================================================================
// empireWarsStart, startup of the Empire Wars Game Mode.
//==============================================================================
/*
void empireWarsStart()
{
	// Do all the checks before we want to return an Empire Wars Wagon to a plan.
	int ewImperialWagonQuery = createSimpleUnitQuery(cUnitTypedeImperialWagon);
	kbUnitQueryExecute(ewImperialWagonQuery);
	int mainBase = kbBaseGetMainID(cMyID);
	int planID = -1;
	
	if (civIsEuropean() == true)
	{
		planID = createSimpleBuildPlan(gHouseUnit, 1, 100, true, cEconomyEscrowID, mainBase, 0);
		aiPlanAddUnitType(planID, cUnitTypedeImperialWagon, 1, 1, 1);
		aiPlanAddUnit(planID, kbUnitQueryGetResult(ewImperialWagonQuery, 0));
		planID = createSimpleBuildPlan(gMarketUnit, 1, 100, true, cEconomyEscrowID, mainBase, 0);
		aiPlanAddUnitType(planID, cUnitTypedeImperialWagon, 1, 1, 1);
		aiPlanAddUnit(planID, kbUnitQueryGetResult(ewImperialWagonQuery, 1));
		if (cMyCiv != cCivBritish)
		{
			planID = createSimpleBuildPlan(gTowerUnit, 1, 100, true, cEconomyEscrowID, mainBase, 0);
			aiPlanAddUnitType(planID, cUnitTypedeImperialWagon, 1, 1, 1);
			aiPlanAddUnit(planID, kbUnitQueryGetResult(ewImperialWagonQuery, 2));
		}
		return;
	}
	
}
*/

//==============================================================================
// updateMilitaryTrainPlanBuildings
//==============================================================================
void updateMilitaryTrainPlanBuildings(int baseID = -1)
{
   static int buildingIDs = -1;
   int size = xsArrayGetSize(gArmyUnitMaintainPlans);
   int planID = -1;
   int buildingQuery = -1;
   int numberFound = 0;
   int buildingID = -1;
   int buildingPUID = -1;
   int numberBuildings = 0;

   if (buildingIDs < 0)
      buildingIDs = xsArrayCreateInt(8, -1, "Temp train buildings");


   for (i = 0; < size)
   {
      planID = xsArrayGetInt(gArmyUnitMaintainPlans, i);
      if (planID < 0)
         continue;
      if (baseID < 0)
      {
         // clear all buildings.
         aiPlanSetNumberVariableValues(planID, cTrainPlanBuildingID, 1, true);
      }
      else
      {
         // Restrict train plan to train from the base if we can.
         if (buildingQuery < 0)
         {
            buildingQuery = createSimpleUnitQuery(cUnitTypeLogicalTypeBuildingsNotWalls, cMyID, cUnitStateAlive, kbBaseGetLocation(cMyID, baseID), kbBaseGetDistance(cMyID, baseID));
            numberFound = kbUnitQueryExecute(buildingQuery);
         }

         numberBuildings = 0;

         for (j = 0; < numberFound)
         {
            buildingID = kbUnitQueryGetResult(buildingQuery);
            buildingPUID = kbUnitGetProtoUnitID(buildingID);
            if (kbProtoUnitCanTrain(buildingPUID, aiPlanGetVariableInt(planID, cTrainPlanUnitType, 0)) == false)
               continue;
            xsArraySetInt(buildingIDs, numberBuildings, buildingID);
            numberBuildings++;
         }

         if (numberBuildings == 0)
         {
            aiPlanSetNumberVariableValues(planID, cTrainPlanBuildingID, 1, true);
         }
         else
         {
            aiPlanSetNumberVariableValues(planID, cTrainPlanBuildingID, numberBuildings, true);
            for (j = 0; < numberBuildings)
               aiPlanSetVariableInt(planID, cTrainPlanBuildingID, j, xsArrayGetInt(buildingIDs, j));
         }
      }
   }
}

//==============================================================================
/*
   Military Manager

   Create maintain plans for military unit lines.  Control 'maintain' levels,
   buy upgrades.
*/
//==============================================================================
rule militaryManager
inactive
minInterval 28
{
   static bool init = false; // Flag to indicate vars, plans are initialized
   static int unitsNotMaintained = -1;
   static int unitsNotMaintainedValue = -1;
   static int unitsNotMaintainedUpgrade = -1;
   if (init == false)
   {
      // Need to initialize, if we're allowed to.
      if (cvOkToTrainArmy == true)
      {
         init = true;
         if (cvNumArmyUnitTypes >= 0)
            gNumArmyUnitTypes = cvNumArmyUnitTypes;
         else
            gNumArmyUnitTypes = 3;
         gLandUnitPicker = initUnitPicker("Land military units", gNumArmyUnitTypes, 1, 30, -1, -1, 1, true);

         // now the goal
         // wmj -- hard coded for now, but this should most likely ramp up as the ages progress
         if (kbGetAge() == cAge2)
         aiSetMinArmySize(20);
	 else
         if (kbGetAge() == cAge3)
         aiSetMinArmySize(15);
	 else
         if ((kbGetAge() == cAge4) && (gRevolutionType != 0))
         aiSetMinArmySize(10);
	 else
         aiSetMinArmySize(5);
	 if (kbGetAge() == cvMaxAge)
         aiSetMinArmySize(5);
	     //gMainAttackGoal = createSimpleAttackGoal("AttackGoal", aiGetMostHatedPlayerID(), gLandUnitPicker, -1, cAge2, -1, gMainBase, true);
         //aiPlanSetVariableInt(gMainAttackGoal, cGoalPlanReservePlanID, 0, gLandReservePlan);

         unitsNotMaintained = xsArrayCreateInt(3, -1, "Units not maintained");
         unitsNotMaintainedValue = xsArrayCreateFloat(3, -1, "Units not maintained value");
         unitsNotMaintainedUpgrade = xsArrayCreateInt(3, -1, "Units not maintained upgrade");
      }
   }

   if (gLandUnitPicker != -1)
   {
      int age = kbGetAge();
      int targetPlayer = aiGetMostHatedPlayerID();

      if (agingUp() == true)
         age++;

      setUnitPickerPreference(
          gLandUnitPicker); // Update preferences in case btBiasEtc vars have changed, or cvPrimaryArmyUnit has changed.

      kbUnitPickSetMinimumPop(gLandUnitPicker, 1);
      kbUnitPickSetMaximumPop(gLandUnitPicker, aiGetMilitaryPop());

      if (cvNumArmyUnitTypes < 0)
      {
         if (age < cAge3)
            gNumArmyUnitTypes = 2;
         else
            gNumArmyUnitTypes = 3;
         kbUnitPickSetDesiredNumberUnitTypes(gLandUnitPicker, gNumArmyUnitTypes, 1, true);
      }
	  
	  
	  int TowerBuildPlanID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, gTowerUnit);
 
      if ((TowerBuildPlanID < 0) && (kbUnitCount(cMyID, gTowerUnit, cUnitStateABQ) < gNumTowers) && (cvOkToFortify == true))
   {                                            
	  if ((kbGetAge() == cvMaxAge) || (gRevolutionType != 0))
	  {
	  gNumTowers = kbGetBuildLimit(cMyID, gTowerUnit);
      TowerBuildPlanID = createSimpleBuildPlan(gTowerUnit, 1, 95, true, cEconomyEscrowID, kbBaseGetMainID(cMyID), 1);
      aiEcho("Starting a new house build plan.");
      aiPlanSetDesiredResourcePriority(TowerBuildPlanID, 40);
	  }
   }
  
  
	  if (kbGetAge() == cvMaxAge)
      xsEnableRule("turtleUp");
      if (gRevolutionType != 0)
      xsEnableRule("turtleUp");
  

      /*
       if(kbGetAge() == cAge3)
       {
          kbUnitPickSetMinimumPop(gLandUnitPicker, 1);     //Min is really managed by scoring system.
                                                                   // An ally or trigger-spawned mission should 'go'
       even if it's very small. kbUnitPickSetMaximumPop(gLandUnitPicker, 55);
       }
       if(kbGetAge() == cAge4)
       {
          kbUnitPickSetMinimumPop(gLandUnitPicker, 1);
          kbUnitPickSetMaximumPop(gLandUnitPicker, 70);
       }
       if(kbGetAge() == cAge5)
       {
          kbUnitPickSetMinimumPop(gLandUnitPicker, 1);
          kbUnitPickSetMaximumPop(gLandUnitPicker, 90);
       }
      */

      //setUnitPickerCommon(gLandUnitPicker);

      // Bump up an age when we are transitioning to plan early for resources.
      kbUnitPickRun(gLandUnitPicker);
	  
	  kbUnitPickSetPreferenceWeight(gLandUnitPicker, 2.0);
      if (gSPC == false)
      {
         kbUnitPickSetCombatEfficiencyWeight(gLandUnitPicker,
                                             0.4); // Changed from 1.0 to dilute the power of the preference weight.
         kbUnitPickSetBuildingCombatEfficiencyWeight(gLandUnitPicker, 0.0);
      }
      else
      {
         kbUnitPickSetCombatEfficiencyWeight(gLandUnitPicker, 0.2); // Leave it at 1.0 to avoid messing up SPC balance
         kbUnitPickSetBuildingCombatEfficiencyWeight(gLandUnitPicker, 0.0);
      }

      kbUnitPickSetCostWeight(gLandUnitPicker, 0.0);

      // Default to land units.
      kbUnitPickSetEnemyPlayerID(gLandUnitPicker, aiGetMostHatedPlayerID());
      kbUnitPickSetAttackUnitType(gLandUnitPicker, cUnitTypeLogicalTypeLandMilitary);

      // Set the default target types and weights, for use until we've seen enough actual units.
      kbUnitPickAddCombatEfficiencyType(gLandUnitPicker, cUnitTypeLogicalTypeLandMilitary, 2.0);

      kbUnitPickAddBuildingCombatEfficiencyType(gLandUnitPicker, cUnitTypeMilitaryBuilding, 0.0);
      kbUnitPickAddBuildingCombatEfficiencyType(gLandUnitPicker, cUnitTypeAbstractTownCenter, 0.0);
      kbUnitPickRun(gLandUnitPicker);

      int numMilitaryBuildings = xsArrayGetSize(gMilitaryBuildings);
      int planID = -1;
      int upgradePlanID = -1;
      float totalFactor = 0.0;
      int baseID = kbBaseGetMainID(cMyID);
      vector gatherPoint = kbBaseGetMilitaryGatherPoint(cMyID, baseID);
      int puid = -1;
      int buildingPUID = -1;
      int trainBuildingPUID = -1;
      int numberToMaintain = 0;
      int popCount = 0;
      int upgradeTechID = -1;
      float totalValue = 0.0;

      for (i = 0; < gNumArmyUnitTypes)
         totalFactor = totalFactor + kbUnitPickGetResultFactor(gLandUnitPicker, i);

      for (i = 0; < gNumArmyUnitTypes)
      {
         puid = kbUnitPickGetResult(gLandUnitPicker, i);
         trainBuildingPUID = -1;
         numberToMaintain = 0;
         popCount = kbGetProtoUnitPopCount(puid);

         // update maintain plan.
         planID = xsArrayGetInt(gArmyUnitMaintainPlans, i);
         if (planID >= 0 && puid != aiPlanGetVariableInt(planID, cTrainPlanUnitType, 0))
         {
            int otherPlanID = -1;

            for (j = i + 1; < gNumArmyUnitTypes)
            {
               otherPlanID = xsArrayGetInt(gArmyUnitMaintainPlans, j);
               if (otherPlanID >= 0 && puid == aiPlanGetVariableInt(otherPlanID, cTrainPlanUnitType, 0))
               {
                  xsArraySetInt(gArmyUnitMaintainPlans, j, planID);
                  break;
               }
               otherPlanID = -1;
            }

            if (otherPlanID < 0)
            {
               aiPlanDestroy(planID);
               planID = -1;
            }
            else
            {
               planID = otherPlanID;
               xsArraySetInt(gArmyUnitMaintainPlans, i, planID);
            }
         }

         if (planID < 0 && puid >= 0)
         {
            planID = aiPlanCreate("Land military " + kbGetUnitTypeName(puid) + " maintain", cPlanTrain);
            aiPlanSetMilitary(planID, true);
            // Unit type.
            aiPlanSetVariableInt(planID, cTrainPlanUnitType, 0, puid);
            aiPlanSetBaseID(planID, baseID);
            aiPlanSetVariableVector(planID, cTrainPlanGatherPoint, 0, gatherPoint);
            aiPlanSetActive(planID);
            xsArraySetInt(gArmyUnitMaintainPlans, i, planID);
            aiEcho("*** Creating maintain plan for " + kbGetUnitTypeName(puid));
         }

         if (popCount > 0)
         {
            numberToMaintain =
                (kbUnitPickGetResultFactor(gLandUnitPicker, i) / totalFactor) * aiGetMilitaryPop() / popCount;
         }
         else
         {
            numberToMaintain =
                (kbUnitPickGetResultFactor(gLandUnitPicker, i) / totalFactor) * aiGetMilitaryPop() /
                (kbUnitCostPerResource(puid, cResourceFood) + kbUnitCostPerResource(puid, cResourceWood) +
                 kbUnitCostPerResource(puid, cResourceGold));
         }
         aiPlanSetVariableInt(planID, cTrainPlanNumberToMaintain, 0, numberToMaintain);

         for (j = 0; < numMilitaryBuildings)
         {
            buildingPUID = xsArrayGetInt(gMilitaryBuildings, j);
            if (kbProtoUnitCanTrain(buildingPUID, puid) == true)
            {
               trainBuildingPUID = buildingPUID;
               break;
            }
         }

         // create a research plan.
         if (trainBuildingPUID >= 0 && age >= cAge3)
         {
            upgradeTechID = kbTechTreeGetCheapestUnitUpgrade(puid, trainBuildingPUID);
            if (upgradeTechID >= 0)
            {
               upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, upgradeTechID);

               if (upgradePlanID < 0)
               {
                  upgradePlanID = aiPlanCreate("Research " + kbGetTechName(upgradeTechID), cPlanResearch);
                  aiPlanSetVariableInt(upgradePlanID, cResearchPlanTechID, 0, upgradeTechID);
                  aiPlanSetVariableInt(upgradePlanID, cResearchPlanBuildingTypeID, 0, trainBuildingPUID);
                  aiPlanSetActive(upgradePlanID);
                  aiEcho("*** Creating research plan for " + kbGetTechName(upgradeTechID));
               }

               aiPlanSetParentID(upgradePlanID, planID);

               totalValue = kbUnitCostPerResource(puid, cResourceFood) + kbUnitCostPerResource(puid, cResourceWood) +
                            kbUnitCostPerResource(puid, cResourceGold);
               totalValue = totalValue * kbUnitCount(cMyID, puid, cUnitStateABQ);

               // below default priority if we do not have enough units.
               if (totalValue < 1000.0)
                  aiPlanSetDesiredResourcePriority(upgradePlanID, 50 - (5 - totalValue / 200));
               else
                  aiPlanSetDesiredResourcePriority(upgradePlanID, 55);
            }
         }

         xsArraySetInt(gArmyUnitBuildings, i, trainBuildingPUID);
      }

      // Also research upgrades for units not maintained.
      //if (aiGetWorldDifficulty() >= cDifficultyModerate && age >= cAge3)
      //{
         // Remove any units in the unit picker.
         for (i = 0; < 3)
         {
            puid = xsArrayGetInt(unitsNotMaintained, i);
            if (puid < 0)
               continue;
            for (j = 0; < gNumArmyUnitTypes)
            {
               if (puid == kbUnitPickGetResult(gLandUnitPicker, j))
               {
                  xsArraySetInt(unitsNotMaintained, i, -1);
                  upgradePlanID = xsArrayGetInt(unitsNotMaintainedUpgrade, i);
                  if (upgradePlanID >= 0)
                  {
                     if (aiPlanGetParentID(upgradePlanID) < 0)
                        aiPlanDestroy(upgradePlanID);
                     xsArraySetInt(unitsNotMaintainedUpgrade, i, -1);
                  }
                  puid = -1;
                  break;
               }
            }
            if (puid >= 0)
            {
               totalValue = kbUnitCostPerResource(puid, cResourceFood) + kbUnitCostPerResource(puid, cResourceWood) +
                            kbUnitCostPerResource(puid, cResourceGold);
               totalValue = totalValue * kbUnitCount(cMyID, puid, cUnitStateAlive);
               xsArraySetFloat(unitsNotMaintainedValue, i, totalValue);
            }
            else
            {
               xsArraySetFloat(unitsNotMaintainedValue, i, 0.0);
            }
         }

         int militaryQuery = createSimpleUnitQuery(cUnitTypeLogicalTypeLandMilitary, cMyID, cUnitStateAlive);
         int numberFound = kbUnitQueryExecute(militaryQuery);
         int unitID = -1;
         int militaryPUID = -1;
         float lowestTotalValue = 0.0;
         int lowestTotalValueIndex = 0;

         // Query all units, pick unit types with the highest total value.
         for (i = 0; < numberFound)
         {
            unitID = kbUnitQueryGetResult(militaryQuery, i);
            puid = kbUnitGetProtoUnitID(unitID);

            // avoid unit types in the unit picker.
            for (j = 0; < gNumArmyUnitTypes)
            {
               if (puid == kbUnitPickGetResult(gLandUnitPicker, j))
               {
                  puid = -1;
                  break;
               }
            }
            if (puid < 0)
               break;

            // ignore unit types already in the array.
            for (j = 0; < 3)
            {
               if (puid == xsArrayGetInt(unitsNotMaintained, j))
               {
                  puid = -1;
                  break;
               }
            }
            if (puid < 0)
               break;

            // pick unit type in the array with the lowest value and replace it.
            lowestTotalValue = 99999.0;
            lowestTotalValueIndex = 0;

            for (j = 0; < 3)
            {
               militaryPUID = xsArrayGetInt(unitsNotMaintained, j);
               totalValue = xsArrayGetFloat(unitsNotMaintainedValue, j);
               if (militaryPUID < 0 || lowestTotalValue > totalValue)
               {
                  lowestTotalValue = totalValue;
                  lowestTotalValueIndex = j;
                  break;
               }
            }

            totalValue = kbUnitCostPerResource(puid, cResourceFood) + kbUnitCostPerResource(puid, cResourceWood) +
                         kbUnitCostPerResource(puid, cResourceGold);
            totalValue = totalValue * kbUnitCount(cMyID, puid, cUnitStateAlive);

            if (totalValue > lowestTotalValue)
            {
               xsArraySetInt(unitsNotMaintained, lowestTotalValueIndex, puid);
               xsArraySetFloat(unitsNotMaintainedValue, lowestTotalValueIndex, totalValue);
               upgradePlanID = xsArrayGetInt(unitsNotMaintainedUpgrade, lowestTotalValueIndex);
               if (upgradePlanID >= 0)
                  aiPlanDestroy(upgradePlanID);
               xsArraySetInt(unitsNotMaintainedUpgrade, lowestTotalValueIndex, -1);
            }
         }

         // Research upgrades when available.
         for (i = 0; < 3)
         {
            puid = xsArrayGetInt(unitsNotMaintained, i);
            for (j = 0; < numMilitaryBuildings)
            {
               buildingPUID = xsArrayGetInt(gMilitaryBuildings, j);
               if (kbProtoUnitCanTrain(buildingPUID, puid) == true)
               {
                  trainBuildingPUID = buildingPUID;
                  break;
               }
            }
            if (trainBuildingPUID >= 0)
            {
               upgradeTechID = kbTechTreeGetCheapestUnitUpgrade(puid, trainBuildingPUID);
               if (upgradeTechID >= 0)
               {
                  upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, upgradeTechID);

                  if (upgradePlanID < 0)
                  {
                     upgradePlanID = aiPlanCreate("Research " + kbGetTechName(upgradeTechID), cPlanResearch);
                     aiPlanSetVariableInt(upgradePlanID, cResearchPlanTechID, 0, upgradeTechID);
                     aiPlanSetVariableInt(upgradePlanID, cResearchPlanBuildingTypeID, 0, trainBuildingPUID);
                     aiPlanSetActive(upgradePlanID);
                     aiEcho("*** Creating research plan for " + kbGetTechName(upgradeTechID));
                  }

                  totalValue = xsArrayGetFloat(unitsNotMaintainedValue, i);

                  // below default priority if we do not have enough units.
                  if (totalValue < 1000.0)
                     aiPlanSetDesiredResourcePriority(upgradePlanID, 45 - (5 - totalValue / 200));
                  else
                     aiPlanSetDesiredResourcePriority(upgradePlanID, 50);
                  xsArraySetInt(unitsNotMaintainedUpgrade, i, upgradePlanID);
               }
            }
         }
      //}

      //if (aiGetWorldDifficulty() >= cDifficultyExpert)
      //{
         planID = aiPlanGetIDByTypeAndVariableType(cPlanAttack, cAttackPlanBaseAttackMode,
                                                   cAttackPlanBaseAttackModeExplicit);
         if (planID >= 0 && aiPlanGetVariableBool(planID, cAttackPlanAllowMoreUnitsDuringAttack, 0) == true)
            baseID = gForwardBaseID;
         else
            baseID = -1;
         updateMilitaryTrainPlanBuildings(baseID);
      //}
   }
}

int getNavalTargetPlayer() // Find an enemy player ID to attack on the water.
{
   int count = 0;
   int retVal = -1;
   static int unitQueryID = -1;

   // If we don't have the query yet, create one.
   if (unitQueryID < 0)
   {
      unitQueryID = kbUnitQueryCreate("navy target count");
      kbUnitQuerySetIgnoreKnockedOutUnits(unitQueryID, true);
      kbUnitQuerySetPlayerRelation(unitQueryID, cPlayerRelationEnemyNotGaia);
   }

   kbUnitQuerySetUnitType(unitQueryID, gFishingUnit); // Fishing boats
   kbUnitQuerySetState(unitQueryID, cUnitStateABQ);
   kbUnitQueryResetResults(unitQueryID);
   count = kbUnitQueryExecute(unitQueryID);
   // aiEcho("Enemy fishing boats: "+ count);

   kbUnitQuerySetUnitType(unitQueryID, cUnitTypeAbstractWarShip); // Warships
   kbUnitQuerySetState(unitQueryID, cUnitStateABQ);
   count = kbUnitQueryExecute(unitQueryID); // Cumulative, don't clear it.
   // aiEcho("Enemy fishing boats and warships: "+ count);

   kbUnitQuerySetUnitType(unitQueryID, gDockUnit); // Docks
   kbUnitQuerySetState(unitQueryID, cUnitStateABQ);
   count = kbUnitQueryExecute(unitQueryID); // Cumulative, don't clear it.
   // aiEcho("Enemy fishing boats, warships and docks: "+ count);

   if (count > 0)
      retVal = kbUnitGetPlayerID(kbUnitQueryGetResult(unitQueryID, 0));

   aiEcho("Enemy boat owner is player " + retVal);

   return (retVal);
}

rule waterAttackDefend
active
minInterval 15
{ // Broke this out separately (from navyManager) so that scenarios that start with a pre-made navy will work.
   if (cvInactiveAI == true)
   {
      xsDisableSelf();
      return;
   }
   int navyUnit = getUnit(cUnitTypeAbstractWarShip, cMyID, cUnitStateAlive);

   if (navyUnit < 0)
      return;

   int flagUnit = getUnit(cUnitTypeHomeCityWaterSpawnFlag, cMyID);
   if (flagUnit >= 0)
      gNavyVec = kbUnitGetPosition(flagUnit);
   else
      gNavyVec = kbUnitGetPosition(navyUnit);

   if (gNavyDefendPlan < 0)
   {
      gNavyDefendPlan = aiPlanCreate("Primary Water Defend", cPlanDefend);
      aiPlanAddUnitType(gNavyDefendPlan, cUnitTypeAbstractWarShip, 0, 0, 200); // Grab first caravel and any others

      aiPlanSetVariableVector(gNavyDefendPlan, cDefendPlanDefendPoint, 0, gNavyVec);
      aiPlanSetVariableFloat(gNavyDefendPlan, cDefendPlanEngageRange, 0, 100.0); // Loose
      aiPlanSetVariableBool(gNavyDefendPlan, cDefendPlanPatrol, 0, false);
      aiPlanSetVariableFloat(gNavyDefendPlan, cDefendPlanGatherDistance, 0, 40.0);
      aiPlanSetInitialPosition(gNavyDefendPlan, gNavyVec);
      aiPlanSetUnitStance(gNavyDefendPlan, cUnitStanceDefensive);
      aiPlanSetVariableInt(gNavyDefendPlan, cDefendPlanRefreshFrequency, 0, 20);
      aiPlanSetVariableInt(gNavyDefendPlan, cDefendPlanAttackTypeID, 0, cUnitTypeUnit); // Only units
      aiPlanSetDesiredPriority(gNavyDefendPlan,
                               18); // Very low priority, gather unused units, belowing fishing by default.
      aiPlanSetActive(gNavyDefendPlan);
      aiEcho("Creating primary navy defend plan at " + gNavyVec);
   }

   int enemyQuery =
       createSimpleUnitQuery(cUnitTypeAbstractWarShip, cPlayerRelationEnemyNotGaia, cUnitStateAlive, gNavyVec, 100.0);
   kbUnitQuerySetSeeableOnly(enemyQuery, true);
   int numberFound = 0;

   numberFound = kbUnitQueryExecute(enemyQuery);

   if (numberFound > 0)
      aiPlanSetDesiredPriority(gNavyDefendPlan, 21); // Above fishing when there are enemies around.
   else
      aiPlanSetDesiredPriority(gNavyDefendPlan, 18);

   if (aiPlanGetNumberUnits(gNavyDefendPlan, cUnitTypeAbstractWarShip) >= 3)
   {                                  // Time to start an attack?
      if (getNavalTargetPlayer() > 0) // There's something to attack
      {
         int attackPlan = aiPlanCreate("Navy attack plan", cPlanAttack);
         aiPlanSetVariableInt(attackPlan, cAttackPlanPlayerID, 0, getNavalTargetPlayer());
         aiPlanSetNumberVariableValues(attackPlan, cAttackPlanTargetTypeID, 2, true);
         aiPlanSetVariableInt(attackPlan, cAttackPlanTargetTypeID, 0, cUnitTypeUnit);
         aiPlanSetVariableInt(attackPlan, cAttackPlanTargetTypeID, 1, gDockUnit);
         aiPlanSetVariableVector(attackPlan, cAttackPlanGatherPoint, 0, gNavyVec);
         aiPlanSetVariableFloat(attackPlan, cAttackPlanGatherDistance, 0, 30.0);
         aiPlanSetVariableInt(attackPlan, cAttackPlanRefreshFrequency, 0, 5);
         aiPlanSetDesiredPriority(attackPlan, 48); // Above defend, fishing.  Below explore.
         aiPlanAddUnitType(attackPlan, cUnitTypeAbstractWarShip, 1, 10, 200);
         // aiPlanAddUnitType(attackPlan, cUnitTypexpWarCanoe, 1, 10, 200);
         aiPlanSetInitialPosition(attackPlan, gNavyVec);
         aiEcho("***** LAUNCHING NAVAL ATTACK, plan ID is " + attackPlan);
         aiPlanSetActive(attackPlan, true);
      }
   }

   static int navyRepairPlan = -1;
   static int dockID = -1;
   vector dockPosition = kbUnitGetPosition(dockID);

   if (dockID < 0 || kbUnitGetPosition(dockID) == cInvalidVector)
      dockID = getUnit(gDockUnit, cMyID, cUnitStateAlive);

   if (dockID < 0)
   {
      if (navyRepairPlan >= 0)
      {
         aiPlanDestroy(navyRepairPlan);
         navyRepairPlan = -1;
      }
   }
   else
   {
      if (navyRepairPlan < 0)
      {
         navyRepairPlan = aiPlanCreate("Navy repair plan", cPlanDefend);
         aiPlanSetVariableFloat(navyRepairPlan, cDefendPlanEngageRange, 0, 10.0);
         aiPlanSetVariableBool(navyRepairPlan, cDefendPlanPatrol, 0, false);
         aiPlanSetVariableFloat(navyRepairPlan, cDefendPlanGatherDistance, 0, 10.0);
         aiPlanSetInitialPosition(navyRepairPlan, dockPosition);
         aiPlanSetUnitStance(navyRepairPlan, cUnitStanceDefensive);
         aiPlanSetVariableInt(navyRepairPlan, cDefendPlanRefreshFrequency, 0, 20);
         aiPlanSetVariableInt(navyRepairPlan, cDefendPlanAttackTypeID, 0, cUnitTypeUnit); // Only units
         aiPlanSetDesiredPriority(navyRepairPlan, 50);
         aiPlanSetActive(navyRepairPlan);
      }

      int unitID = -1;
      int bestUnitID = -1;

      numberFound = aiPlanGetNumberUnits(navyRepairPlan);
      for (i = 0; < numberFound)
      {
         unitID = aiPlanGetUnitByIndex(navyRepairPlan, i);
         if (kbUnitGetHealth(unitID) > 0.95)
         {
            aiTaskUnitMove(unitID, gNavyVec);
            continue;
         }
         bestUnitID = unitID;
         break;
      }

      if (bestUnitID < 0)
      {
         // Look for ships to repair
         float unitHitpoints = 0.0;
         int unitPlanID = -1;
         float bestUnitHitpoints = 9999.0;
         int shipQueryID = createSimpleUnitQuery(cUnitTypeAbstractWarShip, cMyID, cUnitStateAlive);
         numberFound = kbUnitQueryExecute(shipQueryID);
         for (i = 0; < numberFound)
         {
            unitID = kbUnitQueryGetResult(shipQueryID, i);
            unitPlanID = kbUnitGetPlanID(unitID);
            if (unitPlanID >= 0 && (aiPlanGetDesiredPriority(unitPlanID) > 50 ||
                                    aiPlanGetType(unitPlanID) == cPlanTransport || kbUnitGetHealth(unitID) > 0.95))
               continue;
            unitHitpoints = kbUnitGetCurrentHitpoints(unitID);
            if (unitHitpoints < bestUnitHitpoints)
            {
               bestUnitID = unitID;
               bestUnitHitpoints = unitHitpoints;
            }
         }
      }

      aiPlanSetVariableVector(navyRepairPlan, cDefendPlanDefendPoint, 0, dockPosition);
      if (bestUnitID >= 0)
      {
         aiPlanAddUnitType(navyRepairPlan, cUnitTypeAbstractWarShip, 1, 1, 1);
         aiPlanAddUnit(navyRepairPlan, bestUnitID);
      }
      else
      {
         aiPlanAddUnitType(navyRepairPlan, cUnitTypeAbstractWarShip, 0, 0, 0);
      }
   }
}

void createWaterExplorePlan()
{
   if (gWaterExplorePlan < 0)
   {
      vector location = cInvalidVector;
      if (getUnit(gFishingUnit, cMyID, cUnitStateAlive) >= 0)
         location = kbUnitGetPosition(getUnit(gFishingUnit, cMyID, cUnitStateAlive));
      else
         location = gNavyVec;
      gWaterExplorePlan = aiPlanCreate("Water Explore", cPlanExplore);
      aiPlanSetVariableBool(gWaterExplorePlan, cExplorePlanReExploreAreas, 0, false);
      aiPlanSetInitialPosition(gWaterExplorePlan, location);
      aiPlanSetDesiredPriority(
          gWaterExplorePlan, 45); // Low, so that transport plans can steal it as needed, but just above fishing plans.
      aiPlanAddUnitType(gWaterExplorePlan, gFishingUnit, 1, 1, 1);
      aiPlanSetEscrowID(gWaterExplorePlan, cEconomyEscrowID);
      aiPlanSetVariableBool(gWaterExplorePlan, cExplorePlanDoLoops, 0, false);
      aiPlanSetActive(gWaterExplorePlan);
   }

   // more aggressive exploring on island maps
   if (gStartOnDifferentIslands == true)
   {
      vector initialLocation = kbGetPlayerStartingPosition(cMyID);
      if (getAreaGroupNumberTiles(kbAreaGroupGetIDByPosition(initialLocation)) < 2000)
      {
         aiEcho("***** Adding water explore waypoints for larger islands.");
         int numberAreaGroups = kbAreaGroupGetNumber();
         int numberAreas = 0;
         int areaID = -1;
         int numberBorderAreas = 0;
         int borderAreaID = -1;
         static int waypoints = -1;
         int numberWaypoints = 0;

         if (waypoints < 0)
            xsArrayCreateVector(100, cInvalidVector, "Water explore waypoints");

         for (areaGroupID = 0; < numberAreaGroups)
         {
            if (kbAreaGroupGetType(areaGroupID) != cAreaGroupTypeLand || getAreaGroupNumberTiles(areaGroupID) < 2000)
               continue;
            numberAreas = kbAreaGroupGetNumberAreas(areaGroupID);
            for (i = 0; < numberAreas)
            {
               areaID = kbAreaGroupGetAreaID(areaGroupID, i);
               numberBorderAreas = kbAreaGetNumberBorderAreas(areaID);
               for (j = 0; < numberBorderAreas)
               {
                  borderAreaID = kbAreaGetBorderAreaID(areaID, j);
                  if (kbAreaGetType(borderAreaID) == cAreaTypeWater)
                  {
                     location = kbAreaGetCenter(areaID);
                     xsArraySetVector(waypoints, numberWaypoints, location);
                     numberWaypoints = numberWaypoints + 1;
                     if (numberWaypoints >= xsArrayGetSize(waypoints))
                        xsArrayResizeVector(waypoints, numberWaypoints * 2);
                     break;
                  }
               }
            }
         }

         aiEcho("***** Water explore number waypoints " + numberWaypoints);
         for (i = 0; < numberWaypoints)
         {
            aiPlanAddWaypoint(gWaterExplorePlan, xsArrayGetVector(waypoints, i));
         }
      }
      if (aiPlanGetNumberUnits(gWaterExplorePlan, gFishingUnit) == 0)
         aiPlanAddUnitType(gWaterExplorePlan, cUnitTypeAbstractWarShip, 1, 1, 1);
      else
         aiPlanAddUnitType(gWaterExplorePlan, cUnitTypeAbstractWarShip, 0, 0, 0);
      aiPlanAddWaypoint(gWaterExplorePlan, guessEnemyLocation());
   }
}

//==============================================================================
/*
   Navy Manager

   Create maintain plans for navy unit lines.  Control 'maintain' levels.
*/
//==============================================================================
rule navyManager
inactive
minInterval 30
{

   if (gNavyMap == false)
   {
      gNavyMode = cNavyModeOff;
      aiEcho("gNavyMap was false, turning off navy manager.");
      xsDisableSelf();
      return;
   }

   if (getUnit(cUnitTypeHomeCityWaterSpawnFlag, cMyID) < 0)
   {
      aiEcho("**** NO WATER FLAG, TURNING NAVY OFF ****");
      xsDisableSelf();
      return;
   }

   int navyEnemyPlayer = getNavalTargetPlayer();
   // If it was not full on...
   if (gNavyMode == cNavyModeOff)
   { // We're not currently training a navy...see if we should be
      // Turning it on by default, now that we have variable maintain levels
      // gNavyMode = cNavyModeActive;
      if (navyEnemyPlayer > 0)
      {
         gNavyMode = cNavyModeActive; // They have a navy.
         aiEcho("Saw enemy naval units.");
      }

      if (cvOkToTrainNavy == false)
         gNavyMode = cNavyModeOff; // Overrides others.

      if (gNavyMode == cNavyModeActive) // We're turning it on
      {
         if (gCaravelMaintain >= 0)
            aiPlanSetActive(gCaravelMaintain, true);
         if (gGalleonMaintain >= 0)
            aiPlanSetActive(gGalleonMaintain, true);
         if (gFrigateMaintain >= 0)
            aiPlanSetActive(gFrigateMaintain, true);
         if (gMonitorMaintain >= 0)
            aiPlanSetActive(gMonitorMaintain, true);
         aiEcho("**** TURNING NAVY ON ****");
      }
      else
         aiEcho("No navy targets detected.");
   }

   if (gNavyMode == cNavyModeOff)
      return; // We didn't turn it on, so we're done

   // If we're here, navyMode is active.  See if we need to turn it off
   if (cvOkToTrainNavy == false)
      gNavyMode = cNavyModeOff;

   // If we don't see any naval targets or threats, turn it off.
   // Disabling this now that we added variable maintain plans.  If no enemy navy is visible, maintain a small force.
   // if (navyTargetPlayer < 0)
   //   gNavyMode = cNavyModeOff;      // No need for a navy, we don't see targets any more

   if (gNavyMode != cNavyModeActive)
   { // It's been turned off or set to explore, stop the plans
      aiEcho("**** TURNING NAVY OFF BECAUSE WE SEE NO DOCKS OR SHIPS ****");
      if (gCaravelMaintain >= 0)
         aiPlanSetActive(gCaravelMaintain, false);
      if (gGalleonMaintain >= 0)
         aiPlanSetActive(gGalleonMaintain, false);
      if (gFrigateMaintain >= 0)
         aiPlanSetActive(gFrigateMaintain, false);
      if (gMonitorMaintain >= 0)
         aiPlanSetActive(gMonitorMaintain, false);
   }
   if (gNavyMode == cNavyModeOff)
      return;

   // If we're here, gNavyMode is active, and it should be.  Make sure we have a dock, then make sure maintain plans
   // exist.

   vector flagVec = cInvalidVector;
   int flagUnit = getUnit(cUnitTypeHomeCityWaterSpawnFlag, cMyID);
   if (flagUnit >= 0)
   {
      flagVec = kbUnitGetPosition(flagUnit);
   }
   else
   {
      int closestDock =
          getUnitByLocation(gDockUnit, cMyID, cUnitStateAlive, kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)), 500.0);
      if (closestDock >= 0)
         flagVec = kbUnitGetPosition(closestDock);
   }
   if ((gNavyVec == cInvalidVector) && (flagVec != cInvalidVector))
      gNavyVec = flagVec; // Set global vector

   if ((kbUnitCount(cMyID, gDockUnit, cUnitStateABQ) < 1) &&
       (aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, gDockUnit) < 0))
   { // No dock and not making any, let's start a plan.
      int dockPlan = aiPlanCreate("military dock plan", cPlanBuild);
      aiPlanSetVariableInt(dockPlan, cBuildPlanBuildingTypeID, 0, gDockUnit);
      // Priority.
      aiPlanSetDesiredPriority(dockPlan, 80);
      // Mil vs. Econ.
      aiPlanSetMilitary(dockPlan, true);
      aiPlanSetEconomy(dockPlan, false);
      // Escrow.
      aiPlanSetEscrowID(dockPlan, cMilitaryEscrowID);
      // Builders. //BHG - check for the new dockwagon, mostly for the honhsu map
      if (kbUnitCount(cMyID, cUnitTypeYPDockWagon, cUnitStateAlive) > 0)
      {
         aiPlanAddUnitType(dockPlan, cUnitTypeYPDockWagon, 1, 1, 1);
      }
      else
      {
         aiPlanAddUnitType(dockPlan, gEconUnit, 1, 1, 1);
      }

      aiPlanSetNumberVariableValues(dockPlan, cBuildPlanDockPlacementPoint, 2, true);
      aiPlanSetVariableVector(dockPlan, cBuildPlanDockPlacementPoint, 0,
                              kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)));    // One point at main base
      aiPlanSetVariableVector(dockPlan, cBuildPlanDockPlacementPoint, 1, gNavyVec); // One point at water flag

      aiPlanSetActive(dockPlan);
      aiEcho("**** STARTING NAVY DOCK PLAN, plan ID " + dockPlan);
      return; // Nothing else to do until dock is complete
   }

   closestDock = getUnitByLocation(gDockUnit, cMyID, cUnitStateAlive, flagVec, 500.0);
   if (closestDock < 0)
      closestDock = getUnit(gDockUnit, cMyID, cUnitStateAlive);

   createWaterExplorePlan();

   if (closestDock < 0)
      return; // Don't fire up maintain plans until we have a base ID

   int baseID = kbUnitGetBaseID(closestDock);
   if (baseID < 0)
      return; // Don't fire up maintain plans until we have a base ID

   if (gWaterExploreMaintain < 0)
   {
      gWaterExploreMaintain = createSimpleMaintainPlan(gFishingUnit, 1, true, baseID, 1);
   }

   if ((gCaravelMaintain < 0) && (gNavyMode == cNavyModeActive)) // Need to init plans
   {
      if (cMyCiv == cCivXPAztec)
      {
         gCaravelMaintain = createSimpleMaintainPlan(gCaravelUnit, 10, false, baseID, 1); // xpWarCanoe
         gGalleonMaintain = createSimpleMaintainPlan(gGalleonUnit, 20, false, baseID, 1); // Canoe
         gFrigateMaintain = createSimpleMaintainPlan(gGalleonUnit, 5, false, baseID, 1);  // TlalocCanoe
      }
      else if (cMyCiv == cCivDEInca)
      {
         gCaravelMaintain = createSimpleMaintainPlan(gCaravelUnit, 8, false, baseID, 1); // deChinchaRaft
      }
      else if (civIsNative() == true)
      {
         gCaravelMaintain = createSimpleMaintainPlan(gCaravelUnit, 10, false, baseID, 1); // xpWarCanoe
         gGalleonMaintain = createSimpleMaintainPlan(gGalleonUnit, 20, false, baseID, 1); // Canoe
      }
      else if ((cMyCiv == cCivChinese) || (cMyCiv == cCivSPCChinese))
      {
         gCaravelMaintain = createSimpleMaintainPlan(gCaravelUnit, 5, false, baseID, 1); // War Junk
         gFrigateMaintain = createSimpleMaintainPlan(gFrigateUnit, 3, false, baseID, 1); // Fuchuan
         gMonitorMaintain = createSimpleMaintainPlan(gMonitorUnit, 2, false, baseID, 1);
      }
      else if (civIsAfrican() == true)
      {
         gCaravelMaintain = createSimpleMaintainPlan(gCaravelUnit, 5, false, baseID, 1); // Battle Canoe
         gFrigateMaintain = createSimpleMaintainPlan(gFrigateUnit, 2, false, baseID, 1); // Dhow/Xebec
         gMonitorMaintain = createSimpleMaintainPlan(gMonitorUnit, 2, false, baseID, 1); // Cannon Boat
      }
      else
      {
         gCaravelMaintain = createSimpleMaintainPlan(gCaravelUnit, 5, false, baseID, 1);
         gGalleonMaintain = createSimpleMaintainPlan(gGalleonUnit, 3, false, baseID, 1);
         gFrigateMaintain = createSimpleMaintainPlan(gFrigateUnit, 3, false, baseID, 1);
         gMonitorMaintain = createSimpleMaintainPlan(gMonitorUnit, 2, false, baseID, 1);
      }
      aiEcho("**** ACTIVATING NAVAL TRAIN PLANS ****");
   }

   int numberCaravels = 0;
   int numberGalleons = 0;
   int numberFrigates = 0;
   int numberMonitors = 0;

   // Train some navy when we want to defend fishing boats or boom.
   if (gStartOnDifferentIslands == true || gTimeToFish == true || (btRushBoom <= 0.0 && kbGetAge() >= cAge3))
   {
      int navyQuery = -1;
      int navySize = 0;
      float netNavyValue = 0.0;
      int unitID = -1;
      int puid = -1;

      navyQuery = createSimpleUnitQuery(cUnitTypeAbstractWarShip, navyEnemyPlayer, cUnitStateAlive);
      navySize = kbUnitQueryExecute(navyQuery);

      for (i = 0; < navySize)
      {
         unitID = kbUnitQueryGetResult(navyQuery, i);
         puid = kbUnitGetProtoUnitID(unitID);
         netNavyValue =
             netNavyValue + (kbUnitCostPerResource(puid, cResourceWood) + kbUnitCostPerResource(puid, cResourceGold));
      }

      navyQuery = createSimpleUnitQuery(cUnitTypeAbstractWarShip, cMyID, cUnitStateABQ);
      navySize = kbUnitQueryExecute(navyQuery);

      int caravelLimit = 0;
      int galleonLimit = 0;
      int frigateLimit = 0;
      int monitorLimit = 0;

      caravelLimit = kbGetBuildLimit(cMyID, gCaravelUnit);
      if (cMyCiv == cCivXPAztec || cMyCiv == cCivXPIroquois || cMyCiv == cCivXPSioux)
         galleonLimit = kbGetBuildLimit(cMyID, gGalleonUnit);
      if (cMyCiv != cCivXPIroquois && cMyCiv != cCivXPSioux && cMyCiv != cCivDEInca && kbGetAge() >= cAge3)
         frigateLimit = kbGetBuildLimit(cMyID, gFrigateUnit);
      if (civIsNative() == false && kbGetAge() >= cAge4)
         monitorLimit = kbGetBuildLimit(cMyID, gMonitorUnit);

      for (i = 0; < navySize)
      {
         unitID = kbUnitQueryGetResult(navyQuery, i);
         puid = kbUnitGetProtoUnitID(unitID);
         netNavyValue =
             netNavyValue - (kbUnitCostPerResource(puid, cResourceWood) + kbUnitCostPerResource(puid, cResourceGold));

         switch (puid)
         {
         case gCaravelUnit:
         {
            numberCaravels = numberCaravels + 1;
            break;
         }
         case gGalleonUnit:
         {
            numberGalleons = numberGalleons + 1;
            break;
         }
         case gFrigateUnit:
         {
            numberFrigates = numberFrigates + 1;
            break;
         }
         case gMonitorUnit:
         {
            numberMonitors = numberMonitors + 1;
            break;
         }
         }
      }

      // 1 more caravel or equivalent amount of war ships than enemy.
      netNavyValue = netNavyValue + 400.0;
      aiEcho("Navy enemy player is " + navyEnemyPlayer + ", net navy value is " + netNavyValue);

      int caravelValue =
          kbUnitCostPerResource(gCaravelUnit, cResourceWood) + kbUnitCostPerResource(gCaravelUnit, cResourceGold);
      int galleonValue =
          kbUnitCostPerResource(gGalleonUnit, cResourceWood) + kbUnitCostPerResource(gGalleonUnit, cResourceGold);
      // African dhows/xebecs cost influence
      int frigateValue = kbUnitCostPerResource(gFrigateUnit, cResourceWood) +
                         kbUnitCostPerResource(gFrigateUnit, cResourceGold) +
                         kbUnitCostPerResource(gFrigateUnit, cResourceInfluence);
      int monitorValue =
          kbUnitCostPerResource(gMonitorUnit, cResourceWood) + kbUnitCostPerResource(gMonitorUnit, cResourceGold);

      // Prioritize ships in the following order - frigate, caravel, monitor, galleon
      while (netNavyValue > 0.0)
      {
         if (numberFrigates < frigateLimit)
         {
            numberFrigates = numberFrigates + 1;
            netNavyValue = netNavyValue - frigateValue;
            continue;
         }
         if (numberCaravels < caravelLimit)
         {
            numberCaravels = numberCaravels + 1;
            netNavyValue = netNavyValue - caravelValue;
            continue;
         }
         if (numberMonitors < monitorLimit)
         {
            numberMonitors = numberMonitors + 1;
            netNavyValue = netNavyValue - monitorValue;
            continue;
         }
         if (numberGalleons < galleonLimit)
         {
            numberGalleons = numberGalleons + 1;
            netNavyValue = netNavyValue - galleonValue;
            continue;
         }
         break;
      }
   }

   if (gCaravelMaintain >= 0)
      aiPlanSetVariableInt(gCaravelMaintain, cTrainPlanNumberToMaintain, 0, numberCaravels);
   if (gGalleonMaintain >= 0)
      aiPlanSetVariableInt(gGalleonMaintain, cTrainPlanNumberToMaintain, 0, numberGalleons);
   if (gMonitorMaintain >= 0)
      aiPlanSetVariableInt(gMonitorMaintain, cTrainPlanNumberToMaintain, 0, numberMonitors);
   if (gFrigateMaintain >= 0)
      aiPlanSetVariableInt(gFrigateMaintain, cTrainPlanNumberToMaintain, 0, numberFrigates);
}

//==============================================================================
// rule age2Monitor
/*
   Watch for us reaching age 2.
*/
//==============================================================================
rule age2Monitor
inactive
group tcComplete
minInterval 5
{
   if (kbGetAge() >= cAge2) // We're in age 2
   {
      xsDisableSelf();
      xsEnableRule("age3Monitor");
      if (xsIsRuleEnabled("militaryManager") == false)
      {
         xsEnableRule("militaryManager");
         aiEcho("Enabling the military manager.");
         militaryManager(); // runImmediately doesn't work.
      }
      if (xsIsRuleEnabled("navyManager") == false)
      {
         xsEnableRule("navyManager");
         aiEcho("Enabling the navy manager.");
      }
      if (xsIsRuleEnabled("attackManager") == false && cvOkToAttack == true)
      {
         xsEnableRule("attackManager");
         aiEcho("Enabling the attack manager.");
      }

      xsEnableRule("healerMonitor");
      xsEnableRule("tamboMonitor");
		
      if (getGaiaUnitCount(cUnitTypeSocketCree, cUnitStateAny) > 0)
         xsEnableRule("maintainCreeCoureurs");
			
      if (getGaiaUnitCount(cUnitTypedeSocketBerbers, cUnitStateAny) > 0)
         xsEnableRule("maintainBerberNomads");
			
      xsEnableRule("islandExploreMonitor");
		
      if (civIsAfrican() == false)
         xsEnableRule("nativeMonitor");
			
      if (getGaiaUnitCount(cUnitTypeTradePostSocket, cUnitStateAny) > 0)
      {
         xsEnableRule("tradeRouteUpgradeMonitor");
         if (aiGetWorldDifficulty() >= cDifficultyEasy)
            xsEnableRule("tradeRouteTacticMonitor");
      }
		
      xsEnableRule("settlerUpgradeMonitor");
		
      if (cMyCiv == cCivDESwedish)
      {
         xsEnableRule("arsenalUpgradeMonitor");
         xsEnableRule("advancedArsenalUpgradeMonitor");
      }
      if (civIsAsian() == true)
         xsEnableRule("consulateMonitor");
			
		// Enable Golden Pavilion upgrades for Japanese (these are part of the advanced Arsenal rule).
      if (((cMyCiv == cCivJapanese) || (cMyCiv == cCivSPCJapanese) || (cMyCiv == cCivSPCJapaneseEnemy)) &&
			(kbUnitCount(cMyID, cUnitTypeypWJGoldenPavillion2, cUnitStateAlive) > 0))
				xsEnableRule("advancedArsenalUpgradeMonitor");

      // Enable training units and researching techs with influence resource.
      if (civIsAfrican() == true)
		{
         xsEnableRule("influenceManager");
			xsEnableRule("allianceUpgradeMonitor");
			updategAfricanAlliancesAgedUpWith();
		}

      // Allow abuns to gather from mountain monasteries.
      if (cMyCiv == cCivDEEthiopians)
      {
         aiAddGathererType(cUnitTypedeAbun);
         // Hack the gold gather plan to set resource as mountain monastery.
         if (kbUnitCount(cMyID, cUnitTypedeAbun, cUnitStateAlive) > 0)
            xsEnableRule("hackGoldGatherPlanMountainMonastery");
      }

      // Use Caravels to fish.
      aiAddGathererType(cUnitTypeAbstractFishingBoat);

      findEnemyBase(); // Create a one-off explore plan to probe the likely enemy base location.
      updateResourceDistribution(true);
      updateSettlerCounts();
      /*if (cMyCiv == cCivChinese) {
        int planid2 = createSimpleResearchPlan(cTechypVillagePopCapIncrease, getUnit(cUnitTypeypVillage),
      cEconomyEscrowID, 85); aiEcho("Creating plan #"+planid2+" to get more popcap with tech
      "+kbGetTechName(cTechypVillagePopCapIncrease)+" at the "+kbGetProtoUnitName(cUnitTypeypVillage));
      }*/
      // kbBaseSetMaximumResourceDistance(cMyID, kbBaseGetMainID(cMyID), 80.0);

      gAgeUpTime = xsGetTime();
      gAgeUpPlanTime = 0;
      /*if (aiGetWorldDifficulty() >= gDifficultyExpert)
      {
         // Avoid planning for age upgrades until 10 minutes passed after aging up.
         if (btRushBoom > 0.0 && kbGetAge() == cAge2)
            gAgeUpPlanTime = xsGetTime() + 10 * 60 * 1000;
      }*/

      // updateEscrows();

      kbEscrowAllocateCurrentResources();

      //-- Set the resource TargetSelector factors.
      gTSFactorDistance = -40.0;
      gTSFactorPoint = 10.0;
      gTSFactorTimeToDone = 0.0;
      gTSFactorBase = 100.0;
      gTSFactorDanger = -40.0;
      kbSetTargetSelectorFactor(cTSFactorDistance, gTSFactorDistance);
      kbSetTargetSelectorFactor(cTSFactorPoint, gTSFactorPoint);
      kbSetTargetSelectorFactor(cTSFactorTimeToDone, gTSFactorTimeToDone);
      kbSetTargetSelectorFactor(cTSFactorBase, gTSFactorBase);
      kbSetTargetSelectorFactor(cTSFactorDanger, gTSFactorDanger);

      setUnitPickerPreference(gLandUnitPicker);

      if (gLastAttackMissionTime < 0)
         gLastAttackMissionTime =
             xsGetTime() - 180000; // Pretend they all fired 3 minutes ago, even if that's a negative number.
      if (gLastDefendMissionTime < 0)
         gLastDefendMissionTime =
             xsGetTime() - 300000; // Actually, start defense ratings at 100% charge, i.e. 5 minutes since last one.


       if (civIsAfrican() != true)
      xsEnableRule("siegeWeaponMonitor");
	  
	  if (cMyCiv == cCivDEAmericans)
	xsEnableRule("churchUpgradeMonitorAmerican");  
      xsEnableRule("minorTribeTechMonitor");
      xsEnableRule("minorAsianTribeTechMonitor");

      // Enable summer palace tactic monitor for Chinese
      if (cMyCiv == cCivChinese)
         xsEnableRule("summerPalaceTacticMonitor");

      // Enable dojo tactic monitor for Japanese
      if (cMyCiv == cCivJapanese)
         xsEnableRule("dojoTacticMonitor");

      // Enable unique church upgrades
      if (civIsEuropean() == true)
         xsEnableRule("royalDecreeMonitor");

      // Enable mansabdar maintain plans for Indians
      if (cMyCiv == cCivIndians)
         xsEnableRule("mansabdarMonitor");

      // Enable daimyo maintain plans for Japanese
      if (cMyCiv == cCivJapanese)
         xsEnableRule("daimyoMonitor");

      aiEcho("*** We're in age 2.");
   }
}

//==============================================================================
// rule age3Monitor
/*
   Watch for us reaching age 3.
*/
//==============================================================================
rule age3Monitor
inactive
minInterval 10
{
   if (kbGetAge() >= cAge3)
   {
      aiEcho("*** We're in age 3.");
	  
	  

      // Bump up settler train plan
      updateSettlerCounts();
      /*if (cMyCiv == cCivChinese) {
        int planid = createSimpleResearchPlan(cTechypVillagePopCapIncrease2, getUnit(cUnitTypeypVillage),
      cEconomyEscrowID, 85); aiEcho("Creating plan #"+planid+" to get more popcap with tech
      "+kbGetTechName(cTechypVillagePopCapIncrease2)+" at the "+kbGetProtoUnitName(cUnitTypeypVillage));
      }*/

      xsDisableSelf();
      xsEnableRule("age4Monitor");
      gAgeUpTime = xsGetTime();
      gAgeUpPlanTime = 0;

      // kbBaseSetMaximumResourceDistance(cMyID, kbBaseGetMainID(cMyID), 80.0);

      // Increase number of towers to be built (even rushers start building now)
      if (civIsAsian() == false)
      {
         //gNumTowers = gNumTowers + 3;
         //if (gNumTowers > kbGetBuildLimit(cMyID, gTowerUnit))
            gNumTowers = kbGetBuildLimit(cMyID, gTowerUnit);
      }
      else
      {
         //gNumTowers = gNumTowers + 2;
         //if (gNumTowers > kbGetBuildLimit(cMyID, gTowerUnit))
            gNumTowers = kbGetBuildLimit(cMyID, gTowerUnit);
      }
		
		// Switch from war hut to nobles hut.
      if (cMyCiv == cCivXPAztec)
         gTowerUnit = cUnitTypeNoblesHut;
		
      // updateEscrows();

		if (cMyCiv == cCivDEInca)
		{
			xsEnableRule("strongholdConstructionMonitor");
			xsEnableRule("strongholdUpgradeMonitor");
			xsEnableRule("KanchaTacticMonitor");
		}

      // Enable Arsenal upgrades for Europeans and Japanese (Dutch Consulate Arsenal).
		if ((civIsEuropean() == true) || ((cMyCiv == cCivJapanese) || (cMyCiv == cCivSPCJapanese) || (cMyCiv == cCivSPCJapaneseEnemy)))
			xsEnableRule("arsenalUpgradeMonitor");
     
      // Enable minor tribe techs
      xsEnableRule("minorTribeTechMonitor");
      xsEnableRule("minorAsianTribeTechMonitor");

      // Enable agra fort upgrades for Indians
      if (cMyCiv == cCivIndians)
         xsEnableRule("agraFortUpgradeMonitor");

      // Enable summer palace tactic monitor for Chinese
      if (cMyCiv == cCivChinese)
         xsEnableRule("summerPalaceTacticMonitor");

      // Enable dojo tactic monitor for Japanese
      if (cMyCiv == cCivJapanese)
         xsEnableRule("dojoTacticMonitor");
		
		// Enable Golden Pavilion upgrades for Japanese (these are part of the advanced Arsenal rule).
      if (((cMyCiv == cCivJapanese) || (cMyCiv == cCivSPCJapanese) || (cMyCiv == cCivSPCJapaneseEnemy)) &&
			(kbUnitCount(cMyID, cUnitTypeypWJGoldenPavillion3, cUnitStateAlive) > 0))
				xsEnableRule("advancedArsenalUpgradeMonitor");

      // Enable basic church upgrades
      if (civIsEuropean() == true)
         xsEnableRule("churchUpgradeMonitor");

      // Enable unique church upgrades
      if (civIsEuropean() == true)
         xsEnableRule("royalDecreeMonitor");

      // Enable monastery techs
      xsEnableRule("monasteryMonitor");

      // Enable navy upgrades
      xsEnableRule("navyUpgradeMonitor");

      // Enable mansabdar maintain plans for Indians
      if (cMyCiv == cCivIndians)
         xsEnableRule("mansabdarMonitor");

      // Enable daimyo maintain plans for Japanese
      if (cMyCiv == cCivJapanese)
         xsEnableRule("daimyoMonitor");
			
		if (civIsAfrican() == true)
			updategAfricanAlliancesAgedUpWith();
   }
}

//==============================================================================
// rule age4Monitor
/*
   Watch for us reaching age 4.
*/
//==============================================================================
rule age4Monitor
inactive
minInterval 10
{
   if (kbGetAge() >= cAge4)
   {
      aiEcho("*** We're in age 4.");

      // Bump up settler train plan
      updateSettlerCounts();

      xsDisableSelf();
      xsEnableRule("age5Monitor");
      gAgeUpTime = xsGetTime();
      gAgeUpPlanTime = 0;

      // kbBaseSetMaximumResourceDistance(cMyID, kbBaseGetMainID(cMyID), 80.0);

      // Increase number of towers to be built (even rushers build as many as possible late in the game)
      if (civIsAsian() == false)
      {
         //gNumTowers = gNumTowers + 4;
         //if (gNumTowers > kbGetBuildLimit(cMyID, gTowerUnit))
            gNumTowers = kbGetBuildLimit(cMyID, gTowerUnit);
      }
      else
      {
         //gNumTowers = gNumTowers + 3;
         //if (gNumTowers > kbGetBuildLimit(cMyID, gTowerUnit))
            gNumTowers = kbGetBuildLimit(cMyID, gTowerUnit);
      }

      xsEnableRule("balloonMonitor");

      // Enable sacred field handling for Indians
      if (cMyCiv == cCivIndians)
         xsEnableRule("sacredFieldMonitor");

      // Enable Golden Pavilion upgrades for Japanese (these are part of the advanced Arsenal rule).
      if (((cMyCiv == cCivJapanese) || (cMyCiv == cCivSPCJapanese) || (cMyCiv == cCivSPCJapaneseEnemy)) &&
			(kbUnitCount(cMyID, cUnitTypeypWJGoldenPavillion4, cUnitStateAlive) > 0))
				xsEnableRule("advancedArsenalUpgradeMonitor");

      // Enable dojo upgrade for Japanese
      if (cMyCiv == cCivJapanese)
         xsEnableRule("dojoUpgradeMonitor");

      if (aiGetWorldDifficulty() >= cDifficultyModerate)
      { // Don't max out on upgrades on lower difficulty levels.

         // Enable shrine upgrade for Japanese
         if (cMyCiv == cCivJapanese)
            xsEnableRule("shrineUpgradeMonitor");

         if (aiGetWorldDifficulty() >= cDifficultyHard)
         {
            // Enable fort upgrade
            xsEnableRule("fortUpgradeMonitor");

            // Enable factory upgrades and production configuration
            xsEnableRule("factoryUpgradeMonitor");
            xsEnableRule("factoryTacticMonitor");
         }
      }
	  
	  
			xsEnableRule("brigadeMonitor");
		
		if (civIsAfrican() == true)
			updategAfricanAlliancesAgedUpWith();
	  if (civIsEuropean() == true)
		{
			gAbstractArtilleryUnit = cUnitTypexpHorseArtillery;
		}
   }
}

//==============================================================================
// rule age5Monitor
/*
   Watch for us reaching age 5.
*/
//==============================================================================
rule age5Monitor
inactive
minInterval 10
{
   if (kbGetAge() >= cAge5)
   {
      aiEcho("*** We're in age 5.");
      // Bump up settler train plan
      updateSettlerCounts();
		
		// Enable Golden Pavilion upgrades for Japanese (these are part of the advanced Arsenal rule).
      if (((cMyCiv == cCivJapanese) || (cMyCiv == cCivSPCJapanese) || (cMyCiv == cCivSPCJapaneseEnemy)) &&
			(kbUnitCount(cMyID, cUnitTypeypWJGoldenPavillion5, cUnitStateAlive) > 0))
				xsEnableRule("advancedArsenalUpgradeMonitor");
		
		if (civIsAfrican() == true)
			updategAfricanAlliancesAgedUpWith();
	
      xsDisableSelf();
      gAgeUpTime = xsGetTime();
      gAgeUpPlanTime = 0;
	  xsEnableRule("turtleUp");
	  
   if (gSPC == false)
		{
      xsEnableRule("autoFeedLowestAlly");
		}
		
      xsEnableRule("nativeUpgradeMonitor");
      xsEnableRule("capitolUpgradeMonitor");
      xsEnableRule("asianUpgradeMonitor");
   }
}

//==============================================================================
// rule startFishing
//==============================================================================
rule startFishing
inactive
group tcComplete
minInterval 15
{	
	aiEcho("startFishing rule running, gGoodFishingMap is: " + gGoodFishingMap + ", cvOkToFish is: " + cvOkToFish);
   if ((cvOkToFish == true) && (gGoodFishingMap == true))
   {
      //  Check to see if we have spotted a fish reasonably close to our water spawn flag.
      int flag = getUnit(cUnitTypeHomeCityWaterSpawnFlag, cMyID);
      if (flag >= 0)
      {
         static int fishQuery = -1;
         int fish = -1;
         int fishAreaGroup = -1;
         int flagAreaGroup = -1;

         flagAreaGroup = kbAreaGroupGetIDByPosition(kbUnitGetPosition(flag));

         if (fishQuery < 0)
         {
            fishQuery = kbUnitQueryCreate("fish query");
            kbUnitQuerySetIgnoreKnockedOutUnits(fishQuery, true);
            kbUnitQuerySetPlayerID(fishQuery, 0);
            kbUnitQuerySetUnitType(fishQuery, cUnitTypeAbstractFish);
            kbUnitQuerySetState(fishQuery, cUnitStateAny);
            kbUnitQuerySetPosition(fishQuery, kbUnitGetPosition(flag));
            kbUnitQuerySetMaximumDistance(fishQuery, 100.0);
            kbUnitQuerySetAscendingSort(fishQuery, true);
         }
         kbUnitQueryResetResults(fishQuery);
         if (kbUnitQueryExecute(fishQuery) > 0)
            fish = kbUnitQueryGetResult(fishQuery, 0); // Get the nearest fish.
         if (fish >= 0)
            fishAreaGroup = kbAreaGroupGetIDByPosition(kbUnitGetPosition(fish));
         if ((fish >= 0) && (fishAreaGroup == flagAreaGroup))
            aiEcho("Found fish # " + fish + " at " + kbUnitGetPosition(fish));
         else
         {
            aiEcho("No fish found near " + kbUnitGetPosition(flag));
            return; // No fish near enough, keep looking
         }
      } // else, no flag, so just go ahead.

      if (fish < 0)
         fish = getUnit(cUnitTypeAbstractFish, 0, cUnitStateAny); // need to have one fish visible

      if (fish < 0)
         return;

      aiEcho("*** Creating maintain plan for fishing boats.");
      gFishingBoatMaintainPlan = createSimpleMaintainPlan(gFishingUnit, 0, true, kbBaseGetMainID(cMyID), 1);

      createWaterExplorePlan();
		xsEnableRule("fishManager");
      xsDisableSelf();
   }
	// Normally, disable if we have the cv variable on false.
   // But if cvOkToFish is false, keep rule active in case it gets set to true later.
}

//==============================================================================
// rule fishManager
//
// Updates fishing boat maintain plan
//==============================================================================
rule fishManager
inactive
minInterval 30
{
   if (gTimeToFish == false)
   {
      // don't fish until age2 transition.
      if (kbGetAge() < cAge2 && agingUp() == false)
         return;
      static int randomizer = -1;
      if (randomizer < 0)
         randomizer = aiRandInt(10);
      if (btRushBoom <= 0.0 && randomizer < 3)
         gTimeToFish = true;
      else
         return;
   }

	if (kbUnitCount(cMyID, gDockUnit, cUnitStateAlive) < 1)
	{
		aiPlanSetVariableInt(gFishingBoatMaintainPlan, cTrainPlanNumberToMaintain, 0, 0);
		return;
	}

   static float maxDistance = 80.0;
   const int cMaxFishingBoats = 30;
   int numberFishingBoats = kbUnitCount(cMyID, gFishingUnit, cUnitStateABQ);
   int numberFoodFishingBoats =
       kbGetAmountValidResourcesByLocation(gNavyVec, cResourceFood, cAIResourceSubTypeFish, maxDistance) / 400.0;
   int numberGoldFishingBoats =
       getUnitCountByLocation(cUnitTypeAbstractWhale, 0, cUnitStateAny, gNavyVec, maxDistance) * 4;

   if (numberFishingBoats > numberFoodFishingBoats || numberFishingBoats > numberGoldFishingBoats)
   {
      maxDistance = maxDistance + 30.0;
      return;
   }

   if (numberFishingBoats < numberFoodFishingBoats)
      numberFishingBoats = numberFoodFishingBoats;
   if (numberFishingBoats < numberGoldFishingBoats)
      numberFishingBoats = numberGoldFishingBoats;
   if (numberFishingBoats > cMaxFishingBoats)
      numberFishingBoats = cMaxFishingBoats;

   int fishingBoatQuery = createSimpleUnitQuery(gFishingUnit, cMyID, cUnitStateAlive);
   kbUnitQuerySetActionType(fishingBoatQuery, cActionTypeIdle);
   int numberFound = kbUnitQueryExecute(fishingBoatQuery);
	
   if (numberFound > 1)
      numberFishingBoats = 0;

	if ((gStartOnDifferentIslands == true) && (numberFishingBoats < 1))
   {
      numberFishingBoats = 1; // Train at least 1 Fishing Boat these maps to explore.
   }

   aiPlanSetVariableInt(gFishingBoatMaintainPlan, cTrainPlanNumberToMaintain, 0, numberFishingBoats);
   aiPlanSetDesiredResourcePriority(gFishingBoatMaintainPlan, 70);
}

//==============================================================================
// rule repairManager
//==============================================================================
rule repairManager
inactive
group tcComplete
minInterval 20
{
   if (aiGetWorldDifficulty() < cDifficultyModerate)
   {
      xsDisableSelf();
      return;
   }

   if (aiPlanGetIDByIndex(cPlanRepair, -1, true, 0) < 0)
      createRepairPlan(50);
}

//==============================================================================
// getNumberPlanGatherers
//==============================================================================
int getNumberPlanGatherers(int resource = cResourceGold, int subType = cAIResourceSubTypeEasy)
{
   int numPlans = aiPlanGetActiveCount();
   int count = 0;

   for (i = 0; < numPlans)
   {
      int planID = aiPlanGetIDByActiveIndex(i);
      if (aiPlanGetType(planID) != cPlanGather)
         continue;
      if (aiPlanGetVariableInt(planID, cGatherPlanResourceType, 0) != resource ||
          aiPlanGetVariableInt(planID, cGatherPlanResourceSubType, 0) != subType)
         continue;
      count = count + aiPlanGetNumberWantedUnits(planID);
   }

   return (count);
}

//==============================================================================
// addMillBuildPlan
//==============================================================================
void addMillBuildPlan(void)
{
   bool tacticFarm = (gFarmUnit == cUnitTypeypRicePaddy || gFarmUnit == cUnitTypedeField);
   int numberToBuild = 1;

   if (gFarmUnit == cUnitTypedeField)
      numberToBuild = 4;

   if (aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, gFarmUnit) >= 0)
      return;

   if (tacticFarm == true)
   {
      // We have enough Rice Paddies / Fields.
      if (kbUnitCount(cMyID, gEconUnit, cUnitStateABQ) <
          (kbUnitCount(cMyID, gFarmUnit, cUnitStateABQ) - 1) * cMaxSettlersPerFarm)
         return;
   }
   else
   {
      // We have enough Mills.
      if (kbUnitCount(cMyID, gEconUnit, cUnitStateABQ) <
          kbUnitCount(cMyID, gFarmUnit, cUnitStateABQ) * cMaxSettlersPerFarm)
         return;
   }

   createSimpleBuildPlan(gFarmUnit, numberToBuild, 70, true, cEconomyEscrowID, kbBaseGetMainID(cMyID), 1);
}

//==============================================================================
// addPlantationBuildPlan
//==============================================================================
void addPlantationBuildPlan(void)
{
   bool tacticFarm = (gPlantationUnit == cUnitTypeypRicePaddy || gPlantationUnit == cUnitTypedeField);
   int numberToBuild = 1;

   if (gPlantationUnit == cUnitTypedeField)
      numberToBuild = 4;

      if (aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, gPlantationUnit) >= 0)
         return;

   if (tacticFarm == true)
   {
      // we have enough rice paddies
      if (kbUnitCount(cMyID, gEconUnit, cUnitStateABQ) <
          (kbUnitCount(cMyID, gPlantationUnit, cUnitStateABQ) - 1) * cMaxSettlersPerPlantation)
         return;
   }
   else
   {
      // we have enough plantations
      if (kbUnitCount(cMyID, gEconUnit, cUnitStateABQ) <
          kbUnitCount(cMyID, gPlantationUnit, cUnitStateABQ) * cMaxSettlersPerPlantation)
         return;
   }

   createSimpleBuildPlan(gPlantationUnit, numberToBuild, 70, true, cEconomyEscrowID, kbBaseGetMainID(cMyID), 1);
}


// TO DO rename to Tribal Marketplace.
//==============================================================================
// addTradingLodgeBuildPlan
//==============================================================================
void addTradingLodgeBuildPlan(void)
{
   if (aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypedeFurTrade) >= 0)
      return;

   int buildPlanID =
       createSimpleBuildPlan(cUnitTypedeFurTrade, 1, 70, true, cEconomyEscrowID, kbBaseGetMainID(cMyID), 1);
   aiPlanSetDesiredResourcePriority(buildPlanID,
                                    60); // above average but below villager production.
}

//==============================================================================
// removeMillBuildPlan
//==============================================================================
void removeMillBuildPlan(void)
{
   bool tacticFarm = (gFarmUnit == cUnitTypeypRicePaddy || gFarmUnit == cUnitTypedeField);
   int numberToBuild = 1;

   if (gFarmUnit == cUnitTypedeField)
      numberToBuild = 4;

      if (aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, gFarmUnit) >= 0)
         return;

   int planID = -1;
   int numPlans = 0;

   if (numberToBuild == 1)
   {
      planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, gFarmUnit);
      if (planID >= 0 && aiPlanGetState(planID) != cPlanStateBuild)
         aiPlanDestroy(planID);
   }
   else
   {
      numPlans = aiPlanGetActiveCount();
      for (i = 0; < numPlans)
      {
         planID = aiPlanGetIDByActiveIndex(i);
         if (aiPlanGetType(planID) != cPlanBuild || aiPlanGetState(planID) == cPlanStateBuild)
            continue;
         if (aiPlanGetVariableInt(planID, cBuildPlanBuildingTypeID, 0) != gFarmUnit)
            continue;
         aiPlanDestroy(planID);
      }
   }
}

//==============================================================================
// removePlantationBuildPlan
//==============================================================================
void removePlantationBuildPlan(void)
{
   bool tacticFarm = (gPlantationUnit == cUnitTypeypRicePaddy || gPlantationUnit == cUnitTypedeField);
   int numberToBuild = 1;

   if (gPlantationUnit == cUnitTypedeField)
      numberToBuild = 4;

   if (aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, gPlantationUnit) >= 0)
         return;

   int planID = -1;
   int numPlans = 0;

   if (numberToBuild == 1)
   {
      planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, gPlantationUnit);
      if (planID >= 0 && aiPlanGetState(planID) != cPlanStateBuild)
         aiPlanDestroy(planID);
      }
   else
   {
      numPlans = aiPlanGetActiveCount();
      for (i = 0; < numPlans)
      {
         planID = aiPlanGetIDByActiveIndex(i);
         if (aiPlanGetType(planID) != cPlanBuild || aiPlanGetState(planID) == cPlanStateBuild)
            continue;
         if (aiPlanGetVariableInt(planID, cBuildPlanBuildingTypeID, 0) != gPlantationUnit)
            continue;
         aiPlanDestroy(planID);
      }
   }
}

//==============================================================================
// getNumberIdleVillagers
//
// Get number of idle villagers without a plan.
//==============================================================================
int getNumberIdleVillagers(bool reset = true)
{
   int villagerQuery = createSimpleUnitQuery(gEconUnit, cMyID, cUnitStateAlive);
   kbUnitQuerySetActionType(villagerQuery, cActionTypeIdle);
   int numberFound = kbUnitQueryExecute(villagerQuery);
   static int numberIdleVillagers = 0;

   if (reset == true)
   {
      for (i = 0; < numberFound)
      {
         int unitID = kbUnitQueryGetResult(villagerQuery, i);
         if (kbUnitGetPlanID(unitID) >= 0)
            continue;
         numberIdleVillagers = numberIdleVillagers + 1;
      }
   }

   return (numberIdleVillagers);
}

//==============================================================================
// updateFoodBreakdown
//==============================================================================
void updateFoodBreakdown()
{
   // Return when we run out of attempts
   // We still need to update when there are idle villagers to assign them to new gather plans.
   int attempts = xsArrayGetInt(gAdjustBreakdownAttempts, cResourceFood);
   if (attempts <= 0)
   {
      if (getNumberIdleVillagers(true) < 3)
         return;
   }
   else
   {
      xsArraySetInt(gAdjustBreakdownAttempts, cResourceFood, attempts - 1);
   }

   int numberMills = 0;

   if ((civIsAfrican() == true) || (civIsAsian() == true))
   {
		numberMills = getUnitCountByTactic(gFarmUnit, cMyID, cUnitStateAlive, civIsAfrican() == true ? cTacticFieldFood : cTacticPaddyFood);
   }
   else
   {
      numberMills = kbUnitCount(cMyID, gFarmUnit, cUnitStateAlive);
   }

   // Get an estimate for the number of food gatherers.
   // Figure out how many mill plans that should be, and how many villagers will be farming.
   // Look at how many hunt plans we'd have, and see if that's a reasonable number.

   int numFarmGatherers = getNumberPlanGatherers(cResourceFood, cAIResourceSubTypeFarm);
   int numHuntBerryGatherers = getNumberPlanGatherers(cResourceFood, cAIResourceSubTypeHunt) +
                               getNumberPlanGatherers(cResourceFood, cAIResourceSubTypeEasy);
   float foodPercentage = aiGetResourcePercentage(cResourceFood);
   float actualFoodPercentage = aiGetActualResourcePercentage(cResourceFood);
   // Can we max out the farms?
   if ((foodPercentage > 0.0 || actualFoodPercentage > 0.0) &&
    (numFarmGatherers >= (numberMills * cMaxSettlersPerFarm) || (numFarmGatherers >= (numberMills * cMaxSettlersPerFarm - 3) && numHuntBerryGatherers > 0)))
   {
      if (gTimeToFarm == true)
         addMillBuildPlan(); // If we don't have enough mills, and we need to farm, and we're not building one, build
                             // one.
   }
   else
   {
      // We can't fill the farms
      if (foodPercentage == 0.0)
      removeMillBuildPlan();
   }

   if (cvOkToGatherFood == false)
   {
      gGatherPlanNumHuntPlans = 0;
      gGatherPlanNumBerryPlans = 0;
      gGatherPlanNumMillPlans = 0;
      gGatherPlanNumFishPlans = 0;
   }
   else
   {
      // Anything greater than 0 means we allow gatherers on the associated resource breakdown.
      gGatherPlanNumHuntPlans = 1;
      gGatherPlanNumBerryPlans = 1;
      gGatherPlanNumMillPlans = 1;
      if (kbUnitCount(cMyID, cUnitTypeAbstractFishingBoat, cUnitStateABQ) > 0)
         gGatherPlanNumFishPlans = 1;
   else
         gGatherPlanNumFishPlans = 0;
   }
}

//==============================================================================
// updateWoodBreakdown
//==============================================================================
void updateWoodBreakdown()
{
   // Don't create resource breakdowns for invalid bases.
   int mainBaseID = kbBaseGetMainID(cMyID);
   if (mainBaseID < 0)
      return;

   // Return when we run out of attempts
   // We still need to update when there are idle villagers to assign them to new gather plans.
   int attempts = xsArrayGetInt(gAdjustBreakdownAttempts, cResourceWood);
   int numberIdleVillagers = getNumberIdleVillagers(false);
   if (attempts <= 0)
   {
      if (numberIdleVillagers < 3)
         return;
   }
   else
   {
      xsArraySetInt(gAdjustBreakdownAttempts, cResourceWood, attempts - 1);
   }

   if (cvOkToGatherWood == false || gDisableWoods == true)
   {
      gGatherPlanNumWoodPlans = 0;
   }
      else
   {
      // Anything greater than 0 means we allow gatherers on the associated resource breakdown.
      gGatherPlanNumWoodPlans = 1;
   }
}

//==============================================================================
// updateGoldBreakdown
//==============================================================================
void updateGoldBreakdown()
{
   // Don't create resource breakdowns for invalid bases.
   int mainBaseID = kbBaseGetMainID(cMyID);
   if (mainBaseID < 0)
      return;

   // Return when we run out of attempts
   // We still need to update when there are idle villagers to assign them to new gather plans.
   int attempts = xsArrayGetInt(gAdjustBreakdownAttempts, cResourceGold);
   if (attempts <= 0)
   {
      if (getNumberIdleVillagers(false) < 3)
         return;
   }
   else
   {
      xsArraySetInt(gAdjustBreakdownAttempts, cResourceGold, attempts - 1);
   }

   int numberPlants = 0;
   int numGoldGatherers = aiGetNumberDesiredGatherers(cResourceGold);
   int numPlantGatherers = getNumberPlanGatherers(cResourceGold, cAIResourceSubTypeFarm);
   int numMineGatherers = getNumberPlanGatherers(cResourceGold, cAIResourceSubTypeEasy);
   // We didn't supply enough plans to get the desired resource percentage.
   float goldPercentage = aiGetResourcePercentage(cResourceGold);
   float actualGoldPercentage = aiGetActualResourcePercentage(cResourceGold);
	
	if ((civIsAfrican() == true) || (civIsAsian() == true))
   {
		numberPlants = getUnitCountByTactic(gPlantationUnit, cMyID, cUnitStateAlive, civIsAfrican() == true ? cTacticFieldCoin : cTacticPaddyCoin);
   }
   else
   {
      numberPlants = kbUnitCount(cMyID, gPlantationUnit, cUnitStateAlive);
   }

   if ((goldPercentage > 0.0 || actualGoldPercentage > 0.0) &&
    (numPlantGatherers >= (numberPlants * cMaxSettlersPerPlantation) || (numPlantGatherers >= (numberPlants * cMaxSettlersPerPlantation - 3) && numMineGatherers > 0)))// Can we max out the farms?
   {
      if (gTimeForPlantations == true)
         addPlantationBuildPlan(); // If we don't have enough plantations, and we need to farm, and we're not building
                                   // one, build one.
   }
   else
   { // We can't fill the farms
      if (goldPercentage == 0.0)
      removePlantationBuildPlan();
   }

      if (cMyCiv == cCivXPIroquois || cMyCiv == cCivXPSioux)
      {
      int numTradingLodges = kbUnitCount(cMyID, cUnitTypedeFurTrade, cUnitStateABQ);
      const int cMaxSettlersPerTradingLodge = 10;
      if ((goldPercentage > 0.0 || actualGoldPercentage > 0.0) &&
         (numTradingLodges == 0 || numMineGatherers >= (numTradingLodges * cMaxSettlersPerTradingLodge - 5)))
      {
            addTradingLodgeBuildPlan();
      }
   }

   if (cvOkToGatherGold == false)
   {
      gGatherPlanNumMinePlans = 0;
      gGatherPlanNumEstatePlans = 0;
      gGatherPlanNumWhalePlans = 0;
   }
   else
   {
      // Anything greater than 0 means we allow gatherers on the associated resource breakdown.
      gGatherPlanNumMinePlans = 1;
      gGatherPlanNumEstatePlans = 1;
      if (kbUnitCount(cMyID, cUnitTypeAbstractFishingBoat, cUnitStateABQ) > 0)
         gGatherPlanNumWhalePlans = 1;
      else
         gGatherPlanNumWhalePlans = 0;
   }
}

rule updateResourceBreakdowns
inactive
group tcComplete
minInterval 29
{
   static int executionCount = 0;
   int mainBaseID = kbBaseGetMainID(cMyID);

   switch (executionCount)
   {
   case 0:
   {
      updateFoodBreakdown();
      xsSetRuleMinIntervalSelf(1);
      break;
   }
   case 1:
   {
      updateWoodBreakdown();
      break;
   }
   case 2:
   {
      updateGoldBreakdown();
      xsSetRuleMinIntervalSelf(29);

      // Update resource breakdowns in one go to reduce chance villagers move around in a short timespan.
      if (mainBaseID >= 0)
      {
         // food
         aiSetResourceBreakdown(cResourceFood, cAIResourceSubTypeEasy, gGatherPlanNumBerryPlans,
                                gGatherPlanPriorityBerry, 1.0, mainBaseID);
         aiSetResourceBreakdown(cResourceFood, cAIResourceSubTypeHunt, gGatherPlanNumHuntPlans, gGatherPlanPriorityHunt,
                                1.0, mainBaseID);
         aiSetResourceBreakdown(cResourceFood, cAIResourceSubTypeFarm, gGatherPlanNumMillPlans, gGatherPlanPriorityMill,
                                1.0, mainBaseID, 999.0);
         aiSetResourceBreakdown(cResourceFood, cAIResourceSubTypeFish, gGatherPlanNumFishPlans, gGatherPlanPriorityFish,
                                1.0, mainBaseID, 999.0);

         // wood
         aiSetResourceBreakdown(cResourceWood, cAIResourceSubTypeEasy, gGatherPlanNumWoodPlans, gGatherPlanPriorityWood,
                                1.0, mainBaseID);

         // gold
         aiSetResourceBreakdown(cResourceGold, cAIResourceSubTypeEasy, gGatherPlanNumMinePlans, gGatherPlanPriorityMine,
                                1.0, mainBaseID);
         aiSetResourceBreakdown(cResourceGold, cAIResourceSubTypeFarm, gGatherPlanNumEstatePlans,
                                gGatherPlanPriorityEstate, 1.0, mainBaseID, 999.0);
         aiSetResourceBreakdown(cResourceGold, cAIResourceSubTypeFish, gGatherPlanNumWhalePlans,
                                gGatherPlanPriorityWhale, 1.0, mainBaseID, 999.0);
      }
      break;
   }
   }

   executionCount = (executionCount + 1) % 3;
}

//==============================================================================
// initGatherGoal()
//==============================================================================
int initGatherGoal()
{
   /* Create the gather goal, return its handle.  The gather goal stores the key data for controlling
      gatherer distribution.
   */
   int planID = aiPlanCreate("GatherGoals", cPlanGatherGoal);

   if (planID >= 0)
   {
      // Overall percentages.
      aiPlanSetDesiredPriority(planID, 90);
      // Set the RGP weights.  Script in charge.
      aiSetResourceGathererPercentageWeight(cRGPScript, 0.5); // Portion driven by forecast
      aiSetResourceGathererPercentageWeight(cRGPCost, 0.5);   // Portion driven by exchange rates

      // Set the gather goal to reflect those settings (Gather goal values are informational only to simplify
      // debugging.) Set the gather goal to reflect those settings (Gather goal values are informational only to
      // simplify debugging.)
      aiPlanSetVariableFloat(planID, cGatherGoalPlanScriptRPGPct, 0, 1.0);
      aiPlanSetVariableFloat(planID, cGatherGoalPlanCostRPGPct, 0, 1.0);

      aiPlanSetNumberVariableValues(planID, cGatherGoalPlanGathererPct, cNumResourceTypes, true);
      // Set initial gatherer assignments.
      aiPlanSetVariableFloat(planID, cGatherGoalPlanGathererPct, cResourceGold, 0.0);
      aiPlanSetVariableFloat(planID, cGatherGoalPlanGathererPct, cResourceWood, 0.2);
      aiPlanSetVariableFloat(planID, cGatherGoalPlanGathererPct, cResourceFood, 0.8);
      /*
            if (cMyCiv == cCivFrench)
            {
               aiPlanSetVariableFloat(planID, cGatherGoalPlanGathererPct, cResourceWood, 0.6);
               aiPlanSetVariableFloat(planID, cGatherGoalPlanGathererPct, cResourceFood, 0.4);
            }
      */
      // Standard resource breakdown setup, all easy at the start.
      aiPlanSetNumberVariableValues(planID, cGatherGoalPlanNumFoodPlans, 5, true);
      if ((cMyCiv != cCivJapanese) && (cMyCiv != cCivSPCJapanese) && (cMyCiv != cCivSPCJapaneseEnemy))
      {
         aiPlanSetVariableInt(planID, cGatherGoalPlanNumFoodPlans, cAIResourceSubTypeHunt, 1);
      }
      else
      {
         aiPlanSetVariableInt(planID, cGatherGoalPlanNumFoodPlans, cAIResourceSubTypeEasy, 1);
      }
      aiPlanSetVariableInt(planID, cGatherGoalPlanNumFoodPlans, cAIResourceSubTypeHerdable, 0);
      aiPlanSetVariableInt(planID, cGatherGoalPlanNumFoodPlans, cAIResourceSubTypeHunt, 0);
      aiPlanSetVariableInt(planID, cGatherGoalPlanNumFoodPlans, cAIResourceSubTypeHuntAggressive, 0);
      aiPlanSetVariableInt(planID, cGatherGoalPlanNumFoodPlans, cAIResourceSubTypeFarm, 0);
      aiPlanSetVariableInt(planID, cGatherGoalPlanNumFoodPlans, cAIResourceSubTypeFish, 0);
      aiPlanSetVariableInt(planID, cGatherGoalPlanNumWoodPlans, cAIResourceSubTypeEasy, 1);
      aiPlanSetVariableInt(planID, cGatherGoalPlanNumGoldPlans, cAIResourceSubTypeEasy, 1);

      // Cost weights...set the convenience copies in the gather goal first, then the real ones next.
      aiPlanSetNumberVariableValues(planID, cGatherGoalPlanResourceCostWeight, cNumResourceTypes, true);
      aiPlanSetVariableFloat(planID, cGatherGoalPlanResourceCostWeight, cResourceGold, 1.0); // Gold is the standard
      aiPlanSetVariableFloat(planID, cGatherGoalPlanResourceCostWeight, cResourceWood,
                             1.2); // Start at 1.2, since wood is harder to collect
      aiPlanSetVariableFloat(planID, cGatherGoalPlanResourceCostWeight, cResourceFood,
                             1.0); // Premium for food, or 1.0?

      // Setup AI Cost weights.  This makes it actually work, the calls above just set the convenience copy in the
      // gather goal.
      kbSetAICostWeight(cResourceFood,
                        aiPlanGetVariableFloat(planID, cGatherGoalPlanResourceCostWeight, cResourceFood));
      kbSetAICostWeight(cResourceWood,
                        aiPlanGetVariableFloat(planID, cGatherGoalPlanResourceCostWeight, cResourceWood));
      kbSetAICostWeight(cResourceGold,
                        aiPlanGetVariableFloat(planID, cGatherGoalPlanResourceCostWeight, cResourceGold));

      // Set initial gatherer percentages.
      aiSetResourcePercentage(cResourceFood, false, 1.0);
      aiSetResourcePercentage(cResourceWood, false, 0.0);
      aiSetResourcePercentage(cResourceGold, false, 0.0);

      if (cMyCiv == cCivDutch)
      {
         aiSetResourcePercentage(cResourceFood, false, 0.0);
         aiSetResourcePercentage(cResourceGold, false, 1.0);
      }
      else if (cMyCiv == cCivIndians)
      {
         aiSetResourcePercentage(cResourceFood, false, 0.0);
         aiSetResourcePercentage(cResourceWood, false, 1.0);
      }

      // Set up the initial resource breakdowns.
      int numFoodEasyPlans = aiPlanGetVariableInt(planID, cGatherGoalPlanNumFoodPlans, cAIResourceSubTypeEasy);
      int numFoodHuntPlans = aiPlanGetVariableInt(planID, cGatherGoalPlanNumFoodPlans, cAIResourceSubTypeHunt);
      int numFoodHerdablePlans = aiPlanGetVariableInt(planID, cGatherGoalPlanNumFoodPlans, cAIResourceSubTypeHerdable);
      int numFoodHuntAggressivePlans =
          aiPlanGetVariableInt(planID, cGatherGoalPlanNumFoodPlans, cAIResourceSubTypeHuntAggressive);
      int numFishPlans = aiPlanGetVariableInt(planID, cGatherGoalPlanNumFoodPlans, cAIResourceSubTypeFish);
      int numFarmPlans = aiPlanGetVariableInt(planID, cGatherGoalPlanNumFoodPlans, cAIResourceSubTypeFarm);
      int numWoodPlans = aiPlanGetVariableInt(planID, cGatherGoalPlanNumWoodPlans, cAIResourceSubTypeEasy);
      int numGoldPlans = aiPlanGetVariableInt(planID, cGatherGoalPlanNumGoldPlans, cAIResourceSubTypeEasy);

      if ((kbBaseGetMainID(cMyID) >= 0)) // Don't bother if we don't have a main base
      {
         if (cvOkToGatherFood == true)
         {
            if ((cMyCiv != cCivJapanese) && (cMyCiv != cCivSPCJapanese) && (cMyCiv != cCivSPCJapaneseEnemy))
            {
               aiSetResourceBreakdown(cResourceFood, cAIResourceSubTypeEasy, 0, 49, 1.0,
                                      kbBaseGetMainID(cMyID)); // All on easy hunting food at start
               aiSetResourceBreakdown(cResourceFood, cAIResourceSubTypeHunt, numFoodHuntPlans, 49, 1.0,
                                      kbBaseGetMainID(cMyID)); // All on easy hunting food at start
            }
            else
            {
               aiSetResourceBreakdown(cResourceFood, cAIResourceSubTypeEasy, numFoodEasyPlans, 49, 1.0,
                                      kbBaseGetMainID(cMyID)); // All on easy food at start
            }
            /*if ((cMyCiv != cCivIndians) && (cMyCiv != cCivSPCIndians) && (cMyCiv != cCivJapanese) && (cMyCiv !=
            cCivSPCJapanese) && (cMyCiv != cCivSPCJapaneseEnemy))
            {
               aiSetResourceBreakdown(cResourceFood, cAIResourceSubTypeHerdable, numFoodHerdablePlans, 24, 1.0,
            kbBaseGetMainID(cMyID));
            }*/
            aiSetResourceBreakdown(cResourceFood, cAIResourceSubTypeHerdable, numFoodHerdablePlans, 24, 0.0,
                                   kbBaseGetMainID(cMyID));
            aiSetResourceBreakdown(cResourceFood, cAIResourceSubTypeHuntAggressive, numFoodHuntAggressivePlans, 49, 0.0,
                                   kbBaseGetMainID(cMyID));
            aiSetResourceBreakdown(cResourceFood, cAIResourceSubTypeFish, numFishPlans, 49, 0.0,
                                   kbBaseGetMainID(cMyID));
            aiSetResourceBreakdown(cResourceFood, cAIResourceSubTypeFarm, numFarmPlans, 51, 0.0,
                                   kbBaseGetMainID(cMyID));
            // if ((cMyCiv == cCivJapanese) || (cMyCiv == cCivSPCJapanese) || (cMyCiv == cCivSPCJapaneseEnemy))
            //{
            //   aiSetResourceBreakdown(cResourceFood, cAIResourceSubTypeFarm, numFarmPlans, 51, 1.0,
            //   kbBaseGetMainID(cMyID));
            //}
         }
         if (cvOkToGatherWood == true)
            aiSetResourceBreakdown(cResourceWood, cAIResourceSubTypeEasy, numWoodPlans, 50, 1.0,
                                   kbBaseGetMainID(cMyID));
         if (cvOkToGatherGold == true)
            aiSetResourceBreakdown(cResourceGold, cAIResourceSubTypeEasy, numGoldPlans, 55, 1.0,
                                   kbBaseGetMainID(cMyID));
      }
   }
   return (planID);
}

//==============================================================================
// initResourceBreakdowns()
//==============================================================================
void initResourceBreakdowns()
{
   // Set initial gatherer percentages.
   aiSetResourcePercentage(cResourceFood, false, 1.0);
   aiSetResourcePercentage(cResourceWood, false, 0.0);
   aiSetResourcePercentage(cResourceGold, false, 0.0);

   if (cMyCiv == cCivDutch)
   {
      aiSetResourcePercentage(cResourceFood, false, 0.0);
      aiSetResourcePercentage(cResourceGold, false, 1.0);
   }
   else if (cMyCiv == cCivIndians)
   {
      aiSetResourcePercentage(cResourceFood, false, 0.0);
      aiSetResourcePercentage(cResourceWood, false, 1.0);
   }

   // Set up the initial resource breakdowns.
   int mainBaseID = kbBaseGetMainID(cMyID);
   bool hasFishingBoats = kbUnitCount(cMyID, cUnitTypeAbstractFishingBoat, cUnitStateAlive) > 0;

   if (mainBaseID >= 0) // Don't bother if we don't have a main base
   {
      if (cvOkToGatherFood == true)
      {
         if ((cMyCiv != cCivJapanese) && (cMyCiv != cCivSPCJapanese) && (cMyCiv != cCivSPCJapaneseEnemy))
         {
            aiSetResourceBreakdown(cResourceFood, cAIResourceSubTypeEasy, 0, 49, 1.0,
                                   mainBaseID); // All on easy hunting food at start
            aiSetResourceBreakdown(cResourceFood, cAIResourceSubTypeHunt, 1, 49, 1.0,
                                   mainBaseID); // All on easy hunting food at start
         }
         else
         {
            aiSetResourceBreakdown(cResourceFood, cAIResourceSubTypeEasy, 1, 49, 1.0,
                                   mainBaseID); // All on easy food at start
            aiSetResourceBreakdown(cResourceFood, cAIResourceSubTypeHunt, 0, 49, 1.0, mainBaseID);
         }
         aiSetResourceBreakdown(cResourceFood, cAIResourceSubTypeHerdable, 0, 24, 0.0, mainBaseID);
         aiSetResourceBreakdown(cResourceFood, cAIResourceSubTypeHuntAggressive, 0, 49, 0.0, mainBaseID);
         if (hasFishingBoats == true)
            aiSetResourceBreakdown(cResourceFood, cAIResourceSubTypeFish, 1, 49, 0.0, mainBaseID);
         else
            aiSetResourceBreakdown(cResourceFood, cAIResourceSubTypeFish, 0, 49, 0.0, mainBaseID);
         aiSetResourceBreakdown(cResourceFood, cAIResourceSubTypeFarm, 0, 51, 0.0, mainBaseID);
      }
      if (cvOkToGatherWood == true)
         aiSetResourceBreakdown(cResourceWood, cAIResourceSubTypeEasy, 1, 50, 1.0, mainBaseID);
      if (cvOkToGatherGold == true)
      {
         aiSetResourceBreakdown(cResourceGold, cAIResourceSubTypeEasy, 1, 55, 1.0, mainBaseID);
         if (hasFishingBoats == true)
            aiSetResourceBreakdown(cResourceGold, cAIResourceSubTypeFish, 1, 49, 0.0, mainBaseID);
         else
            aiSetResourceBreakdown(cResourceGold, cAIResourceSubTypeFish, 0, 49, 0.0, mainBaseID);
      }
   }

   // create crate plan too.
	if (civIsAfrican() == false)
		crateMonitor();
}

//==============================================================================
// initResourceBreakdownsDelay
//
// Delay resource breakdowns until cherry orchard is built
//==============================================================================
rule initResourceBreakdownsDelay
inactive
highFrequency
{
   if (kbUnitCount(cMyID, cUnitTypeypBerryBuilding, cUnitStateAlive) < 1)
      return;
   initResourceBreakdowns();
   xsDisableSelf();
}

rule earlySlaughterMonitor
inactive
minInterval 1
{
   int cattleID = -1;
   
   if (cattleID < 0)
   {
      vector loc = kbUnitGetPosition(getUnit(cUnitTypeTownCenter));
      cattleID = getUnitByLocation(cUnitTypedeAutoSangaCattle, cPlayerRelationAny, cUnitStateAny, loc, 10.0);
      if (cattleID < 0)
         cattleID = getUnitByLocation(cUnitTypedeAutoZebuCattle, cPlayerRelationAny, cUnitStateAny, loc, 10.0);
   }

   static int planID = -1;

   if (planID < 0)
   {
      planID = aiPlanCreate("Early cattle slaughter plan", cPlanReserve);
      aiPlanAddUnitType(planID, gEconUnit, 5, 5, 5);
      aiPlanSetDesiredPriority(planID, 95);
      aiPlanSetActive(planID);
   }

   if (cattleID < 0 || kbUnitGetPosition(cattleID) == cInvalidVector)
   {
      aiPlanDestroy(planID);
      xsDisableSelf();
   }
   else
   {
      for (i = 0; < 5)
      {
         int workerUnitID = aiPlanGetUnitByIndex(planID, i);
         aiTaskUnitWork(workerUnitID, cattleID);
      }
   }
}

//==============================================================================
// updateEconSiteList
/*
   Scan all potential econ bases that aren't being used.   Sort them into a
   rational order of planned use, considering size, proximity to each other,
   security, etc.
*/
//==============================================================================
void updateEconSiteList(void) {}

//==============================================================================
// initEcon
/*
   Called when the initial units have disembarked.  Sets up initial economy.
*/
//==============================================================================
void initEcon(void)
{
   if (cMyCiv == cCivFrench)
      gEconUnit = cUnitTypeCoureur;

   if ((cMyCiv == cCivXPIroquois) || (cMyCiv == cCivXPSioux) || (cMyCiv == cCivXPAztec) || (cMyCiv == cCivDEInca))
      gEconUnit = cUnitTypeSettlerNative;

   if (cMyCiv == cCivRussians)
      gTowerUnit = cUnitTypeBlockhouse;

   if (civIsAsian() == true)
   {
      gEconUnit = cUnitTypeypSettlerAsian;

      gTowerUnit = cUnitTypeypCastle;
      gFarmUnit = cUnitTypeypRicePaddy;
      gPlantationUnit = cUnitTypeypRicePaddy;

      gMarketUnit = cUnitTypeypTradeMarketAsian;
      gDockUnit = cUnitTypeYPDockAsian;

      cvOkToBuildForts = false;

      gFishingUnit = cUnitTypeypFishingBoatAsian;
   }

   if (civIsAfrican() == true)
   {
      gEconUnit = cUnitTypedeSettlerAfrican;
      gHouseUnit = cUnitTypedeHouseAfrican;

      gTowerUnit = cUnitTypedeTower;
      gFarmUnit = cUnitTypedeField;
      gPlantationUnit = cUnitTypedeField;

      gMarketUnit = cUnitTypedeLivestockMarket;
      gDockUnit = cUnitTypedePort;
      gLivestockPenUnit = cUnitTypedeLivestockMarket;

      gFishingUnit = cUnitTypedeFishingBoatAfrican;
      gCaravelUnit = cUnitTypedeBattleCanoe;
      if (cMyCiv == cCivDEEthiopians)
         gFrigateUnit = cUnitTypedeMercDhow;
      else if (cMyCiv == cCivDEHausa)
         gFrigateUnit = cUnitTypedeMercXebec;
      gMonitorUnit = cUnitTypedeCannonBoat;

      cMaxSettlersPerFarm = 3;
      cMaxSettlersPerPlantation = 3;
   }

   if ((cMyCiv == cCivXPAztec) || (cMyCiv == cCivXPIroquois) || (cMyCiv == cCivXPSioux) || (cMyCiv == cCivDEInca))
   {
      gTowerUnit = cUnitTypeWarHut;
      gFarmUnit = cUnitTypeFarm;
   }

   if (cMyCiv == cCivXPSioux)
      gTowerUnit = cUnitTypeTeepee;

   if (cMyCiv == cCivOttomans)
      gCaravelUnit = cUnitTypeGalley;

	if (civIsNative() == true)
		gCaravelUnit = cMyCiv == cCivDEInca ? cUnitTypedeChinchaRaft : cUnitTypexpWarCanoe;

   if (cMyCiv == cCivXPAztec || cMyCiv == cCivXPIroquois || cMyCiv == cCivXPSioux)
      gGalleonUnit = cUnitTypeCanoe;

   if (cMyCiv == cCivXPAztec)
      gFrigateUnit = cUnitTypexpTlalocCanoe;

   if (cMyCiv == cCivDutch)
      gGalleonUnit = cUnitTypeFluyt;

   if ((cMyCiv == cCivChinese) || (cMyCiv == cCivSPCChinese))
   {
      gHouseUnit = cUnitTypeypVillage;

      gCaravelUnit = cUnitTypeypWarJunk;
      gFrigateUnit = cUnitTypeypFuchuan;

      gLivestockPenUnit = cUnitTypeypVillage;
   }

   if ((cMyCiv == cCivJapanese) || (cMyCiv == cCivSPCJapanese) || (cMyCiv == cCivSPCJapaneseEnemy))
   {
      gEconUnit = cUnitTypeypSettlerJapanese;

      gHouseUnit = cUnitTypeypShrineJapanese;

      gTowerUnit = cUnitTypeypCastle;

      gCaravelUnit = cUnitTypeypFune;
      gGalleonUnit = cUnitTypeypAtakabune;
      gFrigateUnit = cUnitTypeypTekkousen;

      gLivestockPenUnit = cUnitTypeypShrineJapanese;
   }
	
	if (cMyCiv == cCivDEAmericans)
   {
      gCaravelUnit = cUnitTypedeSloop;
      gGalleonUnit = cUnitTypedeSteamer;
      gMonitorUnit = cUnitTypexpIronclad;
   }

   if ((cMyCiv == cCivIndians) || (cMyCiv == cCivSPCIndians))
   {
      gHouseUnit = cUnitTypeypHouseIndian;

      gLivestockPenUnit = cUnitTypeypSacredField;

      gEconUnit = cUnitTypeypSettlerIndian;
   }

   if ((cMyCiv == cCivBritish) || (cMyCiv == cCivTheCircle) || (cMyCiv == cCivPirate) || (cMyCiv == cCivSPCAct3))
      gHouseUnit = cUnitTypeManor;

   if ((cMyCiv == cCivFrench) || (cMyCiv == cCivDutch))
      gHouseUnit = cUnitTypeHouse;

   if ((cMyCiv == cCivGermans) || (cMyCiv == cCivRussians))
      gHouseUnit = cUnitTypeHouseEast;

   if ((cMyCiv == cCivSpanish) || (cMyCiv == cCivPortuguese) || (cMyCiv == cCivOttomans))
      gHouseUnit = cUnitTypeHouseMed;

   if (cMyCiv == cCivXPIroquois)
      gHouseUnit = cUnitTypeLonghouse;

   if (cMyCiv == cCivXPAztec)
      gHouseUnit = cUnitTypeHouseAztec;

   if (cMyCiv == cCivDEInca)
      gHouseUnit = cUnitTypedeHouseInca;

   if (cMyCiv == cCivDESwedish)
      gHouseUnit = cUnitTypedeTorp;

   // Escrow initialization is now delayed until the TC is built, as
   // any escrow allocation prevents the AI from affording a TC.
   // For now, though, override the default and set econ/mil to 0
   kbEscrowSetPercentage(cEconomyEscrowID, cResourceFood, 0.0);
   kbEscrowSetPercentage(cEconomyEscrowID, cResourceWood, 0.0);
   kbEscrowSetPercentage(cEconomyEscrowID, cResourceGold, 0.0);
   kbEscrowSetPercentage(cEconomyEscrowID, cResourceFame, 0.0);

   kbEscrowSetPercentage(cMilitaryEscrowID, cResourceFood, 0.0);
   kbEscrowSetPercentage(cMilitaryEscrowID, cResourceWood, 0.0);
   kbEscrowSetPercentage(cMilitaryEscrowID, cResourceGold, 0.0);
   kbEscrowSetPercentage(cMilitaryEscrowID, cResourceFame, 0.0);

   kbEscrowAllocateCurrentResources();

   aiSetEconomyPercentage(1.0);
   aiSetMilitaryPercentage(1.0); // Priority balance neutral

	// TO DO Can we remove this?
   // TO DO:  Define current bases, areagroup, etc.
   gFarmBaseID = kbBaseGetMainID(cMyID);
   gFoodBaseID = kbBaseGetMainID(cMyID); // Where we hunt or gather non-farm food.
   gGoldBaseID = kbBaseGetMainID(cMyID);
   gWoodBaseID = kbBaseGetMainID(cMyID);

   // Adjust target settler counts based on train limit.
   int settlerLimit = kbGetBuildLimit(cMyID, gEconUnit);
   for (index = 0; < 5)
   {
      if (xsArrayGetInt(gTargetSettlerCounts, index) > settlerLimit)
         xsArraySetInt(gTargetSettlerCounts, index, settlerLimit);
   }

   if ((gSPC == true) || (cMyCiv != cCivJapanese && cMyCiv != cCivSPCJapanese && cMyCiv != cCivSPCJapaneseEnemy) ||
       (getUnitCountByLocation(cUnitTypeBerryBush, 0, cUnitStateAny, kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)),
                               30.0) > 0))
      initResourceBreakdowns();
   else // If we are japanese, wait until the first cherry orchard is built if we have no berry bushes.
      xsEnableRule("initResourceBreakdownsDelay");

   // Create a herd plan to gather all herdables that we encounter.
   gHerdPlanID = aiPlanCreate("Gather Herdable Plan", cPlanHerd);
   if (gHerdPlanID >= 0)
   {
      aiPlanAddUnitType(gHerdPlanID, cUnitTypeHerdable, 0, 100, 100);
      // aiPlanSetBaseID(gHerdPlanID, kbBaseGetMainID(cMyID));
      aiPlanSetVariableInt(gHerdPlanID, cHerdPlanBuildingTypeID, 0, cUnitTypeTownCenter);
      aiPlanSetVariableFloat(gHerdPlanID, cHerdPlanDistance, 0, 5.0);
      aiPlanSetActive(gHerdPlanID);
   }

   xsEnableRuleGroup("startup");
   if (cMyCiv != cCivJapanese && cMyCiv != cCivSPCJapanese && cMyCiv != cCivSPCJapaneseEnemy)// &&
       //aiGetWorldDifficulty() >= gDifficultyExpert)
      xsEnableRule("backHerdMonitor");
   if (civIsAfrican() == true && getUnit(cUnitTypeTownCenter) >= 0)
   {
      xsEnableRule("earlySlaughterMonitor");
      earlySlaughterMonitor();
   }

   // Lastly, force an update on the economy...call the function directly.
   econMaster();
}

float getCorrectedResourcePercentage(int resource = cResourceFood)
{
   // Restore resource percentage with wood when we disabled wood gathering.
   if (gDisableWoods == true)
   {
      float percentOnGold = aiGetResourcePercentage(cResourceGold);
      float percentOnWood = percentOnGold * gGoldPercentageToBuyForWood / aiGetMarketBuyCost(cResourceWood) * 100.0;
      float percentOnFood = aiGetResourcePercentage(cResourceFood);

      percentOnGold = percentOnGold * (1.0 - gGoldPercentageToBuyForWood);

      float percentOnResource = 0.0;
      float total = percentOnGold + percentOnWood + percentOnFood;

      if (resource == cResourceGold)
         percentOnResource = percentOnGold / total;
      else if (resource == cResourceWood)
         percentOnResource = percentOnWood / total;
      else
         percentOnResource = percentOnFood / total;

      return (percentOnResource);
   }

   return (aiGetResourcePercentage(resource));
}

int getResourcePerGatherer(int resource = cResourceFood, float maxDistance = 80.0, bool searchAllAreaGroups = false)
{
   int mainBaseID = kbBaseGetMainID(cMyID);
   int resourcePerGatherer = cMinResourcePerGatherer;

   if (mainBaseID < 0)
      return (resourcePerGatherer);

   int numGatherers =
       kbUnitCount(cMyID, gEconUnit, cUnitStateAlive) + kbUnitCount(cMyID, cUnitTypeSettlerWagon, cUnitStateAlive);
   int numberBases = kbBaseGetNumber(cMyID);
   int baseID = -1;
   int resourceAmount = 0;
   float percentOnResource = getCorrectedResourcePercentage(resource);
   int numResourceGatherers = percentOnResource * numGatherers;
   int numFarms = 0;

   switch (resource)
   {
   case cResourceFood:
   {
      static int startingHuntAmount = -1;
      if (startingHuntAmount < 0)
      {
         if ((cMyCiv != cCivJapanese) && (cMyCiv != cCivSPCJapanese) && (cMyCiv != cCivSPCJapaneseEnemy))
         {
            startingHuntAmount = kbGetAmountValidResources(mainBaseID, cResourceFood, cAIResourceSubTypeHunt,
                                                           maxDistance, searchAllAreaGroups);
            gEarlyHunts = startingHuntAmount > 0;
         }
         else
         {
            startingHuntAmount = 0;
            gEarlyHunts = false;
         }
      }

      for (i = 0; < numberBases)
      {
         baseID = kbBaseGetIDByIndex(cMyID, i);
         if (kbBaseGetSettlement(cMyID, baseID) == false)
            continue;
         if ((cMyCiv != cCivJapanese) && (cMyCiv != cCivSPCJapanese) && (cMyCiv != cCivSPCJapaneseEnemy))
            resourceAmount = resourceAmount + kbGetAmountValidResources(baseID, cResourceFood, cAIResourceSubTypeHunt,
                                                                        maxDistance, searchAllAreaGroups);
         // dont count fruits unless we're Japanese, they're too slow compared to huntables
         if (startingHuntAmount == 0)
            resourceAmount = resourceAmount + kbGetAmountValidResources(baseID, cResourceFood, cAIResourceSubTypeEasy,
                                                                        maxDistance, searchAllAreaGroups);
      }

      if (civIsAsian() == true || civIsAfrican() == true)
         numFarms = gNumberFoodPaddies;
      else
         numFarms = kbUnitCount(cMyID, gFarmUnit, cUnitStateAlive);

      numResourceGatherers = numResourceGatherers - numFarms * cMaxSettlersPerFarm;
      break;
   }
   case cResourceWood:
   {
      for (i = 0; < numberBases)
      {
         baseID = kbBaseGetIDByIndex(cMyID, i);
         if (kbBaseGetSettlement(cMyID, baseID) == false)
            continue;
         resourceAmount = resourceAmount + kbGetAmountValidResources(baseID, cResourceWood, cAIResourceSubTypeEasy,
                                                                     maxDistance, searchAllAreaGroups);
      }
      break;
   }
   case cResourceGold:
   {
      if (cMyCiv != cCivXPIroquois && cMyCiv != cCivXPSioux)
      {
         for (i = 0; < numberBases)
         {
            baseID = kbBaseGetIDByIndex(cMyID, i);
            if (kbBaseGetSettlement(cMyID, baseID) == false)
               continue;
            resourceAmount = resourceAmount + kbGetAmountValidResources(baseID, cResourceGold, cAIResourceSubTypeEasy,
                                                                        maxDistance, searchAllAreaGroups);
         }
      }
      else
      {
         static int mineQuery = -1;
         vector location = cInvalidVector;
         int mineCount = 0;
         int mineID = -1;
         // For natives we just go through each mine and count total resources
         if (mineQuery < 0)
         {
            mineQuery = kbUnitQueryCreate("Mine query for resource check");
            kbUnitQuerySetPlayerID(mineQuery, 0);
            kbUnitQuerySetUnitType(mineQuery, cUnitTypeMine);
            kbUnitQuerySetAscendingSort(mineQuery, true); // Ascending distance from initial location
         }

         kbUnitQuerySetMaximumDistance(mineQuery, maxDistance);

         for (i = 0; < numberBases)
         {
            baseID = kbBaseGetIDByIndex(cMyID, i);
            if (kbBaseGetSettlement(cMyID, baseID) == false)
               continue;
            location = kbBaseGetLocation(cMyID, baseID);
            kbUnitQuerySetPosition(mineQuery, location);
            kbUnitQueryResetResults(mineQuery);
            mineCount = kbUnitQueryExecute(mineQuery);
            for (j = 0; < mineCount)
            {
               mineID = kbUnitQueryGetResult(mineQuery, j);
               if (searchAllAreaGroups == false)
               {
                  if (kbAreaGroupGetIDByPosition(kbUnitGetPosition(mineID)) !=
                      kbAreaGroupGetIDByPosition(kbBaseGetLocation(cMyID, mainBaseID)))
                     continue;
               }
               resourceAmount = resourceAmount + kbUnitGetResourceAmount(mineID, cResourceGold);
            }
         }
      }

      if (civIsAsian() == true || civIsAfrican() == true)
         numFarms = gNumberGoldPaddies;
      else
         numFarms = kbUnitCount(cMyID, gPlantationUnit, cUnitStateAlive);

      numResourceGatherers = numResourceGatherers - numFarms * cMaxSettlersPerPlantation;
      break;
   }
   }

   if (numResourceGatherers > 0)
      resourcePerGatherer = resourceAmount / numResourceGatherers;

   return (resourcePerGatherer);
}

void updateResources()
{
   int mainBaseID = kbBaseGetMainID(cMyID);
   float maxDistance = kbBaseGetMaximumResourceDistance(cMyID, mainBaseID);
   vector mainBaseLocation = kbBaseGetLocation(cMyID, mainBaseID);
   float newMaxDistance = 0.0;
   static bool searchAllAreaGroups = false;
   static int lastBlacklistResourceTime = 0;
   int numResources = kbResourceGetNumber();

   if (mainBaseID < 0)
      return;
   // when we are gathering natural resources over this distance, start farming.
   const float cFarmNaturalResourceDistance = 50.0;
   // max distance to gather natural resources.
   const float cMaxNaturalResourceDistance = 80.0;
   int time = xsGetTime();
   int numberFarms = 0;
   int numberPlants = 0;
   const int cCanExceedMaxDistanceFood = 1;
   const int cCanExceedMaxDistanceWood = 2;
   const int cCanExceedMaxDistanceGold = 4;
   int canExceedMaxDistance = 0;
   int unitID = -1;
   vector location = cInvalidVector;
   int baseID = -1;

   if (time <= 5000)
      return;

   int foodPerGatherer = getResourcePerGatherer(cResourceFood, maxDistance, searchAllAreaGroups);
   int woodPerGatherer = getResourcePerGatherer(cResourceWood, maxDistance, searchAllAreaGroups);
   int goldPerGatherer = getResourcePerGatherer(cResourceGold, maxDistance, searchAllAreaGroups);

   // aiEcho("       Resources:   Food " + foodAmount + ", Wood " + woodAmount + ", Gold " + goldAmount);
   aiEcho("    Per gatherer:   Food " + foodPerGatherer + ", Wood " + woodPerGatherer + ", Gold " + goldPerGatherer);

   gLowOnResources = false;
   gDisableWoods = false;

   if (time > 120000)
   {
      if ((foodPerGatherer < cMinResourcePerGatherer) || (woodPerGatherer < cMinResourcePerGatherer) ||
          (goldPerGatherer < cMinResourcePerGatherer))
      {
         if (searchAllAreaGroups == true)
            gLowOnResources = true;
         else if (gIslandMap == true)
         {
            // starting from next time, considering resources on other islands.
            searchAllAreaGroups = true;
            return;
         }

         // When we run out of resources, but have no farms to gather from, allow exceeding max resource distance.
         if (maxDistance >= cMaxNaturalResourceDistance)
         {
            if (foodPerGatherer < (cMinResourcePerGatherer / 2))
            {
               if (gTimeToFarm == true)
               {
                  if (civIsAsian() == true || civIsAfrican() == true)
                     numberFarms = gNumberFoodPaddies;
                  else
                     numberFarms = kbUnitCount(cMyID, gFarmUnit, cUnitStateAlive);
               }
               if (numberFarms == 0)
                  canExceedMaxDistance |= cCanExceedMaxDistanceFood;
            }
            if (woodPerGatherer < (cMinResourcePerGatherer / 2))
            {
               gDisableWoods = (((gRevolutionType & cRevolutionFinland) == 0) &&
                                (kbUnitCount(cMyID, gMarketUnit, cUnitStateAlive) > 0));
               if (gDisableWoods == false)
                  canExceedMaxDistance |= cCanExceedMaxDistanceWood;
            }
            if (goldPerGatherer < (cMinResourcePerGatherer / 2))
            {
               if (gTimeForPlantations == true)
               {
                  if (civIsAsian() == true || civIsAfrican() == true)
                     numberPlants = gNumberGoldPaddies;
                  else
                     numberPlants = kbUnitCount(cMyID, gPlantationUnit, cUnitStateAlive);
               }
               if (numberPlants == 0)
                  canExceedMaxDistance |= cCanExceedMaxDistanceGold;
            }
         }

         // Increase max distance.
         newMaxDistance = maxDistance + 30.0;
         if ((canExceedMaxDistance != 0) && (newMaxDistance > cMaxNaturalResourceDistance))
            newMaxDistance = cMaxNaturalResourceDistance;
         kbBaseSetMaximumResourceDistance(cMyID, mainBaseID, newMaxDistance);
      }
   }

   // After 10 minutes into the game, check for resources to blacklist every 60 seconds.
   if ((time > 600000) && (time - lastBlacklistResourceTime >= 60000))
   {
      int resourceID = -1;
      int resourceType = -1;
      int resourceSubType = -1;
      bool blacklisted = false;

      // go through all resources, blacklist any too close to enemy bases.
      for (i = 0; < numResources)
      {
         resourceID = kbResourceGetIDByIndex(i);
         resourceType = kbResourceGetType(resourceID);
         resourceSubType = kbResourceGetSubType(resourceID);

         // Allow all fish and whales on the map for now.
         if (resourceSubType == cAIResourceSubTypeFarm || resourceSubType == cAIResourceSubTypeFish)
            continue;

         blacklisted = false;

         bool checkDistanceToEnemy = true;

         // If we have no resources to gather, don't blacklist.
         // TODO: this check does not work when once we have access to resources previoulsy blacklisted.
         switch(resourceType)
         {
         case cResourceFood:
         {
            if ((canExceedMaxDistance & cCanExceedMaxDistanceFood) != 0 && foodPerGatherer == 0 && (resourceSubType == cAIResourceSubTypeHunt || resourceSubType == cAIResourceSubTypeEasy))
               checkDistanceToEnemy = false;
            break;
         }
         case cResourceWood:
         {
            if ((canExceedMaxDistance & cCanExceedMaxDistanceWood) != 0 && woodPerGatherer == 0 && resourceSubType == cAIResourceSubTypeEasy)
               checkDistanceToEnemy = false;
            break;
         }
         case cResourceGold:
         {
            if ((canExceedMaxDistance & cCanExceedMaxDistanceGold) != 0 && goldPerGatherer == 0 && resourceSubType == cAIResourceSubTypeEasy)
               checkDistanceToEnemy = false;
            break;
         }                        
         }

         if (checkDistanceToEnemy == true)
         {
            unitID = kbResourceGetUnit(resourceID, 0);
            if (unitID >= 0)
            {
               location = kbUnitGetPosition(unitID);
               baseID = kbFindClosestBase(cPlayerRelationEnemy, location);
               // Closer to enemy base than our main base?
               if (distance(location, mainBaseLocation) >
                  distance(location, kbBaseGetLocation(kbBaseGetOwner(baseID), baseID)))
               {
                  blacklisted = true;
                  aiEcho("Blacklisting resource " + resourceID + " at " + location);
               }
            }
         }

         kbResourceSetBlacklisted(resourceID, blacklisted);
      }
      lastBlacklistResourceTime = time;
   }

   // We ran out of resources pretty early, find a new base
   /*if (gLowOnResources == true)
      {
      if (xsIsRuleEnabled("findNewBase") == false)
         xsEnableRule("findNewBase");
   }*/

   if ((gTimeToFarm == false) && (time > 120000) &&
       (foodPerGatherer < cMinResourcePerGatherer || maxDistance >= cFarmNaturalResourceDistance) &&
       (gRevolutionType & cRevolutionFinland) == 0)
   {
      // If max distance is larger than distance to farm, we have to calculate resource amount again.
      if (maxDistance < cFarmNaturalResourceDistance ||
          getResourcePerGatherer(cResourceFood, cFarmNaturalResourceDistance, searchAllAreaGroups) <
              cMinResourcePerGatherer)
      {
         gTimeToFarm = true;
         aiEcho("        **** It's time to start farming!");
      }
   }

   if ((gTimeForPlantations == false) &&
       (goldPerGatherer < cMinResourcePerGatherer || maxDistance >= cFarmNaturalResourceDistance) &&
       (gRevolutionType & cRevolutionFinland) == 0 && (civIsAsian() == true || civIsAfrican() == true || kbGetAge() >= cAge3))
   {
      // If max distance is larger than distance to farm, we have to calculate resource amount again.
      if (maxDistance < cFarmNaturalResourceDistance ||
          getResourcePerGatherer(cResourceGold, cFarmNaturalResourceDistance, searchAllAreaGroups) <
              cMinResourcePerGatherer)
      {
         gTimeForPlantations = true;
         aiEcho("        **** It's time to start using plantations!");
      }
   }

   if ((gTimeToFish == false) && (gGoodFishingMap == true) && (time > 5000) &&
       (foodPerGatherer < 1.5 * cMinResourcePerGatherer || goldPerGatherer < 1.5 * cMinResourcePerGatherer) &&
       (gRevolutionType & cRevolutionFinland) == 0)
   {
      gTimeToFish = true;
      aiEcho("        **** It's time to start fishing!");
   }
}

//==============================================================================
/*
   econMaster(int mode, int value)

   Performs top-level economic analysis and direction.   Generally called
   by the econMasterRule, it can be called directly for special-event processing.
   EconMasterRule calls it with default parameters, directing it to do a full
   reanalysis.
*/
//==============================================================================
void econMaster(int mode = -1, int value = -1)
{
   static int lastUpdateTime = 0;
   int time = xsGetTime();

   // These functions can be called less frequently than updateResourceDistribution().
   if (time - lastUpdateTime >= 30000)
   {
      // Monitor main base supply of food and gold, activate farming and plantations when resources run low
      updateResources();
      // Update our settler maintain targets, based on age, personality.
      updateSettlerCounts();
      lastUpdateTime = time;
   }

   // Maintain list of possible future econ bases, prioritize them
   //updateEconSiteList(); // TODO

   // Evaluate active base status...are all bases still usable?  Adjust if not.
   // evaluateBases();        // TODO

   // Update forecasts for economic and military expenses.  Set resource
   // exchange rates.
   // updateForecasts();

   // Set desired gatherer ratios.  Spread them out per base, set per-base
   // resource breakdowns.
   // updateGatherers();

   updateResourceDistribution();

   // Maintain escrow balance based on age, personality, actual vs. desired settler pop.
   // updateEscrows();
}

//==============================================================================
// rule econMasterRule
/*
   This rule calls the econMaster() function on a regular basis.  The
   function is separate so that it may be called with a parameter for
   unscheduled processing based on unexpected events.
*/
//==============================================================================
rule econMasterRule
inactive
group startup
minInterval 10
{
   econMaster();
}

//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
// Military
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================

rule delayWalls
inactive
minInterval 10
{
   if ((kbGetPopCap() - kbGetPop()) < 20)
      return; // Don't start walls until we have pop room
   int wallPlanID = aiPlanCreate("WallInBase", cPlanBuildWall);
   if (wallPlanID != -1)
   {
      aiPlanSetVariableInt(wallPlanID, cBuildWallPlanWallType, 0, cBuildWallPlanWallTypeRing);
      aiPlanAddUnitType(wallPlanID, gEconUnit, 0, 1, 1);
      aiPlanSetVariableVector(wallPlanID, cBuildWallPlanWallRingCenterPoint, 0,
                              kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)));
      aiPlanSetVariableFloat(wallPlanID, cBuildWallPlanWallRingRadius, 0, 30.0);
      aiPlanSetVariableInt(wallPlanID, cBuildWallPlanNumberOfGates, 0, 2);
      aiPlanSetBaseID(wallPlanID, kbBaseGetMainID(cMyID));
      aiPlanSetEscrowID(wallPlanID, cEconomyEscrowID);
      aiPlanSetDesiredPriority(wallPlanID, 80);
      aiPlanSetActive(wallPlanID, true);
      sendStatement(cPlayerRelationAlly, cAICommPromptToAllyWhenIWallIn);
      // Enable our wall gap rule, too.
      xsEnableRule("fillInWallGaps");
      aiEcho("Enabling Wall Plan for Base ID: " + kbBaseGetMainID(cMyID));
   }
   xsDisableSelf();
}

rule turtleUp
inactive
group tcComplete
minInterval 10
{
   // Over 0.5 offense means no walls or towers
   // Under -0.5 means always walls
   // Intermediate values give linear odds of walling.
   // Number of towers ranges from 1 at 0.5 up to 6 at -1.0
   // Numbers below 0 also encourage shipping towers from the home city
   if ((kbUnitCount(cMyID, gEconUnit, cUnitStateAlive) + kbUnitCount(cMyID, cUnitTypeSettlerWagon, cUnitStateAlive)) <
       10)
      return;

   if ((cMyCiv == cCivDutch) && (kbUnitCount(cMyID, cUnitTypeBank, cUnitStateABQ) < 1))
      return;
  
  
      //if (kbUnitCount(cMyID, gTowerUnit, cUnitStateABQ) < gNumTowers)
      //createSimpleBuildPlan(gTowerUnit, 10, 99, true, cEconomyEscrowID, kbBaseGetMainID(cMyID), 1);

   float odds = btOffenseDefense * -1.0;
   odds = odds + 0.5;             // Range -0.5 to +1.5
   int needToRoll = 100.0 * odds; // Range -50 to +150
   if ((aiRandInt(100) < needToRoll) && (cvOkToBuildWalls == true))
   {
      // aiEcho("Decided to do walls.");
      // gBuildWalls = true;
      // xsEnableRule("delayWalls");   // Start walls once we have housing room
   }

   if (gNumTowers < 0)
   { // If it hasn't been defined elsewhere, set defaults
      if (civIsAsian() == false)
      {
         if (aiGetGameMode() == cGameModeDeathmatch)
        gNumTowers = kbGetBuildLimit(cMyID, gTowerUnit);
      else
		  if ((kbGetAge() >= cvMaxAge) || (gRevolutionType != 0))
        gNumTowers = kbGetBuildLimit(cMyID, gTowerUnit);
	  else 
		gNumTowers = 0;
      if (gNumTowers < 0)
         gNumTowers = 0.0;
      }
      else
      {
         if (aiGetGameMode() == cGameModeDeathmatch)
        gNumTowers = kbGetBuildLimit(cMyID, gTowerUnit);
      else
		  if ((kbGetAge() >= cvMaxAge) || (gRevolutionType != 0))
        gNumTowers = kbGetBuildLimit(cMyID, gTowerUnit);
	  else 
		gNumTowers = 0;
      if (gNumTowers < 0)
         gNumTowers = 0.0;
      }
   }
   if (cvOkToFortify == false)
      gNumTowers = 0;

   aiEcho(" ");
   aiEcho("Planning on making " + gNumTowers + " towers.");
   aiEcho(" ");

   xsEnableRule("towerManager");
   xsEnableRule("aztecWarhutUpgradeMonitor");

   xsDisableSelf();
}

/*void setUnitPickerCommon(int upID = -1)
{
   int targetPlayer = aiGetMostHatedPlayerID();

   kbUnitPickSetPreferenceWeight(upID, 1.0);
   if (gSPC == false)
   {
      kbUnitPickSetCombatEfficiencyWeight(upID,
                                          2.0); // Changed from 1.0 to dilute the power of the preference weight.
      // Late in game, less focus on taking down buildings.
      if (xsGetTime() < 900000 || kbUnitCount(targetPlayer, cUnitTypeBuilding, cUnitStateAlive | cUnitStateBuilding) >= 70)
         kbUnitPickSetBuildingCombatEfficiencyWeight(upID, 0.5);
      else
         kbUnitPickSetBuildingCombatEfficiencyWeight(upID, 0.0);
   }
   else
   {
      kbUnitPickSetCombatEfficiencyWeight(upID, 1.0); // Leave it at 1.0 to avoid messing up SPC balance
      kbUnitPickSetBuildingCombatEfficiencyWeight(upID, 0.25);
   }
   kbUnitPickSetCostWeight(upID, 0.0);

   // Default to land units.
   kbUnitPickSetEnemyPlayerID(upID, targetPlayer);
   kbUnitPickSetAttackUnitType(upID, cUnitTypeLogicalTypeLandMilitary);

   // Set the default target types and weights, for use until we've seen enough actual units.
   kbUnitPickAddCombatEfficiencyType(upID, cUnitTypeLogicalTypeLandMilitary, 0.0);

   kbUnitPickAddBuildingCombatEfficiencyType(upID, cUnitTypeMilitaryBuilding, 0.0);
   kbUnitPickAddBuildingCombatEfficiencyType(upID, cUnitTypeAbstractTownCenter, 0.0);
   
}

void setUnitPickerDisabledUnits(int upID = -1)
{
   kbUnitPickSetPreferenceFactor(upID, cUnitTypeAbstractNativeWarrior, 0.0);

   if (cMyCiv == cCivFrench)
         kbUnitPickSetPreferenceFactor(upID, cUnitTypeCoureur,
                                    0.0); // Avoid coureurs, they mess up econ/mil calcs.

   if (civIsNative() == true)
      kbUnitPickSetPreferenceFactor(upID, cUnitTypexpWarrior,
                                 0.0); // Never pick xpWarrior or xpDogSoldier, available via dance only
   if (cMyCiv == cCivXPSioux)
      kbUnitPickSetPreferenceFactor(upID, cUnitTypexpDogSoldier, 0.0);
   if (cMyCiv == cCivXPAztec)
   {
      kbUnitPickSetPreferenceFactor(upID, cUnitTypexpMedicineManAztec, 0.0);
      kbUnitPickSetPreferenceFactor(upID, cUnitTypexpSkullKnight, 0.0);
   }
   kbUnitPickSetPreferenceFactor(upID, cUnitTypeypMercFlailiphant, 0.0);
   /*kbUnitPickSetPreferenceFactor(upID, cUnitTypeypMercIronTroop, 0.0);
   kbUnitPickSetPreferenceFactor(upID, cUnitTypeypMercYojimbo, 0.0);*/
/*
   if ((cMyCiv == cCivIndians) || (cMyCiv == cCivSPCIndians))
   {
      kbUnitPickSetPreferenceFactor(upID, cUnitTypeypSowarMansabdar, 0.0);
      kbUnitPickSetPreferenceFactor(upID, cUnitTypeypRajputMansabdar, 0.0);
      kbUnitPickSetPreferenceFactor(upID, cUnitTypeypSepoyMansabdar, 0.0);
      kbUnitPickSetPreferenceFactor(upID, cUnitTypeypUrumiMansabdar, 0.0);
      kbUnitPickSetPreferenceFactor(upID, cUnitTypeypZamburakMansabdar, 0.0);
      kbUnitPickSetPreferenceFactor(upID, cUnitTypeypNatMercGurkhaJemadar, 0.0);
      kbUnitPickSetPreferenceFactor(upID, cUnitTypeypMercFlailiphantMansabdar, 0.0);
      kbUnitPickSetPreferenceFactor(upID, cUnitTypeypHowdahMansabdar, 0.0);
      kbUnitPickSetPreferenceFactor(upID, cUnitTypeypMahoutMansabdar, 0.0);
      kbUnitPickSetPreferenceFactor(upID, cUnitTypeypSiegeElephantMansabdar, 0.0);
   }

   if (cMyCiv == cCivDEInca)
      kbUnitPickSetPreferenceFactor(upID, cUnitTypedeChasqui, 0.0);

   if (civIsAfrican() == true)
   {
      // Exclude units costing influence
      kbUnitPickSetPreferenceFactor(upID, cUnitTypeMercenary, 0.0);
      kbUnitPickSetPreferenceFactor(upID, cUnitTypedeBowmanLevy, 0.0);
      kbUnitPickSetPreferenceFactor(upID, cUnitTypedeSpearmanLevy, 0.0);
      kbUnitPickSetPreferenceFactor(upID, cUnitTypedeGunnerLevy, 0.0);
      kbUnitPickSetPreferenceFactor(upID, cUnitTypedeMaigadi, 0.0);
      kbUnitPickSetPreferenceFactor(upID, cUnitTypedeSebastopolMortar, 0.0);
      kbUnitPickSetPreferenceFactor(upID, cUnitTypeFalconet, 0.0);
      kbUnitPickSetPreferenceFactor(upID, cUnitTypeOrganGun, 0.0);
      kbUnitPickSetPreferenceFactor(upID, cUnitTypeCulverin, 0.0);
      kbUnitPickSetPreferenceFactor(upID, cUnitTypeMortar, 0.0);
      kbUnitPickSetPreferenceFactor(upID, cUnitTypeypMahout, 0.0);
      kbUnitPickSetPreferenceFactor(upID, cUnitTypeypHowdah, 0.0);
   }     
}
*/
/* setUnitPickerPreference()

   Updates the unit picker biases, arbitrates between the potentially conflicting sources.

   Priority order is:

      1)  If control is from a trigger, that wins.  The unit line specified in gCommandUnitLine gets a +.8, all others
   +.2 2)  If control is ally command, ditto.  (Can only be one unit due to UI limits. 3)  If we're not under command,
   but cvPrimaryArmyUnit (and optionally cvSecondaryArmyUnit) are set, they rule. If just primary, it gets .8 to .2 for
   other classes. If primary and secondary, they get 1.0 and 0.5, others get 0.0. 4)  If not under command and no cv's
   are set, we go with the btBiasCav, btBiasInf and btBiasArt line settings.

*/

void setUnitPickerPreference(int upID = -1)
{
   // Add the main unit lines
   if (upID < 0)
      return;

   // Check for commanded unit preferences.
   if ((gUnitPickSource == cOpportunitySourceTrigger) || (gUnitPickSource == cOpportunitySourceAllyRequest))
   { // We have an ally or trigger command, so bias everything for that one unit
      if (cvPrimaryArmyUnit < 0)
         return; // This should never happen, it should be set when the unitPickSource is set.

      kbUnitPickResetAll(gLandUnitPicker);

      kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractInfantry, 0.2); // Range 0.0 to 1.0
      kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractArtillery, 0.2);
      kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractCavalry, 0.2);
      kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractNativeWarrior, 0.0);
      kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeCoureur,
                                    0.0); // Avoid coureurs, they mess up econ/mil calcs.
      if (cMyCiv == cCivXPAztec || cMyCiv == cCivDEInca)
         kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractLightInfantry, 0.2);
      kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypexpWarrior,
                                    0.0); // Never pick xpWarrior or xpDogSoldier, available via dance only
      kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypexpDogSoldier, 0.0);
      kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypexpMedicineManAztec, 0.0);
      kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypexpSkullKnight, 0.0);
      /*kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypMercFlailiphant, 0.0);
      kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypMercIronTroop, 0.0);
      kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypMercYojimbo, 0.0);*/
			 kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractConsulateUnit, 0.0); 

      if ((cMyCiv == cCivIndians) || (cMyCiv == cCivSPCIndians))
      {
         kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypSowarMansabdar, 0.0);
         kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypRajputMansabdar, 0.0);
         kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypSepoyMansabdar, 0.0);
         kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypUrumiMansabdar, 0.0);
         kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypZamburakMansabdar, 0.0);
         kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypNatMercGurkhaJemadar, 0.0);
         kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypMercFlailiphantMansabdar, 0.0);
         kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypHowdahMansabdar, 0.0);
         kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypMahoutMansabdar, 0.0);
         kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypSiegeElephantMansabdar, 0.0);
			 kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractConsulateUnit, 0.0); 
      }

      if (cMyCiv == cCivDEInca)
         kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypedeChasqui, 0.0);

      if (civIsAfrican() == true)
      {
         // Exclude units costing influence
         kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeMercenary, 0.0);
         kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypedeBowmanLevy, 0.0);
         kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypedeSpearmanLevy, 0.0);
         kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypedeGunnerLevy, 0.0);
         kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypedeMaigadi, 0.0);
         kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypedeSebastopolMortar, 0.0);
         kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeFalconet, 0.0);
         kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeOrganGun, 0.0);
         kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeCulverin, 0.0);
         kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeMortar, 0.0);
         kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypMahout, 0.0);
         kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypHowdah, 0.0);
      }

      kbUnitPickSetPreferenceFactor(gLandUnitPicker, cvPrimaryArmyUnit, 0.8);
      kbUnitPickRemovePreferenceFactor(gLandUnitPicker, cUnitTypeAbstractBannerArmy);

      return;
   }

   // Check for cv settings
   if (cvPrimaryArmyUnit >= 0)
   {
      kbUnitPickResetAll(gLandUnitPicker);

      // See if 1 or 2 lines set.  If 1, score 0.8 vs. 0.2.  If 2, score 1.0, 0.5 and 0.0.
      if (cvSecondaryArmyUnit < 0)
      {
         kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractInfantry, 0.2); // Range 0.0 to 1.0
         kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractArtillery, 0.2);
         kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractCavalry, 0.2);
         kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractNativeWarrior, 0.0);
         if (cMyCiv == cCivXPAztec)
            kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractLightInfantry, 0.2);
         kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeCoureur,
                                       0.0); // Avoid coureurs, they mess up econ/mil calcs.
         kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypexpWarrior,
                                       0.0); // Never pick xpWarrior or xpDogSoldier, available via dance only
         kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypexpDogSoldier, 0.0);
         kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypexpMedicineManAztec, 0.0);
         kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypexpSkullKnight, 0.0);
         kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypMercFlailiphant, 0.0);
         kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypMercIronTroop, 0.0);
         kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypMercYojimbo, 0.0);
			 kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractConsulateUnit, 0.0); 

         if ((cMyCiv == cCivIndians) || (cMyCiv == cCivSPCIndians))
         {
            kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypSowarMansabdar, 0.0);
            kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypRajputMansabdar, 0.0);
            kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypSepoyMansabdar, 0.0);
            kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypUrumiMansabdar, 0.0);
            kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypNatMercGurkhaJemadar, 0.0);
            kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypZamburakMansabdar, 0.0);
            kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypMercFlailiphantMansabdar, 0.0);
            kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypHowdahMansabdar, 0.0);
            kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypMahoutMansabdar, 0.0);
            kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypSiegeElephantMansabdar, 0.0);
			 kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractConsulateUnit, 0.0); 
         }

         if (cMyCiv == cCivDEInca)
            kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypedeChasqui, 0.0);

         if (civIsAfrican() == true)
         {
            // Exclude units costing influence
            kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeMercenary, 0.0);
            kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypedeBowmanLevy, 0.0);
            kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypedeSpearmanLevy, 0.0);
            kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypedeGunnerLevy, 0.0);
            kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypedeMaigadi, 0.0);
            kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypedeSebastopolMortar, 0.0);
            kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeFalconet, 0.0);
            kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeOrganGun, 0.0);
            kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeCulverin, 0.0);
            kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeMortar, 0.0);
            kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypMahout, 0.0);
            kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypHowdah, 0.0);
         }

         kbUnitPickSetPreferenceFactor(gLandUnitPicker, cvPrimaryArmyUnit, 0.8);
         kbUnitPickRemovePreferenceFactor(gLandUnitPicker, cUnitTypeAbstractBannerArmy);
      }
      else
      {
         kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractInfantry, 0.0); // Range 0.0 to 1.0
         kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractArtillery, 0.0);
         kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractCavalry, 0.0);
         kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractNativeWarrior, 0.0);
         if (cMyCiv == cCivXPAztec || cMyCiv == cCivDEInca)
            kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractLightInfantry, 0.0);
         kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeCoureur,
                                       0.0); // Avoid coureurs, they mess up econ/mil calcs.
         kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypexpWarrior,
                                       0.0); // Never pick xpWarrior or xpDogSoldier, available via dance only
         kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypexpDogSoldier, 0.0);
         kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypexpMedicineManAztec, 0.0);
         kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypexpSkullKnight, 0.0);
         kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypMercFlailiphant, 0.0);
         kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypMercIronTroop, 0.0);
         kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypMercYojimbo, 0.0);
			 kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractConsulateUnit, 0.0); 

         if ((cMyCiv == cCivIndians) || (cMyCiv == cCivSPCIndians))
         {
            kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypSowarMansabdar, 0.0);
            kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypRajputMansabdar, 0.0);
            kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypSepoyMansabdar, 0.0);
            kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypUrumiMansabdar, 0.0);
            kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypNatMercGurkhaJemadar, 0.0);
            kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypZamburakMansabdar, 0.0);
            kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypMercFlailiphantMansabdar, 0.0);
            kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypHowdahMansabdar, 0.0);
            kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypMahoutMansabdar, 0.0);
            kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypSiegeElephantMansabdar, 0.0);
			 kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractConsulateUnit, 0.0); 
         }

         if (cMyCiv == cCivDEInca)
            kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypedeChasqui, 0.0);

         if (civIsAfrican() == true)
         {
            // Exclude units costing influence
            kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeMercenary, 0.0);
            kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypedeBowmanLevy, 0.0);
            kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypedeSpearmanLevy, 0.0);
            kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypedeGunnerLevy, 0.0);
            kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypedeMaigadi, 0.0);
            kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypedeSebastopolMortar, 0.0);
            kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeFalconet, 0.0);
            kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeOrganGun, 0.0);
            kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeCulverin, 0.0);
            kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeMortar, 0.0);
            kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypMahout, 0.0);
            kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypHowdah, 0.0);
         }

         kbUnitPickSetPreferenceFactor(gLandUnitPicker, cvPrimaryArmyUnit, 1.0);
         kbUnitPickSetPreferenceFactor(gLandUnitPicker, cvSecondaryArmyUnit, 0.5);
         if (cvTertiaryArmyUnit >= 0)
         {
            kbUnitPickSetPreferenceFactor(gLandUnitPicker, cvTertiaryArmyUnit, 0.5);
         }
         kbUnitPickRemovePreferenceFactor(gLandUnitPicker, cUnitTypeAbstractBannerArmy);
      }
      return;
   }

   //kbUnitPickSetMinimumCounterModePop(gLandUnitPicker, 15);
   // No commands active.  No primary unit set.  Go with our default biases.
   //kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractInfantry,
   //                              0.5 + (btBiasInf / 2.0)); // Range 0.0 to 1.0
   //kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractArtillery, 0.5 + (btBiasArt / 2.0));
   //kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractCavalry, 0.5 + (btBiasCav / 2.0));
   //if (cMyCiv == cCivXPAztec || cMyCiv == cCivDEInca)
   //   kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractLightInfantry, 0.5 + (btBiasCav / 2.0));
   /*if (cMyCiv == cCivIndians)
   { //Elephants are soooo expensive
      kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypMahout, 0.1);
      kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypHowdah, 0.1);
   }*/
   // kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractNativeWarrior, 0.5 + (btBiasNative / 2.0));
   kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeCoureur,
                                 0.0); // Avoid coureurs, they mess up econ/mil calcs.
   kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypexpWarrior,
                                 0.0); // Never pick xpWarrior or xpDogSoldier, available via dance only
   kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypexpDogSoldier, 0.0);
   kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypexpMedicineManAztec, 0.0);
   kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypexpSkullKnight, 0.0);
   kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypMercFlailiphant, 0.0);
   kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypMercIronTroop, 0.0);
   kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypMercYojimbo, 0.0);
   kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractConsulateUnit, 0.0); 

   if ((cMyCiv == cCivChinese) || (cMyCiv == cCivSPCChinese))
   {
   kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractConsulateUnit, 0.0); 
	   /*
      kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractInfantry, 0.0);
      kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractCavalry, 0.0);

      kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractBannerArmy, 0.5);   // Banner Armies

      kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypStandardArmy, 0.4);   // Range 0.0 to 1.0
      kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypMingArmy, 0.4);   // Range 0.0 to 1.0
      kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypImperialArmy, 0.4);   // Range 0.0 to 1.0
      kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypTerritorialArmy, 0.8);   // Range 0.0 to 1.0
      kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypOldHanArmy, 0.6);   // Range 0.0 to 1.0
      kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypForbiddenArmy, 0.6);
      kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypBlackFlagArmy, 0.2);
      kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypMongolianArmy, 0.2);

      kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractArtillery, 0.2);
	  */
   }

   if ((cMyCiv == cCivIndians) || (cMyCiv == cCivSPCIndians))
   {
      kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypSowarMansabdar, 0.0);
      kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypRajputMansabdar, 0.0);
      kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypSepoyMansabdar, 0.0);
      kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypUrumiMansabdar, 0.0);
      kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypNatMercGurkhaJemadar, 0.0);
      kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypZamburakMansabdar, 0.0);
      kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypMercFlailiphantMansabdar, 0.0);
      kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypHowdahMansabdar, 0.0);
      kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypMahoutMansabdar, 0.0);
      kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypSiegeElephantMansabdar, 0.0);
			 kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractConsulateUnit, 0.0); 
   }

   if ((cMyCiv == cCivJapanese) || (cMyCiv == cCivSPCJapanese) || (cMyCiv == cCivSPCJapaneseEnemy) ||
       (cMyCiv == cCivOttomans))
   {
      if (kbUnitCount(cMyID, cUnitTypeypChurch, cUnitStateAlive) == 0)
         kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypexpSpy, 0.0);
			 kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractConsulateUnit, 0.0); 
   }

   if (cMyCiv == cCivDEInca)
      kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypedeChasqui, 0.0);

   if (civIsAfrican() == true)
   {
      // Exclude units costing influence
      kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeMercenary, 0.0);
      kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypedeBowmanLevy, 0.0);
      kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypedeSpearmanLevy, 0.0);
      kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypedeGunnerLevy, 0.0);
      kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypedeMaigadi, 0.0);
      kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypedeSebastopolMortar, 0.0);
      kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeFalconet, 0.0);
      kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeOrganGun, 0.0);
      kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeCulverin, 0.0);
      kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeMortar, 0.0);
      kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypMahout, 0.0);
      kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypHowdah, 0.0);
   }

   // handled separately in consulate monitor
   kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractConsulateSiegeFortress, 0.0);
   kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractConsulateSiegeIndustrial, 0.0);
   kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractConsulateUnit, 0.0);
   kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractConsulateUnitColonial, 0.0);

   // handled seperately in native monitor
   kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractNativeWarrior, 0.0);

   kbUnitPickRemovePreferenceFactor(gLandUnitPicker, cUnitTypeAbstractBannerArmy);static bool counterUnitMode = false;
   int unitPreferenceRandomizer = aiRandInt(10); // 0-9
   
   float enemyToCounter = aiGetMostHatedPlayerID();
   //float enemyToCounter = cPlayerRelationEnemyNotGaia;
   
   float lightInfantryCount = kbUnitCount(enemyToCounter, cUnitTypeAbstractHeavyInfantry, cUnitStateAlive) +
                              kbUnitCount(enemyToCounter, cUnitTypeAbstractLightCavalry, cUnitStateAlive); 
							  
   float heavyCavalryCount =  kbUnitCount(enemyToCounter, cUnitTypeAbstractRangedInfantry, cUnitStateAlive) - 
							  kbUnitCount(enemyToCounter, cUnitTypeAbstractMusketeer, cUnitStateAlive)+ 
							  kbUnitCount(enemyToCounter, cUnitTypeAbstractArtillery, cUnitStateAlive) +
							  kbUnitCount(enemyToCounter, cUnitTypeAbstractLancer, cUnitStateAlive);
							  
   float heavyInfantryCount = kbUnitCount(enemyToCounter, cUnitTypeAbstractCavalry, cUnitStateAlive) - 
							  kbUnitCount(enemyToCounter, cUnitTypeAbstractLancer, cUnitStateAlive) +
							  kbUnitCount(enemyToCounter, cUnitTypeAbstractLightInfantry, cUnitStateAlive) +
							  kbUnitCount(enemyToCounter, cUnitTypeAbstractHeavyCavalry, cUnitStateAlive);
   
   float lightCavalryCount =  kbUnitCount(enemyToCounter, cUnitTypeAbstractHeavyCavalry, cUnitStateAlive) + 
							  kbUnitCount(enemyToCounter, cUnitTypeAbstractLancer, cUnitStateAlive) +
							  kbUnitCount(enemyToCounter, cUnitTypeAbstractArtillery, cUnitStateAlive) +
							  kbUnitCount(enemyToCounter, cUnitTypeAbstractLightInfantry, cUnitStateAlive) +
							  kbUnitCount(enemyToCounter, cUnitTypeCuirassier, cUnitStateAlive);
							  
   float artilleryCount = 	  kbUnitCount(enemyToCounter, cUnitTypeAbstractInfantry, cUnitStateAlive);/* - 
							  kbUnitCount(enemyToCounter, cUnitTypeAbstractArtillery, cUnitStateAlive) -
							  kbUnitCount(enemyToCounter, cUnitTypeAbstractHeavyCavalry, cUnitStateAlive);*/
   
   float coreUnitCount = 	  kbUnitCount(enemyToCounter, cUnitTypeLogicalTypeLandMilitary, cUnitStateAlive);
   
   float totalEnemyCount =    lightInfantryCount + heavyCavalryCount + heavyInfantryCount + lightCavalryCount + artilleryCount;
   
   float MahoutCount =  	  kbUnitCount(enemyToCounter, cUnitTypeAbstractRangedInfantry, cUnitStateAlive) - 
							  kbUnitCount(enemyToCounter, cUnitTypeAbstractMusketeer, cUnitStateAlive)+ 
							  kbUnitCount(enemyToCounter, cUnitTypeAbstractArtillery, cUnitStateAlive) +
							  kbUnitCount(enemyToCounter, cUnitTypeAbstractLancer, cUnitStateAlive);
							  
   float HowdahCount =  	  kbUnitCount(enemyToCounter, cUnitTypeAbstractHeavyCavalry, cUnitStateAlive)+ 
							  kbUnitCount(enemyToCounter, cUnitTypeAbstractLancer, cUnitStateAlive) +
							  kbUnitCount(enemyToCounter, cUnitTypeAbstractArtillery, cUnitStateAlive) +
							  kbUnitCount(enemyToCounter, cUnitTypeAbstractLightInfantry, cUnitStateAlive) +
							  kbUnitCount(enemyToCounter, cUnitTypeCuirassier, cUnitStateAlive); 
							  
   float LancerCount =  	  kbUnitCount(enemyToCounter, cUnitTypeAbstractArtillery, cUnitStateAlive) +
							  kbUnitCount(enemyToCounter, cUnitTypeAbstractInfantry, cUnitStateAlive);
							  
   float SiegeTrooperCount =  kbUnitCount(enemyToCounter, cUnitTypeAbstractInfantry, cUnitStateAlive);
   
   float AbusGunCount = 	  kbUnitCount(enemyToCounter, cUnitTypeAbstractInfantry, cUnitStateAlive);
							  
   
   float JanissaryCount = 	  kbUnitCount(enemyToCounter, cUnitTypeAbstractHeavyInfantry, cUnitStateAlive) +
							  kbUnitCount(enemyToCounter, cUnitTypeAbstractLightInfantry, cUnitStateAlive) +
							  kbUnitCount(enemyToCounter, cUnitTypeAbstractCavalry, cUnitStateAlive);
							  
   float OttoHussarCount =    kbUnitCount(enemyToCounter, cUnitTypeAbstractRangedInfantry, cUnitStateAlive) - 
							  kbUnitCount(enemyToCounter, cUnitTypeAbstractMusketeer, cUnitStateAlive) +
							  kbUnitCount(enemyToCounter, cUnitTypeAbstractHeavyCavalry, cUnitStateAlive)+ 
							  kbUnitCount(enemyToCounter, cUnitTypeAbstractLancer, cUnitStateAlive) +
							  kbUnitCount(enemyToCounter, cUnitTypeAbstractArtillery, cUnitStateAlive) +
							  kbUnitCount(enemyToCounter, cUnitTypeCuirassier, cUnitStateAlive);
							  
   float CuirassierCount =    kbUnitCount(enemyToCounter, cUnitTypeAbstractRangedInfantry, cUnitStateAlive) - 
							  kbUnitCount(enemyToCounter, cUnitTypeWarWagon, cUnitStateAlive) - 
							  kbUnitCount(enemyToCounter, cUnitTypeDopplesoldner, cUnitStateAlive) - 
							  kbUnitCount(enemyToCounter, cUnitTypeypKensei, cUnitStateAlive) - 
							  kbUnitCount(enemyToCounter, cUnitTypeAbstractHowdah, cUnitStateAlive) +
							  kbUnitCount(enemyToCounter, cUnitTypeAbstractCavalry, cUnitStateAlive)+ 
							  kbUnitCount(enemyToCounter, cUnitTypeAbstractLancer, cUnitStateAlive) +
							  kbUnitCount(enemyToCounter, cUnitTypeAbstractArtillery, cUnitStateAlive) +
							  kbUnitCount(enemyToCounter, cUnitTypeCuirassier, cUnitStateAlive);
   
   float SamuraiCount = 	  kbUnitCount(enemyToCounter, cUnitTypeAbstractHandInfantry, cUnitStateAlive) +
							  kbUnitCount(enemyToCounter, cUnitTypeAbstractHeavyCavalry, cUnitStateAlive) -
							  kbUnitCount(enemyToCounter, cUnitTypeAbstractRangedInfantry, cUnitStateAlive) +
							  kbUnitCount(enemyToCounter, cUnitTypeAbstractLightInfantry, cUnitStateAlive) +
							  kbUnitCount(enemyToCounter, cUnitTypeCuirassier, cUnitStateAlive);
							  
   float EspadaCount = 	  	  kbUnitCount(enemyToCounter, cUnitTypeAbstractCavalry, cUnitStateAlive) -
							  kbUnitCount(enemyToCounter, cUnitTypeAbstractRangedInfantry, cUnitStateAlive) +
							  kbUnitCount(enemyToCounter, cUnitTypeAbstractLightInfantry, cUnitStateAlive) +
							  kbUnitCount(enemyToCounter, cUnitTypeCuirassier, cUnitStateAlive);
							  
   float JaguarKnightCount =  kbUnitCount(enemyToCounter, cUnitTypeAbstractHeavyInfantry, cUnitStateAlive) +
							  kbUnitCount(enemyToCounter, cUnitTypeAbstractHeavyCavalry, cUnitStateAlive) +
							  kbUnitCount(enemyToCounter, cUnitTypeAbstractLightInfantry, cUnitStateAlive) +
							  kbUnitCount(enemyToCounter, cUnitTypeCuirassier, cUnitStateAlive);
							  
   float RifleRiderCount = 	  kbUnitCount(enemyToCounter, cUnitTypeAbstractHeavyInfantry, cUnitStateAlive) +
							  kbUnitCount(enemyToCounter, cUnitTypeAbstractHeavyCavalry, cUnitStateAlive) +
							  kbUnitCount(enemyToCounter, cUnitTypeAbstractArtillery, cUnitStateAlive) +
							  kbUnitCount(enemyToCounter, cUnitTypeAbstractLightInfantry, cUnitStateAlive) +
							  kbUnitCount(enemyToCounter, cUnitTypeCuirassier, cUnitStateAlive);
   
   float TercioCount = 	  	  kbUnitCount(enemyToCounter, cUnitTypeAbstractHeavyCavalry, cUnitStateAlive) -
							  kbUnitCount(enemyToCounter, cUnitTypeAbstractRangedInfantry, cUnitStateAlive) +
							  kbUnitCount(enemyToCounter, cUnitTypeAbstractLightInfantry, cUnitStateAlive) +
							  kbUnitCount(enemyToCounter, cUnitTypeCuirassier, cUnitStateAlive);
							  							  
   float SiegeCount = 	  	  kbUnitCount(enemyToCounter, cUnitTypeTownCenter, cUnitStateAlive) +
							  kbUnitCount(enemyToCounter, cUnitTypeFortFrontier, cUnitStateAlive) +
							  kbUnitCount(enemyToCounter, cUnitTypedeIncaStronghold, cUnitStateAlive) +
							  kbUnitCount(enemyToCounter, cUnitTypedeKallanka, cUnitStateAlive) +
							  kbUnitCount(enemyToCounter, cUnitTypeCWallGate, cUnitStateAlive);
							  							  
   float CounterArtCount = 	  kbUnitCount(enemyToCounter, cUnitTypeAbstractArtillery, cUnitStateAlive) -
							  kbUnitCount(enemyToCounter, gAbstractCounterArtilleryUnit, cUnitStateAlive);
							  
   float AssassinCount = 	  kbUnitCount(enemyToCounter, cUnitTypeMercenary, cUnitStateAlive);
							  
   float BolasCount = 	  	  kbUnitCount(enemyToCounter, cUnitTypeAbstractCavalry, cUnitStateAlive) +
							  kbUnitCount(enemyToCounter, cUnitTypeAbstractLightInfantry, cUnitStateAlive); /*-
							  kbUnitCount(enemyToCounter, cUnitTypeAbstractInfantry, cUnitStateAlive);*/
   
   float ArrowKnightCount =   kbUnitCount(enemyToCounter, cUnitTypeAbstractArtillery, cUnitStateAlive); 
   
   float MantletCount =   	  kbUnitCount(enemyToCounter, cUnitTypeRanged, cUnitStateAlive); 
   
   float BowRiderCount = 	  kbUnitCount(enemyToCounter, cUnitTypeAbstractHeavyCavalry, cUnitStateAlive) + 
							  kbUnitCount(enemyToCounter, cUnitTypeAbstractLancer, cUnitStateAlive) +
							  kbUnitCount(enemyToCounter, cUnitTypeAbstractArtillery, cUnitStateAlive) +
							  kbUnitCount(enemyToCounter, cUnitTypeAbstractLightInfantry, cUnitStateAlive) +
							  kbUnitCount(enemyToCounter, cUnitTypeAbstractLightCavalry, cUnitStateAlive) +
							  kbUnitCount(enemyToCounter, cUnitTypeCuirassier, cUnitStateAlive);

   if (totalEnemyCount > 10)
   {  
      counterUnitMode = true;
      /* We see one of this player's units for the first time...let's do some analysis on it

         Setup the military unit preferences.  These are just various strategies of unit
         combos and what-not that are more or less setup to coincide with the bonuses
         and mainline units of each civ.  We start with a random choice.  If we have
         an enemy unit type to preference against, we override that random choice.
          
         0:  Counter infantry (i.e. enemyToCounter == cUnitTypeAbstractInfantry).
         1:  Counter artillery (i.e. enemyToCounter == cUnitTypeAbstractArtillery).
         2:  Counter cavalry (i.e. enemyToCounter == cUnitTypeAbstractCavalry).
      */
      
      // Calculate enemy's basic unit ratio and favor appropriate counters
      float lightInfantryFactor = lightInfantryCount * 2 / totalEnemyCount;
      float heavyInfantryFactor = heavyInfantryCount * 2 / totalEnemyCount;
      float JanissaryFactor = JanissaryCount * 2 / totalEnemyCount;
      float coreUnitFactor = coreUnitCount * 2 / totalEnemyCount;
      float TercioFactor = TercioCount * 2 / totalEnemyCount;
      float ArrowKnightFactor = ArrowKnightCount * 2 / totalEnemyCount;
      float JaguarKnightFactor = JaguarKnightCount * 2 / totalEnemyCount;
      float EspadaFactor = EspadaCount * 2 / totalEnemyCount;
      float BolasFactor = BolasCount * 1.5 / totalEnemyCount;
	  
      float CuirassierFactor = CuirassierCount * 2 / totalEnemyCount;
      float MantletFactor = MantletCount * 1.5 / totalEnemyCount;
      float lightCavalryFactor = lightCavalryCount * 2 / totalEnemyCount;
      float heavyCavalryFactor = heavyCavalryCount * 2 / totalEnemyCount;
      float MahoutFactor = MahoutCount * 2 / totalEnemyCount;
      float HowdahFactor = HowdahCount * 2 / totalEnemyCount;
      float LancerFactor = LancerCount * 2 / totalEnemyCount;
      float SiegeTrooperFactor = SiegeTrooperCount * 1.5 / totalEnemyCount;
      float AbusGunFactor = AbusGunCount * 1.5 / totalEnemyCount;
      float SamuraiFactor = SamuraiCount * 2 / totalEnemyCount;
      float RifleRiderFactor = RifleRiderCount * 2 / totalEnemyCount;
      float OttoHussarFactor = OttoHussarCount * 2 / totalEnemyCount;
      float SiegeFactor = SiegeCount * .5 / totalEnemyCount;
      float CounterArtFactor = CounterArtCount * .2 / totalEnemyCount;
      float artilleryFactor = artilleryCount * 0.5 / totalEnemyCount;
	  
      float AssassinFactor = AssassinCount * 2 / totalEnemyCount;
      float ShinobiFactor = lightInfantryCount * 2 / totalEnemyCount;
      float MercTercioFactor = TercioCount * 2 / totalEnemyCount;
      float MercAssassinFactor = AssassinCount * 2 / totalEnemyCount;
      float MerclightInfantryFactor = lightInfantryCount * 2 / totalEnemyCount;
      float MercJanissaryFactor = JanissaryCount * 2 / totalEnemyCount;
      float MercCuirassierFactor = CuirassierCount * 2 / totalEnemyCount;
      float MerclightCavalryFactor = lightCavalryCount * 2 / totalEnemyCount;
      float MercheavyCavalryFactor = heavyCavalryCount * 2 / totalEnemyCount;
      float MercLancerFactor = LancerCount * 2 / totalEnemyCount;
      float MercSamuraiFactor = SamuraiCount * 2 / totalEnemyCount;
      float MercartilleryFactor = artilleryCount * 0.5 / totalEnemyCount;
      float BowRiderFactor = BowRiderCount * 2 / totalEnemyCount;
	  
	  static int lastprompttime = 0;
	  static int lastprompttimecav = 0;
	  static int lastprompttimeart = 0;
	  /*
	  if ((xsGetTime() - lastprompttime) > 4*60*1000)
	  {
       if ( ((lightInfantryFactor >= 1.0) || (heavyInfantryFactor >= 1.0) || (JanissaryFactor >= 1.0) || (TercioFactor >= 1.0)) && (kbUnitCount(cMyID, cUnitTypeAbstractInfantry, cUnitStateABQ) > 9) )
	    {
	      sendStatement(cPlayerRelationAlly, cAICommPromptToAllyConfirmInf); 
	      lastprompttime = xsGetTime();
	    }
	  }
	  if ((xsGetTime() - lastprompttimecav) > 4*60*1000)
	  {
      if ( ((lightCavalryFactor >= 1.0) || (LancerFactor >= 1.0) || (heavyCavalryFactor >= 1.0)) && (kbUnitCount(cMyID, cUnitTypeAbstractCavalry, cUnitStateABQ) > 9) )
	    {
	      sendStatement(cPlayerRelationAlly, cAICommPromptToAllyConfirmCav); 
	      lastprompttimecav = xsGetTime();
	    }
	  }
	  if ((xsGetTime() - lastprompttimeart) > 4*60*1000)
	  {
      if ( (artilleryFactor >= 1.0) && (kbUnitCount(cMyID, cUnitTypeAbstractArtillery, cUnitStateABQ) > 1) )
	    {
         sendStatement(cPlayerRelationAlly, cAICommPromptToAllyConfirmArt);
	     lastprompttimeart = xsGetTime();
	    }
	  }
	 */
	 int age1 = 5;
	 int age2 = 5;
	 int age3 = 5;
	 int age4 = 5;
	 int age5 = 5;
	 int limit = 5;
     int age = kbGetAge();
	 switch (age)
   {
   case cAge1:
   {
      limit = age1;
      break;
   }
   case cAge2:
   {
      limit = age2;
      break;
   }
   case cAge3:
   {
      limit = age3;
      break;
   }
   case cAge4:
   {
      limit = age4;
      break;
   }
   case cAge5:
   {
      limit = age5;
      break;
   }
   }
	  if ((xsGetTime() - lastprompttime) > 4*60*1000)
	    {
	 if ((kbUnitCount(cMyID, cUnitTypeAbstractInfantry, cUnitStateABQ) > limit) && ((lightInfantryFactor >= 1.0) 
		 || (heavyInfantryFactor >= 1.0) || (JanissaryFactor >= 1.0) || (TercioFactor >= 1.0)))
         sendStatement(cPlayerRelationAlly, cAICommPromptToAllyConfirmInf);
	      lastprompttime = xsGetTime();
	    }
	  if ((xsGetTime() - lastprompttimecav) > 4*60*1000)
	    {
     if ((kbUnitCount(cMyID, cUnitTypeAbstractCavalry, cUnitStateABQ) > limit) && ((lightCavalryFactor >= 1.0) 
		 || (LancerFactor >= 1.0) || (heavyCavalryFactor >= 1.0)))
         sendStatement(cPlayerRelationAlly, cAICommPromptToAllyConfirmCav); 
	      lastprompttimecav = xsGetTime();
	    }
	  if ((xsGetTime() - lastprompttimeart) > 4*60*1000)
	    {
      if (kbUnitCount(cMyID, cUnitTypeAbstractArtillery, cUnitStateABQ) > 1)
         sendStatement(cPlayerRelationAlly, cAICommPromptToAllyConfirmArt); 
	     lastprompttimeart = xsGetTime();
	    }
		
	  if ((xsGetTime() - lastprompttimeart) > 4*60*1000)
	    {
      if (kbUnitCount(cMyID, cUnitTypeAbstractSiegeTrooper, cUnitStateABQ) > 5)
         sendStatement(cPlayerRelationAlly, cAICommPromptToAllyConfirmArt); 
	     lastprompttimeart = xsGetTime();
	    }
		 
      switch(kbGetCiv())
      { 
	  
          case cCivXPIroquois:
          {
             if (kbGetAge() > cAge2)
			 {
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypexpMusketWarrior, lightInfantryFactor); 
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypexpMusketRider, lightCavalryFactor); 
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypexpMantlet, MantletFactor);   
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypexpHorseman, heavyCavalryFactor*0);  
			 kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypexpAenna, lightInfantryFactor*0); 
			 kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypexpTomahawk, heavyInfantryFactor*0);  
			 }
			 else
			 {
			 kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypexpTomahawk, heavyInfantryFactor);    
			 kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypexpAenna, lightInfantryFactor);
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypexpHorseman, heavyCavalryFactor); 
			 }
             break;
          }
		  
          case cCivXPSioux:
          {
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypexpAxeRider, heavyCavalryFactor); 
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypexpBowRider, BowRiderFactor); 
		  
             if (kbGetAge() > cAge2)  
			 {
			 kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypexpRifleRider, RifleRiderFactor);
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypexpBowRider, lightInfantryFactor*0); 
			 }
			 else
			 {
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypexpBowRider, lightInfantryFactor); 
			 }
             break;
          }
		  
          case cCivXPAztec:
          {                                      
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypexpCoyoteMan, heavyCavalryFactor);
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypexpMacehualtin, lightInfantryFactor);
			 
             if (kbGetAge() > cAge2)
			 {
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypexpEagleKnight, lightCavalryFactor*2);  
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypexpEagleKnight, coreUnitFactor);  
			 kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypexpPumaMan, heavyInfantryFactor*0);  
			 }
			 else
			 {
			 kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypexpPumaMan, heavyInfantryFactor);  
			 }
             break;
          }
		  
          case cCivChinese:
          {
             if (kbGetAge() > cAge2)
			 {
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypImperialArmy, lightInfantryFactor);
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypImperialArmy, heavyCavalryFactor);
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypForbiddenArmy, heavyCavalryFactor*2);
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypTerritorialArmy, lightInfantryFactor);
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypTerritorialArmy, heavyInfantryFactor);
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypBlackFlagArmy, heavyInfantryFactor);
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypBlackFlagArmy, heavyCavalryFactor); 
			 }
			 else
			 {
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypStandardArmy, lightInfantryFactor);
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypStandardArmy, MahoutFactor);
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypMingArmy, SamuraiFactor);
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypMingArmy, lightCavalryFactor);
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypOldHanArmy, lightInfantryFactor);
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypOldHanArmy, heavyInfantryFactor);
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypMongolianArmy, lightCavalryFactor); 
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypMongolianArmy, heavyCavalryFactor); 
			 }
			 if (kbUnitCount(cMyID, cUnitTypeypFlameThrower, cUnitStateABQ) < 5)
			 {
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypFlameThrower, SiegeTrooperFactor); 
			 }			 
			 else
			 kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypFlameThrower, SiegeTrooperFactor*0);
			 kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractConsulateUnit, 0.0); 
             break;
          }
		  
          case cCivJapanese:
          {
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypAshigaru, heavyInfantryFactor);
			 kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypYumi, lightInfantryFactor);    
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypNaginataRider, heavyCavalryFactor);   
			 kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractConsulateUnit, 0.0); 
			 
             if (kbGetAge() > cAge2)
			 {
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypKensei, SamuraiFactor);
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypNaginataRider, heavyCavalryFactor); 
			 }       
             break;
          }
		  
          case cCivIndians:
          {                
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypSowar, heavyCavalryFactor); 
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypZamburak, lightCavalryFactor); 
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypNatMercGurkha, lightInfantryFactor);  
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypSepoy, heavyInfantryFactor);
			 kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractConsulateUnit, 0.0); 
			 
             if (kbGetAge() > cAge2)
			 {
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypMahout, MahoutFactor); 
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypHowdah, HowdahFactor); 
			 }   
             break;
          }
		  
          case cCivBritish:
          { 
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeMusketeer, heavyInfantryFactor);
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeHussar, heavyCavalryFactor);                  
             
			 if (kbGetAge() > cAge2)
			 {             
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeDragoon, lightCavalryFactor); 
			 //if (kbUnitCount(cMyID, gAbstractArtilleryUnit, cUnitStateABQ+cUnitStateAlive) < 7)
			 if (kbUnitCount(cMyID, gAbstractArtilleryUnit, cUnitStateABQ) < 7)
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, gAbstractArtilleryUnit, artilleryFactor);
		     else
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, gAbstractArtilleryUnit, artilleryFactor*0);
             }
			 
			 if (((kbGetAge() > cAge3) && (kbTechGetStatus(cTechHCImprovedLongbows) == cTechStatusActive)) || (kbGetAge() < cAge3))
			 {             
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeLongbowman, lightInfantryFactor); 
             }
			 else
			 {
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeLongbowman, lightInfantryFactor*0); 
			 }
             break;
          }
          case cCivFrench:
          {
             if (kbGetAge() > cAge2)
			 {  
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeCuirassier, CuirassierFactor);   
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeSkirmisher, lightInfantryFactor);
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeMusketeer, lightInfantryFactor*0);   
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeHussar, heavyCavalryFactor*0); 
			 }
			 else
			 {
			 kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeMusketeer, lightInfantryFactor);   
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeHussar, heavyCavalryFactor);
			 }
			 
			 if ((kbGetAge() == cAge3) || (kbGetAge() == cAge4))
			 {
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeDragoon, lightCavalryFactor);  
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeMusketeer, heavyInfantryFactor); 
			 }	
			 else
			 {
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeDragoon, lightCavalryFactor*0);  
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeMusketeer, heavyInfantryFactor*0); 
			 }
             break;
           }
		   
           case cCivDutch:
           {  
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeSkirmisher, lightInfantryFactor);    

			 if (kbGetAge() > cAge2)
			 {
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeRuyter, lightCavalryFactor*2);          
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeHussar, OttoHussarFactor*0);           
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeHussar, heavyCavalryFactor);
			 if (kbUnitCount(cMyID, gAbstractArtilleryUnit, cUnitStateABQ) < 7)
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, gAbstractArtilleryUnit, artilleryFactor);
		     else
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, gAbstractArtilleryUnit, artilleryFactor*0);
			 }
			 else
			 {          
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeHussar, OttoHussarFactor); 
			 }
             break;   
           }
		   
           case cCivSpanish:
           {
			 if (kbGetAge() < cAge4)
			 {  
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeMusketeer, lightInfantryFactor);  
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypePikeman, TercioFactor);
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeRodelero, EspadaFactor);  
			 }
			 else
			 {  
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeMusketeer, lightInfantryFactor*0);  
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypePikeman, TercioFactor*0);
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeRodelero, EspadaFactor*0);  
			 }
			 
             if (kbGetAge() > cAge3)
			 {  
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeSkirmisher, lightInfantryFactor); 
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeMusketeer, heavyInfantryFactor);
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeDragoon, lightCavalryFactor);  
			 }
			 
             if (kbGetAge() > cAge2)
			 {  
			 kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeHussar, heavyCavalryFactor*0);
			 kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeLancer, LancerFactor);
			 }
			 else
			 {
			 kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeHussar, heavyCavalryFactor);
			 }
              break;
           }
		   
           case cCivGermans:
           {         
             if (kbGetAge() < cAge3)
			 {  
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeCrossbowman, lightInfantryFactor);    
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeUhlan, OttoHussarFactor);  
			 }
			 else
			 {  
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeCrossbowman, lightInfantryFactor*0);    
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeUhlan, OttoHussarFactor*0);    
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeUhlan, heavyCavalryFactor);  
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeSkirmisher, lightInfantryFactor); 
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeWarWagon, lightCavalryFactor); 
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeDopplesoldner, SamuraiFactor); 
			 }
             break;
           }
		   
           case cCivRussians:
           {
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeCossack, OttoHussarFactor);                
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeMusketeer, heavyInfantryFactor);
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeStrelet, lightInfantryFactor);  
			 break;
           }
		   
           case cCivPortuguese:
           {
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeMusketeer, heavyInfantryFactor);     
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeHussar, heavyCavalryFactor);  
			 
             if (kbGetAge() < cAge3)
			 {  
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeMusketeer, lightInfantryFactor);      
			 }
			 else
			 {
			 kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeMusketeer, lightInfantryFactor*0);    
			 kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeCacadore, lightInfantryFactor);        
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeDragoon, lightCavalryFactor);  
			 if (kbUnitCount(cMyID, gAbstractArtilleryUnit, cUnitStateABQ) < 7)
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, gAbstractArtilleryUnit, artilleryFactor);
		     else
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, gAbstractArtilleryUnit, artilleryFactor*0);
			 }			 
			 break;                
           }
		   
           case cCivOttomans:
           {
			    
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeJanissary, JanissaryFactor); 
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeHussar, OttoHussarFactor);  
			 if (kbGetAge() > cAge2)
			 {
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbusGun, AbusGunFactor);
			 }
			 else
			 {
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbusGun, AbusGunFactor*0);
			 if (kbUnitCount(cMyID, gAbstractArtilleryUnit, cUnitStateABQ) < 7)
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, gAbstractArtilleryUnit, artilleryFactor);
		     else
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, gAbstractArtilleryUnit, artilleryFactor*0);
			 }   
             break;       
           }
		   
		   case cCivDESwedish:
           {         
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypedeCarolean, JanissaryFactor); 
			 if (kbUnitCount(cMyID, cUnitTypedeLeatherCannon, cUnitStateABQ) < 10)
			 {
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypedeLeatherCannon, artilleryFactor);
			 }
			 else
			 kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypedeLeatherCannon, artilleryFactor*0);
			
             if (kbGetAge() < cAge3)
			 {  
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeHussar, heavyCavalryFactor); 
			 }
			 else
			 {
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypedeFinnishRider, heavyCavalryFactor); 
			 kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeHussar, heavyCavalryFactor*0); 
			 }
             break;
           }
		   
		   case cCivDEInca:
           {         
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypedeJungleBowman, lightInfantryFactor); 
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypedeIncaRunner, heavyCavalryFactor);
			 kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypedeChasqui, 0.0);
			 
             if ((kbGetAge() > cAge2) || (kbTechGetStatus(cTechDEHCEarlyKallanka) == cTechStatusActive))
			 {      
			 kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypedeIncaSpearman, heavyInfantryFactor*0);  
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypedeIncaSpearman, TercioFactor); 
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypedeBolasWarrior, BolasFactor); 
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypedeSlinger, SiegeTrooperFactor); 
			 }
			 else
			 {
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypedeIncaSpearman, heavyInfantryFactor);  
			 }
             break;
           }
		   
		   
		   case cCivDEAmericans:
           {         
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypedeRegular, heavyInfantryFactor); 
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeHussar, heavyCavalryFactor);  
			 if (kbTechGetStatus(cTechDEHCLegionHungarian) == cTechStatusActive)
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypedeLegionMagyarHussar, heavyCavalryFactor*2);
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypedeStateMilitia, lightInfantryFactor);  
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractOutlaw, 0.1);  
			 
			 
             if (kbGetAge() < cAge3)
			 {/*      
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypedeStateMilitia, lightInfantryFactor);  
			 }
			 else
			 {
			 kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypedeStateMilitia, lightInfantryFactor*0);  
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypedeRifleman, lightInfantryFactor); 
			 */
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypedeUSCavalry, lightCavalryFactor);  
			 }
             break;
           }
		   
		   
		   case cCivDEEthiopians:
           {         
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypedeGascenya, heavyInfantryFactor); 
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypedeNeftenya, lightInfantryFactor);  
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypedeJavelinRider, lightCavalryFactor);  
			
			if (kbGetAge() < cAge3)
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypedeShotelWarrior, heavyCavalryFactor); 
			 else
			 {
			 kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypedeShotelWarrior, heavyCavalryFactor*0);
			 kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypedeOromoWarrior, heavyCavalryFactor*0.25);
			 }			 
             break;
           }
		   
		   
		   case cCivDEHausa:
           {         
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypedeFulaWarrior, lightInfantryFactor);  
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypedeJavelinRider, lightCavalryFactor);  
			
			if (kbGetAge() < cAge3)
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypedeRaider, heavyCavalryFactor); 
			 else
			 {
			 kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypedeRaider, heavyCavalryFactor*0);
			 kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypedeLifidi, heavyCavalryFactor);
			 }			 
             break;
           }
		   
		   
       } 
	   
	   if (civIsNative() == false)
	   {
	   if ((kbGetAge() < cAge5) || (civIsAfrican() == true) || ((kbGetAge() == cAge5) && (kbTechGetStatus(cTechDEPoliticianMercContractor) == cTechStatusActive)) || ((kbGetAge() == cAge5) && (kbTechGetStatus(cTechDEPoliticianFederalNewYork) == cTechStatusActive)))
		{

			 /*if ((kbGetAge() >= cAge3) && (kbUnitCount(cMyID, gAbstractCounterArtilleryUnit, cUnitStateABQ) < 3)
			 && (kbUnitCount(cMyID, gAbstractCounterArtilleryUnit, cUnitStateAlive) < 3))
			 {
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, gAbstractCounterArtilleryUnit, CounterArtFactor);
			 }*/	
	     // if (civIsNative() == false)
		// {
			/*if (civIsEuropean() == true)
			{
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, gAbstractAssassinUnit, AssassinFactor);
			}*/
			 
			 
         
			 
			 /*if (kbTechGetStatus(cTechSaloonNinja) == cTechStatusActive)
			 {
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeMercNinja, MercAssassinFactor * 1.625);
			 }*/
			 if (kbTechGetStatus(cTechSaloonMameluke) == cTechStatusActive)
			 {
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeMercMameluke, MercCuirassierFactor * 2.0);
			 }
			 if (kbTechGetStatus(cTechDESaloonSudaneseRider) == cTechStatusActive)
			 {
			 kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypedeMercSudaneseRider, MercCuirassierFactor * 1.0);
             }
			 if (kbTechGetStatus(cTechDESaloonCannoneer) == cTechStatusActive)
			 {
			 kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypedeMercCannoneer, MerclightInfantryFactor * 2);
             }
			 if (kbTechGetStatus(cTechDESaloonAskari) == cTechStatusActive)
			 {
			 kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypedeMercAskari, MercJanissaryFactor * 1.625);
             }
			 if (kbTechGetStatus(cTechDESaloonAmazon) == cTechStatusActive)
			 {
			 kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypedeMercAmazon, MerclightInfantryFactor * 1.625);
             }
			 if (kbTechGetStatus(cTechDESaloonZenata) == cTechStatusActive)
			 {
			 kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypedeMercZenata, MerclightCavalryFactor * 1.625);
             }
			 if (kbTechGetStatus(cTechDESaloonGatlingCamel) == cTechStatusActive)
			 {
			 kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypedeMercGatlingCamel, MercLancerFactor * 2.5);
             }
			 if (kbTechGetStatus(cTechDESaloonKanuri) == cTechStatusActive)
			 {
			 kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypedeMercKanuri, MerclightCavalryFactor * 1.625);
             }
			 if (kbTechGetStatus(cTechSaloonHackapell) == cTechStatusActive)
			 {
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeMercHackapell, MercheavyCavalryFactor * 1.625);
             }
			 if (kbTechGetStatus(cTechdeSaloonHarquebusier) == cTechStatusActive)
			 {
			 kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypedeMercHarquebusier, MercheavyCavalryFactor * 1.625);
             }
			 if (kbTechGetStatus(cTechSaloonStradiot) == cTechStatusActive)
			 {
			 kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeMercStradiot, MercheavyCavalryFactor * 0.5);
             }
			 if (kbTechGetStatus(cTechypSaloonJat) == cTechStatusActive)
			 {
			 kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypMercJatLancer, MercLancerFactor * 0.5);
             }
			 if (kbTechGetStatus(cTechSaloonElmeti) == cTechStatusActive)
			 {
			 kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeMercElmeti, MercLancerFactor * 1.625);
             }
			 if (kbTechGetStatus(cTechSaloonManchu) == cTechStatusActive)
			 {
			 kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeMercManchu, MerclightCavalryFactor * 1.625);
             }
			 if (kbTechGetStatus(cTechypSaloonYojimbo) == cTechStatusActive)
			 {
			 kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypMercYojimbo, MerclightCavalryFactor * 1.625);
             }
			 if (kbTechGetStatus(cTechSaloonBlackRider) == cTechStatusActive)
			 {
			 kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeMercBlackRider, MerclightCavalryFactor * 1.625);
             }
			 if (kbTechGetStatus(cTechSaloonHighlander) == cTechStatusActive)
			 {
			 kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeMercHighlander, MercJanissaryFactor * 1.625);
             }
			 if (kbTechGetStatus(cTechSaloonFusilier) == cTechStatusActive)
			 {
			 kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeMercFusilier, MercJanissaryFactor * 1.625);
             }
			 if (kbTechGetStatus(cTechSaloonCorsair) == cTechStatusActive)
			 {
			 kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeMercBarbaryCorsair, MercTercioFactor * 0.5);
             }
			 if (kbTechGetStatus(cTechSaloonSwissPikeman) == cTechStatusActive)
			 {
			 kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeMercSwissPikeman, MercTercioFactor * 1.625);
             }
			 if (kbTechGetStatus(cTechSaloonLandsknecht) == cTechStatusActive)
			 {
			 kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeMercLandsknecht, MercTercioFactor * 1.625);
             }
			 //if (kbTechGetStatus(cTechypSaloonArsonist) == cTechStatusActive)
			 //{
			 //kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypMercArsonist, MerclightInfantryFactor * 1.625);
             //}
			 if (kbTechGetStatus(cTechypSaloonIronTroop) == cTechStatusActive)
			 {
			 kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypMercIronTroop, MerclightInfantryFactor * 1.625);
             }
			 if (kbTechGetStatus(cTechSaloonJaeger) == cTechStatusActive)
			 {
			 kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeMercJaeger, ShinobiFactor * 1.625);
             }
			 if (kbTechGetStatus(cTechSaloonGreatCannon) == cTechStatusActive)
			 {
			 kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeMercGreatCannon, MercartilleryFactor * 1.625);
             }
			 if (kbTechGetStatus(cTechSaloonRonin) == cTechStatusActive)
			 {
			 kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeMercRonin, MercSamuraiFactor * 1.625);
			 }
			}
			else
			kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeMercenary, 0.0);
	        if ((civIsAfrican() == false) && ((kbUnitCount(cMyID, cUnitTypeMercenary, cUnitStateAlive) + (kbUnitCount(cMyID, cUnitTypeMercenary, cUnitStateAlive)) < 11)))
			kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeMercenary, 0.0);
		}
		
			 if (gRevolutionType != 0)
			 {
			 if (kbTechGetStatus(cTechDEHCREVHajduks) == cTechStatusActive)
			 {
			 kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeSaloonOutlawRifleman, MerclightInfantryFactor * 1.0);
			 }
			 
			 if (kbTechGetStatus(cTechDEHCREVChinacos) == cTechStatusActive)
			 {
			 kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeSaloonOutlawRifleman, MerclightInfantryFactor * 1.0);
			 }
			 if (kbTechGetStatus(cTechDEHCREVCharros) == cTechStatusActive)
			 {
			 kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypedeREVVaquero, MerclightCavalryFactor * 1.0);
			 }
			 
			 if (kbTechGetStatus(cTechDEHCREVGranaderos) == cTechStatusActive)
			 {
			 kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypedeREVGranadero, coreUnitFactor * 1.0);
			 }
			 
			 if (kbTechGetStatus(cTechDEREVMagyarHussarAlt) == cTechStatusActive)
			 {
			 kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeHussar, coreUnitFactor * 1.0);
			 }
			 if (kbTechGetStatus(cTechDERevolutionChile) == cTechStatusActive)
			 {
			 kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeHussar, coreUnitFactor * 1.0);
			 }
			 
			 if (kbTechGetStatus(cTechDERevolutionHaiti) == cTechStatusActive)
			 {
			 kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeSaloonPirate, coreUnitFactor * 1.0);
			 }
			 
			 if (kbTechGetStatus(cTechDERevolutionColombia) == cTechStatusActive)
			 {
			 kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeMusketeer, MercJanissaryFactor * 1.0);
			 }
			 
			 kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypedeREVLlanero, MercLancerFactor * 1.0);
			 kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypedeREVJagunco, RifleRiderFactor * 1.0);
			 kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypedeREVGaucho,  MerclightCavalryFactor * 1.0);
			 kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypedeREVBarbaryWarrior, MercTercioFactor * 1.0);
			 kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypedeREVBarbaryMarksman, MerclightInfantryFactor * 1.0);
			 kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypedeREVJavaSpearman, MercTercioFactor * 1.0);
			 kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypedeREVCetbang, MercartilleryFactor * 1.0);
			 kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypexpGatlingGun, MercartilleryFactor * 1.0);
			 kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypedeNizam, coreUnitFactor * 1.5);
			 //kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypedeNizam, MercJanissaryFactor * 1.5);
			 kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypexpColonialMilitia, MercJanissaryFactor * 1.0);
			}
		
			 /*
			 if (civIsEuropean() == true)
			 {
			 if ((kbGetAge() >= cAge2) && ((kbUnitCount(cMyID, gAbstractArtilleryUnit, cUnitStateAlive) + (kbUnitCount(cMyID, gAbstractArtilleryUnit, cUnitStateAlive)) < 5)))
			 {  
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, gAbstractArtilleryUnit, artilleryFactor); 
			 }
			 else
			 kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeFalconet, artilleryFactor*0); 
			 
             if ((kbGetAge() >= cAge4) && ((kbUnitCount(cMyID, cUnitTypexpHorseArtillery, cUnitStateAlive) + (kbUnitCount(cMyID, cUnitTypexpHorseArtillery, cUnitStateAlive)) < 5)))
			 {
			 kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypexpHorseArtillery, artilleryFactor); 
			 }
			 else
			 kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypexpHorseArtillery, artilleryFactor*0); 
			 }
			 
			 
			 if ((kbGetAge() >= cAge3) && ((kbUnitCount(cMyID, gSiegeWeaponUnit, cUnitStateAlive) + (kbUnitCount(cMyID, gSiegeWeaponUnit, cUnitStateAlive)) < 5)))
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, gSiegeWeaponUnit, SiegeFactor * 1);
			 else
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, gSiegeWeaponUnit, SiegeFactor * 0);
			 */
			 
			  /*
             if ((kbGetAge() > cAge1) && (kbUnitCount(cMyID, cUnitTypeAbstractPet, cUnitStateAlive) >= kbGetBuildLimit(cMyID, cUnitTypeAbstractPet)))
			 {
			 kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractPet, 1.0);
			 }
			 else
			 {
			 kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractPet, 0.0);
			 }
			 */
			 
			if (gSPC == true) 
           {
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractHeavyInfantry, heavyInfantryFactor);
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractHeavyCavalry, heavyCavalryFactor);   
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractLancer, LancerFactor);               
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractLightCavalry, lightCavalryFactor); 
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractRangedInfantry, lightInfantryFactor); 
			 kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeLogicalTypeLandMilitary, coreUnitFactor*.25); 
           }
	return;     
    }

    if (counterUnitMode == false)
    {   
       // No commands active. Go with our default biases...
       setStandardArmyPreference();
       //if (civIsAsian() == true)
       //{ 
          // Set preferences for consulate units
          //setConsulateArmyPreference();
       //}      
   }
}

//==============================================================================
// initUnitPicker
//==============================================================================
int initUnitPicker(string name = "BUG", int numberTypes = 1, int minUnits = 10, int maxUnits = 20, int minPop = -1,
                   int maxPop = -1, int numberBuildings = 1, bool guessEnemyUnitType = false)
{
   // Create it.
   int upID = kbUnitPickCreate(name);
   if (upID < 0)
      return (-1);

   // Default init.
   kbUnitPickResetAll(upID);

   kbUnitPickSetPreferenceWeight(upID, 1.0);
   if (gSPC == false)
   {
      kbUnitPickSetCombatEfficiencyWeight(upID, 1.0); // Changed from 1.0 to dilute the power of the preference weight.
      kbUnitPickSetBuildingCombatEfficiencyWeight(upID, 0.0);
   }
   else
   {
      kbUnitPickSetCombatEfficiencyWeight(upID, 1.0); // Leave it at 1.0 to avoid messing up SPC balance
      kbUnitPickSetBuildingCombatEfficiencyWeight(upID, 0.0);
   }
   kbUnitPickSetCostWeight(upID, 0.0);
   // Desired number units types, buildings.
   kbUnitPickSetDesiredNumberUnitTypes(upID, numberTypes, numberBuildings, true);
   // Min/Max units and Min/Max pop.
   kbUnitPickSetMinimumNumberUnits(upID, minUnits); // Sets "need" level on attack plans
   kbUnitPickSetMaximumNumberUnits(upID,
                                   maxUnits); // Sets "max" level on attack plans, sets "numberToMaintain" on train
                                              // plans for primary unit, half that for secondary, 1/4 for tertiary, etc.
   kbUnitPickSetMinimumPop(upID, minPop);     // Not sure what this does...
   kbUnitPickSetMaximumPop(upID,
                           maxPop); // If set, overrides maxNumberUnits for how many of the primary unit to maintain.

   // Default to land units.
   kbUnitPickSetEnemyPlayerID(upID, aiGetMostHatedPlayerID());
   kbUnitPickSetAttackUnitType(upID, cUnitTypeLogicalTypeLandMilitary);
   kbUnitPickSetGoalCombatEfficiencyType(upID, cUnitTypeLogicalTypeLandMilitary);

   // Set the default target types and weights, for use until we've seen enough actual units.
   // kbUnitPickAddCombatEfficiencyType(upID, cUnitTypeLogicalTypeLandMilitary, 1.0);
   kbUnitPickAddCombatEfficiencyType(upID, cUnitTypeSettler,
                                     0.2); // We need to build units that can kill settlers efficiently.
   kbUnitPickAddCombatEfficiencyType(upID, cUnitTypeHussar, 0.0);      // Major component
   kbUnitPickAddCombatEfficiencyType(upID, cUnitTypeMusketeer, 0.0);   // Bigger component
   kbUnitPickAddCombatEfficiencyType(upID, cUnitTypePikeman, 0.0);     // Minor component
   kbUnitPickAddCombatEfficiencyType(upID, cUnitTypeCrossbowman, 0.0); // Minor component

   kbUnitPickAddBuildingCombatEfficiencyType(upID, cUnitTypeMilitaryBuilding, 0.0);
   kbUnitPickAddBuildingCombatEfficiencyType(upID, cUnitTypeAbstractTownCenter, 0.0);

   setUnitPickerPreference(upID); // Set generic preferences for this civ

   // Done.
   return (upID);
}
int getMatchTarget()    // Find an enemy player buildingID to attack.
{
   int count = 0;
   int retVal = -1;
   static int unitQueryID = -1;

   //If we don't have the query yet, create one.
   if (unitQueryID < 0)
   {
      unitQueryID=kbUnitQueryCreate("navy target count");
      kbUnitQuerySetIgnoreKnockedOutUnits(unitQueryID, true);
      kbUnitQuerySetPlayerRelation(unitQueryID, cPlayerRelationEnemyNotGaia);
   }     
   kbUnitQuerySetUnitType(unitQueryID, cUnitTypeBuilding);
   kbUnitQuerySetState(unitQueryID, cUnitStateABQ);
   kbUnitQueryResetResults(unitQueryID);
   count = kbUnitQueryExecute(unitQueryID); 
   //aiEcho("Enemy building: "+ count);
   if (count > 0)
   {
      retVal = kbUnitGetPlayerID(kbUnitQueryGetResult(unitQueryID,0));
   }
   
   return(retVal);
}


rule siegeWeaponMonitor
inactive
mininterval 60
{
   if (aiTreatyActive() == true)
   {
      aiEcho("delayed because treaty is active.");
      return;
   }
   
     bool homeBaseUnderAttack = false;
	  if (gDefenseReflexBaseID == kbBaseGetMainID(cMyID))
      homeBaseUnderAttack = true;


   static int mortarPlan = -1;    
   static int ypHandMortarPlan = -1;
   static int ypMorutaruPlan = -1;
   static int ypSiegeElephantPlan = -1;
   static int ArrowKnightPlan = -1;
   static int HauracaPlan = -1;
   static int xpRamPlan = -1;   
   static int gAbstractArtilleryUnitPlan1 = -1;  
   static int gAbstractArtilleryUnitPlan2 = -1;  
   static int gAbstractArtilleryUnitPlan3 = -1;  
   
      if ((kbGetCiv() != cCivIndians) && (cMyCiv != cCivDEInca) && (cMyCiv != cCivXPSioux))
    { 
   if ((kbGetAge() == cAge3) && (cMyCiv != cCivXPIroquois)) //&& (xsArrayGetFloat(gResourceNeeds, cResourceGold) < +800.0))
   {    
      if (gAbstractArtilleryUnitPlan1 < 0)
      {  gAbstractArtilleryUnitPlan1 = createSimpleMaintainPlan(gAbstractArtilleryUnit, 2, true, kbBaseGetMainID(cMyID), 2);  }
      else
      {  aiPlanSetVariableInt(gAbstractArtilleryUnitPlan1, cTrainPlanNumberToMaintain, 0, 2); }
    }
	else
	{
	aiPlanDestroy(gAbstractArtilleryUnitPlan1);
	}
	
	if (kbGetAge() == cAge4)
   {    
      if (gAbstractArtilleryUnitPlan2 < 0)
      {  gAbstractArtilleryUnitPlan2 = createSimpleMaintainPlan(gAbstractArtilleryUnit, 3, true, kbBaseGetMainID(cMyID), 3);  }
      else
      {  aiPlanSetVariableInt(gAbstractArtilleryUnitPlan2, cTrainPlanNumberToMaintain, 0, 3); }
    }
	else
	{
	aiPlanDestroy(gAbstractArtilleryUnitPlan2);
	}
	
	if (kbGetAge() > cAge4) //&& (xsArrayGetFloat(gResourceNeeds, cResourceGold) < +800.0))
   {    
      if (gAbstractArtilleryUnitPlan3 < 0)
      {  gAbstractArtilleryUnitPlan3 = createSimpleMaintainPlan(gAbstractArtilleryUnit, 5, true, kbBaseGetMainID(cMyID), 5);  }
      else
      {  aiPlanSetVariableInt(gAbstractArtilleryUnitPlan3, cTrainPlanNumberToMaintain, 0, 5); }
    }
	}
	
	
   if ((kbGetAge() > cAge3) && (homeBaseUnderAttack == false)) //&& (xsArrayGetFloat(gResourceNeeds, cResourceGold) < +800.0))
  {
   if (civIsNative() == true)
    {     
		if (cMyCiv == cCivXPIroquois)
		{
      if (xpRamPlan < 0)
      {  xpRamPlan = createSimpleMaintainPlan(cUnitTypexpRam, 5, true, kbBaseGetMainID(cMyID), 5);  }
      else
      {  aiPlanSetVariableInt(xpRamPlan, cTrainPlanNumberToMaintain, 0, 5); }
		}
		if (cMyCiv == cCivXPAztec)
		{
      if (ArrowKnightPlan < 0)
      {  ArrowKnightPlan = createSimpleMaintainPlan(cUnitTypexpArrowKnight, 5, true, kbBaseGetMainID(cMyID), 5);  }
      else
      {  aiPlanSetVariableInt(ArrowKnightPlan, cTrainPlanNumberToMaintain, 0, 5); }
		}
		if (cMyCiv == cCivDEInca)
		{
      if (HauracaPlan < 0)
      {  HauracaPlan = createSimpleMaintainPlan(cUnitTypedeSlinger, 5, true, kbBaseGetMainID(cMyID), 5);  }
      else
      {  aiPlanSetVariableInt(HauracaPlan, cTrainPlanNumberToMaintain, 0, 5); }
		}
	}
   if (civIsEuropean() == true)
    {
      if (mortarPlan < 0)
      {  mortarPlan = createSimpleMaintainPlan(cUnitTypeMortar, 2, true, kbBaseGetMainID(cMyID), 2);  }
      else
      {  aiPlanSetVariableInt(mortarPlan, cTrainPlanNumberToMaintain, 0, 2); }
    }
	if (civIsNative() == true)
    {
      if (mortarPlan < 0)
      {  mortarPlan = createSimpleMaintainPlan(cUnitTypeMortar, 2, true, kbBaseGetMainID(cMyID), 2);  }
      else
      {  aiPlanSetVariableInt(mortarPlan, cTrainPlanNumberToMaintain, 0, 2); }
    }
   if (civIsAsian() == true)
    {
      if ( (kbGetCiv() == cCivChinese) || (kbGetCiv() == cCivSPCChinese) )
      {
         if (ypHandMortarPlan < 0)
         {  ypHandMortarPlan = createSimpleMaintainPlan(cUnitTypeypHandMortar, 10, true, kbBaseGetMainID(cMyID), 10);  }
         else
         {  aiPlanSetVariableInt(ypHandMortarPlan, cTrainPlanNumberToMaintain, 0, 10); }
      }
      if (((kbGetCiv() == cCivSPCJapanese)||(kbGetCiv() == cCivJapanese)||(kbGetCiv() == cCivSPCJapaneseEnemy)))
      {  
         if (ypMorutaruPlan < 0)
         {  ypMorutaruPlan = createSimpleMaintainPlan(cUnitTypeypMorutaru, 2, true, kbBaseGetMainID(cMyID), 2);  }
         else
         {  aiPlanSetVariableInt(ypMorutaruPlan, cTrainPlanNumberToMaintain, 0, 2); }
      }
      if ( (kbGetCiv() == cCivIndians) || (kbGetCiv() == cCivSPCIndians) )
      {
         if (ypSiegeElephantPlan < 0)
         {  ypSiegeElephantPlan = createSimpleMaintainPlan(cUnitTypeypSiegeElephant, 2, true, kbBaseGetMainID(cMyID), 2);  }
         else
         {  aiPlanSetVariableInt(ypSiegeElephantPlan, cTrainPlanNumberToMaintain, 0, 2); }
      }           
    }
  }
  
   if (homeBaseUnderAttack == true)
  {
	  aiPlanDestroy(xpRamPlan);
	  aiPlanDestroy(ArrowKnightPlan);
	  aiPlanDestroy(HauracaPlan);
	  aiPlanDestroy(mortarPlan);
	  aiPlanDestroy(ypHandMortarPlan);
	  aiPlanDestroy(ypMorutaruPlan);
	  aiPlanDestroy(ypSiegeElephantPlan);
  }
  
  return;
}



rule siegeWeaponManager
inactive
mininterval 10
{     

   if (aiTreatyActive() == true)
   {
      aiEcho("delayed because treaty is active.");
      return;
   }
   
   
   if (kbUnitCount(cMyID, gSiegeWeaponUnit, cUnitStateAlive) < 1)
   {
   xsSetRuleMinIntervalSelf(60);
      return;
   }
   else
   {
   xsSetRuleMinIntervalSelf(5);
   }
   
   /*
   static int gAbstractArtilleryUnitPlan = -1;   
   
   static int gSiegeWeaponUnitPlan = -1;   
   
   if ((kbGetAge() >= cAge4) && (kbGetCiv() != cCivIndians) && (cMyCiv != cCivXPAztec) && (cMyCiv != cCivXPSioux))
   {     
      if (gAbstractArtilleryUnitPlan < 0)
      {  gAbstractArtilleryUnitPlan = createSimpleMaintainPlan(gAbstractArtilleryUnit, 2, true, kbBaseGetMainID(cMyID), 2);  }
      else
      {  aiPlanSetVariableInt(gAbstractArtilleryUnitPlan, cTrainPlanNumberToMaintain, 0, 2); }
   }
   

   if ((kbGetAge() >= cAge4) && (kbGetCiv() != cCivIndians) && (cMyCiv != cCivXPAztec) && (cMyCiv != cCivXPSioux))
   {     
      if (gSiegeWeaponUnitPlan < 0)
      {  gSiegeWeaponUnitPlan = createSimpleMaintainPlan(gSiegeWeaponUnit, 2, true, kbBaseGetMainID(cMyID), 2);  }
      else
      {  aiPlanSetVariableInt(gSiegeWeaponUnitPlan, cTrainPlanNumberToMaintain, 0, 2); }
   }
   */
   
  
   vector siegeWeaponVec = cInvalidVector;
   
   int siegeWeaponUnit = getUnit(gSiegeWeaponUnit, cMyID, cUnitStateAlive);   
      
   if (siegeWeaponUnit >= 0)
      siegeWeaponVec = kbUnitGetPosition(siegeWeaponUnit);
   else
      siegeWeaponVec = kbBaseGetMilitaryGatherPoint(cMyID, kbBaseGetMainID(cMyID));  
       
   int numUnit = kbUnitCount(cMyID, gSiegeWeaponUnit, cUnitStateAlive);
   if (kbUnitCount(cMyID, gSiegeWeaponUnit, cUnitStateAlive) > 0) 
   { 
      if (getMatchTarget() >= 0)  // There's something to attack :)
      {
         int attackPlan = aiPlanCreate("Mortar Attack plan", cPlanAttack);
         aiPlanSetVariableInt(attackPlan, cAttackPlanPlayerID, 0, getMatchTarget());
         aiPlanSetNumberVariableValues(attackPlan, cAttackPlanTargetTypeID, 14, true);
         aiPlanSetVariableInt(attackPlan, cAttackPlanTargetTypeID, 0, cUnitTypeypShrineJapanese);
         aiPlanSetVariableInt(attackPlan, cAttackPlanTargetTypeID, 1, cUnitTypedeTorp);
         aiPlanSetVariableInt(attackPlan, cAttackPlanTargetTypeID, 2, cUnitTypedeTorpGeneric);
         aiPlanSetVariableInt(attackPlan, cAttackPlanTargetTypeID, 3, cUnitTypeTradingPost);
         aiPlanSetVariableInt(attackPlan, cAttackPlanTargetTypeID, 4, cUnitTypeFortFrontier);
         aiPlanSetVariableInt(attackPlan, cAttackPlanTargetTypeID, 5, gTowerUnit);
         aiPlanSetVariableInt(attackPlan, cAttackPlanTargetTypeID, 6, gMilitaryBuildings);
         aiPlanSetVariableInt(attackPlan, cAttackPlanTargetTypeID, 7, cUnitTypeTownCenter);
         aiPlanSetVariableInt(attackPlan, cAttackPlanTargetTypeID, 8, cUnitTypeFactory);    
         aiPlanSetVariableInt(attackPlan, cAttackPlanTargetTypeID, 9, cUnitTypeAbstractWonder);    
         aiPlanSetVariableInt(attackPlan, cAttackPlanTargetTypeID, 10, cUnitTypeBank);
         aiPlanSetVariableInt(attackPlan, cAttackPlanTargetTypeID, 11, cUnitTypedeHouseInca);
         aiPlanSetVariableInt(attackPlan, cAttackPlanTargetTypeID, 12, cUnitTypeLogicalTypeBuildingsNotWalls);
         aiPlanSetVariableInt(attackPlan, cAttackPlanTargetTypeID, 13, gWallnonp);
         aiPlanSetVariableVector(attackPlan, cAttackPlanGatherPoint, 0, siegeWeaponVec);
         aiPlanSetVariableFloat(attackPlan, cAttackPlanGatherDistance, 0, 100.0);
         aiPlanSetVariableInt(attackPlan, cAttackPlanRefreshFrequency, 0, 1);
         aiPlanSetDesiredPriority(attackPlan, 99);          
         aiPlanAddUnitType(attackPlan, gSiegeWeaponUnit, numUnit, numUnit, numUnit);
         aiPlanSetUnitStance(attackPlan, cUnitStanceAggressive);
         aiPlanSetInitialPosition(attackPlan, siegeWeaponVec);
         aiEcho("***** ATTACK, plan ID is +attackPlan *****"); 
         aiPlanSetActive(attackPlan, true);
      }
   }
}

//==============================================================================
/*
   nativeMonitor

   Make and update maintain plans for native warriors
   since they don't show up often
*/
//==============================================================================
rule nativeMonitor
inactive
minInterval 30
{
   static int nativeUPID = -1;
   static int nativeMaintainPlans = -1;
   static int nativeBuildingIDs = -1;

   if (cvOkToTrainArmy == false)
      return;

   if (nativeUPID < 0)
   {
      // Create it.
      nativeUPID = kbUnitPickCreate("Native Warrior");
      if (nativeUPID < 0)
         return;

      nativeMaintainPlans = xsArrayCreateInt(3, -1, "Native warrior maintain plans");
      nativeBuildingIDs = xsArrayCreateInt(3, -1, "Native warrior buildings");
   }

   int trainUnitID = -1;
   int planID = -1;
   int numberToMaintain = 0;
   int militaryPopPercentage = btBiasNative * 10 + 10;
   int buildLimit = 0;
   int upgradeTechID = -1;
   int upgradePlanID = -1;
   float totalValue = 0.0;
   int trainBuildingID = -2;
   int mainBaseID = kbBaseGetMainID(cMyID);
   vector mainBaseLocation = kbBaseGetLocation(cMyID, mainBaseID);
   float mainBaseDist = kbBaseGetDistance(cMyID, mainBaseID);

   // Default init.
   kbUnitPickResetAll(nativeUPID);
   kbUnitPickSetPreferenceWeight(nativeUPID, 1.0);
   kbUnitPickSetCombatEfficiencyWeight(nativeUPID, 0.0);
   kbUnitPickSetBuildingCombatEfficiencyWeight(nativeUPID, 0.0);
   kbUnitPickSetCostWeight(nativeUPID, 0.0);
   // Desired number units types, buildings.
   kbUnitPickSetDesiredNumberUnitTypes(nativeUPID, 3, 1, true);
   kbUnitPickSetEnemyPlayerID(nativeUPID, aiGetMostHatedPlayerID());
   kbUnitPickSetPreferenceFactor(nativeUPID, cUnitTypeAbstractNativeWarrior, 1.0);
   kbUnitPickRun(nativeUPID);

   int numberPlans = xsArrayGetSize(nativeMaintainPlans);
   int numberUnitTypes = kbUnitPickGetNumberResults(nativeUPID);

   if (numberUnitTypes > numberPlans)
   {
      xsArrayResizeInt(nativeMaintainPlans, numberUnitTypes);
      for (i = numberPlans; < numberUnitTypes)
         xsArraySetInt(nativeMaintainPlans, i, -1);
   }

   for (i = 0; < numberUnitTypes)
   {
      trainUnitID = kbUnitPickGetResult(nativeUPID, i);
      planID = xsArrayGetInt(nativeMaintainPlans, i);
      buildLimit = kbGetBuildLimit(cMyID, trainUnitID);
      if (buildLimit == 0)
         trainUnitID = -1;
      if (planID >= 0)
      {
         if (trainUnitID == aiPlanGetVariableInt(planID, cTrainPlanUnitType, 0))
         {
            if (kbGetAge() <= cAge4)
            {
               // resource equivalent to 0-20% of our military pop
               numberToMaintain =
                   (aiGetMilitaryPop() * militaryPopPercentage) / (kbUnitCostPerResource(trainUnitID, cResourceGold) +
                                                                   kbUnitCostPerResource(trainUnitID, cResourceWood) +
                                                                   kbUnitCostPerResource(trainUnitID, cResourceFood));
            }
            else
            {
               numberToMaintain = buildLimit;
            }
            aiPlanSetVariableInt(planID, cTrainPlanNumberToMaintain, 0, numberToMaintain);
            continue;
         }
         aiPlanDestroy(planID);
      }
      if (trainUnitID < 0)
         continue;
      if (kbGetAge() <= cAge4)
      {
         // resource eqivalent to 0-20% of our military pop
         numberToMaintain =
             (aiGetMilitaryPop() * militaryPopPercentage) /
             (kbUnitCostPerResource(trainUnitID, cResourceGold) + kbUnitCostPerResource(trainUnitID, cResourceWood) +
              kbUnitCostPerResource(trainUnitID, cResourceFood));
      }
      else
      {
         numberToMaintain = buildLimit;
      }

      planID = createSimpleMaintainPlan(trainUnitID, numberToMaintain, false, mainBaseID, 1);
      xsArraySetInt(nativeMaintainPlans, i, planID);

      // Train from main base whenever possible.
      if (numberToMaintain > 0)
      {
         if (trainBuildingID == -2)
         {
            trainBuildingID = getUnitByLocation(cUnitTypeNativeEmbassy, cMyID, cUnitStateAlive, mainBaseLocation, mainBaseDist);
            if (trainBuildingID < 0 && civIsAfrican() == true)
               trainBuildingID = getUnitByLocation(cUnitTypedePalace, cMyID, cUnitStateAlive, mainBaseLocation, mainBaseDist);
         }
         aiPlanSetVariableInt(planID, cTrainPlanBuildingID, 0, trainBuildingID);
      }
      else
      {
         aiPlanSetVariableInt(planID, cTrainPlanBuildingID, 0, -1);
      }

      // create a research plan.
      if (kbGetAge() >= cAge3)
      {
         upgradeTechID = kbTechTreeGetCheapestUnitUpgrade(trainUnitID, cUnitTypeTradingPost);
         if (upgradeTechID >= 0)
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, upgradeTechID);

            if (upgradePlanID < 0)
            {
               upgradePlanID = aiPlanCreate("Research " + kbGetTechName(upgradeTechID), cPlanResearch);
               aiPlanSetVariableInt(upgradePlanID, cResearchPlanTechID, 0, upgradeTechID);
               aiPlanSetVariableInt(upgradePlanID, cResearchPlanBuildingTypeID, 0, cUnitTypeTradingPost);
               aiPlanSetActive(upgradePlanID);
               aiEcho("*** Creating research plan for " + kbGetTechName(upgradeTechID));
            }

            aiPlanSetParentID(upgradePlanID, planID);

            totalValue = kbUnitCostPerResource(trainUnitID, cResourceFood) +
                         kbUnitCostPerResource(trainUnitID, cResourceWood) +
                         kbUnitCostPerResource(trainUnitID, cResourceGold) +
                         kbUnitCostPerResource(trainUnitID, cResourceInfluence);
            totalValue = totalValue * kbUnitCount(cMyID, trainUnitID, cUnitStateABQ);

            // below default priority if we do not have enough units.
            if (totalValue < 800.0)
               aiPlanSetDesiredResourcePriority(upgradePlanID, 45 - (5 - totalValue / 200));
            else
               aiPlanSetDesiredResourcePriority(upgradePlanID, 50);
         }
      }
   }

   for (i = numberUnitTypes; < numberPlans)
   {
      planID = xsArrayGetInt(nativeMaintainPlans, i);
      if (planID >= 0)
      {
         aiPlanDestroy(planID);
         xsArraySetInt(nativeMaintainPlans, i, -1);
      }
   }
}

//==============================================================================
// calculateDefenseEngageRange
//
// Calculates the max engage range without enemy buildings nearby.
//==============================================================================
float calculateDefenseReflexEngageRange(vector location = cInvalidVector, float range = 0.0, float minRange = 0.0)
{
   int enemyBuildingQuery =
       createSimpleUnitQuery(cUnitTypeBuilding, cPlayerRelationEnemyNotGaia, cUnitStateABQ, location, range);
   kbUnitQuerySetAscendingSort(enemyBuildingQuery, true);
   int numberFound = kbUnitQueryExecute(enemyBuildingQuery);
   if (numberFound == 0)
   {
      // no buildings nearby, we're good.
      return (range);
   }

   int enemyBuildingID = kbUnitQueryGetResult(enemyBuildingQuery, 0);
   float dist = distance(kbUnitGetPosition(enemyBuildingID), location);
   if (dist < minRange)
   {
      aiEcho("******** WARNING! Defend location too close to enemy buildings, distance=" + dist);
      return (minRange);
   }

   aiEcho("******** Defend plan engage range changed to " + dist);

   return (dist - minRange);
}

//==============================================================================
/*
   moveDefenseReflex(vector, radius, baseID)

   Move the defend and reserve plans to the specified location
   Sets the gLandDefendPlan0 to a high pop count, so it steals units from the reserve plan,
   which will signal the AI to not start new attacks as no reserves are available.
*/
//==============================================================================
void moveDefenseReflex(vector location = cInvalidVector, float radius = -1.0, int baseID = -1)
{
   if (radius < 0.0)
      radius = cvDefenseReflexRadiusActive;
   if (location != cInvalidVector)
   {
      radius = calculateDefenseReflexEngageRange(location, radius, 15.0);
      aiPlanSetVariableVector(gLandDefendPlan0, cDefendPlanDefendPoint, 0, location);
      aiPlanSetVariableFloat(gLandDefendPlan0, cDefendPlanEngageRange, 0, radius);
      aiPlanSetVariableFloat(gLandDefendPlan0, cDefendPlanGatherDistance, 0, radius - 10.0);
      aiPlanSetVariableInt(gLandDefendPlan0, cDefendPlanDefendBaseID, 0, baseID);
      aiPlanAddUnitType(gLandDefendPlan0, cUnitTypeLogicalTypeLandMilitary, 0, 0, 200);
      // We should prioritize defending over gathering when under attack
      if ((gRevolutionType & cRevolutionFinland) == cRevolutionFinland)
         aiPlanAddUnitType(gLandDefendPlan0, gEconUnit, 0, 200, 200);

      aiPlanSetVariableVector(gLandReservePlan, cDefendPlanDefendPoint, 0, location);
      aiPlanSetVariableFloat(gLandReservePlan, cDefendPlanEngageRange, 0, radius);
      aiPlanSetVariableFloat(gLandReservePlan, cDefendPlanGatherDistance, 0, radius - 10.0);
      aiPlanSetVariableInt(gLandReservePlan, cDefendPlanDefendBaseID, 0, baseID);
      aiPlanAddUnitType(gLandReservePlan, cUnitTypeLogicalTypeLandMilitary, 0, 0, 1);

      gDefenseReflex = true;
      gDefenseReflexBaseID = baseID;
      gDefenseReflexLocation = location;
      gDefenseReflexTimeout = xsGetTime() + aiRandInt(10) * 1000;
      gDefenseReflexPaused = false;
   }
   aiEcho("******** Defense reflex moved to base " + baseID + " with radius " + radius + " and location " + location);
}

//==============================================================================
/*
   pauseDefenseReflex()

   The base (gDefenseReflexBaseID) is still under attack, but we don't have enough
   forces to engage.  Retreat to main base, set a small radius, and wait until we
   have enough troops to re-engage through a moveDefenseReflex() call.
   Sets gLandDefendPlan0 to high troop count to keep reserve plan empty.
   Leaves the base ID and location untouched, even though units will gather at home.
*/
//==============================================================================
void pauseDefenseReflex(void)
{
   vector loc = kbBaseGetMilitaryGatherPoint(cMyID, kbBaseGetMainID(cMyID));
   if (gForwardBaseState != cForwardBaseStateNone && gForwardBaseShouldDefend == true)
      loc = gForwardBaseLocation;

   float radius = calculateDefenseReflexEngageRange(loc, cvDefenseReflexRadiusPassive, 15.0);

   aiPlanSetVariableVector(gLandDefendPlan0, cDefendPlanDefendPoint, 0, loc);
   aiPlanSetVariableFloat(gLandDefendPlan0, cDefendPlanEngageRange, 0, radius);
   aiPlanSetVariableFloat(gLandDefendPlan0, cDefendPlanGatherDistance, 0, radius - 10.0);
   aiPlanSetVariableInt(gLandDefendPlan0, cDefendPlanDefendBaseID, 0, -1);

   aiPlanSetVariableVector(gLandReservePlan, cDefendPlanDefendPoint, 0, loc);
   aiPlanSetVariableFloat(gLandReservePlan, cDefendPlanEngageRange, 0, radius);
   aiPlanSetVariableFloat(gLandReservePlan, cDefendPlanGatherDistance, 0, radius - 10.0);
   aiPlanSetVariableInt(gLandReservePlan, cDefendPlanDefendBaseID, 0, -1);

   aiPlanAddUnitType(gLandDefendPlan0, cUnitTypeLogicalTypeLandMilitary, 0, 0, 200);
   // We should prioritize defending over gathering when under attack
   if ((gRevolutionType & cRevolutionFinland) == cRevolutionFinland)
      aiPlanAddUnitType(gLandDefendPlan0, gEconUnit, 0, 200, 200);
   aiPlanAddUnitType(gLandReservePlan, cUnitTypeLogicalTypeLandMilitary, 0, 0, 1);

   gDefenseReflexPaused = true;

   aiEcho("******** Defense reflex paused.");
}

//==============================================================================
/*
   endDefenseReflex()

   Move the defend and reserve plans to their default positions
*/
//==============================================================================
void endDefenseReflex(void)
{
   vector resLoc = kbBaseGetMilitaryGatherPoint(cMyID, kbBaseGetMainID(cMyID));
   vector defLoc = kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID));
   if (gForwardBaseState != cForwardBaseStateNone && gForwardBaseShouldDefend == true)
   {
      resLoc = gForwardBaseLocation;
      defLoc = gForwardBaseLocation;
   }
   float radius = calculateDefenseReflexEngageRange(defLoc, cvDefenseReflexRadiusActive, 15.0);

   aiPlanSetVariableVector(gLandDefendPlan0, cDefendPlanDefendPoint, 0,
                           defLoc); // Main base or forward base (if forward base exists)
   aiPlanSetVariableFloat(gLandDefendPlan0, cDefendPlanEngageRange, 0, radius);
   aiPlanSetVariableFloat(gLandDefendPlan0, cDefendPlanGatherDistance, 0, radius - 10.0);
   aiPlanSetVariableInt(gLandDefendPlan0, cDefendPlanDefendBaseID, 0, -1);
   aiPlanAddUnitType(gLandDefendPlan0, cUnitTypeLogicalTypeLandMilitary, 0, 0,
                     1); // Defend plan will use 1 unit to defend against stray snipers, etc.
   // Move units back to gathering when possible
   if ((gRevolutionType & cRevolutionFinland) == cRevolutionFinland)
      aiPlanAddUnitType(gLandDefendPlan0, gEconUnit, 0, 0, 1);

   radius = calculateDefenseReflexEngageRange(resLoc, cvDefenseReflexRadiusPassive, 15.0);

   aiPlanSetVariableVector(gLandReservePlan, cDefendPlanDefendPoint, 0, resLoc);
   aiPlanSetVariableFloat(gLandReservePlan, cDefendPlanEngageRange, 0, radius); // Small radius
   aiPlanSetVariableFloat(gLandReservePlan, cDefendPlanGatherDistance, 0, radius - 10.0);
   aiPlanSetVariableInt(gLandReservePlan, cDefendPlanDefendBaseID, 0, -1);
   aiPlanAddUnitType(gLandReservePlan, cUnitTypeLogicalTypeLandMilitary, 0, 0, 200); // All unused troops

   aiEcho("******** Defense reflex terminated for base " + gDefenseReflexBaseID + " at location " +
          gDefenseReflexLocation);
   aiEcho("******** Returning to " + resLoc);
   aiEcho(" Forward base ID is " + gForwardBaseID + ", location is " + gForwardBaseLocation);

   gDefenseReflex = false;
   gDefenseReflexPaused = false;
   gDefenseReflexBaseID = -1;
   gDefenseReflexLocation = cInvalidVector;
   gDefenseReflexTimeout = 0;
}

rule endDefenseReflexDelay // Use this instead of calling endDefenseReflex in the createMainBase function, so that the
                           // new BaseID will be available.
    inactive minInterval 1
{
   xsDisableSelf();
   endDefenseReflex();
}

int baseBuildingCount(int baseID = -1, int relation = cPlayerRelationAny, int state = cUnitStateAlive)
{
   int retVal = -1;

   if (baseID >= 0)
   {
      // Check for buildings in the base, regardless of player ID (only baseOwner can have buildings there)
      int owner = kbBaseGetOwner(baseID);
      retVal = getUnitCountByLocation(cUnitTypeBuilding, relation, state, kbBaseGetLocation(owner, baseID), kbBaseGetDistance(owner, baseID));
   }

   return (retVal);
}

//==============================================================================
// useLevy
//==============================================================================
rule useLevy
inactive
group tcComplete
minInterval 10
{
   if (civIsEuropean() == false)
   {
      xsDisableSelf();
      return;
   }

   // Check to see if town is being overrun.  If so, generate a plan
   // to 'research' levy.  If plan is active but enemies disappear,
   // destroy it.  Once research is complete, end this rule.

   static int levyPlan = -1;
   vector mainBaseVec = cInvalidVector;
   int techID = -1;

   if (cMyCiv != cCivDEAmericans)
      techID = cTechLevy;
   else
      techID = cTechDEUSLevy;

   mainBaseVec = kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID));

   int towncenterID = getUnitByLocation(cUnitTypeTownCenter, cMyID, cUnitStateAlive, mainBaseVec, 40.0);

   if ((towncenterID < 0) || (kbBuildingTechGetStatus(techID, towncenterID) != cTechStatusObtainable))
   {
      if (levyPlan >= 0)
      {
         aiEcho("   ** Destroying levy plan.");
         aiPlanDestroy(levyPlan);
         levyPlan = -1;
      }
      return;
   }

   int enemyCount = getUnitCountByLocation(cUnitTypeLogicalTypeLandMilitary, cPlayerRelationEnemyNotGaia,
                                           cUnitStateAlive, mainBaseVec, 40.0);
   int allyCount = getUnitCountByLocation(cUnitTypeLogicalTypeLandMilitary, cPlayerRelationAlly, cUnitStateAlive,
                                          mainBaseVec, 40.0);

   if (levyPlan < 0)
   { // Create a new plan.
      if (enemyCount >= (allyCount + 5))
      { // We're behind by 5 or more
         if (kbBuildingTechGetStatus(techID, towncenterID) == cTechStatusObtainable)
            levyPlan = createSimpleResearchPlan(techID, towncenterID, cMilitaryEscrowID, 99); // Extreme priority
         if (levyPlan >= 0)
         {
            aiEcho("***** Starting a levy plan, there are " + enemyCount + " enemy units in my base against " +
                   allyCount + " friendlies.");
            aiPlanSetDesiredResourcePriority(levyPlan, 85);
         }
      }
   }
   else // Plan exists, make sure it's still needed.
   {
      if ((enemyCount > (allyCount + 2)) && (aiPlanGetState(levyPlan) >= 0))
      { // Do nothing
         aiEcho("   ** Still waiting for levy.");
      }
      else
      {
         aiEcho("   ** Destroying levy plan.");
         aiPlanDestroy(levyPlan);
         levyPlan = -1;
      }
   }
}

//==============================================================================
// useAsianLevy
//==============================================================================
rule useAsianLevy
inactive
group tcComplete
minInterval 10
{
   if (civIsAsian() == false)
   {
      xsDisableSelf();
      return;
   }

   // Check to see if town is being overrun.  If so, generate a plan
   // to 'research' levy.  If plan is active but enemies disappear,
   // destroy it.  Once research is complete, end this rule.

   static int levyPlan = -1;
   vector mainBaseVec = cInvalidVector;

   mainBaseVec = kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID));

   int towncenterID = getUnitByLocation(cUnitTypeTownCenter, cMyID, cUnitStateAlive, mainBaseVec, 40.0);

   int levy1 = cTechypAssemble;
   int levy2 = cTechypMuster;
   if ((cMyCiv == cCivIndians) || (cMyCiv == cCivSPCIndians))
   {
      levy1 = cTechypAssembleIndians;
      levy2 = cTechypMusterIndians;
   }

   if ((towncenterID < 0) || ((kbBuildingTechGetStatus(levy1, towncenterID) != cTechStatusObtainable) &&
                              (kbBuildingTechGetStatus(levy2, towncenterID) != cTechStatusObtainable)))
   {
      if (levyPlan >= 0)
      {
         aiEcho("   ** Destroying levy plan.");
         aiPlanDestroy(levyPlan);
         levyPlan = -1;
      }
      return;
   }

   int enemyCount = getUnitCountByLocation(cUnitTypeLogicalTypeLandMilitary, cPlayerRelationEnemyNotGaia,
                                           cUnitStateAlive, mainBaseVec, 40.0);
   int enemyCavalryCount = getUnitCountByLocation(cUnitTypeAbstractCavalry, cPlayerRelationEnemyNotGaia,
                                                  cUnitStateAlive, mainBaseVec, 40.0) +
                           getUnitCountByLocation(cUnitTypeAbstractCoyoteMan, cPlayerRelationEnemyNotGaia,
                                                  cUnitStateAlive, mainBaseVec, 40.0);
   int allyCount = getUnitCountByLocation(cUnitTypeLogicalTypeLandMilitary, cPlayerRelationAlly, cUnitStateAlive,
                                          mainBaseVec, 40.0);

   if (levyPlan < 0)
   { // Create a new plan.
      if (enemyCount >= (allyCount + 5))
      { // We're behind by 5 or more
         if (kbBuildingTechGetStatus(levy1, towncenterID) == cTechStatusObtainable &&
             (enemyCavalryCount * 2 >= enemyCount))
            levyPlan = createSimpleResearchPlan(levy1, towncenterID, cMilitaryEscrowID, 99); // Extreme priority
         else if (kbBuildingTechGetStatus(levy2, towncenterID) == cTechStatusObtainable)
            levyPlan = createSimpleResearchPlan(levy2, towncenterID, cMilitaryEscrowID, 99); // Extreme priority
         if (levyPlan >= 0)
         {
            aiEcho("***** Starting a levy plan, there are " + enemyCount + " enemy units in my base against " +
                   allyCount + " friendlies.");
            aiPlanSetDesiredResourcePriority(levyPlan, 85);
         }
      }
   }
   else // Plan exists, make sure it's still needed.
   {
      if ((enemyCount > (allyCount + 2)) && (aiPlanGetState(levyPlan) >= 0))
      { // Do nothing
         aiEcho("   ** Still waiting for levy.");
      }
      else
      {
         aiEcho("   ** Destroying levy plan.");
         aiPlanDestroy(levyPlan);
         levyPlan = -1;
      }
   }
}

//==============================================================================
// consulateLevy
//==============================================================================
rule consulateLevy
inactive
minInterval 10
{
   // Check to see if town is being overrun. If so, generate a plan to research
   // Ottoman levy at the consulate.  If plan is active but enemies disappear,
   // destroy it.  Once research is complete, end this rule.

   int levyPlan = -1;
   vector mainBaseVec = cInvalidVector;

   mainBaseVec = kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID));

   if (kbTechGetStatus(cTechypConsulateOttomansSettlerCombat) == cTechStatusActive)
   {
      xsDisableSelf();
      return;
   }

   int enemyCount = getUnitCountByLocation(cUnitTypeLogicalTypeLandMilitary, cPlayerRelationEnemyNotGaia,
                                           cUnitStateAlive, mainBaseVec, 40.0);
   int allyCount = getUnitCountByLocation(cUnitTypeLogicalTypeLandMilitary, cPlayerRelationAlly, cUnitStateAlive,
                                          mainBaseVec, 40.0);

   if (levyPlan < 0) // No plan, see if we need one.
   {
      if ((enemyCount >= (allyCount + 5)) &&
          (kbTechGetStatus(cTechypConsulateOttomansSettlerCombat) == cTechStatusObtainable))
      { // We're behind by 5 or more
         aiEcho("***** Starting consulate levy plan, there are " + enemyCount + " enemy units in my base against " +
                allyCount + " friendlies.");
         levyPlan = createSimpleResearchPlan(cTechypConsulateOttomansSettlerCombat, getUnit(cUnitTypeypConsulate),
                                             cMilitaryEscrowID, 99); // Extreme priority
         aiPlanSetDesiredResourcePriority(levyPlan, 85);
      }
   }
   else // Plan exists, make sure it's still needed
   {
      if ((enemyCount > (allyCount + 2)) && (aiPlanGetState(levyPlan) >= 0))
      { // Do nothing
         aiEcho("   ** Still waiting for consulate levy.");
      }
      else
      {
         aiEcho("   ** Destroying consulate levy plan.");
         aiPlanDestroy(levyPlan);
         levyPlan = -1;
      }
   }
}

//==============================================================================
// useAfricanLevy
//==============================================================================
rule useAfricanLevy
inactive
group tcComplete
minInterval 10
{
   if (civIsAfrican() == false)
   {
      xsDisableSelf();
      return;
   }

   // Check to see if town is being overrun.  If so, generate a plan
   // to 'research' levy.  If plan is active but enemies disappear,
   // destroy it.  Once research is complete, end this rule.

   vector mainBaseVec = cInvalidVector;

   mainBaseVec = kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID));

   int houseID = getUnitByLocation(gHouseUnit, cMyID, cUnitStateAlive, mainBaseVec, 40.0);

   if (houseID < 0)
      return;

   int enemyCount = getUnitCountByLocation(cUnitTypeLogicalTypeLandMilitary, cPlayerRelationEnemyNotGaia,
                                           cUnitStateAlive, mainBaseVec, 40.0);
   int enemyCavalryCount = getUnitCountByLocation(cUnitTypeAbstractCavalry, cPlayerRelationEnemyNotGaia,
                                                  cUnitStateAlive, mainBaseVec, 40.0) +
                           getUnitCountByLocation(cUnitTypeAbstractCoyoteMan, cPlayerRelationEnemyNotGaia,
                                                  cUnitStateAlive, mainBaseVec, 40.0);
   int allyCount = getUnitCountByLocation(cUnitTypeLogicalTypeLandMilitary, cPlayerRelationAlly, cUnitStateAlive,
                                          mainBaseVec, 40.0);

   if (enemyCount >= (allyCount + 5))
   { // We're behind by 5 or more
      int levy = -1;
      if (enemyCavalryCount * 2 >= enemyCount)
         levy = cUnitTypedeSpearmanLevy;
      else if (kbGetAge() >= cAge3)
         levy = cUnitTypedeGunnerLevy;
      else
         levy = cUnitTypedeBowmanLevy;
      if (kbCanAffordUnit(levy, cMilitaryEscrowID) == true)
         aiTaskUnitTrain(houseID, levy);
   }
}

//==============================================================================
// useWarParties
//==============================================================================
rule useWarParties
inactive
group tcComplete
minInterval 10
{
   // Check to see if town is being overrun. If so, generate a plan to research
   // available war party.  If plan is active but enemies disappear, destroy it.

   // Disable rule for non-native civs
   if (civIsNative() == false)
   {
      xsDisableSelf();
      return;
   }

   static int partyPlan = -1;
   vector mainBaseVec = cInvalidVector;

   mainBaseVec = kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID));
   int enemyCount = getUnitCountByLocation(cUnitTypeLogicalTypeLandMilitary, cPlayerRelationEnemyNotGaia,
                                           cUnitStateAlive, mainBaseVec, 40.0);
   int allyCount = getUnitCountByLocation(cUnitTypeLogicalTypeLandMilitary, cPlayerRelationAlly, cUnitStateAlive,
                                          mainBaseVec, 40.0);

   if (partyPlan < 0) // No plan, see if we need one.
   {
      if (enemyCount >= (allyCount + 5)) // We're behind by 5 or more
      {
         aiEcho("***** Starting a WarParty plan, there are " + enemyCount + " enemy units in my base against " +
                allyCount + " friendlies.");
         if (cMyCiv == cCivXPAztec)
         {
            if ((kbTechGetStatus(cTechBigAztecScoutingParty) == cTechStatusObtainable) &&
                (kbUnitCount(cMyID, cUnitTypeTownCenter, cUnitStateAlive) >= 1) && (kbGetAge() >= cAge2))
               partyPlan = createSimpleResearchPlan(
                   cTechBigAztecScoutingParty,
                   getUnitByLocation(cUnitTypeTownCenter, cMyID, cUnitStateAlive, mainBaseVec, 40.0), cMilitaryEscrowID,
                   99); // Extreme priority
            else if ((kbTechGetStatus(cTechBigAztecRaidingParty) == cTechStatusObtainable) &&
                     (kbUnitCount(cMyID, cUnitTypeTownCenter, cUnitStateAlive) >= 1) && (kbGetAge() >= cAge2))
               partyPlan = createSimpleResearchPlan(
                   cTechBigAztecRaidingParty,
                   getUnitByLocation(cUnitTypeTownCenter, cMyID, cUnitStateAlive, mainBaseVec, 40.0), cMilitaryEscrowID,
                   99); // Extreme priority
            else if ((kbTechGetStatus(cTechBigAztecWarParty) == cTechStatusObtainable) &&
                     (kbUnitCount(cMyID, cUnitTypeTownCenter, cUnitStateAlive) >= 1) && (kbGetAge() >= cAge2))
               partyPlan = createSimpleResearchPlan(
                   cTechBigAztecWarParty,
                   getUnitByLocation(cUnitTypeTownCenter, cMyID, cUnitStateAlive, mainBaseVec, 40.0), cMilitaryEscrowID,
                   99); // Extreme priority
         }
         else if (cMyCiv == cCivXPIroquois)
         {
            if ((kbTechGetStatus(cTechBigIroquoisScoutingParty) == cTechStatusObtainable) &&
                (kbUnitCount(cMyID, cUnitTypeTownCenter, cUnitStateAlive) >= 1) && (kbGetAge() >= cAge2))
               partyPlan = createSimpleResearchPlan(
                   cTechBigIroquoisScoutingParty,
                   getUnitByLocation(cUnitTypeTownCenter, cMyID, cUnitStateAlive, mainBaseVec, 40.0), cMilitaryEscrowID,
                   99); // Extreme priority
            else if ((kbTechGetStatus(cTechBigIroquoisRaidingParty) == cTechStatusObtainable) &&
                     (kbUnitCount(cMyID, cUnitTypeTownCenter, cUnitStateAlive) >= 1) && (kbGetAge() >= cAge2))
               partyPlan = createSimpleResearchPlan(
                   cTechBigIroquoisRaidingParty,
                   getUnitByLocation(cUnitTypeTownCenter, cMyID, cUnitStateAlive, mainBaseVec, 40.0), cMilitaryEscrowID,
                   99); // Extreme priority
            else if ((kbTechGetStatus(cTechBigIroquoisWarParty) == cTechStatusObtainable) &&
                     (kbUnitCount(cMyID, cUnitTypeTownCenter, cUnitStateAlive) >= 1) && (kbGetAge() >= cAge2))
               partyPlan = createSimpleResearchPlan(
                   cTechBigIroquoisWarParty,
                   getUnitByLocation(cUnitTypeTownCenter, cMyID, cUnitStateAlive, mainBaseVec, 40.0), cMilitaryEscrowID,
                   99); // Extreme priority
         }
         else if (cMyCiv == cCivXPSioux)
         {
            if ((xsGetTime() > 18 * 60 * 1000) &&
                (kbTechGetStatus(cTechBigSiouxDogSoldiers) == cTechStatusObtainable) &&
                (kbUnitCount(cMyID, cUnitTypeTownCenter, cUnitStateAlive) >= 1) &&
                (kbGetAge() >= cAge2)) // Use only after at least 18 minutes of game time (i.e. 6 units)
               partyPlan = createSimpleResearchPlan(
                   cTechBigSiouxDogSoldiers,
                   getUnitByLocation(cUnitTypeTownCenter, cMyID, cUnitStateAlive, mainBaseVec, 40.0), cMilitaryEscrowID,
                   99); // Extreme priority
         }
         else if (cMyCiv == cCivDEInca)
         {
            if ((kbTechGetStatus(cTechdeBigIncaScoutingParty) == cTechStatusObtainable) &&
                (kbUnitCount(cMyID, cUnitTypeTownCenter, cUnitStateAlive) >= 1) && (kbGetAge() >= cAge2))
               partyPlan = createSimpleResearchPlan(
                   cTechdeBigIncaScoutingParty,
                   getUnitByLocation(cUnitTypeTownCenter, cMyID, cUnitStateAlive, mainBaseVec, 40.0), cMilitaryEscrowID,
                   99); // Extreme priority
            else if ((kbTechGetStatus(cTechdeBigIncaRaidingParty) == cTechStatusObtainable) &&
                     (kbUnitCount(cMyID, cUnitTypeTownCenter, cUnitStateAlive) >= 1) && (kbGetAge() >= cAge2))
               partyPlan = createSimpleResearchPlan(
                   cTechdeBigIncaRaidingParty,
                   getUnitByLocation(cUnitTypeTownCenter, cMyID, cUnitStateAlive, mainBaseVec, 40.0), cMilitaryEscrowID,
                   99); // Extreme priority
            else if ((kbTechGetStatus(cTechdeBigIncaWarParty) == cTechStatusObtainable) &&
                     (kbUnitCount(cMyID, cUnitTypeTownCenter, cUnitStateAlive) >= 1) && (kbGetAge() >= cAge2))
               partyPlan = createSimpleResearchPlan(
                   cTechdeBigIncaWarParty,
                   getUnitByLocation(cUnitTypeTownCenter, cMyID, cUnitStateAlive, mainBaseVec, 40.0), cMilitaryEscrowID,
                   99); // Extreme priority
         }
      }
   }
   else // Plan exists, make sure it's still needed
   {
      if ((enemyCount >= (allyCount + 2)) && (aiPlanGetState(partyPlan) >= 0))
      { // Do nothing
         aiEcho("   ** Still waiting for WarParty.");
         aiPlanSetDesiredResourcePriority(partyPlan, 85);
      }
      else
      {
         aiEcho("   ** Cancelling WarParty.");
         aiPlanDestroy(partyPlan);
         partyPlan = -1;
      }
   }
}

rule slaughterMonitor
inactive
group tcComplete
minInterval 15
{
   // Disable rule for Indians and Japanese
   if ((cMyCiv == cCivIndians) || (cMyCiv == cCivJapanese))
   {
      xsDisableSelf();
      return;
   }

   static int slaughterPlanID = -1;
   int numCattle = -1;
   int gatherersWanted = -1;
   vector mainBaseVec = cInvalidVector;
   int time = xsGetTime();

   // Don't slaughter cattle early on.
   if (((time < 900000) &&
        ((time < 500000) || ((gTimeToFarm == false) && (kbUnitCount(cMyID, cUnitTypeFarm, cUnitStateAlive) <= 0) &&
                             (kbUnitCount(cMyID, cUnitTypeLivestockPen, cUnitStateAlive) <= 0) &&
                             (kbUnitCount(cMyID, cUnitTypeypVillage, cUnitStateAlive) <= 0)))) &&
       (civIsAfrican() == false || time > 300000))
      return;

   // If we have a main base, count the number of herdables in it
   if (kbBaseGetMainID(cMyID) < 0)
      return;

   mainBaseVec = kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID));
   numCattle = getUnitCountByLocation(cUnitTypeHerdable, cPlayerRelationAny, cUnitStateAny, mainBaseVec, 60.0);

   if (numCattle <= 0)
      gatherersWanted = 0;
   else
      gatherersWanted = 2;

   if (aiPlanGetState(slaughterPlanID) == -1)
   {
      aiEcho("Cattle gather plan " + slaughterPlanID + " is invalid.");
      aiPlanDestroy(slaughterPlanID);
      slaughterPlanID = -1;
   }

   if (slaughterPlanID < 0)
   { // Initialize the plan
      slaughterPlanID = aiPlanCreate("Cattle slaughter", cPlanGather);
      aiPlanSetBaseID(slaughterPlanID, kbBaseGetMainID(cMyID));
      aiPlanSetVariableInt(slaughterPlanID, cGatherPlanResourceUnitTypeFilter, 0, cUnitTypeHerdable);
      aiPlanSetVariableInt(slaughterPlanID, cGatherPlanResourceType, 0, cAllResources);
      aiPlanAddUnitType(slaughterPlanID, gEconUnit, gatherersWanted, gatherersWanted,
                        2 * gatherersWanted); // 2-4 gatherers if there is cattle
      aiPlanSetDesiredPriority(slaughterPlanID, 86);
      aiPlanSetActive(slaughterPlanID);
      aiEcho("Activated cattle slaughter plan " + slaughterPlanID);
   }
   else
   {
      aiPlanAddUnitType(slaughterPlanID, gEconUnit, gatherersWanted, gatherersWanted,
                        2 * gatherersWanted); // 2-4 gatherers if there is cattle
   }
}

//==============================================================================
// navyUpgradeMonitor
//==============================================================================
rule navyUpgradeMonitor
inactive
minInterval 90
{
   // Disable rule if we're not on a water map.
   if (gNavyMap == false)
   {
      xsDisableSelf();
      return;
   }

   // Disable rule once we got all relevant upgrades.
   if ((kbTechGetStatus(cTechCarronade) == cTechStatusActive) &&
       (kbTechGetStatus(cTechArmorPlating) == cTechStatusActive) &&
       (kbTechGetStatus(cTechShipHowitzers) == cTechStatusActive) &&
       (kbTechGetStatus(cTechGillNets) == cTechStatusActive) && (kbTechGetStatus(cTechLongLines) == cTechStatusActive))
   {
      xsDisableSelf();
      return;
   }

   int upgradePlanID = -1;

   // Research and destroy fishing improvement plans when appropriate.
   // After 7 Fishing Boats getting Gill Nets becomes efficient.
   if (kbTechGetStatus(cTechGillNets) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechGillNets);
      if ((upgradePlanID >= 0) && (kbUnitCount(cMyID, gFishingUnit, cUnitStateAlive) < 7))
         aiPlanDestroy(upgradePlanID);
      if ((upgradePlanID < 0) && (kbUnitCount(cMyID, gFishingUnit, cUnitStateAlive) >= 7))
      {
         createSimpleResearchPlan(cTechGillNets, getUnit(gDockUnit), cEconomyEscrowID, 45);
         return;
      }
   }
   // Research Long Lines after 9 Fishing Boats, it has great % improvement but is quite expensive too so we wait a little.
   if (kbTechGetStatus(cTechLongLines) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechLongLines);
      if ((upgradePlanID >= 0) && (kbUnitCount(cMyID, gFishingUnit, cUnitStateAlive) < 9))
         aiPlanDestroy(upgradePlanID);
      if ((upgradePlanID < 0) && (kbUnitCount(cMyID, gFishingUnit, cUnitStateAlive) >= 9))
      {
         createSimpleResearchPlan(cTechLongLines, getUnit(gDockUnit), cEconomyEscrowID, 45);
         return;
      }
   }

   int navySize = kbUnitCount(cMyID, cUnitTypeLogicalTypeNavalMilitary, cUnitStateAlive);

   // Research and destroy navy improvement plans when appropriate.
   if (kbTechGetStatus(cTechCarronade) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechCarronade);
      if ((upgradePlanID >= 0) && (navySize < 3))
         aiPlanDestroy(upgradePlanID);
      if ((upgradePlanID < 0) && (navySize >= 3))
      {
         createSimpleResearchPlan(cTechCarronade, getUnit(gDockUnit), cMilitaryEscrowID, 50);
         return;
      }
   }
   if (kbTechGetStatus(cTechArmorPlating) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechArmorPlating);
      if ((upgradePlanID >= 0) && (navySize < 3))
         aiPlanDestroy(upgradePlanID);
      if ((upgradePlanID < 0) && (navySize >= 3))
      {
         createSimpleResearchPlan(cTechArmorPlating, getUnit(gDockUnit), cMilitaryEscrowID, 50);
         return;
      }
   }
   if (kbTechGetStatus(cTechShipHowitzers) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechShipHowitzers);
      if ((upgradePlanID >= 0) && (kbUnitCount(cMyID, gMonitorUnit, cUnitStateAlive) < 1))
         aiPlanDestroy(upgradePlanID);
      if ((upgradePlanID < 0) && (kbUnitCount(cMyID, gMonitorUnit, cUnitStateAlive) >= 1))
      {
         createSimpleResearchPlan(cTechShipHowitzers, getUnit(gDockUnit), cMilitaryEscrowID, 50);
         return;
      }
   }
}

//==============================================================================
// healerMonitor
//==============================================================================
rule healerMonitor
inactive
minInterval 30
{
   static int healerPlan = -1;

   int priestCount = kbUnitCount(cMyID, cUnitTypePriest, cUnitStateAlive);
   int priestessCount = kbUnitCount(cMyID, cUnitTypedePriestess, cUnitStateAlive);
   int missionaryCount = kbUnitCount(cMyID, cUnitTypeMissionary, cUnitStateAlive);
   int surgeonCount = kbUnitCount(cMyID, cUnitTypeSurgeon, cUnitStateAlive);
   int imamCount = kbUnitCount(cMyID, cUnitTypeImam, cUnitStateAlive);
   int natMedicineManCount = kbUnitCount(cMyID, cUnitTypeNatMedicineMan, cUnitStateAlive);
   int xpMedicineManCount = kbUnitCount(cMyID, cUnitTypexpMedicineMan, cUnitStateAlive);
   int xpMedicineManAztecCount = kbUnitCount(cMyID, cUnitTypexpMedicineManAztec, cUnitStateAlive);
   int griotCount = kbUnitCount(cMyID, cUnitTypedeGriot, cUnitStateAlive);
   int abunCount = kbUnitCount(cMyID, cUnitTypedeAbun, cUnitStateAlive);

   if (healerPlan < 0)
   {
      healerPlan = aiPlanCreate("Healer Control Plan", cPlanDefend);

      aiPlanSetVariableVector(healerPlan, cDefendPlanDefendPoint, 0,
                              kbBaseGetMilitaryGatherPoint(cMyID, kbBaseGetMainID(cMyID)));
      aiPlanSetVariableInt(healerPlan, cDefendPlanDefendBaseID, 0, kbBaseGetMainID(cMyID));
      aiPlanSetVariableFloat(healerPlan, cDefendPlanEngageRange, 0, cvDefenseReflexRadiusActive);
      aiPlanSetVariableBool(healerPlan, cDefendPlanPatrol, 0, false);
      aiPlanSetVariableFloat(healerPlan, cDefendPlanGatherDistance, 0, 10.0);
      aiPlanSetInitialPosition(healerPlan, kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)));
      aiPlanSetUnitStance(healerPlan, cUnitStanceDefensive);
      aiPlanSetVariableInt(healerPlan, cDefendPlanRefreshFrequency, 0, 5);
      aiPlanSetVariableInt(healerPlan, cDefendPlanAttackTypeID, 0, cUnitTypeUnit);
      aiPlanSetDesiredPriority(
          healerPlan,
          51); // Just higher priority than attack and defend plans, but lower than native research and gather plans.
      aiPlanSetActive(healerPlan);
      aiEcho("Creating healer plan");
   }

   // Set units required to 0 to allow gather plans to steal from us.
   aiPlanAddUnitType(healerPlan, cUnitTypePriest, 0, priestCount, priestCount);
   aiPlanAddUnitType(healerPlan, cUnitTypeMissionary, 0, missionaryCount, missionaryCount);
   aiPlanAddUnitType(healerPlan, cUnitTypeSurgeon, 0, surgeonCount, surgeonCount);
   aiPlanAddUnitType(healerPlan, cUnitTypeImam, 0, imamCount, imamCount);
   aiPlanAddUnitType(healerPlan, cUnitTypeNatMedicineMan, 0, natMedicineManCount,
                     natMedicineManCount);
   aiPlanAddUnitType(healerPlan, cUnitTypexpMedicineMan, 0, xpMedicineManCount, xpMedicineManCount);
   aiPlanAddUnitType(healerPlan, cUnitTypexpMedicineManAztec, 0, xpMedicineManAztecCount,
                     xpMedicineManAztecCount);
   aiPlanAddUnitType(healerPlan, cUnitTypedePriestess, 0, priestessCount, priestessCount);
   aiPlanAddUnitType(healerPlan, cUnitTypedeGriot, 0, griotCount, griotCount);
   aiPlanAddUnitType(healerPlan, cUnitTypedeAbun, 0, abunCount, abunCount);
   // aiEcho("Updating healer plan");
}

//==============================================================================
// mostHatedEnemy
// Determine who we should attack, checking cvPlayerToAttack too
//==============================================================================
rule mostHatedEnemy
minInterval 60
active
{
	if (cvPlayerToAttack > 0)
	{
      aiEcho("**** cv Changing most hated Player from " + aiGetMostHatedPlayerID() + " to " + cvPlayerToAttack);
      aiSetMostHatedPlayerID(cvPlayerToAttack);
		if (gLandUnitPicker >= 0)
		{
			kbUnitPickSetEnemyPlayerID(gLandUnitPicker, cvPlayerToAttack); // Update the unit picker.
		}
		xsDisableSelf(); // Most likely the cvPlayerToAttack will not be changed in the middle of the game so don't check again.
		return;
   }
	
	static bool treatyTargetingPerformed = false;
	int arrayIndex = 0;
	int arrayIndexOfSelectedEnemy = 0;
	gNumEnemies = 0;
	bool isTreatyActive = aiTreatyActive();
	
	if (isTreatyActive == true && treatyTargetingPerformed == false) // We only perform the targeting once during treaty.
	{
		// Add IDs of enemies to the array.
		for (i = 1; < cNumberPlayers)
		{
			if (kbGetPlayerTeam(i) != kbGetPlayerTeam(cMyID)) // Not on our team so must be an enemy.
			{
				if (kbHasPlayerLost(i) == false)
				{
					xsArraySetInt(gArrayEnemyPlayerIDs, arrayIndex, i);
					arrayIndex = arrayIndex +1;
					gNumEnemies = gNumEnemies + 1;
				}
			}
		}
		if (kbGetIsFFA()) // We pick a target that is adjacent to us in FFA.
		{
			if(gNumEnemies >= 3) // We only need to sort when we have more than 2 enemies, because if we only have 2 enemies we just chose either one anyway regardless of distance.
			{
				arraySortInt(gArrayEnemyPlayerIDs, 0, gNumEnemies, [](int playerA = 1, int playerB = 2) -> bool
				{
					return(xsArrayGetFloat(gStartingPosDistances, playerA) < xsArrayGetFloat(gStartingPosDistances, playerB));
				});
			}
         arrayIndexOfSelectedEnemy = gNumEnemies >= 2 ? aiRandInt(2) : 0;	
		}
      else
      {
			arrayIndexOfSelectedEnemy = aiRandInt(gNumEnemies);
      }
		
		aiSetMostHatedPlayerID(xsArrayGetInt(gArrayEnemyPlayerIDs, arrayIndexOfSelectedEnemy));
		aiEcho("*** Treaty targeting randomly selected Player " + xsArrayGetInt(gArrayEnemyPlayerIDs, arrayIndexOfSelectedEnemy) + " to be our most hated player");
		
		if (gLandUnitPicker >= 0)
		{
        kbUnitPickSetEnemyPlayerID(gLandUnitPicker, xsArrayGetInt(gArrayEnemyPlayerIDs, arrayIndexOfSelectedEnemy)); // Update the unit picker.
		}
		
		treatyTargetingPerformed = true;
		return;
	}
	
	if(isTreatyActive == false)
	{
		// Add IDs of enemies who are still alive to the array.
		for (i = 1; < cNumberPlayers)
		{
			if (kbIsPlayerEnemy(i)) 
			{
				if (kbHasPlayerLost(i) == false)
				{
					xsArraySetInt(gArrayEnemyPlayerIDs, arrayIndex, i);
					arrayIndex = arrayIndex +1;
					gNumEnemies = gNumEnemies + 1;
				}
			}
		}

      if (kbGetIsFFA()) // We pick a target that is adjacent to us in FFA.
      {
			if(gNumEnemies >= 3) // We only need to sort when we have more than 2 enemies, because if we only have 2 enemies we just chose either one anyway regardless of distance.
			{
				arraySortInt(gArrayEnemyPlayerIDs, 0, gNumEnemies, [](int playerA = 1, int playerB = 2) -> bool
				{
					return(xsArrayGetFloat(gStartingPosDistances, playerA) < xsArrayGetFloat(gStartingPosDistances, playerB));
				});
			}
         arrayIndexOfSelectedEnemy = gNumEnemies >= 2 ? aiRandInt(2) : 0;
		}
      else
      {
			arrayIndexOfSelectedEnemy = aiRandInt(gNumEnemies);
		}

		aiSetMostHatedPlayerID(xsArrayGetInt(gArrayEnemyPlayerIDs, arrayIndexOfSelectedEnemy));
		aiEcho("*** Randomly selected Player " + xsArrayGetInt(gArrayEnemyPlayerIDs, arrayIndexOfSelectedEnemy) + " to be our most hated player");
		
		if (gLandUnitPicker >= 0)
		{
			kbUnitPickSetEnemyPlayerID(gLandUnitPicker, xsArrayGetInt(gArrayEnemyPlayerIDs, arrayIndexOfSelectedEnemy)); // Update the unit picker.
		}
	}		
}

//==============================================================================
// initMil
//==============================================================================
void initMil(void)
{
   aiSetAttackResponseDistance(65.0);
   aiSetAutoGatherMilitaryUnits(true);
   // Immediately select a target.
   mostHatedEnemy();
   
   
   if (kbGetCiv() == cCivBritish)
   {      
      gLandPrimaryArmyUnit = cUnitTypeMusketeer;
      gLandTertiaryArmyUnit = cUnitTypeMusketeer;
      gLandSecondaryArmyUnit = cUnitTypeHussar;
      //gLandPrimaryArmyUnit = cUnitTypeLongbowman;
      //gLandPrimaryArmyUnit = cUnitTypeHussar;
      //gLandPrimaryArmyUnit = cUnitTypeDragoon;
      //gLandSecondaryArmyUnit = cUnitTypeMusketeer;
      //gLandSecondaryArmyUnit = cUnitTypeLongbowman;
      //gLandSecondaryArmyUnit = cUnitTypeHussar;
      //gLandSecondaryArmyUnit = cUnitTypeDragoon;
      //gLandTertiaryArmyUnit = cUnitTypeMusketeer;
      //gLandTertiaryArmyUnit = cUnitTypeLongbowman;
      //gLandTertiaryArmyUnit = cUnitTypeHussar;
      //gLandTertiaryArmyUnit = cUnitTypeDragoon;
      //gLandPrimaryArmyUnit = cUnitTypeMusketeer;//  cUnitTypeHussar + cUnitTypeMusketeer + cUnitTypeDragoon + cUnitTypeLongbowman;
      //gLandSecondaryArmyUnit = cUnitTypeLongbowman;//  + cUnitTypeMusketeer + cUnitTypeDragoon + cUnitTypeLongbowman;
      //gLandTertiaryArmyUnit = cUnitTypeHussar;//  + cUnitTypeMusketeer + cUnitTypeDragoon + cUnitTypeLongbowman;
   	  if (kbGetAge() >= cAge4)
	  gAbstractArtilleryUnit = cUnitTypexpHorseArtillery;
	  else
	  gAbstractArtilleryUnit = cUnitTypeFalconet;
   } 
   if (kbGetCiv() == cCivFrench)
   {  
	  if (kbGetAge() <= cAge2)
	  {
      gLandPrimaryArmyUnit = cUnitTypeMusketeer;
      gLandSecondaryArmyUnit = cUnitTypeMusketeer;
      gLandTertiaryArmyUnit = cUnitTypeHussar;
	  }
	  else
	  {
	  gLandPrimaryArmyUnit = cUnitTypeCuirassier;
	  gLandSecondaryArmyUnit = cUnitTypeCuirassier;
	  gLandTertiaryArmyUnit = cUnitTypeCuirassier;
	  }
      //gLandPrimaryArmyUnit = cUnitTypeSkirmisher;
      //gLandPrimaryArmyUnit = cUnitTypeCuirassier;
      //gLandPrimaryArmyUnit = cUnitTypeDragoon;
      //gLandSecondaryArmyUnit = cUnitTypeMusketeer;
      //gLandSecondaryArmyUnit = cUnitTypeSkirmisher;
      //gLandSecondaryArmyUnit = cUnitTypeCuirassier;
      //gLandSecondaryArmyUnit = cUnitTypeDragoon;
      //gLandTertiaryArmyUnit = cUnitTypeMusketeer;
      //gLandTertiaryArmyUnit = cUnitTypeSkirmisher;
      //gLandTertiaryArmyUnit = cUnitTypeCuirassier;
      //gLandTertiaryArmyUnit = cUnitTypeDragoon;
      //gLandPrimaryArmyUnit = cUnitTypeMusketeer;//  cUnitTypeSkirmisher + cUnitTypeCuirassier + cUnitTypeMusketeer + cUnitTypeDragoon + cUnitTypeHussar;
      //gLandSecondaryArmyUnit = cUnitTypeSkirmisher;//  + cUnitTypeCuirassier + cUnitTypeMusketeer + cUnitTypeDragoon + cUnitTypeHussar;
      //gLandTertiaryArmyUnit = cUnitTypeCuirassier;//  + cUnitTypeCuirassier + cUnitTypeMusketeer + cUnitTypeDragoon + cUnitTypeHussar;
   	  if (kbGetAge() >= cAge4)
	  gAbstractArtilleryUnit = cUnitTypexpHorseArtillery;
	  else
	  gAbstractArtilleryUnit = cUnitTypeFalconet;
   }
   if (kbGetCiv() == cCivGermans)
   {
	  if (kbGetAge() <= cAge2)
	  {
      gLandPrimaryArmyUnit = cUnitTypeCrossbowman;
      gLandSecondaryArmyUnit = cUnitTypeCrossbowman;
      gLandTertiaryArmyUnit = cUnitTypeUhlan;
	  }
	  else
	  {
      gLandPrimaryArmyUnit = cUnitTypeSkirmisher;
      gLandSecondaryArmyUnit = cUnitTypeWarWagon;
      gLandTertiaryArmyUnit = cUnitTypeUhlan;
	  }
      //gLandPrimaryArmyUnit = cUnitTypeDopplesoldner;
      //gLandPrimaryArmyUnit = cUnitTypeSkirmisher;
      //gLandPrimaryArmyUnit = cUnitTypeWarWagon;
      //gLandSecondaryArmyUnit = cUnitTypeDopplesoldner;
      //gLandSecondaryArmyUnit = cUnitTypeUhlan;
      //gLandSecondaryArmyUnit = cUnitTypeSkirmisher;
      //gLandSecondaryArmyUnit = cUnitTypeWarWagon;
      //gLandTertiaryArmyUnit = cUnitTypeDopplesoldner;
      //gLandTertiaryArmyUnit = cUnitTypeUhlan;
      //gLandTertiaryArmyUnit = cUnitTypeSkirmisher;
      //gLandTertiaryArmyUnit = cUnitTypeWarWagon;
      //gLandPrimaryArmyUnit = cUnitTypeDopplesoldner;//  + cUnitTypeWarWagon + cUnitTypeSkirmisher + cUnitTypeUhlan;
      //gLandSecondaryArmyUnit = cUnitTypeSkirmisher;//  + cUnitTypeWarWagon + cUnitTypeSkirmisher + cUnitTypeUhlan;
      //gLandTertiaryArmyUnit = cUnitTypeWarWagon;//  + cUnitTypeWarWagon + cUnitTypeSkirmisher + cUnitTypeUhlan;
   	  if (kbGetAge() >= cAge4)
	  gAbstractArtilleryUnit = cUnitTypexpHorseArtillery;
	  else
	  gAbstractArtilleryUnit = cUnitTypeFalconet;
   }
   if (kbGetCiv() == cCivSpanish)
   {
	  if (kbGetAge() <= cAge2)
	  {
      gLandPrimaryArmyUnit = cUnitTypeMusketeer;
      gLandSecondaryArmyUnit = cUnitTypeMusketeer;
      gLandTertiaryArmyUnit = cUnitTypeHussar;
	  }
	  else
	  {
      gLandPrimaryArmyUnit = cUnitTypeSkirmisher;
      gLandSecondaryArmyUnit = cUnitTypeDragoon;
      gLandTertiaryArmyUnit = cUnitTypeLancer;
	  }
      //gLandPrimaryArmyUnit = cUnitTypeLancer;
      //gLandPrimaryArmyUnit = cUnitTypeRodelero;
      //gLandPrimaryArmyUnit = cUnitTypePikeman;
      //gLandPrimaryArmyUnit = cUnitTypeWarDog;
      //gLandPrimaryArmyUnit = cUnitTypeMusketeer;
      //gLandPrimaryArmyUnit = cUnitTypeSkirmisher;
      //gLandPrimaryArmyUnit = cUnitTypeDragoon;
      //gLandSecondaryArmyUnit = cUnitTypeLancer;
      //gLandSecondaryArmyUnit = cUnitTypeRodelero;
      //gLandSecondaryArmyUnit = cUnitTypePikeman;
      //gLandSecondaryArmyUnit = cUnitTypeWarDog;
      //gLandSecondaryArmyUnit = cUnitTypeMusketeer;
      //gLandSecondaryArmyUnit = cUnitTypeSkirmisher;
      //gLandSecondaryArmyUnit = cUnitTypeDragoon;
      //gLandTertiaryArmyUnit = cUnitTypeLancer;
      //gLandTertiaryArmyUnit = cUnitTypeRodelero;
      //gLandTertiaryArmyUnit = cUnitTypePikeman;
      //gLandTertiaryArmyUnit = cUnitTypeWarDog;
      //gLandTertiaryArmyUnit = cUnitTypeMusketeer;
      //gLandTertiaryArmyUnit = cUnitTypeSkirmisher;
      //gLandTertiaryArmyUnit = cUnitTypeDragoon;
      //gLandPrimaryArmyUnit = cUnitTypeRodelero;//  + cUnitTypePikeman + cUnitTypeLancer + cUnitTypeHussar;
      //gLandSecondaryArmyUnit = cUnitTypeLancer;//  + cUnitTypePikeman + cUnitTypeLancer + cUnitTypeHussar;
      //gLandTertiaryArmyUnit = cUnitTypePikeman;//  + cUnitTypePikeman + cUnitTypeLancer + cUnitTypeHussar;
   	  if (kbGetAge() >= cAge4)
	  gAbstractArtilleryUnit = cUnitTypexpHorseArtillery;
	  else
	  gAbstractArtilleryUnit = cUnitTypeFalconet;
   }
   if (kbGetCiv() == cCivPortuguese)
   {
	  if (kbGetAge() <= cAge2)
	  {
      gLandPrimaryArmyUnit = cUnitTypeMusketeer;
      gLandSecondaryArmyUnit = cUnitTypeMusketeer;
      gLandTertiaryArmyUnit = cUnitTypeHussar;
	  }
	  else
	  {
      gLandPrimaryArmyUnit = cUnitTypeMusketeer;
      gLandSecondaryArmyUnit = cUnitTypeCacadore;
      gLandTertiaryArmyUnit = cUnitTypeDragoon;
	  }
      //gLandPrimaryArmyUnit = cUnitTypeCacadore;
      //gLandPrimaryArmyUnit = cUnitTypeDragoon;
      //gLandPrimaryArmyUnit = cUnitTypeHussar;
      //gLandPrimaryArmyUnit = cUnitTypeOrganGun;
      //gLandSecondaryArmyUnit = cUnitTypeMusketeer;
      //gLandSecondaryArmyUnit = cUnitTypeCacadore;
      //gLandSecondaryArmyUnit = cUnitTypeDragoon;
      //gLandSecondaryArmyUnit = cUnitTypeHussar;
      //gLandSecondaryArmyUnit = cUnitTypeOrganGun;
      //gLandTertiaryArmyUnit = cUnitTypeMusketeer;
      //gLandTertiaryArmyUnit = cUnitTypeCacadore;
      //gLandTertiaryArmyUnit = cUnitTypeDragoon;
      //gLandTertiaryArmyUnit = cUnitTypeHussar;
      //gLandTertiaryArmyUnit = cUnitTypeOrganGun;
      //gLandPrimaryArmyUnit = cUnitTypeMusketeer; // + cUnitTypeCacadore + cUnitTypeDragoon + cUnitTypeOrganGun + cUnitTypeHussar;
      //gLandSecondaryArmyUnit = cUnitTypeCacadore; // + cUnitTypeCacadore + cUnitTypeDragoon + cUnitTypeOrganGun + cUnitTypeHussar;
      //gLandTertiaryArmyUnit = cUnitTypeDragoon; // + cUnitTypeCacadore + cUnitTypeDragoon + cUnitTypeOrganGun + cUnitTypeHussar;
	  if (kbGetAge() >= cAge4)
	  gAbstractArtilleryUnit = cUnitTypexpHorseArtillery;
	  else
	  gAbstractArtilleryUnit = cUnitTypeOrganGun;
   }
   if (kbGetCiv() == cCivDutch)
   {
	  if (kbGetAge() <= cAge2)
	  {
      gLandPrimaryArmyUnit = cUnitTypeSkirmisher;
      gLandSecondaryArmyUnit = cUnitTypeSkirmisher;
      gLandTertiaryArmyUnit = cUnitTypeHussar;
	  }
	  else
	  {
      gLandPrimaryArmyUnit = cUnitTypeSkirmisher;
      gLandSecondaryArmyUnit = cUnitTypeRuyter;
      gLandTertiaryArmyUnit = cUnitTypeHussar;
	  }
      //gLandPrimaryArmyUnit = cUnitTypeHussar;
      //gLandPrimaryArmyUnit = cUnitTypeRuyter;
      //gLandPrimaryArmyUnit = cUnitTypeHalberdier;
      //gLandPrimaryArmyUnit = cUnitTypexpHorseArtillery;
      //gLandPrimaryArmyUnit = cUnitTypeFalconet;
      //gLandPrimaryArmyUnit = cUnitTypeGrenadier;
      //gLandSecondaryArmyUnit = cUnitTypeSkirmisher;
      //gLandSecondaryArmyUnit = cUnitTypeHussar;
      //gLandSecondaryArmyUnit = cUnitTypeRuyter;
      //gLandSecondaryArmyUnit = cUnitTypeHalberdier;
      //gLandSecondaryArmyUnit = cUnitTypexpHorseArtillery;
      //gLandSecondaryArmyUnit = cUnitTypeFalconet;
      //gLandSecondaryArmyUnit = cUnitTypeGrenadier;
      //gLandTertiaryArmyUnit = cUnitTypeSkirmisher;
      //gLandTertiaryArmyUnit = cUnitTypeHussar;
      //gLandTertiaryArmyUnit = cUnitTypeRuyter;
      //gLandTertiaryArmyUnit = cUnitTypeHalberdier;
      //gLandTertiaryArmyUnit = cUnitTypexpHorseArtillery;
      //gLandTertiaryArmyUnit = cUnitTypeFalconet;
      //gLandTertiaryArmyUnit = cUnitTypeGrenadier;
      //gLandPrimaryArmyUnit = cUnitTypeSkirmisher;//  + cUnitTypeRuyter + cUnitTypeHussar;
      //gLandSecondaryArmyUnit = cUnitTypeRuyter;//  + cUnitTypeRuyter + cUnitTypeHussar;
      //gLandTertiaryArmyUnit = cUnitTypeHussar;//  + cUnitTypeRuyter + cUnitTypeHussar;
      gGalleonUnit = cUnitTypeFluyt;
   	  if (kbGetAge() >= cAge4)
	  gAbstractArtilleryUnit = cUnitTypexpHorseArtillery;
	  else
	  gAbstractArtilleryUnit = cUnitTypeFalconet;
   }
   if (kbGetCiv() == cCivRussians)
   {
      gLandPrimaryArmyUnit = cUnitTypeMusketeer;
      gLandSecondaryArmyUnit = cUnitTypeStrelet;
      gLandTertiaryArmyUnit = cUnitTypeCossack;
      //gLandPrimaryArmyUnit = cUnitTypeStrelet;
      //gLandPrimaryArmyUnit = cUnitTypeCossack;
      //gLandPrimaryArmyUnit = cUnitTypeMusketeer;
      //gLandPrimaryArmyUnit = cUnitTypeGrenadier;
      //gLandPrimaryArmyUnit = cUnitTypeCavalryArcher;
      //gLandSecondaryArmyUnit = cUnitTypeStrelet;
      //gLandSecondaryArmyUnit = cUnitTypeCossack;
      //gLandSecondaryArmyUnit = cUnitTypeMusketeer;
      //gLandSecondaryArmyUnit = cUnitTypeGrenadier;
      //gLandSecondaryArmyUnit = cUnitTypeCavalryArcher;
      //gLandTertiaryArmyUnit = cUnitTypeStrelet;
      //gLandTertiaryArmyUnit = cUnitTypeCossack;
      //gLandTertiaryArmyUnit = cUnitTypeMusketeer;
      //gLandTertiaryArmyUnit = cUnitTypeGrenadier;
      //gLandTertiaryArmyUnit = cUnitTypeCavalryArcher;
      //gLandPrimaryArmyUnit = cUnitTypeStrelet;//  + cUnitTypeCossack + cUnitTypeMusketeer;
      //gLandSecondaryArmyUnit = cUnitTypeCossack;//  + cUnitTypeCossack + cUnitTypeMusketeer;
      //gLandTertiaryArmyUnit = cUnitTypeMusketeer;//  + cUnitTypeCossack + cUnitTypeMusketeer;
      gTowerUnit = cUnitTypeBlockhouse;
      gBarracksUnit = gTowerUnit;
   	  if (kbGetAge() >= cAge4)
	  gAbstractArtilleryUnit = cUnitTypexpHorseArtillery;
	  else
	  gAbstractArtilleryUnit = cUnitTypeFalconet;
   }
   if (kbGetCiv() == cCivOttomans)
   {
      gLandPrimaryArmyUnit = cUnitTypeJanissary;
      gLandSecondaryArmyUnit = cUnitTypeAbusGun;
      gLandTertiaryArmyUnit = cUnitTypeHussar;
      //gLandPrimaryArmyUnit = cUnitTypeAbusGun;
      //gLandPrimaryArmyUnit = cUnitTypeHussar;
      //gLandPrimaryArmyUnit = cUnitTypeCavalryArcher;
      //gLandPrimaryArmyUnit = cUnitTypeGrenadier;
      //gLandSecondaryArmyUnit = cUnitTypeJanissary;
      //gLandSecondaryArmyUnit = cUnitTypeAbusGun;
      //gLandSecondaryArmyUnit = cUnitTypeHussar;
      //gLandSecondaryArmyUnit = cUnitTypeCavalryArcher;
      //gLandSecondaryArmyUnit = cUnitTypeGrenadier;
      //gLandTertiaryArmyUnit = cUnitTypeJanissary;
      //gLandTertiaryArmyUnit = cUnitTypeAbusGun;
      //gLandTertiaryArmyUnit = cUnitTypeHussar;
      //gLandTertiaryArmyUnit = cUnitTypeCavalryArcher;
      //gLandTertiaryArmyUnit = cUnitTypeGrenadier;
      //gLandPrimaryArmyUnit = cUnitTypeJanissary;//  + cUnitTypeAbusGun + cUnitTypeHussar;
      //gLandSecondaryArmyUnit = cUnitTypeAbusGun;//  + cUnitTypeAbusGun + cUnitTypeHussar;
      //gLandTertiaryArmyUnit = cUnitTypeHussar;//  + cUnitTypeAbusGun + cUnitTypeHussar; 
      gCaravelUnit = cUnitTypeGalley;
   	  if (kbGetAge() >= cAge4)
	  gAbstractArtilleryUnit = cUnitTypexpHorseArtillery;
	  else
	  gAbstractArtilleryUnit = cUnitTypeFalconet;
   }
   if (kbGetCiv() == cCivXPAztec)   
   {
	  if (kbGetAge() <= cAge2)
	  {
      gLandPrimaryArmyUnit = cUnitTypexpMacehualtin;
      gLandSecondaryArmyUnit = cUnitTypexpMacehualtin;
      gLandTertiaryArmyUnit = cUnitTypexpCoyoteMan;
	  }
	  else
	  {
      gLandPrimaryArmyUnit = cUnitTypexpEagleKnight;
      gLandSecondaryArmyUnit = cUnitTypexpEagleKnight;
      gLandTertiaryArmyUnit = cUnitTypexpEagleKnight;
	  }
      //gLandPrimaryArmyUnit = cUnitTypexpJaguarKnight;
      //gLandPrimaryArmyUnit = cUnitTypexpCoyoteMan;
      //gLandPrimaryArmyUnit = cUnitTypexpMacehualtin;
      //gLandPrimaryArmyUnit = cUnitTypexpPumaMan;
      //gLandPrimaryArmyUnit = cUnitTypexpEagleKnight;
      //gLandSecondaryArmyUnit = cUnitTypexpJaguarKnight;
      //gLandSecondaryArmyUnit = cUnitTypexpCoyoteMan;
      //gLandSecondaryArmyUnit = cUnitTypexpMacehualtin;
      //gLandSecondaryArmyUnit = cUnitTypexpPumaMan;
      //gLandSecondaryArmyUnit = cUnitTypexpEagleKnight;
      //gLandTertiaryArmyUnit = cUnitTypexpJaguarKnight;
      //gLandTertiaryArmyUnit = cUnitTypexpCoyoteMan;
      //gLandTertiaryArmyUnit = cUnitTypexpMacehualtin;
      //gLandTertiaryArmyUnit = cUnitTypexpPumaMan;
      //gLandTertiaryArmyUnit = cUnitTypexpEagleKnight;
      //gLandPrimaryArmyUnit = cUnitTypexpJaguarKnight;//  + cUnitTypexpCoyoteMan + cUnitTypexpMacehualtin;
      //gLandSecondaryArmyUnit = cUnitTypexpCoyoteMan;//  + cUnitTypexpCoyoteMan + cUnitTypexpMacehualtin;
      //gLandTertiaryArmyUnit = cUnitTypexpMacehualtin;//  + cUnitTypexpCoyoteMan + cUnitTypexpMacehualtin;
      gAbstractArtilleryUnit = cUnitTypexpArrowKnight;
	  gAbstractCounterArtilleryUnit = cUnitTypexpArrowKnight;
      gSiegeWeaponUnit = -1;
      gBarracksUnit = cUnitTypeWarHut;
      gTowerUnit = cUnitTypeWarHut;
      gTowerWagonUnit = cUnitTypeWarHutTravois;
      //gTowerUnit = cUnitTypeNoblesHut; 
      gExplorerUnit = cUnitTypexpAztecWarchief;
      //gCaravelUnit = cUnitTypeCanoe;      
      gGalleonUnit = cUnitTypexpWarCanoe;
      gFrigateUnit = cUnitTypexpTlalocCanoe;
	  gAbstractAssassinUnit = -1;
   }   

   if (kbGetCiv() == cCivXPSioux)
   {  
      gLandPrimaryArmyUnit = cUnitTypexpAxeRider;
      gLandSecondaryArmyUnit = cUnitTypexpAxeRider;
      gLandTertiaryArmyUnit = cUnitTypexpAxeRider;
      //gLandPrimaryArmyUnit = cUnitTypexpBowRider;
      //gLandPrimaryArmyUnit = cUnitTypexpRifleRider;
      //gLandPrimaryArmyUnit = cUnitTypexpCoupRider;
      //gLandPrimaryArmyUnit = cUnitTypexpWarRifle;
      //gLandSecondaryArmyUnit = cUnitTypexpAxeRider;
      //gLandSecondaryArmyUnit = cUnitTypexpBowRider;
      //gLandSecondaryArmyUnit = cUnitTypexpRifleRider;
      //gLandSecondaryArmyUnit = cUnitTypexpCoupRider;
      //gLandSecondaryArmyUnit = cUnitTypexpWarRifle;
      //gLandTertiaryArmyUnit = cUnitTypexpAxeRider;
      //gLandTertiaryArmyUnit = cUnitTypexpBowRider;
      //gLandTertiaryArmyUnit = cUnitTypexpRifleRider;
      //gLandTertiaryArmyUnit = cUnitTypexpCoupRider;
      //gLandTertiaryArmyUnit = cUnitTypexpWarRifle;
      //gLandPrimaryArmyUnit = cUnitTypexpAxeRider;//  + cUnitTypexpBowRider + cUnitTypexpRifleRider;
      //gLandSecondaryArmyUnit = cUnitTypexpBowRider;//  + cUnitTypexpBowRider + cUnitTypexpRifleRider;
      //gLandTertiaryArmyUnit = cUnitTypexpRifleRider;//  + cUnitTypexpBowRider + cUnitTypexpRifleRider;
      gAbstractArtilleryUnit = -1;
	  gAbstractCounterArtilleryUnit = -1;
      gSiegeWeaponUnit = -1;
      //gTowerUnit = cUnitTypeTeepee;
      gStableUnit = cUnitTypeCorral;
      gBarracksUnit = cUnitTypeWarHut;
      gTowerUnit = cUnitTypeWarHut;
      gTowerWagonUnit = cUnitTypeWarHutTravois;
      gExplorerUnit = cUnitTypexpLakotaWarchief;
	  gAbstractAssassinUnit = -1;

      //gCaravelUnit = cUnitTypeCanoe;      
      gGalleonUnit = cUnitTypexpWarCanoe;
   }
     
   if ( kbGetCiv() == cCivXPIroquois )
   {  
	  if (kbGetAge() <= cAge2)
	  {
      gLandPrimaryArmyUnit = cUnitTypexpTomahawk;
      gLandSecondaryArmyUnit = cUnitTypexpTomahawk;
      gLandTertiaryArmyUnit = cUnitTypexpTomahawk;
	  }
	  else
	  {
      gLandPrimaryArmyUnit = cUnitTypexpMusketWarrior;
      gLandSecondaryArmyUnit = cUnitTypexpMusketWarrior;
      gLandTertiaryArmyUnit = cUnitTypexpMusketWarrior;
	  }
      //gLandPrimaryArmyUnit = cUnitTypexpMusketWarrior;
      //gLandPrimaryArmyUnit = cUnitTypexpMusketRider;
      //gLandPrimaryArmyUnit = cUnitTypexpMantlet;
      //gLandPrimaryArmyUnit = cUnitTypexpHorseman;
      //gLandSecondaryArmyUnit = cUnitTypexpTomahawk;
      //gLandSecondaryArmyUnit = cUnitTypexpMusketWarrior;
      //gLandSecondaryArmyUnit = cUnitTypexpMusketRider;
      //gLandSecondaryArmyUnit = cUnitTypexpMantlet;
      //gLandSecondaryArmyUnit = cUnitTypexpHorseman;
      //gLandTertiaryArmyUnit = cUnitTypexpTomahawk;
      //gLandTertiaryArmyUnit = cUnitTypexpMusketWarrior;
      //gLandTertiaryArmyUnit = cUnitTypexpMusketRider;
      //gLandTertiaryArmyUnit = cUnitTypexpMantlet;
      //gLandTertiaryArmyUnit = cUnitTypexpHorseman;
      //gLandPrimaryArmyUnit = cUnitTypexpTomahawk;//  + cUnitTypexpAenna + cUnitTypexpWarRifle + cUnitTypexpMantlet;
      //gLandSecondaryArmyUnit = cUnitTypexpMantlet;//  + cUnitTypexpAenna + cUnitTypexpWarRifle + cUnitTypexpMantlet;
      //gLandTertiaryArmyUnit = cUnitTypexpMusketWarrior;//  + cUnitTypexpAenna + cUnitTypexpWarRifle + cUnitTypexpMantlet; 
      gAbstractArtilleryUnit = cUnitTypexpLightCannon;
	  gAbstractCounterArtilleryUnit = cUnitTypexpLightCannon;
      gSiegeWeaponUnit = cUnitTypexpLightCannon;
      gStableUnit = cUnitTypeCorral;
      gBarracksUnit = cUnitTypeWarHut;    
      gTowerUnit = cUnitTypeWarHut;            
      gTowerWagonUnit = cUnitTypeWarHutTravois;
      gExplorerUnit = cUnitTypexpIroquoisWarChief;
      gSiegeWeaponUnit = cUnitTypexpRam;
      //gCaravelUnit = cUnitTypeCanoe;      
      gGalleonUnit = cUnitTypexpWarCanoe;
	  gAbstractAssassinUnit = -1;
   }

   if ( (kbGetCiv() == cCivChinese) || (kbGetCiv() == cCivSPCChinese) )
   {
	  if (kbGetAge() <= cAge2)
	  {
      gLandPrimaryArmyUnit = cUnitTypeypOldHanArmy; // + cUnitTypeypTerritorialArmy + cUnitTypeypForbiddenArmy;
      gLandSecondaryArmyUnit = cUnitTypeypOldHanArmy; // + cUnitTypeypOldHanArmy + cUnitTypeypForbiddenArmy;
      gLandTertiaryArmyUnit = cUnitTypeypOldHanArmy; // + cUnitTypeypTerritorialArmy + cUnitTypeypOldHanArmy;
	  }
	  else
	  {
      gLandPrimaryArmyUnit = cUnitTypeypTerritorialArmy;
      gLandSecondaryArmyUnit = cUnitTypeypTerritorialArmy;
      gLandTertiaryArmyUnit = cUnitTypeypTerritorialArmy; 
	  }
      //gLandSecondaryArmyUnit = cUnitTypeypTerritorialArmy; // + cUnitTypeypOldHanArmy + cUnitTypeypForbiddenArmy;
      //gLandTertiaryArmyUnit = cUnitTypeypForbiddenArmy; // + cUnitTypeypTerritorialArmy + cUnitTypeypOldHanArmy;
      gAbstractArtilleryUnit = cUnitTypeypFlameThrower;
      gBarracksUnit = cUnitTypeypWarAcademy;      
      gStableUnit = -1;
      gTowerUnit = cUnitTypeypCastle;
      gTowerWagonUnit = cUnitTypeYPCastleWagon;  
      gExplorerUnit = cUnitTypeAbstractChineseMonk; 
	  gAbstractCounterArtilleryUnit = cUnitTypeypHandMortar;
      gSiegeWeaponUnit = cUnitTypeypHandMortar;
      gCaravelUnit = cUnitTypeypFireship;
      gGalleonUnit = cUnitTypeypFuchuan;
      gFrigateUnit = cUnitTypeypWarJunk;     
	  gAbstractAssassinUnit = -1;
   }
   
   if ( (kbGetCiv() == cCivJapanese) || (kbGetCiv() == cCivSPCJapanese) || (kbGetCiv() == cCivSPCJapaneseEnemy) )
   {
      gLandPrimaryArmyUnit = cUnitTypeypAshigaru;
      gLandSecondaryArmyUnit = cUnitTypeypAshigaru;
      gLandTertiaryArmyUnit = cUnitTypeypAshigaru;
      //gLandPrimaryArmyUnit = cUnitTypeypKensei;
      //gLandPrimaryArmyUnit = cUnitTypeypAshigaru;
      //gLandPrimaryArmyUnit = cUnitTypeypYumi;
      //gLandPrimaryArmyUnit = cUnitTypeypYabusame;
      //gLandPrimaryArmyUnit = cUnitTypeypNaginataRider;
      //gLandSecondaryArmyUnit = cUnitTypeypKensei;
      //gLandSecondaryArmyUnit = cUnitTypeypAshigaru;
      //gLandSecondaryArmyUnit = cUnitTypeypYumi;
      //gLandSecondaryArmyUnit = cUnitTypeypYabusame;
      //gLandSecondaryArmyUnit = cUnitTypeypNaginataRider;
      //gLandTertiaryArmyUnit = cUnitTypeypKensei;
      //gLandTertiaryArmyUnit = cUnitTypeypAshigaru;
      //gLandTertiaryArmyUnit = cUnitTypeypYumi;
      //gLandTertiaryArmyUnit = cUnitTypeypYabusame;
      //gLandTertiaryArmyUnit = cUnitTypeypNaginataRider;
      //gLandPrimaryArmyUnit = cUnitTypeypAshigaru;//  + cUnitTypeypKensei + cUnitTypeypYumi;
      //gLandSecondaryArmyUnit = cUnitTypeypNaginataRider;//  + cUnitTypeypKensei + cUnitTypeypYumi;
      //gLandTertiaryArmyUnit = cUnitTypeypYumi;//  + cUnitTypeypKensei + cUnitTypeypYumi; 
      gAbstractArtilleryUnit = cUnitTypeypFlamingArrow;
	  gAbstractCounterArtilleryUnit = cUnitTypeypFlamingArrow;
      gBarracksUnit = cUnitTypeypBarracksJapanese;
      gStableUnit = cUnitTypeypStableJapanese;
      gTowerUnit = cUnitTypeypCastle;
      gTowerWagonUnit = cUnitTypeYPCastleWagon;      
      gExplorerUnit = cUnitTypeAbstractJapaneseMonk;
      gSiegeWeaponUnit = cUnitTypeypMorutaru;
      gCaravelUnit = cUnitTypeypFune;
      gGalleonUnit = cUnitTypeypAtakabune;
      gFrigateUnit = cUnitTypeypTekkousen;  
   }
   
   if ( (kbGetCiv() == cCivIndians) || (kbGetCiv() == cCivSPCIndians) )
   {
      gLandPrimaryArmyUnit = cUnitTypeypSepoy;
      gLandSecondaryArmyUnit = cUnitTypeypSepoy;
      gLandTertiaryArmyUnit = cUnitTypeypSepoy;
      //gLandPrimaryArmyUnit = cUnitTypeAbstractGurkha;
      //gLandPrimaryArmyUnit = cUnitTypeAbstractRajput;
      //gLandPrimaryArmyUnit = cUnitTypeAbstractSowar;
      //gLandPrimaryArmyUnit = cUnitTypeAbstractZamburak;
      //gLandPrimaryArmyUnit = cUnitTypeAbstractHowdah;
      //gLandPrimaryArmyUnit = cUnitTypeAbstractMahout;
      //gLandSecondaryArmyUnit = cUnitTypeypSepoy;
      //gLandSecondaryArmyUnit = cUnitTypeypNatMercGurkha;
      //gLandSecondaryArmyUnit = cUnitTypeAbstractRajput;
      //gLandSecondaryArmyUnit = cUnitTypeAbstractSowar;
      //gLandSecondaryArmyUnit = cUnitTypeAbstractZamburak;
      //gLandSecondaryArmyUnit = cUnitTypeAbstractHowdah;
      //gLandSecondaryArmyUnit = cUnitTypeAbstractMahout;
      //gLandTertiaryArmyUnit = cUnitTypeypSepoy;
      //gLandTertiaryArmyUnit = cUnitTypeAbstractGurkha;
      //gLandTertiaryArmyUnit = cUnitTypeAbstractRajput;
      //gLandTertiaryArmyUnit = cUnitTypeAbstractSowar;
      //gLandTertiaryArmyUnit = cUnitTypeAbstractZamburak;
      //gLandTertiaryArmyUnit = cUnitTypeAbstractHowdah;
      //gLandTertiaryArmyUnit = cUnitTypeAbstractMahout;
      //gLandPrimaryArmyUnit = cUnitTypeAbstractSepoy;//  + cUnitTypeAbstractGurkha + cUnitTypeAbstractSowar;
      //gLandSecondaryArmyUnit = cUnitTypeAbstractGurkha;//  + cUnitTypeAbstractGurkha + cUnitTypeAbstractSowar;
      //gLandTertiaryArmyUnit = cUnitTypeAbstractSowar;//  + cUnitTypeAbstractGurkha + cUnitTypeAbstractSowar; 
      gAbstractArtilleryUnit = -1;
      gBarracksUnit = cUnitTypeYPBarracksIndian;
      gStableUnit = cUnitTypeypCaravanserai;
      gTowerUnit = cUnitTypeypCastle;
      gTowerWagonUnit = cUnitTypeYPCastleWagon;
      gExplorerUnit = cUnitTypeAbstractIndianMonk;
	  gAbstractCounterArtilleryUnit = cUnitTypeypSiegeElephant;
      gSiegeWeaponUnit = cUnitTypeypSiegeElephant;     
	  gAbstractAssassinUnit = -1; 
   }
   
   if (kbGetCiv() == cCivDESwedish)
   {
      gLandPrimaryArmyUnit = cUnitTypedeCarolean;
      gLandSecondaryArmyUnit = cUnitTypedeCarolean;
      gLandTertiaryArmyUnit =  cUnitTypeHussar;
	  //gAbstractArtilleryUnit = cUnitTypedeLeatherCannon;
   }
   
   if (kbGetCiv() == cCivDEInca)
   {
    if ((kbGetAge() > cAge2) || (kbTechGetStatus(cTechDEHCEarlyKallanka) == cTechStatusActive))
	  {      
	  gLandPrimaryArmyUnit = cUnitTypedeSlinger; 
      gLandSecondaryArmyUnit = cUnitTypedeSlinger;
      gLandTertiaryArmyUnit = cUnitTypedeSlinger;
	  }
	  else
	  {
      gLandPrimaryArmyUnit = cUnitTypedeJungleBowman;
      gLandSecondaryArmyUnit = cUnitTypedeJungleBowman;
      gLandTertiaryArmyUnit = cUnitTypedeJungleBowman;
	  }
	  gAbstractCounterArtilleryUnit = cUnitTypedeSlinger;
	  //gSiegeWeaponUnit = cUnitTypedeSlinger;
	  gSiegeWeaponUnit = -1;
	  gAbstractArtilleryUnit = -1;
	  gAbstractAssassinUnit = -1;
      gStableUnit = -1;
      gBarracksUnit = cUnitTypeWarHut;
      gTowerUnit = cUnitTypeWarHut;
   }
   
   
   if (kbGetCiv() == cCivDEAmericans)
   {
      gLandPrimaryArmyUnit = cUnitTypedeRegular;
      gLandSecondaryArmyUnit = cUnitTypedeRegular;
      gLandTertiaryArmyUnit =  cUnitTypeHussar;
      gAbstractArtilleryUnit = cUnitTypexpGatlingGun;
	  //gAbstractArtilleryUnit = cUnitTypedeLeatherCannon;
   }
   
   if (kbGetCiv() == cCivDEEthiopians)
   {
      gLandPrimaryArmyUnit = cUnitTypedeJavelinRider;
      gLandSecondaryArmyUnit = cUnitTypedeNeftenya;
      gLandTertiaryArmyUnit =  cUnitTypedeGascenya;
	  gAbstractArtilleryUnit = cUnitTypeFalconet;
   }
   
   if (kbGetCiv() == cCivDEHausa)
   {
      gLandPrimaryArmyUnit = cUnitTypedeJavelinRider;
      gLandSecondaryArmyUnit = cUnitTypedeFulaWarrior;
      gLandTertiaryArmyUnit =  cUnitTypedeLifidi;
	  gAbstractArtilleryUnit = cUnitTypeFalconet;
   }
   
}

//==============================================================================
/* Defend0

   Create a defend plan, protect the main base.
*/
//==============================================================================
rule defend0
inactive
group startup
minInterval 13
{

   if (gLandDefendPlan0 < 0)
   {
      gLandDefendPlan0 = aiPlanCreate("Primary Land Defend", cPlanDefend);
      aiPlanAddUnitType(gLandDefendPlan0, cUnitTypeLogicalTypeLandMilitary, 0, 0, 1); // Small, until defense reflex

      aiPlanSetVariableVector(gLandDefendPlan0, cDefendPlanDefendPoint, 0,
                              kbBaseGetMilitaryGatherPoint(cMyID, kbBaseGetMainID(cMyID)));
      aiPlanSetVariableInt(gLandDefendPlan0, cDefendPlanDefendBaseID, 0, kbBaseGetMainID(cMyID));
      aiPlanSetVariableFloat(gLandDefendPlan0, cDefendPlanEngageRange, 0, cvDefenseReflexRadiusActive);
      aiPlanSetVariableFloat(gLandDefendPlan0, cDefendPlanGatherDistance, 0, cvDefenseReflexRadiusActive - 10.0);
      aiPlanSetVariableBool(gLandDefendPlan0, cDefendPlanPatrol, 0, false);
      aiPlanSetVariableFloat(gLandDefendPlan0, cDefendPlanGatherDistance, 0, 20.0);
      aiPlanSetInitialPosition(gLandDefendPlan0, kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)));
      aiPlanSetUnitStance(gLandDefendPlan0, cUnitStanceDefensive);
      aiPlanSetVariableInt(gLandDefendPlan0, cDefendPlanRefreshFrequency, 0, 5);
      aiPlanSetVariableInt(gLandDefendPlan0, cDefendPlanAttackTypeID, 0, cUnitTypeUnit); // Only units
      aiPlanSetDesiredPriority(gLandDefendPlan0, 10); // Very low priority, don't steal from attack plans
      aiPlanSetActive(gLandDefendPlan0);
      aiEcho("Creating primary land defend plan");

      gLandReservePlan = aiPlanCreate("Land Reserve Units", cPlanDefend);
      aiPlanAddUnitType(gLandReservePlan, cUnitTypeLogicalTypeLandMilitary, 0, 5,
                        200); // All mil units, high MAX value to suck up all excess

      aiPlanSetVariableVector(gLandReservePlan, cDefendPlanDefendPoint, 0,
                              kbBaseGetMilitaryGatherPoint(cMyID, kbBaseGetMainID(cMyID)));
      if (kbBaseGetMilitaryGatherPoint(cMyID, kbBaseGetMainID(cMyID)) == cInvalidVector)
         if (getUnit(cUnitTypeAIStart, cMyID) >= 0) // If no mil gather point, but there is a start block, use it.
            aiPlanSetVariableVector(gLandReservePlan, cDefendPlanDefendPoint, 0,
                                    kbUnitGetPosition(getUnit(cUnitTypeAIStart, cMyID)));
      if (aiPlanGetVariableVector(gLandReservePlan, cDefendPlanDefendPoint, 0) ==
          cInvalidVector) // If all else failed, use main base location.
         aiPlanSetVariableVector(gLandReservePlan, cDefendPlanDefendPoint, 0,
                                 kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)));
      aiPlanSetVariableInt(gLandReservePlan, cDefendPlanDefendBaseID, 0, kbBaseGetMainID(cMyID));
      aiPlanSetVariableFloat(gLandReservePlan, cDefendPlanEngageRange, 0, 60.0); // Loose
      aiPlanSetVariableBool(gLandReservePlan, cDefendPlanPatrol, 0, false);
      aiPlanSetVariableFloat(gLandReservePlan, cDefendPlanGatherDistance, 0, 20.0);
      aiPlanSetInitialPosition(gLandReservePlan, kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)));
      aiPlanSetUnitStance(gLandReservePlan, cUnitStanceDefensive);
      aiPlanSetVariableInt(gLandReservePlan, cDefendPlanRefreshFrequency, 0, 5);
      aiPlanSetVariableInt(gLandReservePlan, cDefendPlanAttackTypeID, 0, cUnitTypeUnit); // Only units
      aiPlanSetDesiredPriority(gLandReservePlan, 5); // Very very low priority, gather unused units.
      aiPlanSetActive(gLandReservePlan);
      // if (gMainAttackGoal >= 0)
      //	aiPlanSetVariableInt(gMainAttackGoal, cGoalPlanReservePlanID, 0, gLandReservePlan);
      aiEcho("Creating reserve plan");
      xsEnableRule("endDefenseReflexDelay"); // Reset to relaxed stances after plans have a second to be created.
   }
}

//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
// General strategy (spans econ/mil)
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================

//==============================================================================
/* getActiveMissionCount(int missionType)

   Returns the number of active missions that match the optional type.  If no types
   is given, returns the total number of missions.
*/
//==============================================================================
/*int getActiveMissionCount(int missionType=-1)
{
   int retVal = 0;

   int missionCount = 0;
   int missionIndex = 0;
   int missionID = -1;

   for (missionIndex = 0; < aiPlanGetNumber(cPlanMission, -1, true))    // Step through all mission plans.  -1 means any
state is OK.
   {
      missionID = aiPlanGetIDByIndex(cPlanMission, -1, true, missionIndex);
      if ( (missionType == -1) || (aiPlanGetVariableInt(missionID, cMissionPlanType, 0) == missionType) )   // No type
specified, or type matches retVal = retVal + 1;
   }

   return(retVal);
}*/

void setMilPopLimit(int age1 = 1, int age2 = 60, int age3 = 80, int age4 = 100, int age5 = 160)
{
   int limit = 1;
   int age = kbGetAge();
   if (agingUp() == true)
      age = age + 1;
   if ((age == cvMaxAge) || (gRevolutionType != 0))
      age = cAge5; // If we're at the highest allowed age, go for our full mil pop.
   // This overrides the normal settings, so an SPC AI capped at age 3 can use his full
   // military pop.
   switch (age)
   {
   case cAge1:
   {
      limit = age1;
      break;
   }
   case cAge2:
   {
      limit = kbGetMaxPop() -140;
      break;
   }
   case cAge3:
   {
      limit = kbGetMaxPop() -120;
      break;
   }
   case cAge4:
   {
      limit = kbGetMaxPop() -99;
      break;
   }
   case cAge5:
   {
      limit = kbGetMaxPop() -50;
      break;
   }
   }
    
	 if (gAgeUpPriority > 60)
	 limit = 50;
 
   int outlawQuery = createSimpleUnitQuery(cUnitTypeAbstractOutlaw, cMyID, cUnitStateAlive);
   int numberFound = kbUnitQueryExecute(outlawQuery);

   // Compensate for the additional pop outlaws used.
   if (numberFound > 0)
   {
      int puid = -1;
      int unitID = -1;
      float additionalPop = 0.0;

      for (i = 0; < numberFound)
      {
         unitID = kbUnitQueryGetResult(outlawQuery, i);
         puid = kbUnitGetProtoUnitID(unitID);
         additionalPop = additionalPop + kbGetProtoUnitPopCount(puid);
         additionalPop =
             additionalPop -
             (kbUnitCostPerResource(unitID, cResourceFood) + kbUnitCostPerResource(unitID, cResourceWood) +
              kbUnitCostPerResource(unitID, cResourceGold) + kbUnitCostPerResource(unitID, cResourceInfluence) / 100.0);
      }

      limit = limit + additionalPop;
	/*  
	  bool homeBaseUnderAttack = false;
   if (gDefenseReflexBaseID == kbBaseGetMainID(cMyID))
      homeBaseUnderAttack = true;
  if ((homeBaseUnderAttack == true) && (age != cvMaxAge))
	 limit = 100;
 */
      //if (limit > age5)
      //   limit = age5; // Cap at max military pop.
	 if ((gRevolutionType & (cRevolutionMilitary | cRevolutionFinland)) == 0)
	 limit = kbGetMaxPop();
   }
   

   if ((cvMaxArmyPop >= 0) && (cvMaxNavyPop >= 0) && (limit > (cvMaxArmyPop + cvMaxNavyPop)))
      limit = cvMaxArmyPop + cvMaxNavyPop; // Manual pop limits have been set

   if ((cvMaxNavyPop <= 0) && (cvMaxArmyPop < limit) && (cvMaxArmyPop >= 0)) // Only army pop set?
      limit = cvMaxArmyPop;

   aiSetMilitaryPop(limit);
}

//==============================================================================
/* rule popManager

   Set population limits based on age, difficulty and control variable settings
*/
//==============================================================================
rule popManager
active
minInterval 15
{
   float difficulty = aiGetWorldDifficulty();
   int intDifficulty = difficulty;
   int cvPopLimit = kbGetMaxPop(); // Used to calculate implied total pop limit based on civ, army and navy components.
   int maxVilPop = kbGetBuildLimit(cMyID, gEconUnit);

   if (maxVilPop < 0)
      maxVilPop = cvPopLimit;

   if ((cvMaxCivPop >= 0) && (cvMaxArmyPop >= 0) && (cvMaxNavyPop >= 0)) // All three are defined, so set a hard total
      cvPopLimit = cvMaxCivPop + cvMaxArmyPop + cvMaxNavyPop;

   int maxMil = -1; // The full age-5 max military size...to be reduced in earlier ages to control runaway spending.

   switch (intDifficulty)
   {
   case cDifficultySandbox:                               // Sandbox
   {                                                      // Typically 20 econ, 20 mil
      gMaxPop = cvPopLimit; //gMaxPop = 40 + (30 * (difficulty - intDifficulty)); // Interpolate between integers
      if (gMaxPop > cvPopLimit)
         gMaxPop = cvPopLimit;
      // 10 minutes.
   if (kbGetAge() < cvMaxAge)
   {
      gAttackMissionInterval = 5*60*1000;
   }
  else
  {
	  if (gAgeUpPriority >= 60)
      gAttackMissionInterval = 5*60*1000;
  else
	  if (xsGetTime() < 60 * 60 * 1000)
      gAttackMissionInterval = 4*60*1000;
  else
      gAttackMissionInterval = 2.0*60*1000;
  }
      if ((gRevolutionType & (cRevolutionMilitary | cRevolutionFinland)) == 0)
      {
         aiSetEconomyPop(99);
         if (aiGetEconomyPop() > maxVilPop)
            aiSetEconomyPop(maxVilPop);
         if ((aiGetEconomyPop() > cvMaxCivPop) && (cvMaxCivPop >= 0))
            aiSetEconomyPop(cvMaxCivPop);
      }
      else
      {
         aiSetEconomyPop(0);
      }
	  maxMil = gMaxPop;  
      setMilPopLimit(0, maxMil, maxMil, maxMil, maxMil); 
      break;
   }
   case cDifficultyEasy:                                  // Easiest
   {                                                      // Typically 35 econ, 35 mil.
      gMaxPop = cvPopLimit; //gMaxPop = 70 + (50 * (difficulty - intDifficulty)); // 70 at easy up to 120 at moderate
      if (gMaxPop > cvPopLimit)
         gMaxPop = cvPopLimit;
      // 8 minutes.
   if (kbGetAge() < cvMaxAge)
   {
      gAttackMissionInterval = 5*60*1000;
   }
  else
  {
	  if (gAgeUpPriority >= 60)
      gAttackMissionInterval = 5*60*1000;
  else
	  if (xsGetTime() < 60 * 60 * 1000)
      gAttackMissionInterval = 4*60*1000;
  else
      gAttackMissionInterval = 2.0*60*1000;
  }
      if (gSPC == true)
         gMaxPop = cvPopLimit; //;
      if ((gRevolutionType & (cRevolutionMilitary | cRevolutionFinland)) == 0)
      {
         aiSetEconomyPop(99);
         if (gSPC == true)
            aiSetEconomyPop(99);
         if (aiGetEconomyPop() > maxVilPop)
            aiSetEconomyPop(maxVilPop);
         if ((aiGetEconomyPop() > cvMaxCivPop) && (cvMaxCivPop >= 0))
            aiSetEconomyPop(cvMaxCivPop);
      }
      else
      {
         aiSetEconomyPop(0);
      }
	  maxMil = gMaxPop;  
      setMilPopLimit(0, maxMil, maxMil, maxMil, maxMil); 
      break;
   }
   case cDifficultyModerate:                               // Moderate
   {                                                       // Typically 60 econ, 60 mil
      gMaxPop = 120 + (80 * (difficulty - intDifficulty)); // 120 at moderate up to 200 at hard
      if (gMaxPop > cvPopLimit)
         gMaxPop = cvPopLimit;
      // 5 minutes.
   if (kbGetAge() < cvMaxAge)
   {
      gAttackMissionInterval = 5*60*1000;
   }
  else
  {
	  if (gAgeUpPriority >= 60)
      gAttackMissionInterval = 5*60*1000;
  else
	  if (xsGetTime() < 55 * 60 * 1000)
      gAttackMissionInterval = 4*60*1000;
  else
      gAttackMissionInterval = 2.0*60*1000;
  }
      if (gSPC == true)
         gMaxPop = cvPopLimit; //gMaxPop = 105;
      if ((gRevolutionType & (cRevolutionMilitary | cRevolutionFinland)) == 0)
      {
         aiSetEconomyPop(99);
         if (gSPC == true)
            aiSetEconomyPop(99);
         if (aiGetEconomyPop() > maxVilPop)
            aiSetEconomyPop(maxVilPop);
         if ((aiGetEconomyPop() > cvMaxCivPop) && (cvMaxCivPop >= 0))
            aiSetEconomyPop(cvMaxCivPop);
      }
      else
      {
         aiSetEconomyPop(0);
      }
	  maxMil = gMaxPop;  
      setMilPopLimit(0, maxMil, maxMil, maxMil, maxMil); 
      break;
   }
   case cDifficultyHard: // Hard
   {                     // Typically 90 econ, 110 mil.
      gMaxPop = kbGetMaxPop();
      if (gMaxPop > cvPopLimit)
         gMaxPop = cvPopLimit;
      // 3 minutes.
      if (gSPC == true)
      {
   if (kbGetAge() < cvMaxAge)
   {
      gAttackMissionInterval = 3*60*1000;
   }
  else
  {
	  if (gAgeUpPriority >= 60)
      gAttackMissionInterval = 5*60*1000;
  else
	  if (xsGetTime() < 45 * 60 * 1000)
      gAttackMissionInterval = 2*60*1000;
  else
      gAttackMissionInterval = 2.0*60*1000;
  }
         gMaxPop = cvPopLimit; //gMaxPop = 185;
      }
      else
   if (kbGetAge() < cvMaxAge)
   {
      gAttackMissionInterval = 4*60*1000;
   }
  else
  {
	  if (gAgeUpPriority >= 60)
      gAttackMissionInterval = 5*60*1000;
  else
	  if (xsGetTime() < 50 * 60 * 1000)
      gAttackMissionInterval = 3*60*1000;
  else
      gAttackMissionInterval = 2.0*60*1000;
  }
      if ((gRevolutionType & (cRevolutionMilitary | cRevolutionFinland)) == 0)
      {
         aiSetEconomyPop(99);
         if (gSPC == true)
            aiSetEconomyPop(99);
         if (aiGetEconomyPop() > maxVilPop)
            aiSetEconomyPop(maxVilPop);
         if ((aiGetEconomyPop() > cvMaxCivPop) && (cvMaxCivPop >= 0))
            aiSetEconomyPop(cvMaxCivPop);
      }
      else
      {
         aiSetEconomyPop(0);
      }
	  maxMil = gMaxPop;  
      setMilPopLimit(0, maxMil, maxMil, maxMil, maxMil); 
      break;
   }
   case cDifficultyExpert: // Expert
   {                       // Typically 90 econ, 110 mil.
      gMaxPop = kbGetMaxPop();
      if (gMaxPop > cvPopLimit)
         gMaxPop = cvPopLimit;
      // 2 minutes.
   if (kbGetAge() < cvMaxAge)
   {
      gAttackMissionInterval = 3*60*1000;
   }
  else
  {
	  if (gAgeUpPriority >= 60)
      gAttackMissionInterval = 5*60*1000;
  else
	  if (xsGetTime() < 45 * 60 * 1000)
      gAttackMissionInterval = 2*60*1000;
  else
      gAttackMissionInterval = 2.0*60*1000;
  }
      if ((gRevolutionType & (cRevolutionMilitary | cRevolutionFinland)) == 0)
      {
         aiSetEconomyPop(99);
         if (aiGetEconomyPop() > maxVilPop)
            aiSetEconomyPop(maxVilPop);
         if ((aiGetEconomyPop() > cvMaxCivPop) && (cvMaxCivPop >= 0))
            aiSetEconomyPop(cvMaxCivPop);
      }
      else
      {
         aiSetEconomyPop(0);
      }
	  maxMil = gMaxPop;  
      setMilPopLimit(0, maxMil, maxMil, maxMil, maxMil); 
      // setMilPopLimit(maxMil / 6, maxMil / 3, maxMil / 2, maxMil, maxMil);
      break;
   }

   case cDifficultyExtreme: // Extreme
   {                        // Typically 90 econ, 110 mil.
      gMaxPop = kbGetMaxPop();
      if (gMaxPop > cvPopLimit)
         gMaxPop = cvPopLimit;
      // 2 minutes.
   if (kbGetAge() < cvMaxAge)
   {
      gAttackMissionInterval = 3*60*1000;
   }
  else
  {
	  if (gAgeUpPriority >= 60)
      gAttackMissionInterval = 5*60*1000;
  else
	  if (xsGetTime() < 40 * 60 * 1000)
      gAttackMissionInterval = 2*60*1000;
  else
      gAttackMissionInterval = 2.0*60*1000;
  }
      if ((gRevolutionType & (cRevolutionMilitary | cRevolutionFinland)) == 0)
      {
         aiSetEconomyPop(99);
         if (aiGetEconomyPop() > maxVilPop)
            aiSetEconomyPop(maxVilPop);
         if ((aiGetEconomyPop() > cvMaxCivPop) && (cvMaxCivPop >= 0))
            aiSetEconomyPop(cvMaxCivPop);
      }
      else
      {
         aiSetEconomyPop(0);
      }
	  maxMil = gMaxPop;  
      setMilPopLimit(0, maxMil, maxMil, maxMil, maxMil); 
      // setMilPopLimit(maxMil / 6, maxMil / 3, maxMil / 2, maxMil, maxMil);
      break;
   }
   }

	 if (gAgeUpPriority > 60)
	 {
		 maxMil = 50;
         setMilPopLimit(0, maxMil, maxMil, maxMil, maxMil); 
	 }
   // Limit the amount of military units we train if we haven't reached the minimum age we want.
   /*if (aiGetWorldDifficulty() >= gDifficultyExpert)
   {
      if (btRushBoom <= -0.5) // Fast industrial
         setMilPopLimit(maxMil / 6, maxMil / 6, maxMil / 6, maxMil, maxMil);
      else if (btRushBoom <= 0.0) // Fast fortress
         setMilPopLimit(maxMil / 6, maxMil / 6, maxMil / 2, maxMil, maxMil);
      else // Rush
         setMilPopLimit(maxMil / 6, maxMil / 2, maxMil / 2, maxMil, maxMil);
   }*/
         //if (kbGetAge() < cvMaxAge)
         //setMilPopLimit(maxMil / 6, maxMil / 4, maxMil / 4, maxMil / 2, maxMil);

   if (aiTreatyGetEnd() > xsGetTime() + 10 * 60 * 1000 && (gExcessResources == false || kbGetAge() < cvMaxAge))
      aiSetMilitaryPop(0);
  
   //gGoodArmyPop = aiGetMilitaryPop() / 3;
        gGoodArmyPop = 15;
    if (kbGetAge() == cAge1)
		gGoodArmyPop = 1;
    if (kbGetAge() == cAge2)
		gGoodArmyPop = 15;
    if (kbGetAge() == cAge3)
		gGoodArmyPop = 15;
    if (kbGetAge() == cAge4)
		gGoodArmyPop = 15;
    if (kbGetAge() == cAge5)
		gGoodArmyPop = 15;
	
   //gGoodArmyPop = aiGetMilitaryPop() / 3;
   // if ( (kbGetAge() == cAge2) && ((xsGetTime() - gAgeUpTime) < 300000) )   // In the first five minutes of age 2, go
   // with tiny armies.
   //   gGoodArmyPop = gGoodArmyPop / 2;

   /*
   aiEcho(" ");
   aiEcho("Population tests:");
   aiEcho("  aiGetEconomyPop() "+ aiGetEconomyPop());
   aiEcho("  aiGetMilitaryPop() "+ aiGetMilitaryPop());
   aiEcho("  aiGetCurrentEconomyPop() "+ aiGetCurrentEconomyPop());
   aiEcho("  aiGetAvailableEconomyPop() "+ aiGetAvailableEconomyPop());
   aiEcho("  aiGetAvailableMilitaryPop() "+ aiGetAvailableMilitaryPop());
   aiEcho("  kbGetPopCap() "+ kbGetPopCap());
   aiEcho("  kbGetPop() "+ kbGetPop());
   aiEcho(" ");
   */
}

rule wagonMonitor
inactive
minInterval 10
{
   if (cvOkToBuild == false)
      return;

   int planID = -1;
   int numPlans = aiPlanGetActiveCount();
   int i = 0;
   int j = 0;
   int wagonType = -1;
   int wagonQueryID = createSimpleUnitQuery(cUnitTypeAbstractWagon, cMyID, cUnitStateAlive);
   int numberFound = kbUnitQueryExecute(wagonQueryID);
   int wagon = -1;

   if (numberFound == 0)
      return;
		
   // First check existing build plans and find if we have wagons to build.
   for (i = 0; < numPlans)
   {
      planID = aiPlanGetIDByActiveIndex(i);
      if (aiPlanGetType(planID) != cPlanBuild)
         continue;
      if (aiPlanGetState(planID) == cPlanStateBuild)
         continue;
      wagonType = findWagonToBuild(aiPlanGetVariableInt(planID, cBuildPlanBuildingTypeID, 0));
      if (wagonType >= 0)
      {
         for (j = 0; < numberFound)
         {
            wagon = kbUnitQueryGetResult(wagonQueryID, j);
            if (kbUnitGetPlanID(wagon) >= 0)
               continue;
            if (kbUnitIsType(wagon, wagonType) == false)
               continue;
            // Remove villagers from plan if there are some.
            if (aiPlanGetNumberUnits(planID, gEconUnit) > 0)
               aiPlanAddUnitType(planID, gEconUnit, 0, 0, 0);
            aiPlanAddUnitType(planID, wagonType, 1, 1, 1);
            aiPlanAddUnit(planID, wagon);
            break;
         }
      }
   }

	// Pick up unused Wagons and let them train something on their own without existing Build Plans.
   for (i = 0; < numberFound)
   {
      wagon = kbUnitQueryGetResult(wagonQueryID, i);
      if (kbUnitGetPlanID(wagon) >= 0)
         continue;
      wagonType = kbUnitGetProtoUnitID(wagon);
      int buildingType = -1;
		
		if (aiGetGameMode() == cGameModeEmpireWars && wagonType == cUnitTypedeImperialWagon)
		{
			if (cMyCiv == cCivDutch && 
			   kbUnitCount(cMyID, cUnitTypeBank, cUnitStateABQ) < kbGetBuildLimit(cMyID, cUnitTypeBank) && 
			   aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeBank) < 0)
			{
				buildingType = cUnitTypeBank;
			}
			else if (kbGetAge() >= cAge3 && 
			        kbUnitCount(cMyID, cUnitTypeTownCenter, cUnitStateABQ) < kbGetBuildLimit(cMyID, cUnitTypeTownCenter) &&
			        aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeTownCenter) < 0)
			{
				buildingType = cUnitTypeTownCenter;
			}
			else
			{
				if (cMyCiv == cCivXPAztec)  
				{
					if (kbGetAge() >= cAge3 && 
					   kbUnitCount(cMyID, cUnitTypeNoblesHut, cUnitStateABQ) < kbGetBuildLimit(cMyID, cUnitTypeNoblesHut) &&
			         aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeNoblesHut) < 0)
					{
						buildingType = cUnitTypeNoblesHut;
					}
					else if (kbUnitCount(cMyID, cUnitTypeWarHut, cUnitStateABQ) < kbGetBuildLimit(cMyID, cUnitTypeWarHut) &&
			              aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeWarHut) < 0)
					{
						buildingType = cUnitTypeWarHut;
					}
				}
				else if (civIsAfrican() == true &&
						  kbGetAge() >= cAge2 && 
						  kbUnitCount(cMyID, cUnitTypedePalace, cUnitStateABQ) < kbGetBuildLimit(cMyID, cUnitTypedePalace) &&
						  aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypedePalace) < 0)
				{
					buildingType = cUnitTypedePalace;
				}	
				else if (cMyCiv != cCivXPSioux &&
					    kbUnitCount(cMyID, gTowerUnit, cUnitStateABQ) < kbGetBuildLimit(cMyID, gTowerUnit) && 
			          aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, gTowerUnit) < 1)
				{
					buildingType = gTowerUnit;
				}
				else if (cMyCiv == cCivXPSioux &&
				        kbUnitCount(cMyID, cUnitTypeWarHut, cUnitStateABQ) < kbGetBuildLimit(cMyID, cUnitTypeWarHut) &&
						  aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeWarHut) < 0)
				{
					buildingType = cUnitTypeWarHut;
				}
			}
			
			if (buildingType != -1)
			{
				// Make the actual Build Plan and go to next iteration.
				planID = createSimpleBuildPlan(buildingType, 1, 75, true, cEconomyEscrowID, kbBaseGetMainID(cMyID), 0);
				aiPlanAddUnit(planID, wagon);
				continue;
			}
		}

      switch (wagonType)
      {
      case cUnitTypeOutpostWagon:
      {
         if (cMyCiv == cCivRussians)
            buildingType = cUnitTypeBlockhouse;
         else if (civIsNative() == true)
            buildingType = cUnitTypeWarHut;
         else if (civIsAfrican() == true)
            buildingType = cUnitTypedeTower;
         else
            buildingType = cUnitTypeOutpost;
         break;
      }
      case cUnitTypeFactoryWagon:
      {
         buildingType = cUnitTypeFactory;
         break;
      }
      // XPack
      case cUnitTypeFarmTravois:
      {
         buildingType = cUnitTypeFarm;
         break;
      }
      case cUnitTypeWarHutTravois:
      {
         buildingType = cUnitTypeWarHut;
         break;
      }
      case cUnitTypeNoblesHutTravois:
      {
         buildingType = cUnitTypeNoblesHut;
         break;
      }
      // YPack
      case cUnitTypeYPVillageWagon:
      {
         buildingType = cUnitTypeypVillage;
         break;
      }
      case cUnitTypeypShrineWagon:
      {
         buildingType = cUnitTypeypShrineJapanese;
         break;
      }
      case cUnitTypeypMarketWagon:
      {
         buildingType = cUnitTypeypTradeMarketAsian;
         break;
      }
      case cUnitTypeYPSacredFieldWagon:
      {
         buildingType = cUnitTypeypSacredField;
         break;
      }
      case cUnitTypeYPDockWagon:
      {
         buildingType = gDockUnit;
         break;
      }
      case cUnitTypeYPRicePaddyWagon:
      {
         buildingType = cUnitTypeypRicePaddy;
         break;
      }
      case cUnitTypeYPCastleWagon:
      {
         buildingType = cUnitTypeypCastle;
         break;
      }
      case cUnitTypeypTradingPostWagon:
      {
         buildingType = cUnitTypeTradingPost;
         break;
      }
      case cUnitTypeYPMilitaryRickshaw:
      {
         if (kbUnitCount(cMyID, cUnitTypeypBarracksJapanese, cUnitStateABQ) <
             kbUnitCount(cMyID, cUnitTypeypStableJapanese, cUnitStateABQ))
            buildingType = cUnitTypeypBarracksJapanese;
         else
            buildingType = cUnitTypeypStableJapanese;
         break;
      }
      case cUnitTypeYPMonasteryWagon:
      {
         buildingType = cUnitTypeypMonastery;
         break;
      }
      case cUnitTypedeKallankaTravois:
      {
         buildingType = cUnitTypedeKallanka;
         break;
      }
      case cUnitTypeYPDojoWagon:
      {
         buildingType = cUnitTypeypDojo;
         break;
      }
      case cUnitTypeYPBerryWagon1:
      {
         buildingType = cUnitTypeypBerryBuilding;
         break;
      }
      case cUnitTypeYPGroveWagon:
      {
         buildingType = cUnitTypeypGroveBuilding;
         break;
      }
      case cUnitTypeypArsenalWagon:
      {
         if (cMyCiv == cCivJapanese || cMyCiv == cCivSPCJapanese || cMyCiv == cCivSPCJapaneseEnemy)
            buildingType = cUnitTypeypArsenalAsian;
         else
            buildingType = cUnitTypeArsenal;
         break;
      }
      case cUnitTypeypBankWagon:
      {
         buildingType = cUnitTypeypBankAsian;
         break;
      }
      case cUnitTypeypChurchWagon:
      {
         if (cMyCiv == cCivJapanese || cMyCiv == cCivSPCJapanese || cMyCiv == cCivSPCJapaneseEnemy
		 || cMyCiv == cCivIndians || cMyCiv == cCivChinese)
            buildingType = cUnitTypeypChurch;
         else
            buildingType = cUnitTypeChurch;
         break;
      }
      case cUnitTypeypBlockhouseWagon:
      {
         buildingType = cUnitTypeBlockhouse;
         break;
      }
      case cUnitTypeYPStableWagon:
      {
         if (cMyCiv == cCivJapanese || cMyCiv == cCivSPCJapanese || cMyCiv == cCivSPCJapaneseEnemy)
            buildingType = cUnitTypeypStableJapanese;
         else if (cMyCiv == cCivIndians)
            buildingType = cUnitTypeypCaravanserai;
         else if (cMyCiv == cCivChinese)
            buildingType = cUnitTypeypWarAcademy;
         else if (cMyCiv == cCivXPIroquois || cMyCiv == cCivXPSioux)
            buildingType = cUnitTypeCorral;
         else if (cMyCiv == cCivXPAztec || cMyCiv == cCivDEInca)
            buildingType = cUnitTypeWarHut;
         else
            buildingType = cUnitTypeStable;
         break;
      }
      // DE
      case cUnitTypedeIncaStrongholdTravois:
      {
         buildingType = cUnitTypedeIncaStronghold;
         break;
      }
      case cUnitTypedeBuilderInca:
      {
         if ((gTimeToFarm == true) &&
             (kbUnitCount(cMyID, cUnitTypeFarm, cUnitStateABQ) <=
              aiGetResourceBreakdownNumberPlans(cResourceFood, cAIResourceSubTypeFarm, kbBaseGetMainID(cMyID))) &&
             (aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeFarm) < 0))
            buildingType = cUnitTypeFarm;
         else if ((kbGetAge() >= cAge3) &&
                  (kbUnitCount(cMyID, cUnitTypedeKallanka, cUnitStateABQ) <
                   kbGetBuildLimit(cMyID, cUnitTypedeKallanka)) &&
                  (aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypedeKallanka) < 0))
            buildingType = cUnitTypedeKallanka;
         else if (kbUnitCount(cMyID, cUnitTypeWarHut, cUnitStateABQ) < kbGetBuildLimit(cMyID, cUnitTypeWarHut) &&
                  (aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeWarHut) < 0))
            buildingType = cUnitTypeWarHut;
         else // farm has no build limit
            buildingType = cUnitTypeFarm;
         break;
      }
      case cUnitTypedeTorpWagon:
      {
         if (cMyCiv == cCivDESwedish)
            buildingType = cUnitTypedeTorp;
         else
            buildingType = cUnitTypedeTorpGeneric;
         break;
      }
      case cUnitTypedeProspectorWagon:
      {
         buildingType = cUnitTypedeMineCopperBuildable;
         break;
      }
      case cUnitTypedeProspectorWagonGold:
      {
         buildingType = cUnitTypedeMineGoldBuildable;
         break;
      }
      case cUnitTypedeREVProspectorWagon:
      {
         buildingType = cUnitTypedeREVMineDiamondBuildable;
         break;
      }
		case cUnitTypedeProspectorWagonSilver:
      {
         buildingType = cUnitTypedeMineSilverBuildable;
         break;
      }
      case cUnitTypedeHomesteadWagon:
      {
         if ((gTimeForPlantations == true) &&
             (kbUnitCount(cMyID, cUnitTypePlantation, cUnitStateABQ) <=
              aiGetResourceBreakdownNumberPlans(cResourceGold, cAIResourceSubTypeFarm, kbBaseGetMainID(cMyID))) &&
             (aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypePlantation) < 0))
            buildingType = cUnitTypePlantation;
         else if ((gTimeToFarm == true) &&
                  (kbUnitCount(cMyID, cUnitTypeMill, cUnitStateABQ) <=
                   aiGetResourceBreakdownNumberPlans(cResourceFood, cAIResourceSubTypeFarm, kbBaseGetMainID(cMyID))) &&
                  (aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeMill) < 0))
            buildingType = cUnitTypeMill;
         else if (kbUnitCount(cMyID, cUnitTypeHerdable, cUnitStateAlive) > 0)
            buildingType = cUnitTypeLivestockPen;
         else // defaults to mill, can be built anytime
            buildingType = cUnitTypeMill;
         break;
      }
      case cUnitTypedeMilitaryWagon:
      {
         int barracks = cUnitTypeBarracks;
         if (cMyCiv == cCivRussians)
            barracks = cUnitTypeBlockhouse;
         if (kbUnitCount(cMyID, barracks, cUnitStateABQ) < kbUnitCount(cMyID, cUnitTypeStable, cUnitStateABQ) ||
             kbUnitCount(cMyID, barracks, cUnitStateABQ) < kbUnitCount(cMyID, cUnitTypeArtilleryDepot, cUnitStateABQ) ||
             kbUnitCount(cMyID, barracks, cUnitStateABQ) == 0)
            buildingType = barracks;
         else if (kbUnitCount(cMyID, cUnitTypeStable, cUnitStateABQ) <
                      kbUnitCount(cMyID, cUnitTypeArtilleryDepot, cUnitStateABQ) ||
                  kbUnitCount(cMyID, cUnitTypeStable, cUnitStateABQ) == 0)
            buildingType = cUnitTypeStable;
         else
            buildingType = cUnitTypeArtilleryDepot;
         break;
      }
      case cUnitTypedeEmbassyTravois:
      {
         buildingType = cUnitTypeNativeEmbassy;
         break;
      }
      case gCoveredWagonUnit:
      {
         buildingType = cUnitTypeTownCenter;
         break;
      }
      case cUnitTypedeFurTradeTravois:
      {
         buildingType = cUnitTypedeFurTrade;
         break;
      }
      case cUnitTypedeStateCapitolWagon:
      {
         buildingType = cUnitTypedeStateCapitol;
         break;
      }
      case cUnitTypedeTradingPostWagon:
      {
         buildingType = -1;

         if (kbTechGetStatus(cTechDEHCArkansasPost) == cTechStatusActive)
         {
            if ((kbUnitCount(cMyID, cUnitTypeMarket, cUnitStateABQ) < 1) &&
                (aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeMarket) < 0))
               buildingType = cUnitTypeMarket;
            else if ((kbUnitCount(cMyID, cUnitTypeChurch, cUnitStateABQ) < kbGetBuildLimit(cMyID, cUnitTypeChurch)) &&
                     (aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeChurch) < 0))
               buildingType = cUnitTypeChurch;
            else if ((kbUnitCount(cMyID, cUnitTypeSaloon, cUnitStateABQ) < kbGetBuildLimit(cMyID, cUnitTypeSaloon)) &&
                     (aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeSaloon) < 0))
               buildingType = cUnitTypeSaloon;
         }

         break;
      }
      case cUnitTypeDEMillWagon:
      {
         buildingType = cUnitTypeMill;
         break;
      }
      case cUnitTypedePlantationWagon:
      {
         buildingType = cUnitTypePlantation;
         break;
      }
      case cUnitTypedeBuilderAfrican:
      {
         if ((kbUnitCount(cMyID, cUnitTypedeLivestockMarket, cUnitStateABQ) < 1) &&
             (aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypedeLivestockMarket) < 0))
            buildingType = cUnitTypedeLivestockMarket;
         break;
      }
      case cUnitTypedeLivestockMarketWagon:
      {
         buildingType = cUnitTypedeLivestockMarket;
         break;
      }
      case cUnitTypedeCampWagon:
      {
         buildingType = cUnitTypedeWarCamp;
         break;
      }
      case cUnitTypedeTowerBuilder:
      {
         buildingType = cUnitTypedeTower;
         break;
      }
      case cUnitTypedeMountainMonasteryBuilder:
      {
         buildingType = cUnitTypedeMountainMonastery;
         break;
      }
      case cUnitTypedeBuilderHausa:
      {
         if ((kbUnitCount(cMyID, cUnitTypedeLivestockMarket, cUnitStateABQ) < 1) &&
             (aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypedeLivestockMarket) < 0))
            buildingType = cUnitTypedeLivestockMarket;
         else if ((kbUnitCount(cMyID, cUnitTypedeWarCamp, cUnitStateABQ) < 3) &&
                  (aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypedeWarCamp) < 0))
            buildingType = cUnitTypedeWarCamp;
			else if ((kbUnitCount(cMyID, gTowerUnit, cUnitStateABQ) < kbGetBuildLimit(gTowerUnit)) &&
                  (aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, gTowerUnit) < 0) &&
						(kbTechGetStatus(cTechDEAllegianceHausaArewa) == cTechStatusActive))
				buildingType = gTowerUnit;
			else if ((kbUnitCount(cMyID, gHouseUnit, cUnitStateABQ) < kbGetBuildLimit(gHouseUnit)) &&
                  (aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, gHouseUnit) < 0))
				buildingType = gHouseUnit;
         break;
      }
      case cUnitTypedeBuilderKingdom:
      {
         if ((kbUnitCount(cMyID, cUnitTypeTownCenter, cUnitStateABQ) < 1) &&
             (aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeTownCenter) < 0))
            buildingType = cUnitTypeTownCenter;
         else if ((kbUnitCount(cMyID, cUnitTypedeUniversity, cUnitStateABQ) < 1) &&
                  (aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypedeUniversity) < 0))
            buildingType = cUnitTypedeUniversity;
         else if ((kbUnitCount(cMyID, cUnitTypedePalace, cUnitStateABQ) < 1) &&
                  (aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypedePalace) < 0))
            buildingType = cUnitTypedePalace;
         break;
      }
      case cUnitTypedeUniversityBuilder:
      {
         if (kbUnitCount(cMyID, cUnitTypedeUniversity, cUnitStateABQ) < kbGetBuildLimit(cMyID, cUnitTypedeUniversity))
            buildingType = cUnitTypedeUniversity;
         break;
      }
		case cUnitTypedePalaceBuilder:
      {
         if (kbUnitCount(cMyID, cUnitTypedePalace, cUnitStateABQ) < kbGetBuildLimit(cMyID, cUnitTypedePalace))
            buildingType = cUnitTypedePalace;
         break;
      }
    case cUnitTypedeLivestockPenWagonJapanese:
      {
         buildingType = cUnitTypeYPLivestockPenAsian;
         break;
	  }
		case cUnitTypedeRedSeaWagon:
		{
			buildingType = cUnitTypedeWarCamp;
         break;
      }
		case cUnitTypeFortWagon:
		{
			if (cMyCiv == cCivChinese)
			buildingType = cUnitTypeFortFrontier;
         break;
      }
		}

      if (buildingType < 0)
         continue;

      // are we on build limit?
      int buildLimit = kbGetBuildLimit(cMyID, buildingType);
      if (buildLimit >= 1)
      {
         int numBuildings = kbUnitCount(cMyID, buildingType, cUnitStateAlive);

         if (numBuildings < buildLimit)
         {
            for (j = 0; < numPlans)
            {
               planID = aiPlanGetIDByActiveIndex(j);
               if (aiPlanGetType(planID) != cPlanBuild)
                  continue;
               if (aiPlanGetVariableInt(planID, cBuildPlanBuildingTypeID, 0) != buildingType)
                  continue;
               numBuildings = numBuildings + 1;
            }
         }
			
         if (numBuildings >= buildLimit)
            continue;
      }

      planID = createSimpleBuildPlan(buildingType, 1, 75, true, cEconomyEscrowID, kbBaseGetMainID(cMyID), 1);
		aiPlanAddUnit(planID, wagon);
   }
}

//==============================================================================
/* townCenterComplete

   Wait until the town center is complete, then build other stuff next to it.
   In a start with a TC, this will fire very quickly.
   In a scenario with no TC, we do the best we can.

*/
//==============================================================================
rule townCenterComplete
inactive
minInterval 2
{
   // First, create a query if needed, then use it to look for a completed town center
   static int townCenterQuery = -1;
   if (townCenterQuery < 0)
   {
      townCenterQuery = kbUnitQueryCreate("Completed Town Center Query");
      kbUnitQuerySetIgnoreKnockedOutUnits(townCenterQuery, true);
      if (townCenterQuery < 0)
         aiEcho("****  Query create failed in townCenterComplete.");
      // Define the query
      if (townCenterQuery != -1)
      {
         kbUnitQuerySetPlayerID(townCenterQuery, cMyID);
         kbUnitQuerySetUnitType(townCenterQuery, cUnitTypeTownCenter);
         kbUnitQuerySetState(townCenterQuery, cUnitStateAlive);
      }
   }

   // Run the query
   kbUnitQueryResetResults(townCenterQuery);
   int count = kbUnitQueryExecute(townCenterQuery);

   //-- If our startmode is one without a TC, wait until a TC is found.
   if ((count < 1) && (gStartMode != cStartModeScenarioNoTC))
      return;

   int tcID = kbUnitQueryGetResult(townCenterQuery, 0);
   aiEcho("New TC is " + tcID + " at " + kbUnitGetPosition(tcID));

   if (tcID >= 0)
   {
      int tcBase = kbUnitGetBaseID(tcID);
      gMainBase = kbBaseGetMainID(cMyID);
      aiEcho(" TC base is " + tcBase + ", main base is " + gMainBase);
      // We have a TC.  Make sure that the main base exists, and it includes the TC
      if (gMainBase < 0)
      { // We have no main base, create one
         gMainBase = createMainBase(kbUnitGetPosition(tcID));
         aiEcho(" We had no main base, so we created one: " + gMainBase);
      }
      aiEcho("TC base area group has " + getAreaGroupNumberTiles(kbAreaGroupGetIDByPosition(kbUnitGetPosition(tcID))) +
             " number of tiles.");
      tcBase = kbUnitGetBaseID(tcID); // in case base ID just changed
      if (tcBase != gMainBase)
      {
         aiEcho(" TC " + tcID + " is not in the main base (" + gMainBase + ".");
         aiEcho(" Setting base " + gMainBase + " to non-main, setting base " + tcBase + " to main.");
         kbBaseSetMain(cMyID, gMainBase, false);
         aiRemoveResourceBreakdown(cResourceFood, cAIResourceSubTypeEasy, gMainBase);
         aiRemoveResourceBreakdown(cResourceFood, cAIResourceSubTypeHunt, gMainBase);
         aiRemoveResourceBreakdown(cResourceFood, cAIResourceSubTypeHerdable, gMainBase);
         aiRemoveResourceBreakdown(cResourceFood, cAIResourceSubTypeHuntAggressive, gMainBase);
         aiRemoveResourceBreakdown(cResourceFood, cAIResourceSubTypeFish, gMainBase);
         aiRemoveResourceBreakdown(cResourceFood, cAIResourceSubTypeFarm, gMainBase);
         aiRemoveResourceBreakdown(cResourceWood, cAIResourceSubTypeEasy, gMainBase);
         aiRemoveResourceBreakdown(cResourceGold, cAIResourceSubTypeEasy, gMainBase);
         kbBaseSetMain(cMyID, tcBase, true);
         gMainBase = tcBase;
      }
      // Setup initial base distance.
      kbBaseSetPositionAndDistance(cMyID, gMainBase, kbBaseGetLocation(cMyID, gMainBase), 40.0);
   }
   else
   {
      aiEcho("No TC, leaving main base as it is.");
   }

   kbBaseSetMaximumResourceDistance(cMyID, kbBaseGetMainID(cMyID), 80.0); // down from 150.

   // Set up the escrows
   kbEscrowSetPercentage(cEconomyEscrowID, cResourceFood, .70);
   kbEscrowSetPercentage(cEconomyEscrowID, cResourceWood, .50);
   kbEscrowSetPercentage(cEconomyEscrowID, cResourceGold, .30);
   kbEscrowSetPercentage(cEconomyEscrowID, cResourceShips, 0.0);
   kbEscrowSetCap(cEconomyEscrowID, cResourceFood, 200);
   kbEscrowSetCap(cEconomyEscrowID, cResourceWood, 200);
   if (cMyCiv == cCivDutch)
   {
      kbEscrowSetCap(cEconomyEscrowID, cResourceFood, 350); // Needed for banks
      kbEscrowSetCap(cEconomyEscrowID, cResourceWood, 350);
   }
   kbEscrowSetCap(cEconomyEscrowID, cResourceGold, 200);

   kbEscrowSetPercentage(cMilitaryEscrowID, cResourceFood, .0);
   kbEscrowSetPercentage(cMilitaryEscrowID, cResourceWood, .0);
   kbEscrowSetPercentage(cMilitaryEscrowID, cResourceGold, .0);
   kbEscrowSetPercentage(cMilitaryEscrowID, cResourceShips, 0.0);
   kbEscrowSetCap(cMilitaryEscrowID, cResourceFood, 300);
   kbEscrowSetCap(cMilitaryEscrowID, cResourceWood, 300);
   kbEscrowSetCap(cMilitaryEscrowID, cResourceGold, 300);

   kbEscrowCreate("VP Site", cResourceFood, .25, cRootEscrowID); // Add an accelerator escrow
   gVPEscrowID = kbEscrowGetID("VP Site");

   kbEscrowSetPercentage(gVPEscrowID, cResourceFood, 0.0);
   kbEscrowSetPercentage(gVPEscrowID, cResourceWood, 0.0);
   kbEscrowSetPercentage(gVPEscrowID, cResourceGold, 0.0);
   kbEscrowSetPercentage(gVPEscrowID, cResourceShips, 0.0);
   kbEscrowSetCap(gVPEscrowID, cResourceFood, 0);
   kbEscrowSetCap(gVPEscrowID, cResourceWood, 300);
   kbEscrowSetCap(gVPEscrowID, cResourceGold, 300);

   kbEscrowCreate("Age Upgrade", cResourceShips, 0.0, cRootEscrowID); // Add an upgrade escrow
   gUpgradeEscrowID = kbEscrowGetID("Age Upgrade");

   kbEscrowSetPercentage(gUpgradeEscrowID, cResourceFood, 0.0);
   kbEscrowSetPercentage(gUpgradeEscrowID, cResourceWood, 0.0);
   kbEscrowSetPercentage(gUpgradeEscrowID, cResourceGold, 0.0);
   kbEscrowSetPercentage(gUpgradeEscrowID, cResourceShips, 0.0);
   kbEscrowSetCap(gUpgradeEscrowID, cResourceFood, 0.0);
   kbEscrowSetCap(gUpgradeEscrowID, cResourceWood, 0.0);
   kbEscrowSetCap(gUpgradeEscrowID, cResourceGold, 0.0);

   kbEscrowAllocateCurrentResources();

   // Town center found, start building the other buildings
   xsDisableSelf();
   xsEnableRuleGroup("tcComplete");
   // Start exploring on water.
   if (gStartOnDifferentIslands == true)
      createWaterExplorePlan();

   if (cMyCiv == cCivOttomans)
      xsEnableRule("ottomanMonitor");

   //   gSettlerMaintainPlan = createSimpleMaintainPlan(gEconUnit, 25 - (13.0*btRushBoom), true, kbBaseGetMainID(cMyID),
   //   1);  // Good through age 2
   gSettlerMaintainPlan = createSimpleMaintainPlan(gEconUnit, xsArrayGetInt(gTargetSettlerCounts, kbGetAge()), true,
                                                   kbBaseGetMainID(cMyID), 1);
   aiPlanSetDesiredResourcePriority(gSettlerMaintainPlan, 70);

   if (cMyCiv == cCivOttomans)
      aiPlanSetVariableInt(gSettlerMaintainPlan, cTrainPlanNumberToMaintain, 0,
                           0); // To not throw off resource planning

   if ((cMyCiv == cCivJapanese) || (cMyCiv == cCivSPCJapanese) || (cMyCiv == cCivSPCJapaneseEnemy))
   {
      /*if (kbUnitCount(cMyID, gFarmUnit, cUnitStateAlive) < 1) {
        createSimpleBuildPlan(gFarmUnit, 1, 100, true, cEconomyEscrowID, kbBaseGetMainID(cMyID), 1);
      }*/
      xsEnableRule("shrineTacticMonitor");
      xsEnableRule("goldenPavillionTacticMonitor");
      //xsEnableRule("forwardShrineManager");
   }

   if (civIsAfrican() == true)
   {
      xsEnableRule("livestockMarketMonitor");
      if (xsIsRuleEnabled("earlySlaughterMonitor") == false)
         xsEnableRule("earlySlaughterMonitor");
      // Enable house monitor after we sold the first livestock for wood.
      if (gSPC == false)
         xsDisableRule("houseMonitor");
   }

   // if ((gWaterMap == true) || (kbUnitCount(cMyID, cUnitTypeHomeCityWaterSpawnFlag) > 0))
   //   gWaterTransportUnitMaintainPlan = createSimpleMaintainPlan(gCaravelUnit, 1, true, kbBaseGetMainID(cMyID), 1);

   if (aiGetGameMode() == cGameModeDeathmatch)
      deathMatchSetup(); // Add a bunch of custom stuff for a DM jump-start.
	//if (aiGetGameMode() == cGameModeEmpireWars)
		//empireWarsStart();

   if (kbUnitCount(cMyID, cUnitTypeypDaimyoRegicide, cUnitStateAlive) > 0)
      xsEnableRule("regicideMonitor");

   int flagUnit = getUnit(cUnitTypeHomeCityWaterSpawnFlag, cMyID);
   if (flagUnit >= 0)
      gNavyVec = kbUnitGetPosition(flagUnit);
   if (gStartOnDifferentIslands == true)
   {
      xsEnableRule("navyManager");
      gNavyMode = cNavyModeActive;
      navyManager();
   }
	
	wagonMonitor();

   // gMainAttackGoal = createSimpleAttackGoal("AttackGoal", aiGetMostHatedPlayerID(), -1, -1, cAge1, -1, gMainBase,
   // true);
   // If we have a negative bias, don't claim trade route TPs until 10 minutes.
   if (btBiasTrade < 0.0)
      gLastClaimTradeMissionTime = xsGetTime() + 600000;
   else
      gLastClaimTradeMissionTime = xsGetTime() - (1.0 - btBiasTrade) * gClaimTradeMissionInterval;
   // Don't claim native TPs until 15 minutes.
   gLastClaimNativeMissionTime = xsGetTime() + 900000;
}

void selectTCBuildPlanPosition(int buildPlan = -1, int baseID = -1)
{
   // We need to figure out where to put the new TC.  Start with the current main base as an anchor.
   // From that, check all gold mines within 100 meters and on the same area group.  For each, see if there
   // is a TC nearby, if not, do it.
   // If all gold mines fail, use the main base location and let it sort it out in the build plan, i.e. TCs repel, gold
   // attracts, etc.
   static int mineQuery = -1;
   if (mineQuery < 0)
   {
      mineQuery = kbUnitQueryCreate("Mine query for TC placement");
      kbUnitQuerySetPlayerID(mineQuery, 0);
      kbUnitQuerySetUnitType(mineQuery, cUnitTypeMine);
      kbUnitQuerySetMaximumDistance(mineQuery, 100.0);
      kbUnitQuerySetAscendingSort(mineQuery, true); // Ascending distance from initial location
   }
   kbUnitQuerySetPosition(mineQuery, kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)));
   kbUnitQueryResetResults(mineQuery);
   int mineCount = kbUnitQueryExecute(mineQuery);
   int i = 0;
   int mineID = -1;
   vector loc = cInvalidVector;
   int mineAreaGroup = -1;
   int mainAreaGroup = kbAreaGroupGetIDByPosition(kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)));
   bool found = false;
   aiEcho("**** Starting TC placement search, found " + mineCount + " mines.");
   for (i = 0; < mineCount)
   { // Check each mine for a nearby TC, i.e. w/in 30 meters.
      mineID = kbUnitQueryGetResult(mineQuery, i);
      loc = kbUnitGetPosition(mineID);
      mineAreaGroup = kbAreaGroupGetIDByPosition(loc);
      if ((getUnitByLocation(cUnitTypeTownCenter, cPlayerRelationAny, cUnitStateABQ, loc, 30.0) < 0) &&
          // Not worth building a TC when there are too few tiles (ex. ceylon starting island.)
          (mineAreaGroup == mainAreaGroup && getAreaGroupNumberTiles(mineAreaGroup) >= 2000))
      {
         aiEcho("    Found good mine at " + loc);
         found = true;
         break;
      }
      else
      {
         aiEcho("    Ignoring mine at " + loc);
      }
   }
   // This time don't limit our area group and search for all resources.
   /*if (found == false)
   {
      int numResources = kbResourceGetNumber();
      int resourceID = -1;
      int resourceQuery = -1;
      int numberFound = 0;
      float resourceAmount = 0.0;
      int unitID = -1;

      for (i = 0; < numResources)
      {
         resourceID = kbResourceGetIDByIndex(i);
         if (kbResourceGetSubType(resourceID) == cAIResourceSubTypeFish)
            continue;
         mineID = kbResourceGetUnit(resourceID, 0);
         if (mineID < 0)
            continue;
         loc = kbUnitGetPosition(mineID);
         mineAreaGroup = kbAreaGroupGetIDByPosition(loc);
         if ((getUnitByLocation(cUnitTypeTownCenter, cPlayerRelationAny, cUnitStateABQ, loc, 30.0) > 0) ||
            // Not worth building a TC when there are too few tiles (ex. ceylon starting island.)
            (getAreaGroupNumberTiles(mineAreaGroup) < 2000))
            continue;
         resourceQuery = createSimpleUnitQuery(cUnitTypeResource, 0, cUnitStateAny, loc, 30.0);
         numberFound = kbUnitQueryExecute(resourceQuery);
         resourceAmount = 0.0;
         for (j = 0; < numberFound)
         {
            unitID = kbUnitQueryGetResult(resourceQuery, j);
            resourceAmount = resourceAmount + kbUnitGetResourceAmount(unitID, cResourceFood)
                           + kbUnitGetResourceAmount(unitID, cResourceWood)
                           + kbUnitGetResourceAmount(unitID, cResourceGold);
            if (resourceAmount >= 0.0)
               break;
         }
         if (resourceAmount >= 0.0)
         {
            aiEcho("    Found good resource location at " + loc);
            found = true;
            xsEnableRule("findNewBase");
            break;
         }
         else
         {
            aiEcho("    Ignoring resource location at " + loc);
         }
      }
   }*/

   // If we found a mine without a nearby TC, use that mine's location.  If not, use the main base.
   if (found == false)
      loc = kbBaseGetLocation(cMyID, baseID);
   // If we have no main base (usually nomad start), and cannot find a mine for placement, just build at the covered
   // wagon position.
   if (loc == cInvalidVector && aiPlanGetNumberNeededUnits(buildPlan, gCoveredWagonUnit) > 0)
      loc = kbUnitGetPosition(getUnit(gCoveredWagonUnit));

   gTCSearchVector = loc;

   // Instead of base ID or areas, use a center position and falloff.
   aiPlanSetVariableVector(buildPlan, cBuildPlanCenterPosition, 0, loc);
   aiPlanSetVariableFloat(buildPlan, cBuildPlanCenterPositionDistance, 0, 50.00);

   // Add position influences for trees, gold, TCs.
   aiPlanSetNumberVariableValues(buildPlan, cBuildPlanInfluenceUnitTypeID, 4, true);
   aiPlanSetNumberVariableValues(buildPlan, cBuildPlanInfluenceUnitDistance, 4, true);
   aiPlanSetNumberVariableValues(buildPlan, cBuildPlanInfluenceUnitValue, 4, true);
   aiPlanSetNumberVariableValues(buildPlan, cBuildPlanInfluenceUnitFalloff, 4, true);

   aiPlanSetVariableInt(buildPlan, cBuildPlanInfluenceUnitTypeID, 0, cUnitTypeWood);
   aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluenceUnitDistance, 0, 30.0);           // 30m range.
   aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluenceUnitValue, 0, 10.0);              // 10 points per tree
   aiPlanSetVariableInt(buildPlan, cBuildPlanInfluenceUnitFalloff, 0, cBPIFalloffLinear); // Linear slope falloff

   aiPlanSetVariableInt(buildPlan, cBuildPlanInfluenceUnitTypeID, 1, cUnitTypeMine);
   aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluenceUnitDistance, 1,
                          40.0);                                                          // 40 meter range for gold
   aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluenceUnitValue, 1, 300.0);             // 300 points each
   aiPlanSetVariableInt(buildPlan, cBuildPlanInfluenceUnitFalloff, 1, cBPIFalloffLinear); // Linear slope falloff

   aiPlanSetVariableInt(buildPlan, cBuildPlanInfluenceUnitTypeID, 2, cUnitTypeMine);
   aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluenceUnitDistance, 2,
                          10.0);                                               // 10 meter inhibition to keep some space
   aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluenceUnitValue, 2, -300.0); // -300 points each
   aiPlanSetVariableInt(buildPlan, cBuildPlanInfluenceUnitFalloff, 2, cBPIFalloffNone); // Cliff falloff

   aiPlanSetVariableInt(buildPlan, cBuildPlanInfluenceUnitTypeID, 3, cUnitTypeTownCenter);
   aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluenceUnitDistance, 3, 40.0); // 40 meter inhibition around TCs.
   aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluenceUnitValue, 3, -500.0);  // -500 points each
   aiPlanSetVariableInt(buildPlan, cBuildPlanInfluenceUnitFalloff, 3, cBPIFalloffNone); // Cliff falloff

   // Weight it to prefer the general starting neighborhood
   aiPlanSetVariableVector(buildPlan, cBuildPlanInfluencePosition, 0, loc); // Position influence for landing position
   aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluencePositionDistance, 0, 100.0);          // 100m range.
   aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluencePositionValue, 0, 300.0);             // 300 points max
   aiPlanSetVariableInt(buildPlan, cBuildPlanInfluencePositionFalloff, 0, cBPIFalloffLinear); // Linear slope falloff

   aiPlanSetActive(buildPlan);
   aiPlanSetEventHandler(buildPlan, cPlanEventStateChange, "tcPlacedEventHandler");
   gTCBuildPlanID = buildPlan; // Save in a global var so the rule can access it.
}

rule reInitGatherers
inactive
group tcComplete
minInterval 11
{
   econMaster();
   updateFoodBreakdown(); // Reinit each gatherer breakdown in case initial pass didn't yet have proper "actual"
                          // assignments.
   updateWoodBreakdown();
   updateGoldBreakdown();
   xsDisableSelf();
}

bool needMoreHouses()
{
   int popCap = kbGetPopCap();
   int age = kbGetAge();
   return (((popCap - kbGetPop()) < (15 + 5 * age)) && (age > cAge1 || popCap < 20));
}

//==============================================================================
/* House monitor

   Make sure we have a house build plan active, regardless of the number of houses.

*/
//==============================================================================
rule houseMonitor
inactive
group tcComplete
minInterval 3
{
   if (kbGetBuildLimit(cMyID, gHouseUnit) <= kbUnitCount(cMyID, gHouseUnit, cUnitStateABQ))
      return; // Don't build if we're at limit.

   int houseBuildPlanID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, gHouseUnit);
   int ShrineBuildPlanID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeypShrineJapanese);
   int popCap = kbGetPopCap();
   int age = kbGetAge();
   
      if ((houseBuildPlanID < 0) && (1 > kbUnitCount(cMyID, gHouseUnit, cUnitStateABQ)) && (kbGetAge() == cAge1)) // None in progress, and pop headroom < 15 in cAge1, etc.
   {                                                         // Start a new one
      houseBuildPlanID = createSimpleBuildPlan(gHouseUnit, 1, 95, true, cEconomyEscrowID, kbBaseGetMainID(cMyID), 1);
      aiEcho("Starting a new house build plan.");
      aiPlanSetDesiredResourcePriority(houseBuildPlanID, 65);
	  //aiPlanAddUnitType(houseBuildPlanID, gEconUnit, 1, 1, 1);
   }
   
   if ((ShrineBuildPlanID < 0) && (needMoreHouses() == true) && (cMyCiv == cCivJapanese)) // None in progress, and pop headroom < 15 in cAge1, etc.
   {                                                         // Start a new one
      ShrineBuildPlanID = createSimpleBuildPlan(cUnitTypeypShrineJapanese, 1, 95, true, cEconomyEscrowID, kbBaseGetMainID(cMyID), 1);
      aiEcho("Starting a new house build plan.");
      aiPlanSetDesiredResourcePriority(ShrineBuildPlanID, 65);
	  //aiPlanAddUnitType(ShrineBuildPlanID, cUnitTypeAbstractJapaneseMonk, 1, 1, 1);
	  //aiPlanAddUnitType(ShrineBuildPlanID, gEconUnit, 1, 1, 1);
   }
   else
   if ((houseBuildPlanID < 0) && (needMoreHouses() == true) && (cMyCiv != cCivJapanese)) // None in progress, and pop headroom < 15 in cAge1, etc.
   {                                                         // Start a new one
      houseBuildPlanID = createSimpleBuildPlan(gHouseUnit, 1, 95, true, cEconomyEscrowID, kbBaseGetMainID(cMyID), 1);
      aiEcho("Starting a new house build plan.");
      aiPlanSetDesiredResourcePriority(houseBuildPlanID, 65);
	  //aiPlanAddUnitType(houseBuildPlanID, gEconUnit, 1, 1, 1);
   }
   
	   if (cMyCiv == cCivBritish || /*cMyCiv == cCivChinese ||*/ cMyCiv == cCivJapanese || cMyCiv == cCivDESwedish || cMyCiv == cCivDEInca)
   {
	   if (kbGetAge() > cAge1)
      xsEnableRule("extraHouseMonitor");
   }
	
}

//==============================================================================
/* Extra house monitor

   Extra houses in age1 to get more villagers early.
   British - build more manors to spawn a villager for each house built.
   Chinese - build more villages to spawn villagers with northern refugees card.

*/
//==============================================================================
rule extraHouseMonitor
inactive
minInterval 3
{
	if (kbGetBuildLimit(cMyID, gHouseUnit) <= kbUnitCount(cMyID, gHouseUnit, cUnitStateABQ))
      return;
  
   int houseBoomPlanID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, gHouseUnit);
   
   if ((houseBoomPlanID < 0) && (kbCanAffordUnit(gHouseUnit, cEconomyEscrowID) == true) && ((agingUp() == true) || (kbGetAge() > cAge1))) // None in progress, and pop headroom < 15 in cAge1, etc.
   {                                                          // Start a new one
      if (cMyCiv == cCivJapanese)
	  {
	  houseBoomPlanID = createSimpleBuildPlan(cUnitTypeypShrineJapanese, 1, 95, true, cEconomyEscrowID, kbBaseGetMainID(cMyID), 1);
      aiEcho("Starting a new house build plan.");
      aiPlanSetDesiredResourcePriority(houseBoomPlanID, 55);
	  //aiPlanAddUnitType(houseBoomPlanID, cUnitTypeAbstractJapaneseMonk, 1, 1, 1);
	  //aiPlanAddUnitType(houseBoomPlanID, gEconUnit, 1, 1, 1);
	  }
	  else
	  {
	  houseBoomPlanID = createSimpleBuildPlan(gHouseUnit, 1, 95, true, cEconomyEscrowID, kbBaseGetMainID(cMyID), 1);
      aiEcho("Starting a new house build plan.");
      aiPlanSetDesiredResourcePriority(houseBoomPlanID, 55);
	  }
   }
}

//==============================================================================
/* Monastery monitor

   Make sure we have a Monastery around, and research healing upgrades for
   Indians and Japanese.

*/
//==============================================================================
rule monasteryMonitor
inactive
minInterval 60
{
   // Disable rule for non-Asian civs
   if (civIsAsian() == false)
   {
      xsDisableSelf();
      return;
   }

   // Build a monastery if there is none
   if ((kbUnitCount(cMyID, cUnitTypeypMonastery, cUnitStateABQ) < 1) &&
       (aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeypMonastery) < 0))
   {
      aiEcho("Starting a new monastery build plan.");
      createSimpleBuildPlan(cUnitTypeypMonastery, 1, 60, true, cEconomyEscrowID, kbBaseGetMainID(cMyID), 1);
      return;
   }

   // If we don't have a monastery yet we are done here.
   if (kbUnitCount(cMyID, cUnitTypeypMonastery, cUnitStateAlive) < 1)
      return;

   int upgradePlanID = -1;

   // Research monk healing upgrades for Indians and Japanese
   if (kbTechGetStatus(cTechypMonasteryImprovedHealing) == cTechStatusObtainable)
   {
      if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypMonasteryImprovedHealing) >= 0)
         return;
      upgradePlanID = createSimpleResearchPlan(cTechypMonasteryImprovedHealing, getUnit(cUnitTypeypMonastery),
                                               cMilitaryEscrowID, 35);
      aiPlanSetDesiredResourcePriority(upgradePlanID, 35);
      return;
   }
   if (kbTechGetStatus(cTechypMonasteryJapaneseHealing) == cTechStatusObtainable)
   {
      if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypMonasteryJapaneseHealing) >= 0)
         return;
      upgradePlanID = createSimpleResearchPlan(cTechypMonasteryJapaneseHealing, getUnit(cUnitTypeypMonastery),
                                               cMilitaryEscrowID, 35);
      aiPlanSetDesiredResourcePriority(upgradePlanID, 35);
      return;
   }

   // If we're not capped at this age, we are done here.
   if (kbGetAge() == cvMaxAge)
   {
      return;
   }

   // Research additional upgrades with low priority
   if (kbTechGetStatus(cTechypMonasteryIndianSpeed) == cTechStatusObtainable)
   {
      if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypMonasteryIndianSpeed) >= 0)
         return;
      upgradePlanID =
          createSimpleResearchPlan(cTechypMonasteryIndianSpeed, getUnit(cUnitTypeypMonastery), cMilitaryEscrowID, 35);
      aiPlanSetDesiredResourcePriority(upgradePlanID, 35);
      return;
   }
   if (kbTechGetStatus(cTechypMonasteryStompUpgrade) == cTechStatusObtainable)
   {
      if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypMonasteryStompUpgrade) >= 0)
         return;
      upgradePlanID =
          createSimpleResearchPlan(cTechypMonasteryStompUpgrade, getUnit(cUnitTypeypMonastery), cMilitaryEscrowID, 35);
      aiPlanSetDesiredResourcePriority(upgradePlanID, 35);
      return;
   }
   if (kbTechGetStatus(cTechypMonasteryJapaneseCombat) == cTechStatusObtainable)
   {
      if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypMonasteryJapaneseCombat) >= 0)
         return;
      upgradePlanID = createSimpleResearchPlan(cTechypMonasteryJapaneseCombat, getUnit(cUnitTypeypMonastery),
                                               cMilitaryEscrowID, 35);
      aiPlanSetDesiredResourcePriority(upgradePlanID, 35);
      return;
   }
   if (kbTechGetStatus(cTechypMonasteryDiscipleAura) == cTechStatusObtainable)
   {
      if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypMonasteryDiscipleAura) >= 0)
         return;
      upgradePlanID =
          createSimpleResearchPlan(cTechypMonasteryDiscipleAura, getUnit(cUnitTypeypMonastery), cMilitaryEscrowID, 35);
      aiPlanSetDesiredResourcePriority(upgradePlanID, 35);
      return;
   }
   if (kbTechGetStatus(cTechypMonasteryShaolinWarrior) == cTechStatusObtainable)
   {
      if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypMonasteryShaolinWarrior) >= 0)
         return;
      upgradePlanID = createSimpleResearchPlan(cTechypMonasteryShaolinWarrior, getUnit(cUnitTypeypMonastery),
                                               cMilitaryEscrowID, 35);
      aiPlanSetDesiredResourcePriority(upgradePlanID, 35);
      return;
   }
   if (kbTechGetStatus(cTechypMonasteryAttackSpeed) == cTechStatusObtainable)
   {
      if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypMonasteryAttackSpeed) >= 0)
         return;
      upgradePlanID =
          createSimpleResearchPlan(cTechypMonasteryAttackSpeed, getUnit(cUnitTypeypMonastery), cMilitaryEscrowID, 35);
      aiPlanSetDesiredResourcePriority(upgradePlanID, 35);
      return;
   }
   if (kbTechGetStatus(cTechypMonasteryCriticalUpgrade) == cTechStatusObtainable)
   {
      if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypMonasteryCriticalUpgrade) >= 0)
         return;
      upgradePlanID = createSimpleResearchPlan(cTechypMonasteryCriticalUpgrade, getUnit(cUnitTypeypMonastery),
                                               cMilitaryEscrowID, 35);
      aiPlanSetDesiredResourcePriority(upgradePlanID, 35);
      return;
   }

   int monk1PlanID = -1;
   int monk2PlanID = -1;
   int monk3PlanID = -1;
   int monk4PlanID = -1;
   int compunctionPlanID = -1;

   if ((cMyCiv == cCivJapanese) || (cMyCiv == cCivSPCJapanese) || (cMyCiv == cCivSPCJapaneseEnemy))
   {
      if (kbTechGetStatus(cTechypMonasteryKillingBlowUpgrade) == cTechStatusObtainable)
      {
         monk3PlanID =
             aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypMonasteryKillingBlowUpgrade);
         if (monk3PlanID < 0)
         {
            monk3PlanID = createSimpleResearchPlan(cTechypMonasteryKillingBlowUpgrade, getUnit(cUnitTypeypMonastery),
                                                   cEconomyEscrowID, 35);
            aiPlanSetDesiredResourcePriority(monk3PlanID, 35);
         }
      }
      if (kbTechGetStatus(cTechypMonasteryRangedSplash) == cTechStatusObtainable)
      {
         monk4PlanID =
             aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypMonasteryRangedSplash);
         if (monk4PlanID < 0)
         {
            monk4PlanID = createSimpleResearchPlan(cTechypMonasteryRangedSplash, getUnit(cUnitTypeypMonastery),
                                                   cEconomyEscrowID, 35);
            aiPlanSetDesiredResourcePriority(monk4PlanID, 35);
         }
      }
   }

   if ((cMyCiv == cCivIndians) || (cMyCiv == cCivSPCIndians))
   {
      if (kbTechGetStatus(cTechypMonasteryPetAura) == cTechStatusObtainable)
      {
         monk1PlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypMonasteryPetAura);
         if (monk1PlanID < 0)
         {
            monk1PlanID =
                createSimpleResearchPlan(cTechypMonasteryPetAura, getUnit(cUnitTypeypMonastery), cEconomyEscrowID, 35);
            aiPlanSetDesiredResourcePriority(monk1PlanID, 35);
         }
      }
   }

   if (kbTechGetStatus(cTechypMonasteryCompunction) == cTechStatusObtainable)
   {
      compunctionPlanID =
          aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypMonasteryCompunction);
      if (compunctionPlanID < 0)
      {
         compunctionPlanID =
             createSimpleResearchPlan(cTechypMonasteryCompunction, getUnit(cUnitTypeypMonastery), cEconomyEscrowID, 35);
         aiPlanSetDesiredResourcePriority(compunctionPlanID, 35);
      }
   }
}

//==============================================================================
/* BHG Consulate monitor

   Make sure we have a Consulate around.
   Research Consulate Techs as appropriate.

*/
//==============================================================================
rule consulateMonitor
inactive
minInterval 5
{
   // Disable rule for non-Asian civilizations
   if (civIsAsian() == false)
   {
      xsDisableSelf();
      return;
   }

   // Quit if consulate is not allowed and not already built
   if ((cvOkToBuildConsulate == false) && (kbUnitCount(cMyID, cUnitTypeypConsulate, cUnitStateABQ) == 0))
   {
      return;
   }

   // Build a consulate if there is none
   if ((kbUnitCount(cMyID, cUnitTypeypConsulate, cUnitStateABQ) < 1) &&
       (aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeypConsulate) < 0))
   {
      createSimpleBuildPlan(cUnitTypeypConsulate, 1, 75, true, cEconomyEscrowID, kbBaseGetMainID(cMyID), 1);
      aiEcho("Starting a new consulate build plan.");
   }

   // If no option has been chosen already, choose one now
   //if ((kbUnitCount(cMyID, cUnitTypeypConsulate, cUnitStateAlive) > 0) && (gFlagChosen == false))
   //
   if ((kbTechGetStatus(cTechypBigConsulateBritish) != cTechStatusActive) ||
   (kbTechGetStatus(cTechypBigConsulateJapanese) != cTechStatusActive))
   {
      chooseConsulateFlag();
   }

   // Maximize export generation in Age 4 and above
   if ((kbGetAge() >= cAge4))
   {
      int consulateQueryID = -1;

      consulateQueryID = kbUnitQueryCreate("consulateGetUnitQuery");
      kbUnitQuerySetIgnoreKnockedOutUnits(consulateQueryID, true);

      // Define a query to get consulate
      if (consulateQueryID != -1)
      {
         kbUnitQuerySetPlayerRelation(consulateQueryID, -1);
         kbUnitQuerySetPlayerID(consulateQueryID, cMyID);
         kbUnitQuerySetUnitType(consulateQueryID, cUnitTypeypConsulate);
         kbUnitQuerySetState(consulateQueryID, cUnitStateAlive);
         kbUnitQueryResetResults(consulateQueryID);
         int numberFound = kbUnitQueryExecute(consulateQueryID);

         // Set export gathering rate to +60 %
         if (numberFound > 0)
         {
            aiUnitSetTactic(kbUnitQueryGetResult(consulateQueryID, 0), cTacticTax10);
         }
      }
   }

   // Research consulate technologies one at a time
   // Unavailable techs are simply ignored
   int upgradePlanID = -1;

   // British technologies
   if (kbTechGetStatus(cTechypConsulateBritishRedcoats) == cTechStatusObtainable)
   {
      
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypConsulateBritishRedcoats);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechypConsulateBritishRedcoats, getUnit(cUnitTypeypConsulate), cMilitaryEscrowID, 95);
      return;
   }
   if (kbTechGetStatus(cTechypConsulateBritishRogersRangers) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypConsulateBritishRogersRangers);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechypConsulateBritishRogersRangers, getUnit(cUnitTypeypConsulate), cMilitaryEscrowID, 95);
      return;
   }
   if (kbTechGetStatus(cTechypConsulateBritishLifeGuards) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypConsulateBritishLifeGuards);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechypConsulateBritishLifeGuards, getUnit(cUnitTypeypConsulate), cMilitaryEscrowID, 95);
      return;
   }

   // Dutch technologies
   // (bank wagon, arsenal wagon, church wagon)
   if (kbTechGetStatus(cTechypConsulateDutchSaloonWagon) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypConsulateDutchSaloonWagon);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechypConsulateDutchSaloonWagon, getUnit(cUnitTypeypConsulate), cEconomyEscrowID, 95);
      return;
   }
   if (kbTechGetStatus(cTechypConsulateDutchArsenalWagon) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypConsulateDutchArsenalWagon);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechypConsulateDutchArsenalWagon, getUnit(cUnitTypeypConsulate), cEconomyEscrowID, 95);
      xsEnableRule("arsenalUpgradeAsianMonitor");
      return;
   }
   if (kbTechGetStatus(cTechypConsulateDutchChurchWagon) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypConsulateDutchChurchWagon);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechypConsulateDutchChurchWagon, getUnit(cUnitTypeypConsulate), cEconomyEscrowID, 95);
      xsEnableRule("churchUpgradeAsianMonitor");
      return;
   }
   if (kbTechGetStatus(cTechypConsulateDutchLivestockPenWagon) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypConsulateDutchLivestockPenWagon);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechypConsulateDutchLivestockPenWagon, getUnit(cUnitTypeypConsulate), cEconomyEscrowID, 95);
      xsEnableRule("ShrineGoatMonitor");
      return;
   }

   // French technologies
   if (kbTechGetStatus(cTechypConsulateFrenchWoodCrates) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypConsulateFrenchWoodCrates);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechypConsulateFrenchWoodCrates, getUnit(cUnitTypeypConsulate), cEconomyEscrowID, 95);
      return;
   }
   if (kbTechGetStatus(cTechypConsulateFrenchCoinCrates) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypConsulateFrenchCoinCrates);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechypConsulateFrenchCoinCrates, getUnit(cUnitTypeypConsulate), cEconomyEscrowID, 95);
      return;
   }
   if (kbTechGetStatus(cTechypConsulateFrenchFoodCrates) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypConsulateFrenchFoodCrates);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechypConsulateFrenchFoodCrates, getUnit(cUnitTypeypConsulate), cEconomyEscrowID, 95);
      return;
   }

   // German technologies
   if (kbTechGetStatus(cTechypConsulateGermansFoodTrickle) == cTechStatusObtainable)
   {
     upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypConsulateGermansFoodTrickle);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechypConsulateGermansFoodTrickle, getUnit(cUnitTypeypConsulate), cEconomyEscrowID, 95);
      return;
   }
   if (kbTechGetStatus(cTechypConsulateGermansWoodTrickle) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypConsulateGermansWoodTrickle);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechypConsulateGermansWoodTrickle, getUnit(cUnitTypeypConsulate), cEconomyEscrowID, 95);
      return;
   }
   if (kbTechGetStatus(cTechypConsulateGermansCoinTrickle) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypConsulateGermansCoinTrickle);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechypConsulateGermansCoinTrickle, getUnit(cUnitTypeypConsulate), cEconomyEscrowID, 95);
      return;
   }

   if (kbTechGetStatus(cTechypConsulateJapaneseMasterTraining) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypConsulateJapaneseMasterTraining);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechypConsulateJapaneseMasterTraining, getUnit(cUnitTypeypConsulate), cMilitaryEscrowID, 95);
      return;
   }
   if (kbTechGetStatus(cTechypConsulateJapaneseMilitaryRickshaw) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypConsulateJapaneseMilitaryRickshaw);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechypConsulateJapaneseMilitaryRickshaw, getUnit(cUnitTypeypConsulate), cMilitaryEscrowID, 95);
      return;
   }

   // Ottoman technologies
   // (Great bombards)
   if (kbTechGetStatus(cTechypConsulateOttomansGunpowderSiege) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypConsulateOttomansGunpowderSiege);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechypConsulateOttomansGunpowderSiege, getUnit(cUnitTypeypConsulate), cMilitaryEscrowID, 95);
      return;
   }
   if (kbTechGetStatus(cTechypConsulateOttomansInfantrySpeed) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypConsulateOttomansInfantrySpeed);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechypConsulateOttomansInfantrySpeed, getUnit(cUnitTypeypConsulate), cMilitaryEscrowID, 95);
      return;
   }

   // Portuguese technologies
   // (Ironclad)
   if ((kbTechGetStatus(cTechypConsulatePortugueseExpeditionaryFleet) == cTechStatusObtainable) &&
       (kbUnitCount(cMyID, cUnitTypeHomeCityWaterSpawnFlag, cUnitStateAlive) > 0))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypConsulatePortugueseExpeditionaryFleet);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechypConsulatePortugueseExpeditionaryFleet, getUnit(cUnitTypeypConsulate), cMilitaryEscrowID, 95);
      return;
   }
   if ((kbTechGetStatus(cTechypConsulatePortugueseFishingFleet) == cTechStatusObtainable) &&
       (kbUnitCount(cMyID, cUnitTypeHomeCityWaterSpawnFlag, cUnitStateAlive) > 0))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypConsulatePortugueseFishingFleet);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechypConsulatePortugueseFishingFleet, getUnit(cUnitTypeypConsulate), cEconomyEscrowID, 95);
      return;
   }
   

   // Russian technologies
   // (fort wagon, factory wagon, blockhouse wagon)
   if (kbTechGetStatus(cTechypConsulateRussianFortWagon) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypConsulateRussianFortWagon);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechypConsulateRussianFortWagon, getUnit(cUnitTypeypConsulate), cMilitaryEscrowID, 95);
      return;
   }
   if (kbTechGetStatus(cTechypConsulateRussianFactoryWagon) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypConsulateRussianFactoryWagon);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechypConsulateRussianFactoryWagon, getUnit(cUnitTypeypConsulate), cEconomyEscrowID, 95);
      return;
   }
   if (kbTechGetStatus(cTechypConsulateRussianOutpostWagon) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypConsulateRussianOutpostWagon);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechypConsulateRussianOutpostWagon, getUnit(cUnitTypeypConsulate), cEconomyEscrowID, 95);
      return;
   }

   // Spanish technologies
   if (kbTechGetStatus(cTechypConsulateSpanishMercantilism) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypConsulateSpanishMercantilism);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechypConsulateSpanishMercantilism, getUnit(cUnitTypeypConsulate), cEconomyEscrowID, 95);
      return;
   }
   if (kbTechGetStatus(cTechypConsulateSpanishFasterShipments) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypConsulateSpanishFasterShipments);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechypConsulateSpanishFasterShipments, getUnit(cUnitTypeypConsulate), cEconomyEscrowID, 95);
      return;
   }
   if (kbTechGetStatus(cTechypConsulateSpanishEnhancedProfits) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypConsulateSpanishEnhancedProfits);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechypConsulateSpanishEnhancedProfits, getUnit(cUnitTypeypConsulate), cEconomyEscrowID, 95);
      return;
   }

   if (cvOkToTrainArmy == false)
      return;

   // Maintain plans
   static int consulateUPID = -1;
   static int consulateMaintainPlans = -1;

   if (consulateUPID < 0)
   {
      // create the unit picker after we choose a consulate flag
      if (kbTechGetStatus(cTechypBigConsulatePortuguese) != cTechStatusActive &&
          kbTechGetStatus(cTechypBigConsulateDutch) != cTechStatusActive &&
          kbTechGetStatus(cTechypBigConsulateRussians) != cTechStatusActive &&
          kbTechGetStatus(cTechypBigConsulateSpanish) != cTechStatusActive &&
          kbTechGetStatus(cTechypBigConsulateBritish) != cTechStatusActive &&
          kbTechGetStatus(cTechypBigConsulateFrench) != cTechStatusActive &&
          kbTechGetStatus(cTechypBigConsulateGermans) != cTechStatusActive &&
          kbTechGetStatus(cTechypBigConsulateOttomans) != cTechStatusActive &&
          kbTechGetStatus(cTechypBigConsulateJapanese) != cTechStatusActive)
         return;

      // Create it.
      consulateUPID = kbUnitPickCreate("Consulate army");
      if (consulateUPID < 0)
         return;

      consulateMaintainPlans = xsArrayCreateInt(4, -1, "Consulate maintain plans");
   }
   
    bool homeBaseUnderAttack = false;
   if (gDefenseReflexBaseID == kbBaseGetMainID(cMyID))
      homeBaseUnderAttack = true;
  
  if ((homeBaseUnderAttack == true) || (kbGetAge() > cAge3))
  {

   int numberResults = 0;
   int i = 0;
   int trainUnitID = -1;
   int planID = -1;
   int numberToMaintain = 0;

   // Default init.
   kbUnitPickResetAll(consulateUPID);

   kbUnitPickSetPreferenceWeight(consulateUPID, 2.0);
   if (gSPC == false)
   {
      kbUnitPickSetCombatEfficiencyWeight(consulateUPID, 0.4); // Changed from 1.0 to dilute the power of the preference weight.
      kbUnitPickSetBuildingCombatEfficiencyWeight(consulateUPID, 0.0);
   }
   else
   {
      kbUnitPickSetCombatEfficiencyWeight(consulateUPID, 0.2); // Leave it at 1.0 to avoid messing up SPC balance
      kbUnitPickSetBuildingCombatEfficiencyWeight(consulateUPID, 0.0);
   }
   kbUnitPickSetCostWeight(consulateUPID, 0.0);
   // Desired number units types, buildings.
   kbUnitPickSetDesiredNumberUnitTypes(consulateUPID, 2, 1, true);

   // Default to land units.
   kbUnitPickSetEnemyPlayerID(consulateUPID, aiGetMostHatedPlayerID());
   kbUnitPickSetAttackUnitType(consulateUPID, cUnitTypeLogicalTypeLandMilitary);

   // Set the default target types and weights, for use until we've seen enough actual units.
   kbUnitPickAddCombatEfficiencyType(consulateUPID, cUnitTypeLogicalTypeLandMilitary, 1.0);

   kbUnitPickAddBuildingCombatEfficiencyType(consulateUPID, cUnitTypeMilitaryBuilding, 0.0);
   kbUnitPickAddBuildingCombatEfficiencyType(consulateUPID, cUnitTypeAbstractTownCenter, 0.0);

   kbUnitPickSetMinimumCounterModePop(consulateUPID, 15);
   kbUnitPickSetPreferenceFactor(consulateUPID, cUnitTypeAbstractConsulateSiegeIndustrial, 0.25);
   kbUnitPickSetPreferenceFactor(consulateUPID, cUnitTypeAbstractConsulateSiegeFortress, 0.0);
   kbUnitPickSetPreferenceFactor(consulateUPID, cUnitTypeAbstractConsulateUnitColonial, 0.0);
   kbUnitPickSetPreferenceFactor(consulateUPID, cUnitTypeAbstractConsulateUnit, 0.0);
   // Banner armies are calculated with a weighed average of unit types the banner army contains
   kbUnitPickRemovePreferenceFactor(consulateUPID, cUnitTypeAbstractBannerArmy);
   kbUnitPickRun(consulateUPID);
   
	
   for (i = 0; < 2)
   {
      trainUnitID = kbUnitPickGetResult(consulateUPID, i);
      planID = xsArrayGetInt(consulateMaintainPlans, i);
      if (planID >= 0)
      {
         if (trainUnitID == aiPlanGetVariableInt(planID, cTrainPlanUnitType, 0))
         {
            numberToMaintain = kbResourceGet(cResourceTrade) / kbUnitCostPerResource(trainUnitID, cResourceTrade);
            aiPlanSetVariableInt(planID, cTrainPlanNumberToMaintain, 0, numberToMaintain);
            continue;
         }
         aiPlanDestroy(planID);
      }
      if (trainUnitID < 0)
         continue;
      numberToMaintain = kbResourceGet(cResourceTrade) / kbUnitCostPerResource(trainUnitID, cResourceTrade);
      planID = createSimpleMaintainPlan(trainUnitID, numberToMaintain, false, kbBaseGetMainID(cMyID), 1);
      aiPlanSetDesiredResourcePriority(planID, 30 - i); // below research plans
      xsArraySetInt(consulateMaintainPlans, i, planID);
   }
  }
  else
	  return;  
}

//==============================================================================
/* BHG regicide monitor

   Pop the regent in the castle

*/
//==============================================================================
rule regicideMonitor
inactive
minInterval 10
{
   // if the castle is up, put the guy in it

   if (kbUnitCount(cMyID, cUnitTypeypCastleRegicide, cUnitStateAlive) > 0)
   {
      // gotta find the castle
      static int castleQueryID = -1;
      // If we don't have the query yet, create one.
      if (castleQueryID < 0)
      {
         castleQueryID = kbUnitQueryCreate("castleGetUnitQuery");
         kbUnitQuerySetIgnoreKnockedOutUnits(castleQueryID, true);
      }
      // Define a query to get all matching units
      if (castleQueryID != -1)
      {
         kbUnitQuerySetPlayerRelation(castleQueryID, -1);
         kbUnitQuerySetPlayerID(castleQueryID, cMyID);
         kbUnitQuerySetUnitType(castleQueryID, cUnitTypeypCastleRegicide);
         kbUnitQuerySetState(castleQueryID, cUnitStateAlive);
      }
      else
      {
         return;
      }

      // gotta find the regent
      static int regentQueryID = -1;
      // If we don't have the query yet, create one.
      if (regentQueryID < 0)
      {
         regentQueryID = kbUnitQueryCreate("regentGetUnitQuery");
         kbUnitQuerySetIgnoreKnockedOutUnits(regentQueryID, true);
      }
      // Define a query to get all matching units
      if (regentQueryID != -1)
      {
         kbUnitQuerySetPlayerRelation(regentQueryID, -1);
         kbUnitQuerySetPlayerID(regentQueryID, cMyID);
         kbUnitQuerySetUnitType(regentQueryID, cUnitTypeypDaimyoRegicide);
         kbUnitQuerySetState(regentQueryID, cUnitStateAlive);
      }
      else
      {
         return;
      }

      kbUnitQueryResetResults(castleQueryID);
      kbUnitQueryResetResults(regentQueryID);

      kbUnitQueryExecute(castleQueryID);
      kbUnitQueryExecute(regentQueryID);

      int index = 0;

      aiTaskUnitWork(kbUnitQueryGetResult(regentQueryID, index), kbUnitQueryGetResult(castleQueryID, index));
   }
   else
   {
      xsDisableSelf();
   }
}

//==============================================================================
/* Building monitor

   Make sure we have the right number of buildings, or at least a build plan,
   for each required building type.

*/
//==============================================================================
rule buildingMonitor
inactive
group tcComplete
minInterval 5
{
   int planID = -1;
   int numberBuildings = 0;
   int numberMilitaryBuildings = 0;
   int numberBuildingsWanted = 0;
   int numberTotalBuildingsWanted = 0;
   int numberFound = 0;
   int buildingQuery = -1;
   int buildingID = -1;
   int puid = -1;
   int buildingPUID = -1;
   int buildLimit = 0;
   int maintainPlanID = -1;
   static int WagonMaintainPlan = -1; 
   vector location = cInvalidVector;
   bool buildForward = false;
   static int lastForwardBaseCheckTime = 0;
   int baseID = -1;
   float maxDistance = 0.0;
   int existingPlanID = -1;

   if (cvOkToBuild == false)
      return;

   if (gDefenseReflexBaseID == kbBaseGetMainID(cMyID))
      return;

   int age = kbGetAge();
   int transitionAge = age;

   if (agingUp() == true)
      transitionAge = age + 1;

   // go through building queue.
   numberFound = xsArrayGetSize(gQueuedBuildPlans);
   for (i = 0; < numberFound)
   {
      planID = xsArrayGetInt(gQueuedBuildPlans, i);
      if (planID < 0)
         continue;
      puid = aiPlanGetVariableInt(planID, cBuildPlanBuildingTypeID, 0);
      existingPlanID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, puid);
      if (existingPlanID >= 0 && aiPlanGetState(existingPlanID) != cPlanStateBuild)
         continue;
      // No active build plans with the same puid left, activate this plan.
      baseID = aiPlanGetBaseID(planID);
      aiPlanSetBaseID(planID, -1);
      // If we fail to select a location, queue it again.
      if (selectBuildPlanPosition(planID, puid, baseID) == false)
      {
         aiPlanSetBaseID(planID, baseID);
         continue;
      }
      aiPlanSetActive(planID);
      xsArraySetInt(gQueuedBuildPlans, i, -1);
   }

   // if Dutch, add banks to the build limit.
   if (cMyCiv == cCivDutch)
   {
	  if ((kbGetAge() > cAge1) || (agingUp() == true))
	  {
	  planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeBank);
		if ((planID < 0) && (kbUnitCount(cMyID, cUnitTypeBank, cUnitStateABQ) < kbGetBuildLimit(cMyID, cUnitTypeBank)))  // If I'm not building one and I could be, do it.
		{     
		planID = createSimpleBuildPlan(cUnitTypeBank, 1, 95, true, cEconomyEscrowID, kbBaseGetMainID(cMyID), 1); // Very high pri, just above houses
		aiEcho("Starting a new bank build plan.");
		aiPlanSetDesiredResourcePriority(planID, 55);
		}
	  }
   }

   // if ((cMyCiv == cCivDutch) && (kbUnitCount(cMyID, cUnitTypeBank, cUnitStateABQ) < 1))
   //   return;

   // At least one market
   planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, gMarketUnit);
   if ((planID < 0) && (kbUnitCount(cMyID, gMarketUnit, cUnitStateAlive) < 1) &&
       ((gRevolutionType & cRevolutionFinland) == 0) &&
       (((needMoreHouses() == false) || (kbResourceGet(cResourceWood) >= 500)) &&
            ((btRushBoom < 0.0 && (transitionAge >= cAge2)) ||
             ((transitionAge >= cAge3) ||
              (kbUnitCount(cMyID, gEconUnit, cUnitStateAlive) >= 18))) ||
        civIsAfrican() == true || gDisableWoods == true))
   { // If we're OK on houses...
      planID = createSimpleBuildPlan(gMarketUnit, 1, 96, true, cEconomyEscrowID, kbBaseGetMainID(cMyID),
                                     1); // Just higher than house
      aiEcho("Starting a new market build plan.");
      if (gDisableWoods == false)
         aiPlanSetDesiredResourcePriority(planID, 45);
      else // extremely high as we cannot gather wood anymore.
         aiPlanSetDesiredResourcePriority(planID, 99);
   }

   // If native and have potential dancers, one community plaza
   if (civIsNative() == true)
   {
      planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeCommunityPlaza);
      if ((planID < 0) && ((kbResourceGet(cResourceWood) >= 900) ||
                           (kbUnitCount(cMyID, cUnitTypexpMedicineManAztec, cUnitStateAlive) >= 2) ||
                           (kbUnitCount(cMyID, cUnitTypedePriestess, cUnitStateAlive) >= 1) ||
                           (kbUnitCount(cMyID, gEconUnit, cUnitStateAlive) >= 18)))
      {
         if ((kbUnitCount(cMyID, cUnitTypeCommunityPlaza, cUnitStateAlive) < 1) &&
             (kbUnitCount(cMyID, gHouseUnit, cUnitStateAlive) >= 1))
         { // Start a new one if we have at least one house.
            planID = createSimpleBuildPlan(cUnitTypeCommunityPlaza, 1, 92, true, cEconomyEscrowID,
                                           kbBaseGetMainID(cMyID), 1);
            aiPlanSetDesiredResourcePriority(planID, 40);
            aiEcho("Starting a new community plaza build plan.");
         }
         else if (cMyCiv == cCivXPSioux && kbUnitCount(cMyID, cUnitTypeCommunityPlaza, cUnitStateAlive) < 1)
         { // Start a new one.
            planID = createSimpleBuildPlan(cUnitTypeCommunityPlaza, 1, 92, true, cEconomyEscrowID,
                                           kbBaseGetMainID(cMyID), 1);
            aiPlanSetDesiredResourcePriority(planID, 40);
            aiEcho("Starting a new community plaza build plan.");
         }
      }
   }

   // At least a town center
   if (transitionAge < cAge2)
   {
   planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeTownCenter);
   if ((planID < 0) && (kbUnitCount(cMyID, cUnitTypeTownCenter, cUnitStateABQ) < 1) &&
       ((gRevolutionType & cRevolutionFinland) == 0))
   { // Start a new one
      planID = createSimpleBuildPlan(cUnitTypeTownCenter, 1, 99, false, cEconomyEscrowID, kbBaseGetMainID(cMyID), 1);
      aiPlanSetDesiredResourcePriority(planID, 99);
      aiEcho("Starting a new town center build plan.");
   }
   }

   // At least 1 granary for food upgrades.
   if (civIsAfrican() == true)
   {
      planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypedeGranary);
      if ((planID < 0) && (kbUnitCount(cMyID, cUnitTypedeGranary, cUnitStateAlive) < 1))
      { // Start a new one
         planID = createSimpleBuildPlan(cUnitTypedeGranary, 1, 70, false, cEconomyEscrowID, kbBaseGetMainID(cMyID), 1);
         aiPlanSetDesiredResourcePriority(planID, 60);
         aiEcho("Starting a new granary build plan.");
      }
   }

   // That's it for age 1
   if (transitionAge < cAge2)
      return;
   // ***************************************************

   // Build enough military buildings for military production.
   numberMilitaryBuildings = xsArrayGetSize(gMilitaryBuildings);
   for (i = 0; < numberMilitaryBuildings)
   {
      buildingPUID = xsArrayGetInt(gMilitaryBuildings, i);
      numberTotalBuildingsWanted = 0;

      for (j = 0; < gNumArmyUnitTypes)
      {
         if (buildingPUID != xsArrayGetInt(gArmyUnitBuildings, j))
            continue;

         maintainPlanID = xsArrayGetInt(gArmyUnitMaintainPlans, j);

         // how many buildings do we want?
         puid = kbUnitPickGetResult(gLandUnitPicker, j);

         if (kbUnitIsType(puid, cUnitTypeAbstractBannerArmy) == false)
            numberBuildingsWanted = 10 * kbGetProtoUnitPopCount(puid);
         else // need more buildings for banner army because only 1 can be queued at a time.
            numberBuildingsWanted = 5 * kbGetProtoUnitPopCount(puid);
         numberBuildingsWanted =
             aiPlanGetVariableInt(maintainPlanID, cTrainPlanNumberToMaintain, 0) / numberBuildingsWanted;
         if (numberBuildingsWanted < 1 &&
             (aiTreatyGetEnd() <= xsGetTime() + 10 * 60 * 1000 || (gExcessResources == true && age >= cvMaxAge)))
            numberBuildingsWanted = 1;

         numberTotalBuildingsWanted = numberTotalBuildingsWanted + numberBuildingsWanted;
      }

      buildLimit = kbGetBuildLimit(cMyID, buildingPUID);
      if (buildLimit >= 0 && numberTotalBuildingsWanted > buildLimit)
         numberTotalBuildingsWanted = buildLimit;
      // don't build too many if we can't train units simultaneously at each building
      buildLimit = kbUnitCount(cMyID, cUnitTypeAbstractVillager, cUnitStateAlive) / 20 + 1;
      if (numberTotalBuildingsWanted > buildLimit)
         numberTotalBuildingsWanted = buildLimit;
      planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, buildingPUID);
      if (numberTotalBuildingsWanted > 0)
      {
         if (planID >= 0)
            continue;
      }
      else
      {
         if (planID >= 0 && aiPlanGetState(planID) != cPlanStateBuild)
            aiPlanDestroy(planID);
         continue;
      }
      for (j = 0; < gNumArmyUnitTypes)
      {
         if (buildingPUID != xsArrayGetInt(gArmyUnitBuildings, j))
            continue;

         maintainPlanID = xsArrayGetInt(gArmyUnitMaintainPlans, j);
         puid = kbUnitPickGetResult(gLandUnitPicker, j);

         buildingQuery = createSimpleUnitQuery(cUnitTypeMilitaryBuilding, cMyID, cUnitStateAlive);
         numberFound = kbUnitQueryExecute(buildingQuery);
         numberBuildings = 0;
         for (k = 0; < numberFound)
         {
            buildingID = kbUnitQueryGetResult(buildingQuery, k);
            if (kbProtoUnitCanTrain(kbUnitGetProtoUnitID(buildingID), puid) == true)
               numberBuildings = numberBuildings + 1;
         }

         buildForward = (gForwardBaseID >= 0 &&
                         getUnitCountByLocation(cUnitTypeLogicalTypeLandMilitary, cPlayerRelationEnemyNotGaia,
                                                cUnitStateAlive, gForwardBaseLocation, 50.0) <= 2) ||
                        (xsGetTime() - lastForwardBaseCheckTime >= 30000 &&
                         /*aiGetWorldDifficulty() >= gDifficultyExpert && */aiTreatyActive() == false &&
                         gForwardBaseState == cForwardBaseStateNone && (xsGetTime() - gForwardBaseUpTime) >= 600000) &&
                            (/*(btRushBoom >= 0.5 && btOffenseDefense > 0.0) ||
                            (btOffenseDefense > 0.0 && xsGetTime() >= 900000) ||*/
                             xsGetTime() >= 1200000);

         // We need at least a building to research upgrades.
         if (numberBuildings >= numberTotalBuildingsWanted &&
             (kbUnitCount(cMyID, buildingPUID, cUnitStateABQ) >= 1 ||
              aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanBuildingTypeID, buildingPUID) < 0))
         {
            // If we have a forward base, ensure that we have at least 1 building there for the army unit.
            if (buildForward == true)
            {
               if (gForwardBaseID >= 0)
               {
                  buildingQuery = createSimpleUnitQuery(cUnitTypeMilitaryBuilding, cMyID, cUnitStateAlive);
                  numberFound = kbUnitQueryExecute(buildingQuery);
                  numberBuildings = 0;
                  for (k = 0; < numberFound)
                  {
                     buildingID = kbUnitQueryGetResult(buildingQuery, k);
                     if (kbProtoUnitCanTrain(kbUnitGetProtoUnitID(buildingID), puid) == true)
                     {
                        numberBuildings = numberBuildings + 1;
                        break;
                     }
                  }
                  if (numberBuildings > 0)
                     continue;
               }
            }
            else
            {
               continue;
            }
         }

         // Build a new forward base?
         if (buildForward == true && gForwardBaseID < 0)
         {
            location = selectForwardBaseLocation();
            if (location != cInvalidVector)
            {
               planID = aiPlanCreate("Forward " + kbGetUnitTypeName(buildingPUID) + " build plan ", cPlanBuild);
               aiPlanSetVariableInt(planID, cBuildPlanBuildingTypeID, 0, buildingPUID);
               aiPlanSetDesiredPriority(planID, 87);
               // Military
               aiPlanSetMilitary(planID, true);
               aiPlanSetEconomy(planID, false);
               aiPlanSetEscrowID(planID, cMilitaryEscrowID);
               if (addBuilderToPlan(planID, buildingPUID, 1) == true)
               {
                  // Instead of base ID or areas, use a center position
                  aiPlanSetVariableVector(planID, cBuildPlanCenterPosition, 0, location);
                  aiPlanSetVariableFloat(planID, cBuildPlanCenterPositionDistance, 0, 50.0);

                  // Weight it to stay very close to center point.
                  aiPlanSetVariableVector(planID, cBuildPlanInfluencePosition, 0,
                                          location); // Position influence for center
                  aiPlanSetVariableFloat(planID, cBuildPlanInfluencePositionDistance, 0, 50.0); // 100m range.
                  aiPlanSetVariableFloat(planID, cBuildPlanInfluencePositionValue, 0, 100.0);   // 100 points for center
                  aiPlanSetVariableInt(planID, cBuildPlanInfluencePositionFalloff, 0,
                                       cBPIFalloffLinear); // Linear slope falloff

                  // Add position influence for nearby towers
                  aiPlanSetVariableInt(planID, cBuildPlanInfluenceUnitTypeID, 0,
                                       cUnitTypeFortFrontier); // Don't build anywhere near another fort.
                  aiPlanSetVariableFloat(planID, cBuildPlanInfluenceUnitDistance, 0, 50.0);
                  aiPlanSetVariableFloat(planID, cBuildPlanInfluenceUnitValue, 0, -200.0); // -20 points per fort
                  aiPlanSetVariableInt(planID, cBuildPlanInfluenceUnitFalloff, 0, cBPIFalloffNone); // Cliff falloff

                  aiPlanSetActive(planID);

                  gForwardBaseLocation = location;
                  gForwardBaseBuildPlan = planID;

                  // Chat to my allies
                  sendStatement(cPlayerRelationAlly, cAICommPromptToAllyIWillBuildMilitaryBase, gForwardBaseLocation);

                  gForwardBaseState = cForwardBaseStateBuilding;

                  aiEcho(" ");
                  aiEcho("    BUILDING FORWARD BASE, MOVING DEFEND PLANS TO COVER.");
                  aiEcho("    PLANNED LOCATION IS " + gForwardBaseLocation);
                  aiEcho(" ");

                  //if (gDefenseReflex == false)
                  //   endDefenseReflex();
               }
               else
               {
                  aiPlanDestroy(planID);
                  planID = -1;
                  buildForward = false;
               }
            }
            else
            {
               buildForward = false;
            }
            lastForwardBaseCheckTime = xsGetTime();
         }

         if (planID < 0)
         {
            if (buildForward == true && gForwardBaseID >= 0)
            { // If we have forward base, build there.
               planID = createSimpleBuildPlan(buildingPUID, 1, 70, false, cMilitaryEscrowID, gForwardBaseID, 1);
            }
            else
            {
               planID = createSimpleBuildPlan(buildingPUID, 1, 70, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
            }
         }

         // If we don't have any, set priority to slightly above default.
         if (numberBuildings < 1)
            aiPlanSetDesiredResourcePriority(planID, 60);
         else
            aiPlanSetDesiredResourcePriority(planID, 41 - numberBuildings);
         aiEcho("Starting a new " + kbGetUnitTypeName(buildingPUID) + " build plan.");
         break;
      }
   }

   // If Russian, at least 1 block house
   // Military buildings to build should be left to be decided with attack goal
   /*if (cMyCiv == cCivRussians)
   {
      planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeBlockhouse);
      if ( (planID < 0) && (kbUnitCount(cMyID, cUnitTypeBlockhouse, cUnitStateAlive) < 1) )
      {     // Start a new one
         createSimpleBuildPlan(cUnitTypeBlockhouse, 1, 70, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
         aiEcho("Starting a new blockhouse build plan.");
      }
   }
   else if ( civIsNative() == true )
   {  // Natives, at least 1 war hut
      planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeWarHut);
      if ( (planID < 0) && (kbUnitCount(cMyID, cUnitTypeWarHut, cUnitStateAlive) < 1) )
      {     // Start a new one
         createSimpleBuildPlan(cUnitTypeWarHut, 1, 70, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
         aiEcho("Starting a new war hut build plan.");
      }
   }
   else if (civIsAsian() == true) {
      if ( (cMyCiv == cCivJapanese) || (cMyCiv == cCivSPCJapanese) || (cMyCiv == cCivSPCJapaneseEnemy) ) {
        planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeypBarracksJapanese);
        if ( (planID < 0) && (kbUnitCount(cMyID, cUnitTypeypBarracksJapanese, cUnitStateAlive) < 1) )
        {     // Start a new one
          createSimpleBuildPlan(cUnitTypeypBarracksJapanese, 1, 70, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID),
  1); aiEcho("Starting a new bansho build plan.");
        }
      }
      else if ( (cMyCiv == cCivChinese) || (cMyCiv == cCivSPCChinese) ) {
        planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeypWarAcademy);
        if ( (planID < 0) && (kbUnitCount(cMyID, cUnitTypeypWarAcademy, cUnitStateAlive) < 1) )
        {     // Start a new one
          createSimpleBuildPlan(cUnitTypeypWarAcademy, 1, 98, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
          aiEcho("Starting a new war academy build plan.");
        }
      }
      else {
        planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeYPBarracksIndian);
        if ( (planID < 0) && (kbUnitCount(cMyID, cUnitTypeYPBarracksIndian, cUnitStateAlive) < 1) )
        {     // Start a new one
          createSimpleBuildPlan(cUnitTypeYPBarracksIndian, 1, 70, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
          aiEcho("Starting a new indian barracks build plan.");
        }
      }
   }
   else // every other civ gets a barracks.
   {
      // At least 1 barracks
      planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeBarracks);
      if ( (planID < 0) && (kbUnitCount(cMyID, cUnitTypeBarracks, cUnitStateAlive) < 1) )
      {     // Start a new one
         createSimpleBuildPlan(cUnitTypeBarracks, 1, 70, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
         aiEcho("Starting a new barracks build plan.");
      }
   }

   // At least one stable
   if ( (civIsNative() == true) )
   {  // Natives, at least 1 corral
      if (cMyCiv != cCivXPAztec)
      {
         planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeCorral);
         if ( (planID < 0) && (kbUnitCount(cMyID, cUnitTypeCorral, cUnitStateAlive) < 1) )
         {     // Start a new one
            createSimpleBuildPlan(cUnitTypeCorral, 1, 70, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
            aiEcho("Starting a new corral build plan.");
         }
      }
   }
  else if (civIsAsian() == true) {
    if ( (cMyCiv == cCivJapanese) || (cMyCiv == cCivSPCJapanese) || (cMyCiv == cCivSPCJapaneseEnemy) ) {
      planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeypStableJapanese);
      if ( (planID < 0) && (kbUnitCount(cMyID, cUnitTypeypStableJapanese, cUnitStateAlive) < 1) )
      {     // Start a new one
        createSimpleBuildPlan(cUnitTypeypStableJapanese, 1, 70, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
        aiEcho("Starting a new dojo build plan.");
      }
    }
    else if ( (cMyCiv == cCivIndians) || (cMyCiv == cCivSPCIndians) ) {
      planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeypCaravanserai);
      if ( (planID < 0) && (kbUnitCount(cMyID, cUnitTypeypCaravanserai, cUnitStateAlive) < 1) )
      {     // Start a new one
        createSimpleBuildPlan(cUnitTypeypCaravanserai, 1, 70, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
        aiEcho("Starting a new Caravanserai build plan.");
      }
    }
   }
   else
   {
      planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeStable);
      if ( (planID < 0) && (kbUnitCount(cMyID, cUnitTypeStable, cUnitStateAlive) < 1) && (civIsNative() == false) )
      {     // Start a new one
         createSimpleBuildPlan(cUnitTypeStable, 1, 70, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
         aiEcho("Starting a new stable build plan.");
      }
   }

   // Mill construction is handled by updateFoodBreakdown, do not build mills here

   // Livestock pen if we own critters
   planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, gLivestockPenUnit);
   if ( (planID < 0) && (kbUnitCount(cMyID, gLivestockPenUnit, cUnitStateAlive) < 1) && (kbUnitCount(cMyID,
  cUnitTypeHerdable, cUnitStateAlive) > 0) ) {     // Start a new one if (civIsNative() == false)
      {
         createSimpleBuildPlan(gLivestockPenUnit, 1, 65, true, cEconomyEscrowID, kbBaseGetMainID(cMyID), 1);
         aiEcho("Starting a new livestock pen build plan.");
         xsEnableRule("herdMonitor");  // Relocate herd plan when it's done
      }
      else
         xsEnableRule("herdMonitor");  // Just wait for farms
   }

   // At least one artillery depot
   if ( (civIsNative() == false) && (civIsAsian() == false) )
   {
      planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeArtilleryDepot);
      if ( (planID < 0) && (kbUnitCount(cMyID, cUnitTypeArtilleryDepot, cUnitStateAlive) < 1) )
      {     // Start a new one
         createSimpleBuildPlan(cUnitTypeArtilleryDepot, 1, 65, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
         aiEcho("Starting a new artillery depot build plan.");
      }
   }
   if (civIsAsian() == true) {
      planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeypCastle);
      if ( (planID < 0) && (kbUnitCount(cMyID, cUnitTypeypCastle, cUnitStateAlive) < 1) )
      {     // Start a new one
        createSimpleBuildPlan(cUnitTypeypCastle, 1, 70, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
        aiEcho("Starting a new siege workshop build plan.");
      }
    }*/

   if (gTimeToFish == true && (kbUnitCount(cMyID, gDockUnit, cUnitStateABQ) < 1) &&
       (aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, gDockUnit) < 0) &&
       ((gRevolutionType & cRevolutionFinland) == 0))
   { // No dock and not making any, let's start a plan.
      planID = createSimpleBuildPlan(gDockUnit, 1, 70, false, cEconomyEscrowID, kbBaseGetMainID(cMyID), 1);
      aiPlanSetDesiredResourcePriority(planID, 70);
      aiEcho("Starting a dock build plan.");
   }

   // At least one church if we sent a royal decree card
   if ((civIsEuropean() == true))/* && ((kbTechGetStatus(cTechHCRoyalDecreeBritish) == cTechStatusActive) ||
                                     (kbTechGetStatus(cTechHCRoyalDecreeDutch) == cTechStatusActive) ||
                                     (kbTechGetStatus(cTechHCRoyalDecreeFrench) == cTechStatusActive) ||
                                     (kbTechGetStatus(cTechHCRoyalDecreeGerman) == cTechStatusActive) ||
                                     (kbTechGetStatus(cTechHCRoyalDecreeOttoman) == cTechStatusActive) ||
                                     (kbTechGetStatus(cTechHCRoyalDecreePortuguese) == cTechStatusActive) ||
                                     (kbTechGetStatus(cTechHCRoyalDecreeRussian) == cTechStatusActive) ||
                                     (kbTechGetStatus(cTechDEHCRoyalDecreeSwedish) == cTechStatusActive) ||
                                     (kbTechGetStatus(cTechHCRoyalDecreeSpanish) == cTechStatusActive)))*/
   {
      planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeChurch);
      if ((planID < 0) && (kbUnitCount(cMyID, cUnitTypeChurch, cUnitStateAlive) < 1))
      { // Start a new one
         planID = createSimpleBuildPlan(cUnitTypeChurch, 1, 60, true, cEconomyEscrowID, kbBaseGetMainID(cMyID), 1);
         aiPlanSetDesiredResourcePriority(planID, 50);
         aiEcho("Starting a new church build plan.");
      }
   }
   
   
   if (kbUnitCount(cMyID, cUnitTypeypChurchWagon, cUnitStateAlive) > 0)
   {
      planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeypChurch);
      if ((planID < 0) && (kbUnitCount(cMyID, cUnitTypeypChurch, cUnitStateAlive) < 1))
      { // Start a new one
         planID = createSimpleBuildPlan(cUnitTypeypChurch, 1, 95, true, cEconomyEscrowID, kbBaseGetMainID(cMyID), 1);
         aiPlanSetDesiredResourcePriority(planID, 95);
         aiEcho("Starting a new church build plan.");
      }
   }
   
   
   if ((kbTechGetStatus(cTechypConsulateDutchLivestockPenWagon) != cTechStatusObtainable) 
	   && (kbUnitCount(cMyID, cUnitTypeYPLivestockPenAsian, cUnitStateABQ) < 1))
   {
      planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeYPLivestockPenAsian);
      if ((planID < 0) && (kbUnitCount(cMyID, cUnitTypeYPLivestockPenAsian, cUnitStateABQ) < 1))
      { // Start a new one
         planID = createSimpleBuildPlan(cUnitTypeYPLivestockPenAsian, 1, 60, true, cEconomyEscrowID, kbBaseGetMainID(cMyID), 1);
         aiPlanSetDesiredResourcePriority(planID, 40);
         aiEcho("Starting a new church build plan.");
      }
   }

   // If we are Ottoman, and close to Villager Build Limit, attempt to build a Mosque
   if (cMyCiv == cCivOttomans)
   {
      int settlerBLDelta =
          kbGetBuildLimit(cMyID, cUnitTypeSettler) - kbUnitCount(cMyID, cUnitTypeSettler, cUnitStateAlive);

      if (settlerBLDelta <= 5)
      {
         planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeChurch);
         if ((planID < 0) && (kbUnitCount(cMyID, cUnitTypeChurch, cUnitStateAlive) < 1))
         {
            planID = createSimpleBuildPlan(cUnitTypeChurch, 1, 60, true, cEconomyEscrowID, kbBaseGetMainID(cMyID), 1);

            if (settlerBLDelta <= 0)
               aiPlanSetDesiredResourcePriority(planID, 95);
            else if (settlerBLDelta <= 2)
               aiPlanSetDesiredResourcePriority(planID, 80);
            else
               aiPlanSetDesiredResourcePriority(planID, 70);

            aiEcho("Starting a new mosque build plan.");
         }
      }
   }

   // Build a native embassy if we allied with natives
   if (xsArrayGetSize(kbVPSiteQuery(cVPNative, cMyID, cVPStateCompleted)) > 0 &&
       ((gRevolutionType & cRevolutionFinland) == 0))
   {
      planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeNativeEmbassy);
      if ((planID < 0) && (kbUnitCount(cMyID, cUnitTypeNativeEmbassy, cUnitStateAlive) < 1))
      { // Start a new one
         planID =
             createSimpleBuildPlan(cUnitTypeNativeEmbassy, 1, 60, true, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
         aiPlanSetDesiredResourcePriority(planID, 40);
         aiEcho("Starting a new native embassy build plan.");
      }
   }

   // Build State Capitol for Americans if Virginia General Assembly card was sent
   if (cMyCiv == cCivDEAmericans &&
       (kbTechGetStatus(cTechDEHCFedGeneralAssembly) == cTechStatusActive || age >= cAge3))
   {
      planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypedeStateCapitol);
      if ((planID < 0) && (kbUnitCount(cMyID, cUnitTypedeStateCapitol, cUnitStateAlive) < 1))
      { // Start a new one
         createSimpleBuildPlan(cUnitTypedeStateCapitol, 1, 60, true, cEconomyEscrowID, kbBaseGetMainID(cMyID), 1);
         aiEcho("Starting a new state capitol build plan.");
      }
   }

   // At least one mountain monastery
   if (cMyCiv == cCivDEEthiopians && age >= cAge2)
   {
      planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypedeMountainMonastery);
      baseID = kbBaseGetMainID(cMyID);
      location = kbBaseGetLocation(cMyID, baseID);
      maxDistance = kbBaseGetDistance(cMyID, baseID) + 10.0;
      numberBuildingsWanted = getUnitCountByLocation(cUnitTypeAbstractMine, 0, cUnitStateAlive, location, maxDistance);
      buildLimit = kbGetBuildLimit(cMyID, cUnitTypedeMountainMonastery);
      if (numberBuildingsWanted > buildLimit)
         numberBuildingsWanted = buildLimit;
      if (numberBuildingsWanted < 1)
         numberBuildingsWanted = 1;
      if ((planID < 0) && (kbUnitCount(cMyID, cUnitTypedeMountainMonastery, cUnitStateABQ) < numberBuildingsWanted) &&
          (aiGetWorldDifficulty() >= cDifficultyHard))
      { // Start a new one
         planID = createSimpleBuildPlan(cUnitTypedeMountainMonastery, 1, 60, true, cEconomyEscrowID,
                                        kbBaseGetMainID(cMyID), 1);
         aiEcho("Starting a new mountain monestary build plan.");
      }
   }
	
	// We build 1 University in our main base, we want this University to be close to our starting Town Center and the in base Palace for the influence bonus.
	// This University will only be built if we sent the 1 Palace Builder card in Exploration/Commerce (otherwise we won't have a Palace in this age, it will be built in Fortress).
   if (cMyCiv == cCivDEHausa)
   {
      planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypedeUniversity);
		if (planID > 0 && (kbUnitCount(cMyID, cUnitTypedePalace, cUnitStateABQ) == 0 || kbUnitCount(cMyID, cUnitTypeTownCenter, cUnitStateABQ) == 0)) 
		{
			aiPlanDestroy(planID); // We have either no TC or no Palace or neither, so we destroy the Palace build plan.
		}
      else if (planID < 0 && kbUnitCount(cMyID, cUnitTypedeUniversity, cUnitStateABQ) < 1 &&
              kbUnitCount(cMyID, cUnitTypedePalace, cUnitStateABQ) >= 1 && kbUnitCount(cMyID, cUnitTypeTownCenter, cUnitStateABQ) >= 1) 
		{	 // We have a Palace and a Town Center so we can calculate the position for the University.
			vector townCenterLocation = kbGetPlayerStartingPosition(cMyID);
			vector palaceLocation = kbUnitGetPosition(getUnit(cUnitTypedePalace, cMyID, cUnitStateABQ));
			vector placeUniversityHere = townCenterLocation + (palaceLocation - townCenterLocation) * 0.5;
         planID = createLocationBuildPlan(cUnitTypedeUniversity, 1, 50, true, cEconomyEscrowID, placeUniversityHere, 1);
         aiEcho("Starting a new University build plan.");
      }
   }
   
   if (transitionAge > cAge2)
   {
   planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeTownCenter);
   if ((planID < 0) && (1 > kbUnitCount(cMyID, cUnitTypeTownCenter, cUnitStateABQ)))
		{     // Start a new one
   planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeTownCenter);
			aiPlanSetDesiredResourcePriority(planID, 99);
			aiEcho("Starting a new town center build plan.");
		}
        else
	// Incas need to build more town centers to reach maximum pop
   if ((planID < 0) && (kbUnitCount(cMyID, cUnitTypeTownCenter, cUnitStateABQ) < kbGetBuildLimit(cMyID, cUnitTypeTownCenter)))
		{     // Start a new one
			planID = createSimpleBuildPlan(cUnitTypeTownCenter, 1, 99, false, cEconomyEscrowID, kbBaseGetMainID(cMyID), 1);
			aiPlanSetDesiredResourcePriority(planID, 55);
			aiEcho("Starting a new town center build plan.");
		}
   }
		if (transitionAge > cAge2)
   {
		if ((WagonMaintainPlan < 0) && (kbUnitCount(cMyID, cUnitTypeypBankWagon, cUnitStateABQ) < kbGetBuildLimit(cMyID, cUnitTypeypBankWagon)))
		{     // Start a new one
			WagonMaintainPlan = createSimpleMaintainPlan(cUnitTypedeStateCapitolTrainBankWagon, 1, false, kbBaseGetMainID(cMyID), 1);
			aiPlanSetDesiredResourcePriority(planID, 55);
		}
   }
   
		if (transitionAge > cAge2)
   {
		if ((WagonMaintainPlan < 0) && (kbUnitCount(cMyID, cUnitTypeypBlockhouseWagon, cUnitStateABQ) < kbGetBuildLimit(cMyID, cUnitTypeypBlockhouseWagon)))
		{     // Start a new one
			WagonMaintainPlan = createSimpleMaintainPlan(cUnitTypedeStateCapitolTrainBankWagon, 1, false, kbBaseGetMainID(cMyID), 1);
			aiPlanSetDesiredResourcePriority(planID, 55);
		}
   }

   // That's it for age 2
   if (transitionAge < cAge3)
      return;
   // **********************************************************

   // Asians have Rice Paddies instead of Plantations
   /*if ( civIsAsian() == false ) {
     int plantsNeeded = 1 + ( (kbUnitCount(cMyID, gEconUnit, cUnitStateAlive) * 0.4) / cMaxSettlersPerPlantation);
   //Enough for 40% of population plantsNeeded = plantsNeeded - kbUnitCount(cMyID, gPlantationUnit, cUnitStateABQ);
     planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, gPlantationUnit);
     if ( (plantsNeeded > 0) && (planID < 0) )
     {     // Start a new one
        createSimpleBuildPlan(gPlantationUnit, 1, 60, true, cEconomyEscrowID, kbBaseGetMainID(cMyID), 1);
        aiEcho("Starting a new plantation build plan.");
     }
   }

   // At least one artillery depot
   if ( cMyCiv == cCivXPIroquois )
   {
      planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeArtilleryDepot);
      if ( (planID < 0) && (kbUnitCount(cMyID, cUnitTypeArtilleryDepot, cUnitStateAlive) < 1) )
      {     // Start a new one
         createSimpleBuildPlan(cUnitTypeArtilleryDepot, 1, 65, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
         aiEcho("Starting a new artillery depot build plan.");
      }
   }*/

   // At least one arsenal
   if ((civIsEuropean() == true) && ((gRevolutionType & cRevolutionFinland) == 0))
   {
      planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeArsenal);
      if ((planID < 0) && (kbUnitCount(cMyID, cUnitTypeArsenal, cUnitStateABQ) < 1))
      { // Start a new one
         createSimpleBuildPlan(cUnitTypeArsenal, 1, 60, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
         aiEcho("Starting a new arsenal build plan.");
      }
   }

   // One more town center for Ottomans and long treaty games
   /*if ((cMyCiv == cCivOttomans || aiTreatyGetEnd() > xsGetTime() + 10 * 60 * 1000) &&
       ((gRevolutionType & cRevolutionFinland) == 0))
   {
      planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeTownCenter);
      if ((planID < 0) && (kbUnitCount(cMyID, cUnitTypeTownCenter, cUnitStateABQ) < 2))
      { // Start a new one
         planID = createSimpleBuildPlan(cUnitTypeTownCenter, 1, 99, false, cEconomyEscrowID, kbBaseGetMainID(cMyID), 1);
         aiPlanSetDesiredResourcePriority(planID, 60);
         aiEcho("Starting a new town center build plan.");
      }
   }*/

   // Incas need to build more town centers to reach maximum pop
		
		/*if ((kbUnitCount(cMyID, cUnitTypeAbstractWagon, cUnitStateABQ) < kbGetBuildLimit(cMyID, cUnitTypeAbstractWagon)) &&
		(8 >= kbGetBuildLimit(cMyID, cUnitTypeAbstractWagon)) && (1 <= kbGetBuildLimit(cMyID, cUnitTypeAbstractWagon)))
		{     // Start a new one
			WagonMaintainPlan = createSimpleMaintainPlan(cUnitTypedeStateCapitolTrainBankWagon, 1, false, kbBaseGetMainID(cMyID), 1);
			aiPlanSetDesiredResourcePriority(planID, 40);
		}*/

   // random chance to build a saloon
   if ((civIsEuropean() == true) && ((gRevolutionType & cRevolutionFinland) == 0))
   {
      int saloonUnitType = cUnitTypeSaloon;

      if (cMyCiv != cCivDEAmericans)
         saloonUnitType = cUnitTypedeTavern;

      planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, saloonUnitType);
      static int saloonRandomizer = -1;
      if (saloonRandomizer < 0)
         saloonRandomizer = aiRandInt(10);
      if ((saloonRandomizer < 2 || xsArrayGetFloat(gResourceNeeds, cResourceWood) < -1000.0) && planID < 0 &&
          kbUnitCount(cMyID, saloonUnitType, cUnitStateAlive) < 1)
      {
         planID = createSimpleBuildPlan(saloonUnitType, 1, 50, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
         aiEcho("Starting a new saloon build plan.");
      }
   }

   // At least one Palace for Africans.
	// We don't need a Palace early for Ethiopians in treaty but we do need one for Hausa for the influence combination with Universities.
   if (cMyCiv == cCivDEEthiopians && (aiTreatyGetEnd() <= xsGetTime() + 600000))
   {
      planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypedePalace);
      if ((planID < 0) && (kbUnitCount(cMyID, cUnitTypedePalace, cUnitStateAlive) < 1))
      { // Start a new one
         planID = createSimpleBuildPlan(cUnitTypedePalace, 1, 60, true, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
         aiPlanSetDesiredResourcePriority(planID, 60);
         aiEcho("Starting a new Palace build plan.");
      }
   }
	
	if (cMyCiv == cCivDEHausa)
	{
		planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypedePalace);
		if ((planID < 0) && (kbUnitCount(cMyID, cUnitTypedePalace, cUnitStateAlive) < 1) && (kbUnitCount(cMyID, cUnitTypedeUniversity, cUnitStateAlive) < 1))
      { // Start a new one at a random spot in the base.
         planID = createSimpleBuildPlan(cUnitTypedePalace, 1, 60, true, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
         aiPlanSetDesiredResourcePriority(planID, 60);
         aiEcho("Starting a new palace build plan.");
      }
		else if ((planID < 0) && (kbUnitCount(cMyID, cUnitTypedePalace, cUnitStateAlive) < 1) && (kbUnitCount(cMyID, cUnitTypedeUniversity, cUnitStateAlive) >= 1))
      { // We have a University so we try to build the Palace next to it for the bonus.
         vector universityLocation = kbUnitGetPosition(getUnit(cUnitTypedeUniversity, cMyID, cUnitStateABQ));
         planID = createLocationBuildPlan(cUnitTypedePalace, 1, 60, true, cEconomyEscrowID, universityLocation, 1);
         aiEcho("Starting a new Palace build plan.");
      }
	}

   // That's it for age 3
   if (transitionAge < cAge4)
      return;
   // **********************************************************

   // At least one church if we don't have one yet
   if ((civIsEuropean() == true) && ((gRevolutionType & cRevolutionFinland) == 0))
   {
      planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeChurch);
      if ((planID < 0) && (kbUnitCount(cMyID, cUnitTypeChurch, cUnitStateAlive) < 1) &&
          (aiGetWorldDifficulty() >= cDifficultyHard))
      { // Start a new one
         planID = createSimpleBuildPlan(cUnitTypeChurch, 1, 60, true, cEconomyEscrowID, kbBaseGetMainID(cMyID), 1);
         aiPlanSetDesiredResourcePriority(planID, 35);
         aiEcho("Starting a new church build plan.");
      }
   }

   // That's it for age 4
   if (age < cAge5)
      return;
   // **********************************************************

   // And how 'bout a capitol, as long as we're here
   if ((civIsEuropean() == true))
   {
      planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeCapitol);
      if ((planID < 0) && (kbUnitCount(cMyID, cUnitTypeCapitol, cUnitStateAlive) < 1))
      { // Start a new one
         createSimpleBuildPlan(cUnitTypeCapitol, 1, 60, true, cEconomyEscrowID, kbBaseGetMainID(cMyID), 1);
         aiEcho("Starting a new capitol build plan.");
      }
   }
   
   
      if (civIsEuropean() == true)
        xsEnableRule("spiesMonitor");
		
      if (civIsEuropean() == false)
        xsEnableRule("spiesNativeMonitor");
}
rule spiesMonitor
inactive
minInterval 30
{
  
   //If we can afford it, then get it.
   float goldCost=kbTechCostPerResource(cTechSpies, cResourceGold);
   float currentGold=kbResourceGet(cResourceGold);
   if(goldCost>currentGold)
      return;

   //Get Omniscience
   int spiesPID=aiPlanCreate("Get_Spies", cPlanProgression);
   if (spiesPID != 0)
   {
      aiPlanSetVariableInt(spiesPID, cProgressionPlanGoalTechID, 0, cTechSpies);
      aiPlanSetDesiredPriority(spiesPID, 51);
      aiPlanSetEscrowID(spiesPID, cMilitaryEscrowID);
      aiPlanSetActive(spiesPID);
   }  
   xsDisableSelf();
}

rule spiesNativeMonitor
inactive
minInterval 30
{

   //If we can afford it, then get it.
   float goldCost=kbTechCostPerResource(cTechSpiesNative, cResourceGold);
   float currentGold=kbResourceGet(cResourceGold);
   if(goldCost>currentGold)
      return;

   //Get Omniscience
   int spiesPID=aiPlanCreate("Get_Spies", cPlanProgression);
   if (spiesPID != 0)
   {
      aiPlanSetVariableInt(spiesPID, cProgressionPlanGoalTechID, 0, cTechSpiesNative);
      aiPlanSetDesiredPriority(spiesPID, 51);
      aiPlanSetEscrowID(spiesPID, cMilitaryEscrowID);
      aiPlanSetActive(spiesPID);
   }  
   xsDisableSelf();
}

//==============================================================================
/* xpBuilder monitor

   Use an idle xpBuilder to build as needed.

*/
//==============================================================================
rule xpBuilderMonitor
inactive
group tcComplete
minInterval 20
{
   if (cMyCiv != cCivXPIroquois)
   {
      xsDisableSelf();
      return;
   }

   static int activePlan = -1;

   if (activePlan != -1) // We already have something active?
   {
      if ((aiPlanGetState(activePlan) < 0) || (aiPlanGetState(activePlan) == cPlanStateNone))
      {
         aiPlanDestroy(activePlan);
         activePlan = -1; // Plan is bad, but didn't die.  It's dead now, so continue below.
      }
      else
      {
         return; // Something is active, let it run.
      }
   }

   // If we get this far, there is no active plan.  See if we have a xpBuilder to use.
   int xpBuilderID = -1;
   int buildingToMake = -1;
   int buildertype = -1;
   if (kbUnitCount(cMyID, cUnitTypexpBuilderStart, cUnitStateAlive) > 0)
   {
      xpBuilderID = getUnit(cUnitTypexpBuilderStart);
      buildingToMake = gHouseUnit; // If all else fails, make a house since we can't make warhuts.
      buildertype = cUnitTypexpBuilderStart;
   }
   else
   {
      xpBuilderID = getUnit(cUnitTypexpBuilder);
      buildingToMake = cUnitTypeWarHut; // If all else fails, make a war hut.
      buildertype = cUnitTypexpBuilder;
   }
   if (xpBuilderID < 0)
      return;

   // We have a xpBuilder, and no plan to use it.  Find something to do with it.
   // Simple logic.  Farm if less than 3.  War hut if less than 2.  Corral if < 2.  House if below pop limit.
   // One override....avoid farms in age 1, they're too slow.
   if ((kbUnitCount(cMyID, gFarmUnit, cUnitStateABQ) < 3) && (kbGetAge() > cAge1) && (gTimeToFarm == true))
      buildingToMake = gFarmUnit;
   else if (kbUnitCount(cMyID, cUnitTypeWarHut, cUnitStateABQ) < 2 && (kbGetAge() > cAge1) &&
            (buildertype == cUnitTypexpBuilder))
      buildingToMake = cUnitTypeWarHut;
   else if (kbUnitCount(cMyID, cUnitTypeCorral, cUnitStateABQ) < 2 && (kbGetAge() > cAge1))
      buildingToMake = cUnitTypeCorral;
   else if (kbGetBuildLimit(cMyID, gHouseUnit) <= kbUnitCount(cMyID, gHouseUnit, cUnitStateAlive))
      buildingToMake = gHouseUnit;

   activePlan = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, buildingToMake);
   if (buildingToMake >= 0 && activePlan < 0)
   {
      activePlan = aiPlanCreate("Use an xpBuilder", cPlanBuild);
      // What to build
      aiPlanSetVariableInt(activePlan, cBuildPlanBuildingTypeID, 0, buildingToMake);

      // 3 meter separation
      aiPlanSetVariableFloat(activePlan, cBuildPlanBuildingBufferSpace, 0, 3.0);
      if (buildingToMake == gFarmUnit)
         aiPlanSetVariableFloat(activePlan, cBuildPlanBuildingBufferSpace, 0, 8.0);

      // Priority.
      aiPlanSetDesiredPriority(activePlan, 95);
      // Mil vs. Econ.
      if ((buildingToMake == cUnitTypeWarHut) || (buildingToMake == cUnitTypeCorral))
      {
         aiPlanSetMilitary(activePlan, true);
         aiPlanSetEconomy(activePlan, false);
      }
      else
      {
         aiPlanSetMilitary(activePlan, false);
         aiPlanSetEconomy(activePlan, true);
      }
      aiPlanSetEscrowID(activePlan, cEconomyEscrowID);

      aiPlanAddUnitType(activePlan, buildertype, 1, 1, 1);

      aiPlanSetBaseID(activePlan, kbBaseGetMainID(cMyID));

      // Go.
      aiPlanSetActive(activePlan);
   }
   else
   {
      aiPlanAddUnitType(activePlan, buildertype, 1, 1, 1);
   }
}

//==============================================================================
/* Native Dance Monitor

   Manage the number of natives dancing, and the 'tactic' they're dancing for.

const int cTacticFertilityDance=12;   Faster training
const int cTacticGiftDance=13;         Faster XP trickle
const int cTacticCityDance=14;
const int cTacticWaterDance=15;       Increases navy HP/attack
const int cTacticAlarmDance=16;        Town defense...
const int cTacticFounderDance=17;      xpBuilder units - Iroquois
const int cTacticMorningWarsDance=18;
const int cTacticEarthMotherDance=19;
const int cTacticHealingDance=20;
const int cTacticFireDance=21;
const int cTacticWarDanceSong=22;
const int cTacticGarlandWarDance=23;
const int cTacticWarChiefDance=24;    new war chief
const int cTacticHolyDance=25;

*/
//==============================================================================
rule danceMonitor
inactive
group tcComplete
minInterval 20
{
   if (civIsNative() == false)
   {
      xsDisableSelf();
      return;
   }

   static int lastTactic = -1;
   static int lastTacticTime = 0;
   static int danceTactics = -1;
   static int lastVillagerTime = 0;
   int time = xsGetTime();

   if (danceTactics < 0)
   {
      // Setup dance tactics we want to use.
      switch (cMyCiv)
      {
      case cCivXPAztec:
      {
         danceTactics = xsArrayCreateInt(6, -1, "Dance tactics");

         // Shared
         xsArraySetInt(danceTactics, 0, cTacticFertilityDance);
         xsArraySetInt(danceTactics, 1, cTacticGiftDance);
         xsArraySetInt(danceTactics, 2, cTacticAlarmDance);
         xsArraySetInt(danceTactics, 3, cTacticWarDance);

         xsArraySetInt(danceTactics, 4, cTacticWarChiefDanceAztec);
         xsArraySetInt(danceTactics, 5, cTacticHolyDanceAztec);
         //xsArraySetInt(danceTactics, 6, cTacticGarlandWarDance);
         break;
      }
      case cCivXPIroquois:
      {
         danceTactics = xsArrayCreateInt(5, -1, "Dance tactics");

         // Shared
         xsArraySetInt(danceTactics, 0, cTacticFertilityDance);
         xsArraySetInt(danceTactics, 1, cTacticGiftDance);
         xsArraySetInt(danceTactics, 2, cTacticAlarmDance);
         xsArraySetInt(danceTactics, 3, cTacticWarDance);

         xsArraySetInt(danceTactics, 4, cTacticWarChiefDance);
         break;
      }
      case cCivXPSioux:
      {
         danceTactics = xsArrayCreateInt(6, -1, "Dance tactics");

         // Shared
         xsArraySetInt(danceTactics, 0, cTacticFertilityDance);
         xsArraySetInt(danceTactics, 1, cTacticGiftDance);
         xsArraySetInt(danceTactics, 2, cTacticAlarmDance);
         xsArraySetInt(danceTactics, 3, cTacticWarDance);

         xsArraySetInt(danceTactics, 4, cTacticWarChiefDanceSioux);
         xsArraySetInt(danceTactics, 5, cTacticWarDanceSong);
         break;
      }
      case cCivDEInca:
      {
         danceTactics = xsArrayCreateInt(6, -1, "Dance tactics");

         // Shared
         xsArraySetInt(danceTactics, 0, cTacticFertilityDance);
         xsArraySetInt(danceTactics, 1, cTacticGiftDance);
         xsArraySetInt(danceTactics, 2, cTacticAlarmDance);
         xsArraySetInt(danceTactics, 3, cTacticWarDance);

         xsArraySetInt(danceTactics, 4, cTacticdeWarChiefDanceInca);
         xsArraySetInt(danceTactics, 5, cTacticdeMoonDance);
         break;
      }
      }
   }

   if (gNativeDancePlan < 0)
   {
      gNativeDancePlan = createNativeResearchPlan(cTacticNormal, 85, 1, 1, 1);
      lastTactic = cTacticNormal;
      lastTacticTime = time;
   }

   int numWarPriests = 0;
   int limitWarPriests = 0;
   int numPriestesses = 0;
   int numLlamas = 0;
   int numEconUnits = 0;

   int totalBonusDancers = 0;
   int mainBaseID = kbBaseGetMainID(cMyID);
   // If not in defense reflex use up to 25 available warrior priests as dancers
   //if (gDefenseReflexBaseID != mainBaseID)
   //{
      // War priest
      numWarPriests = kbUnitCount(cMyID, cUnitTypexpMedicineManAztec, cUnitStateAlive);
      // Don't defend with warrior priests when there are no villagers dancing as we can produce warriors from the plaza.
      //if (gDefenseReflexBaseID != mainBaseID || (numWarPriests > 0 && aiPlanGetNumberUnits(gNativeDancePlan, gEconUnit) == 0))
      //{
         if (cMyCiv == cCivXPAztec)
         {
            limitWarPriests = kbGetBuildLimit(cMyID, cUnitTypexpMedicineManAztec);
            if (limitWarPriests < numWarPriests)
               limitWarPriests = numWarPriests;
         }
         else
         {
            limitWarPriests = numWarPriests;
         }
         totalBonusDancers = numWarPriests;
         if (totalBonusDancers > 25)
            totalBonusDancers = 25;
      //}
   //}

   // Priestess
   if (totalBonusDancers < 25)
   {
      numPriestesses = kbUnitCount(cMyID, cUnitTypedePriestess, cUnitStateAlive);
      if ((totalBonusDancers + numPriestesses) > 25)
      {
         numPriestesses = 25 - totalBonusDancers;
         totalBonusDancers = 25;
      }
      else
      {
         totalBonusDancers = totalBonusDancers + numPriestesses;
      }
   }

   // Llama
   if (cMyCiv == cCivDEInca && totalBonusDancers < 25)
   {
      numLlamas = kbUnitCount(cMyID, cUnitTypeLlama, cUnitStateAlive);
      if ((totalBonusDancers + numLlamas) > 25)
      {
         numLlamas = 25 - totalBonusDancers;
         totalBonusDancers = 25;
      }
      else
      {
         totalBonusDancers = totalBonusDancers + numLlamas;
      }
   }

   aiPlanAddUnitType(gNativeDancePlan, cUnitTypexpMedicineManAztec, numWarPriests, numWarPriests, limitWarPriests);
   aiPlanAddUnitType(gNativeDancePlan, cUnitTypedePriestess, numPriestesses, numPriestesses, numPriestesses);
   if (cMyCiv == cCivDEInca)
      aiPlanAddUnitType(gNativeDancePlan, cUnitTypeLlama, numLlamas, numLlamas, numLlamas);

   int numDanceTactics = xsArrayGetSize(danceTactics);
   int tacticID = -1;
   int tacticPriority = 0;
   int bestTacticID = -1;
   int bestTacticPriority = 0;
   int planID = -1;
   const int cMinDancePriorityVillager = 3;
   int maxMilitaryPop = 0;
   float militaryPercentage = 0.0;
   int numPlazas = kbUnitCount(cMyID, cUnitTypeCommunityPlaza, cUnitStateAlive);
   bool warriorLimitReached =
       kbUnitCount(cMyID, cUnitTypexpWarrior, cUnitStateAlive) >= kbGetBuildLimit(cMyID, cUnitTypexpWarrior);
   
   // Go through all tactics and find the best one.
   for (i = 0; < numDanceTactics)
   {
      tacticID = xsArrayGetInt(danceTactics, i);
      tacticPriority = 0;

      switch (tacticID)
      {
      case cTacticFertilityDance: // Speed up unit production.
      {
         if (kbUnitCount(cMyID, gEconUnit, cUnitStateAlive) > 60 && (aiGetAvailableMilitaryPop() >= 50) &&
             ((kbGetPopCap() - kbGetPop()) >= 50))
            tacticPriority = 94;
         break;
      }
      case cTacticGiftDance: // Generates XP.
      {
         // Defaults to gift dance.
         tacticPriority = cMinDancePriorityVillager - 2;
         break;
      }
      /*case cTacticAlarmDance: // Spawn warriors.
      {
         if (numPlazas > 0 && gDefenseReflexBaseID == mainBaseID && warriorLimitReached == false)
            tacticPriority = 99;
         break;
      }*/
      case cTacticWarDance: // Increase attack.
      {
         planID = aiPlanGetIDByTypeAndVariableType(cPlanAttack, cAttackPlanBaseAttackMode,
                                                   cAttackPlanBaseAttackModeExplicit);
         if (numPlazas > 0 && ((planID >= 0 && aiPlanGetState(planID) == cPlanStateAttack) ||
                               (gDefenseReflexBaseID == mainBaseID && warriorLimitReached == true &&
                                kbGetPopulationSlotsByUnitTypeID(cMyID, cUnitTypeLogicalTypeLandMilitary) >=
                                    (0.3 * aiGetMilitaryPop()))))
            tacticPriority = 98;
         break;
      }
      case cTacticWarChiefDanceAztec: // Rescue Aztec warchief.
      {
         if (aiGetFallenExplorerID() >= 0)
            tacticPriority = cMinDancePriorityVillager - 1;
         break;
      }
      case cTacticWarChiefDance: // Rescue Iroquois warchief.
      {
         if (aiGetFallenExplorerID() >= 0)
            tacticPriority = cMinDancePriorityVillager - 1;
         break;
      }
      case cTacticWarChiefDanceSioux: // Rescue Sioux warchief.
      {
         if (aiGetFallenExplorerID() >= 0)
            tacticPriority = cMinDancePriorityVillager - 1;
         break;
      }
      case cTacticdeWarChiefDanceInca: // Rescue Inca warchief.
      {
         if (aiGetFallenExplorerID() >= 0)
            tacticPriority = cMinDancePriorityVillager - 1;
         break;
      }
      case cTacticHolyDanceAztec: // Spawn warrior priests.
      {
         if (kbUnitCount(cMyID, cUnitTypexpMedicineManAztec, cUnitStateAlive) <
             kbGetBuildLimit(cMyID, cUnitTypexpMedicineManAztec))
         {
            if (totalBonusDancers > 1 || (xsArrayGetFloat(gResourceNeeds, cResourceFood) <= -1000.0 &&
                                          xsArrayGetFloat(gResourceNeeds, cResourceWood) <= -1000.0 &&
                                          xsArrayGetFloat(gResourceNeeds, cResourceGold) <= -1000.0))
               // We spent at least 30 seconds into spawning this unit, avoid switching.
               if (lastTactic == cTacticHolyDanceAztec && (time - lastTacticTime) >= 30000 &&
                   (time - lastTacticTime) < 90000)
                  tacticPriority = 99;
               else
                  tacticPriority = 96;
         }
         break;
      }/*
      case cTacticGarlandWarDance: // Spawn skull knights.
      {
         if ((numPlazas > 0) && (kbGetAge() >= cAge4) && (aiGetAvailableMilitaryPop() >= 10) &&
             ((kbGetPopCap() - kbGetPop()) >= 10))
         {
            // We spent at least 30 seconds into spawning this unit, avoid switching.
            if (lastTactic == cTacticGarlandWarDance && (time - lastTacticTime) >= 30000 &&
                (time - lastTacticTime) < 90000)
               tacticPriority = 99;
            else
               tacticPriority = 95;
         }
         break;
      }
      case cTacticWarDanceSong: // Spawn dog soldiers.
      {
         if ((numPlazas > 0) && (kbGetAge() >= cAge4) && (aiGetAvailableMilitaryPop() >= 10) &&
             ((kbGetPopCap() - kbGetPop()) >= 10))
         {
            // We spent at least 30 seconds into spawning this unit, avoid switching.
            if (lastTactic == cTacticWarDanceSong && (time - lastTacticTime) >= 30000 &&
                (time - lastTacticTime) < 90000)
               tacticPriority = 99;
            else
               tacticPriority = 95;
         }
         break;
      }
      case cTacticdeMoonDance: // Wood trickle.
      {
         // When we run out of wood.
         if ((gDisableWoods == true && time > 120000 && xsArrayGetInt(gResourceNeeds, cResourceWood) > 0.0) ||
             // Don't switch for at least 60 seconds.
             (lastTactic == cTacticdeMoonDance && (time - lastTacticTime) < 60000))
            tacticPriority = 97;
         break;
      }*/
      }

      if (bestTacticPriority < tacticPriority)
      {
         bestTacticID = tacticID;
         bestTacticPriority = tacticPriority;
      }
   }

   if (bestTacticPriority < cMinDancePriorityVillager && totalBonusDancers < 2)
   {
      aiPlanAddUnitType(gNativeDancePlan, gEconUnit, 0, 0, 0);
      return;
   }

   // Build community plaza if there isn't one.
   if (numPlazas < 1)
   {
      planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeCommunityPlaza);
      if (planID < 0)
         planID = createSimpleBuildPlan(cUnitTypeCommunityPlaza, 1, 92, false, cEconomyEscrowID, mainBaseID, 1);
      aiPlanSetDesiredResourcePriority(planID, 60);
      aiPlanAddUnitType(gNativeDancePlan, gEconUnit, 0, 0, 0);
      aiEcho("Starting a new community plaza build plan.");
      return;
   }

   if (bestTacticPriority >= cMinDancePriorityVillager && (time - lastVillagerTime) >= 60000)
   {
      numEconUnits = kbUnitCount(cMyID, gEconUnit, cUnitStateAlive) / 10;

      switch (bestTacticID)
      {
      case cTacticWarDance:
      {
         // Scale by military pop.
         maxMilitaryPop = gMaxPop - aiGetEconomyPop();
         if (maxMilitaryPop > 0)
            militaryPercentage =
                kbGetPopulationSlotsByUnitTypeID(cMyID, cUnitTypeLogicalTypeLandMilitary) / maxMilitaryPop;
         numEconUnits = militaryPercentage * numEconUnits * 2 - totalBonusDancers;
         if (numEconUnits > 25)
            numEconUnits = 25;
         if (numEconUnits < 0)
            numEconUnits = 0;
         aiPlanAddUnitType(gNativeDancePlan, gEconUnit, numEconUnits, numEconUnits * 2, numEconUnits * 2);
         break;
      }
      case cTacticdeMoonDance:
      {
         // Need more dancers as we are out of wood.
         numEconUnits = numEconUnits * 2 - totalBonusDancers;
         if (numEconUnits > 25)
            numEconUnits = 25;
         if (numEconUnits < 0)
            numEconUnits = 0;
         aiPlanAddUnitType(gNativeDancePlan, gEconUnit, numEconUnits, numEconUnits * 2, numEconUnits * 2);
         break;
      }
      default:
      {
         // Add a number of dancers equivalent to 1/10 of settler pop, rounded down
         // Make sure no more than 25 units are assigned in total
         numEconUnits = numEconUnits - totalBonusDancers;
         if (numEconUnits > 25)
            numEconUnits = 25;
         if (numEconUnits < 0)
            numEconUnits = 0;
         aiPlanAddUnitType(gNativeDancePlan, gEconUnit, numEconUnits / 2, numEconUnits, numEconUnits * 2);
         break;
      }
      }

      lastVillagerTime = time;
   }

   aiPlanSetVariableInt(gNativeDancePlan, cNativeResearchPlanTacticID, 0, bestTacticID);
   lastTactic = bestTacticID;
   lastTacticTime = time;
}

//==============================================================================
// Tactic Farm Monitor
//
// Manages farms which can switch resources by tactic.
//==============================================================================
/*rule tacticFarmMonitor
inactive
group tcComplete
minInterval 10
{
   if (civIsAsian() == false && civIsAfrican() == false)
   {
      xsDisableSelf();
      return;
   }

   // gotta get all of the paddies
   static int paddyQueryID = -1;
   static int tacticGold = -1;
   static int tacticFood = -1;

   // If we don't have the query yet, create one.
   if (paddyQueryID < 0)
   {
      paddyQueryID = kbUnitQueryCreate("paddyGetUnitQuery");
      kbUnitQuerySetIgnoreKnockedOutUnits(paddyQueryID, true);
      if (civIsAsian() == true)
      {
         tacticGold = cTacticPaddyCoin;
         tacticFood = cTacticPaddyFood;
      }
      else
      {
         tacticGold = cTacticFieldCoin;
         tacticFood = cTacticFieldFood;
      }
   }

   // Define a query to get all matching units
   if (paddyQueryID != -1)
   {
      kbUnitQuerySetPlayerRelation(paddyQueryID, -1);
      kbUnitQuerySetPlayerID(paddyQueryID, cMyID);
      kbUnitQuerySetUnitType(paddyQueryID, gFarmUnit);
      kbUnitQuerySetState(paddyQueryID, cUnitStateAlive);
   }
   else
      return;

   kbUnitQueryResetResults(paddyQueryID);
   int numberFound = kbUnitQueryExecute(paddyQueryID);
   int i = 0;
   int numberFoodPaddies = 0;
   int numberGoldPaddies = 0;
   int numberWanted = 0;
   int numberOnFood = 0;
   int numberNeeded = 0;
   int unitID = -1;

   numberFoodPaddies = gNumberFoodPaddies + gNumberQueuedFoodPaddies;
   numberGoldPaddies = gNumberGoldPaddies + gNumberQueuedGoldPaddies;
   numberWanted = numberFoodPaddies + numberGoldPaddies;

   if (numberWanted == numberFound)
   {
      gNumberFoodPaddies = numberFoodPaddies;
      gNumberGoldPaddies = numberGoldPaddies;
      gNumberQueuedFoodPaddies = 0;
      gNumberQueuedGoldPaddies = 0;
   }
   else if (numberWanted > numberFound)
   {
      if ((gNumberFoodPaddies + gNumberGoldPaddies) == numberFound)
      {
         // We supposed to have rice paddies queued, but there are no build plans?
         if ((gNumberQueuedFoodPaddies > 0 || gNumberQueuedGoldPaddies > 0) &&
             aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, gFarmUnit) < 0)
         {
            gNumberQueuedFoodPaddies = 0;
            gNumberQueuedGoldPaddies = 0;
         }
      }
      else
      {
         // we lost some rice paddies, recalculate how many we need for food and gold
         for (i = numberFound; < numberWanted)
         {
            // remove gold before food
            if (i % 2 == numberFound % 2)
               numberGoldPaddies = numberGoldPaddies - 1;
            else
               numberFoodPaddies = numberFoodPaddies - 1;
         }
         gNumberFoodPaddies = numberFoodPaddies;
         gNumberGoldPaddies = numberGoldPaddies;
         gNumberQueuedFoodPaddies = 0;
         gNumberQueuedGoldPaddies = 0;
      }
   }
   else
   {
      for (i = numberWanted; < numberFound)
      {
         // we want gold before food
         if (i % 2 == numberWanted % 2)
            numberGoldPaddies = numberGoldPaddies + 1;
         else
            numberFoodPaddies = numberFoodPaddies + 1;
      }
      gNumberFoodPaddies = numberFoodPaddies;
      gNumberGoldPaddies = numberGoldPaddies;
      gNumberQueuedFoodPaddies = 0;
      gNumberQueuedGoldPaddies = 0;
   }

   for (i = 0; < numberFound)
   {
      unitID = kbUnitQueryGetResult(paddyQueryID, i);
      if (aiUnitGetTactic(unitID) == tacticFood)
         numberOnFood = numberOnFood + 1;
   }

   // change rice paddies to food production if not enough
   if (numberOnFood < gNumberFoodPaddies)
   {
      numberNeeded = gNumberFoodPaddies - numberOnFood;
      // Go through empty paddies first
      for (i = 0; < numberFound)
      {
         unitID = kbUnitQueryGetResult(paddyQueryID, i);
         if (kbUnitGetNumberWorkers(unitID) == 0 && aiUnitGetTactic(unitID) != tacticFood)
         {
            aiUnitSetTactic(kbUnitQueryGetResult(paddyQueryID, i), tacticFood);
            numberNeeded = numberNeeded - 1;
            if (numberNeeded == 0)
               break;
         }
      }

      if (numberNeeded > 0)
      {
         for (i = 0; < numberFound)
         {
            unitID = kbUnitQueryGetResult(paddyQueryID, i);
            if (kbUnitGetNumberWorkers(unitID) > 0 && aiUnitGetTactic(unitID) != tacticFood)
            {
               aiUnitSetTactic(kbUnitQueryGetResult(paddyQueryID, i), tacticFood);
               numberNeeded = numberNeeded - 1;
               if (numberNeeded == 0)
                  break;
            }
         }
      }
   }

   // change rice paddies to gold production if not enough
   if ((numberFound - numberOnFood) < gNumberGoldPaddies)
   {
      numberNeeded = gNumberGoldPaddies - (numberFound - numberOnFood);
      // Go through empty paddies first
      for (i = 0; < numberFound)
      {
         unitID = kbUnitQueryGetResult(paddyQueryID, i);
         if (kbUnitGetNumberWorkers(unitID) == 0 && aiUnitGetTactic(unitID) != tacticGold)
         {
            aiUnitSetTactic(unitID, tacticGold);
            numberNeeded = numberNeeded - 1;
            if (numberNeeded == 0)
               break;
         }
      }

      if (numberNeeded > 0)
      {
         for (i = 0; < numberFound)
         {
            unitID = kbUnitQueryGetResult(paddyQueryID, i);
            if (kbUnitGetNumberWorkers(unitID) > 0 && aiUnitGetTactic(unitID) != tacticGold)
            {
               aiUnitSetTactic(unitID, tacticGold);
               numberNeeded = numberNeeded - 1;
               if (numberNeeded == 0)
                  break;
            }
         }
      }
   }
}*/

//==============================================================================
// selectShrineBuildPlanPosition
//==============================================================================
void selectShrineBuildPlanPosition(int planID = -1, int baseID = -1)
{
   static int huntableQuery = -1;

   if (huntableQuery < 0)
   {
      huntableQuery = kbUnitQueryCreate("Huntable query for shrine placement");
      kbUnitQuerySetPlayerID(huntableQuery, 0);
      kbUnitQuerySetUnitType(huntableQuery, cUnitTypeHuntable);
   /*if (kbGetAge() >= cAge3)
      kbUnitQuerySetMaximumDistance(huntableQuery, 1000.0);
  else
   if (kbGetAge() == cAge2)
      kbUnitQuerySetMaximumDistance(huntableQuery, 120.0);
  else*/
      kbUnitQuerySetMaximumDistance(huntableQuery, 1000.0);
      kbUnitQuerySetAscendingSort(huntableQuery, true);
   }
   //if (kbGetAge() == cAge1)
   kbUnitQuerySetPosition(huntableQuery, kbBaseGetLocation(cMyID, baseID));
   //kbUnitQuerySetPosition(huntableQuery, cInvalidVector);
   kbUnitQueryResetResults(huntableQuery);
   int huntableCount = kbUnitQueryExecute(huntableQuery);
   int huntableID = -1;
   vector location = cInvalidVector;
   vector StartBase = cInvalidVector;
   int huntableAreaGroup = -1;
   //int mainAreaGroup = kbAreaGroupGetIDByPosition(kbBaseGetLocation(cMyID, baseID)); kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID))
   bool goodPlaceFound = false;

   aiEcho("**** Starting Shrine placement search, found " + huntableCount + " huntables.");
   for (i = 0; < huntableCount)
   {
      huntableID = kbUnitQueryGetResult(huntableQuery, i);
      location = kbUnitGetPosition(huntableID);
      huntableAreaGroup = kbAreaGroupGetIDByPosition(location);
	  StartBase = kbBaseGetLocation(cMyID, baseID);
	  
      // Where should I build?
      if ((getUnitCountByLocation(cUnitTypeHuntable, 0, cUnitStateAlive, location, 10.0) >=
           (4 * (getUnitCountByLocation(cUnitTypeAbstractShrine, cPlayerRelationAny, cUnitStateABQ, location, 15.0) + 1)) - 1) 
		   && (getUnitCountByLocation(cUnitTypeTownCenter, cPlayerRelationAlly, cUnitStateAlive, location, 45.0) < 1))
      {
         aiEcho("    Found good place to build a shrine at " + location);
         goodPlaceFound = true;
         break;
      }
   }

   if (goodPlaceFound == true)
   {
      aiPlanSetVariableVector(planID, cBuildPlanCenterPosition, 0, location);
      aiPlanSetVariableFloat(planID, cBuildPlanCenterPositionDistance, 0, 10.0);
	  
      aiPlanSetVariableVector(planID, cBuildPlanInfluencePosition, 0, location);     // Influence toward position
      aiPlanSetVariableFloat(planID, cBuildPlanInfluencePositionDistance, 0, 10.0); // 100m range.
      aiPlanSetVariableFloat(planID, cBuildPlanInfluencePositionValue, 0, 5000.0);    // 200 points max
      aiPlanSetVariableInt(planID, cBuildPlanInfluencePositionFalloff, 0, cBPIFalloffNone); // Linear slope falloff
	  
	   // Weight it to prefer the general starting neighborhood
      aiPlanSetVariableVector(planID, cBuildPlanInfluencePosition, 0, StartBase); // Position influence for landing position
      aiPlanSetVariableFloat(planID, cBuildPlanInfluencePositionDistance, 0, 1000.0);          // 100m range.
      aiPlanSetVariableFloat(planID, cBuildPlanInfluencePositionValue, 0, 100.0);             // 300 points max
      aiPlanSetVariableInt(planID, cBuildPlanInfluencePositionFalloff, 0, cBPIFalloffLinear); // Linear slope falloff
	  
	   // Weight it to prefer the general starting neighborhood
      /*aiPlanSetVariableVector(planID, cBuildPlanInfluencePosition, 1, StartBase); // Position influence for landing position
      aiPlanSetVariableFloat(planID, cBuildPlanInfluencePositionDistance, 1, 200.0);          // 100m range.
      aiPlanSetVariableFloat(planID, cBuildPlanInfluencePositionValue, 1, 50.0);             // 300 points max
      aiPlanSetVariableInt(planID, cBuildPlanInfluencePositionFalloff, 1, cBPIFalloffNone); // Linear slope falloff*/
	  
	  aiPlanSetNumberVariableValues(planID, cBuildPlanInfluenceUnitTypeID, 4, true);
	  aiPlanSetNumberVariableValues(planID, cBuildPlanInfluenceUnitDistance, 4, true);
      aiPlanSetNumberVariableValues(planID, cBuildPlanInfluenceUnitValue, 4, true);
	  aiPlanSetNumberVariableValues(planID, cBuildPlanInfluenceUnitFalloff, 4, true);

	  /*aiPlanSetVariableInt(planID, cBuildPlanInfluenceUnitTypeID, 0, cUnitTypeTownCenter);
	  aiPlanSetVariableFloat(planID, cBuildPlanInfluenceUnitDistance, 0, 40.0);              // 40 meter inhibition around TCs.
	  aiPlanSetVariableFloat(planID, cBuildPlanInfluenceUnitValue, 0, -100.0);                // -500 points each
	  aiPlanSetVariableInt(planID, cBuildPlanInfluenceUnitFalloff, 0, cBPIFalloffLinear);      // Cliff falloff*/
	  
	  aiPlanSetVariableInt(planID, cBuildPlanInfluenceUnitTypeID, 0, cUnitTypeAbstractShrine);
	  aiPlanSetVariableFloat(planID, cBuildPlanInfluenceUnitDistance, 0, 8.0);              // 40 meter inhibition around TCs.
	  aiPlanSetVariableFloat(planID, cBuildPlanInfluenceUnitValue, 0, -5000.0);                // -500 points each
	  aiPlanSetVariableInt(planID, cBuildPlanInfluenceUnitFalloff, 0, cBPIFalloffNone);
	  
	  aiPlanSetVariableInt(planID, cBuildPlanInfluenceUnitTypeID, 1, cUnitTypeHuntable);
	  aiPlanSetVariableFloat(planID, cBuildPlanInfluenceUnitDistance, 1, 6.0);              // 40 meter inhibition around TCs.
	  aiPlanSetVariableFloat(planID, cBuildPlanInfluenceUnitValue, 1, 400.0);                // -500 points each
	  aiPlanSetVariableInt(planID, cBuildPlanInfluenceUnitFalloff, 1, cBPIFalloffLinear);      // Cliff falloff
	  
	  /*aiPlanSetVariableInt(planID, cBuildPlanInfluenceUnitTypeID, 2, cUnitTypeAbstractJapaneseMonk);
	  aiPlanSetVariableFloat(planID, cBuildPlanInfluenceUnitDistance, 2, 50.0);              // 40 meter inhibition around TCs.
	  aiPlanSetVariableFloat(planID, cBuildPlanInfluenceUnitValue, 2, 50.0);                // -500 points each
	  aiPlanSetVariableInt(planID, cBuildPlanInfluenceUnitFalloff, 2, cBPIFalloffNone);*/
	  
	  /*aiPlanSetVariableInt(planID, cBuildPlanInfluenceUnitTypeID, 3, cUnitTypeypBerryBuilding);
	  aiPlanSetVariableFloat(planID, cBuildPlanInfluenceUnitDistance, 3, 200.0);              // 40 meter inhibition around TCs.
	  aiPlanSetVariableFloat(planID, cBuildPlanInfluenceUnitValue, 3, 50.0);                // -500 points each
	  aiPlanSetVariableInt(planID, cBuildPlanInfluenceUnitFalloff, 3, cBPIFalloffNone);*/
   }
   else
   {
      selectClosestBuildPlanPosition(planID, baseID);
   }
}

rule forwardShrineManager
inactive
minInterval 3
{
   static int monkQuery = -1;
   static int huntQuery = -1;
   static int shrineQuery = -1;
   static int tcQuery = -1;
   static int shrinePlanID = -1;
   int planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeypShrineJapanese);

   if (gLandExplorePlan < 0 || kbCanAffordUnit(cUnitTypeypShrineJapanese, cEconomyEscrowID) == false || planID >= 0)
   {
      if (gExplorerControlPlan >= 0)
      {
         if (aiPlanGetState(shrinePlanID) >= 0)
            aiPlanDestroy(shrinePlanID);
         xsDisableSelf();
      }
      return;
   }

   if (monkQuery < 0)
   {
      monkQuery = kbUnitQueryCreate("Monk query for shrine placement");
      kbUnitQuerySetPlayerID(monkQuery, cMyID);
      kbUnitQuerySetUnitType(monkQuery, cUnitTypeAbstractJapaneseMonk);
      kbUnitQuerySetIgnoreKnockedOutUnits(monkQuery, true);

      huntQuery = kbUnitQueryCreate("Huntable query for shrine placement");
      kbUnitQuerySetPlayerID(huntQuery, 0);
      kbUnitQuerySetUnitType(huntQuery, cUnitTypeHuntable);
      kbUnitQuerySetMaximumDistance(huntQuery, 30.0);

      shrineQuery = kbUnitQueryCreate("Shrine query for shrine placement");
      kbUnitQuerySetPlayerID(shrineQuery, -1);
      kbUnitQuerySetPlayerRelation(shrineQuery, cPlayerRelationAny);
      kbUnitQuerySetUnitType(shrineQuery, cUnitTypeypShrineJapanese);
      kbUnitQuerySetMaximumDistance(shrineQuery, 30.0);

      tcQuery = kbUnitQueryCreate("TC query for shrine placement");
      kbUnitQuerySetPlayerID(tcQuery, -1);
      kbUnitQuerySetPlayerRelation(tcQuery, cPlayerRelationAny);
      kbUnitQuerySetUnitType(tcQuery, cUnitTypeTownCenter);
      kbUnitQuerySetMaximumDistance(tcQuery, 50.0);
   }

   kbUnitQueryResetResults(monkQuery);
   int numberMonks = kbUnitQueryExecute(monkQuery);
   int numberHunts = 0;
   int numberShrines = 0;
   vector position = cInvalidVector;
   int builderID = -1;

   if (numberMonks == 0)
      return;

   // search for huntables nearby monks
   for (i = 0; < numberMonks)
   {
      builderID = kbUnitQueryGetResult(monkQuery, i);
      if (aiPlanGetType(kbUnitGetPlanID(builderID)) != cPlanExplore)
         continue;
      kbUnitQuerySetPosition(huntQuery, kbUnitGetPosition(builderID));
      kbUnitQueryResetResults(huntQuery);
      numberHunts = kbUnitQueryExecute(huntQuery);
      if (numberHunts < 3)
         continue;
      position = kbUnitGetPosition(kbUnitQueryGetResult(huntQuery, aiRandInt(numberHunts)));
      kbUnitQuerySetPosition(shrineQuery, position);
      kbUnitQueryResetResults(shrineQuery);
      numberShrines = kbUnitQueryExecute(shrineQuery);
      if (numberHunts < (4 * (numberShrines + 1) - 1))
         continue;
      kbUnitQuerySetPosition(tcQuery, position);
      kbUnitQueryResetResults(tcQuery);
      if (kbUnitQueryExecute(tcQuery) > 0)
         continue;
      planID = aiPlanCreate("Forward Shrine Build Plan", cPlanBuild);
      if (planID < 0)
         continue;
      // What to build
      aiPlanSetVariableInt(planID, cBuildPlanBuildingTypeID, 0, cUnitTypeypShrineJapanese);

      aiPlanSetVariableVector(planID, cBuildPlanCenterPosition, 0, position);
      aiPlanSetVariableFloat(planID, cBuildPlanCenterPositionDistance, 0, 30.0);

      // 3 meter separation
      aiPlanSetVariableFloat(planID, cBuildPlanBuildingBufferSpace, 0, 3.0);

      // Priority.
      aiPlanSetDesiredPriority(planID, 90);
      aiPlanSetDesiredResourcePriority(planID, 90);

      // Mil vs. Econ.
      aiPlanSetMilitary(planID, false);
      aiPlanSetEconomy(planID, true);
      // Escrow.
      aiPlanSetEscrowID(planID, cEconomyEscrowID);
      // Builders.
      aiPlanAddUnitType(planID, cUnitTypeAbstractJapaneseMonk, numberMonks, numberMonks, numberMonks);
      for (j = 0; < numberMonks)
         aiPlanAddUnit(planID, kbUnitQueryGetResult(monkQuery, j));

      aiPlanSetVariableVector(planID, cBuildPlanInfluencePosition, 0, position);    // Influence toward position
      aiPlanSetVariableFloat(planID, cBuildPlanInfluencePositionDistance, 0, 50.0); // 50m range.
      aiPlanSetVariableFloat(planID, cBuildPlanInfluencePositionValue, 0, 200.0);   // 200 points max
      aiPlanSetVariableInt(planID, cBuildPlanInfluencePositionFalloff, 0, cBPIFalloffLinear); // Linear slope falloff

      aiPlanSetVariableInt(planID, cBuildPlanInfluenceUnitTypeID, 0, cUnitTypeypShrineJapanese);
      aiPlanSetVariableFloat(planID, cBuildPlanInfluenceUnitDistance, 0, 10.0);
      aiPlanSetVariableFloat(planID, cBuildPlanInfluenceUnitValue, 0, -20.0);
      aiPlanSetVariableInt(planID, cBuildPlanInfluenceUnitFalloff, 0, cBPIFalloffLinear);

      // Go.
      aiPlanSetActive(planID);
      aiEcho("    Building a forward shrine at " + position);
      shrinePlanID = planID;
      break;
   }
}

//==============================================================================
// selectTorpBuildPlanPosition
//==============================================================================
void selectTorpBuildPlanPosition(int planID = -1, int baseID = -1)
{
   static int resourceQuery = -1;
   static int torpQuery = -1;

   if (resourceQuery < 0)
   {
      resourceQuery = kbUnitQueryCreate("Resource query for torp placement");
      kbUnitQuerySetPlayerID(resourceQuery, 0);
      kbUnitQuerySetPosition(resourceQuery, kbBaseGetLocation(cMyID, baseID));
      kbUnitQuerySetMaximumDistance(resourceQuery, 1200);
      kbUnitQuerySetAscendingSort(resourceQuery, true);

      torpQuery = kbUnitQueryCreate("Torp query for torp placement");
      kbUnitQuerySetPlayerRelation(torpQuery, cPlayerRelationAny);
      kbUnitQuerySetUnitType(torpQuery, cUnitTypedeTorp);
   }

   int numberFound = 0;
   int numberTorps = kbUnitQueryExecute(torpQuery);
   vector position = cInvalidVector;
   int numberPositionsToAvoid = xsArrayGetSize(gTorpPositionsToAvoid);
   bool goodPlaceFound = false;
   bool isMine = false;
   int unitID = -1;
   int amount = 0;
   int resourceType = cResourceGold;
   int torpID = -1;
   vector positionToAvoid = cInvalidVector;

   // Search for mines first.
   kbUnitQuerySetUnitType(resourceQuery, cUnitTypeAbstractMine);
   numberFound = kbUnitQueryExecute(resourceQuery);

   for (i = 0; < numberFound)
   {
      unitID = kbUnitQueryGetResult(resourceQuery, i);
      position = kbUnitGetPosition(unitID);
      for (j = 0; < numberPositionsToAvoid - 1)
      {
         positionToAvoid = xsArrayGetVector(gTorpPositionsToAvoid, numberPositionsToAvoid - j - 1);
         if (position == positionToAvoid)
         {
            position = cInvalidVector;
            break;
         }
      }
      if (position == cInvalidVector)
         continue;
      amount = kbUnitGetResourceAmount(unitID, cResourceGold);
      for (j = 0; < numberTorps)
      {
         torpID = kbUnitQueryGetResult(torpQuery, j);
         if (distance(kbUnitGetPosition(torpID), position) >= 24.0)
            continue;
         amount = amount - 500;
      }
      if (amount < 500)
         continue;
      aiEcho("Found good location to build torp at " + position + " ,resource " + resourceType);
      goodPlaceFound = true;
      isMine = true;
      break;
   }

   if (goodPlaceFound == false)
   {
      kbUnitQuerySetUnitType(resourceQuery, cUnitTypeResource);
      numberFound = kbUnitQueryExecute(resourceQuery);

      for (i = 0; < numberFound)
      {
         unitID = kbUnitQueryGetResult(resourceQuery, i);
         // ignore movable resources
         if (kbUnitIsType(unitID, cUnitTypeUnit) == true && kbUnitGetCurrentHitpoints(unitID) > 0.0)
            continue;
         if (kbUnitIsType(unitID, cUnitTypeAbstractMine) == true)
            continue;
         resourceType = cResourceFood;
         if (kbUnitIsType(unitID, cUnitTypeTree) == true)
            resourceType = cResourceWood;
         position = kbUnitGetPosition(unitID);
         for (j = 0; < numberPositionsToAvoid - 1)
         {
            positionToAvoid = xsArrayGetVector(gTorpPositionsToAvoid, numberPositionsToAvoid - j - 1);
            if (position == positionToAvoid)
            {
               position = cInvalidVector;
               break;
            }
         }
         if (position == cInvalidVector)
            continue;
         amount = kbGetAmountValidResourcesByLocation(position, resourceType, cAIResourceSubTypeEasy, 6.0);
         for (j = 0; < numberTorps)
         {
            torpID = kbUnitQueryGetResult(torpQuery, j);
            if (distance(kbUnitGetPosition(torpID), position) >= 20.0)
               continue;
            amount = amount - 500;
         }
         if (amount < 500)
            continue;
         aiEcho("Found good location to build torp at " + position + " ,resource " + resourceType);
         goodPlaceFound = true;
         break;
      }
   }

   if (goodPlaceFound == true)
   {
      aiPlanSetVariableVector(planID, cBuildPlanCenterPosition, 0, position);
      if (isMine == true)
      {
         aiPlanSetVariableFloat(planID, cBuildPlanCenterPositionDistance, 0, 7.99);
         aiPlanSetVariableFloat(planID, cBuildPlanCenterPositionStep, 0, 0.25);
      }
      else
      {
         aiPlanSetVariableFloat(planID, cBuildPlanCenterPositionDistance, 0, 5.99);
      }
      aiPlanSetVariableVector(planID, cBuildPlanInfluencePosition, 0, position);     // Influence toward position
      aiPlanSetVariableFloat(planID, cBuildPlanInfluencePositionDistance, 0, 100.0); // 100m range.
      aiPlanSetVariableFloat(planID, cBuildPlanInfluencePositionValue, 0, 200.0);    // 200 points max
      aiPlanSetVariableInt(planID, cBuildPlanInfluencePositionFalloff, 0, cBPIFalloffLinear); // Linear slope falloff
      gTorpPosition = position;
   }
   else
   {
      selectClosestBuildPlanPosition(planID, baseID);
   }
}

//==============================================================================
// selectTradingLodgeBuildPlanPosition
//==============================================================================
void selectTradingLodgeBuildPlanPosition(int planID = -1, int baseID = -1)
{
   static int mineQuery = -1;

   if (mineQuery < 0)
   {
      mineQuery = kbUnitQueryCreate("Mine query for trading lodge placement");
      kbUnitQuerySetPlayerID(mineQuery, 0);
      kbUnitQuerySetUnitType(mineQuery, cUnitTypeAbstractMine);
      kbUnitQuerySetMaximumDistance(mineQuery, 200.0);
      kbUnitQuerySetAscendingSort(mineQuery, true);
   }
   kbUnitQuerySetPosition(mineQuery, kbBaseGetLocation(cMyID, baseID));
   kbUnitQueryResetResults(mineQuery);
   int mineCount = kbUnitQueryExecute(mineQuery);
   int mineID = -1;
   vector location = cInvalidVector;
   bool goodPlaceFound = false;

   aiEcho("**** Starting Trading lodge placement search, found " + mineCount + " mines.");
   for (i = 0; < mineCount)
   {
      mineID = kbUnitQueryGetResult(mineQuery, i);
      location = kbUnitGetPosition(mineID);
      // Where should I build?
      if (getUnitCountByLocation(cUnitTypedeFurTrade, cPlayerRelationAny, cUnitStateABQ, location, 15.0) > 0)
         continue;
      goodPlaceFound = true;
      break;
   }

   if (goodPlaceFound == true)
   {
      aiPlanSetVariableVector(planID, cBuildPlanCenterPosition, 0, location);
      aiPlanSetVariableFloat(planID, cBuildPlanCenterPositionDistance, 0, 30.0);
      aiPlanSetVariableVector(planID, cBuildPlanInfluencePosition, 0, location);     // Influence toward position
      aiPlanSetVariableFloat(planID, cBuildPlanInfluencePositionDistance, 0, 100.0); // 100m range.
      aiPlanSetVariableFloat(planID, cBuildPlanInfluencePositionValue, 0, 200.0);    // 200 points max
      aiPlanSetVariableInt(planID, cBuildPlanInfluencePositionFalloff, 0, cBPIFalloffLinear); // Linear slope falloff

      aiPlanSetVariableInt(planID, cBuildPlanInfluenceUnitTypeID, 0, cUnitTypedeFurTrade);
      aiPlanSetVariableFloat(planID, cBuildPlanInfluenceUnitDistance, 0, 10.0);
      aiPlanSetVariableFloat(planID, cBuildPlanInfluenceUnitValue, 0, -20.0);
      aiPlanSetVariableInt(planID, cBuildPlanInfluenceUnitFalloff, 0, cBPIFalloffLinear);
   }
   else
   {
      // Base ID.
      aiPlanSetBaseID(planID, baseID);
   }
}

//==============================================================================
// selectFieldBuildPlanPosition
//==============================================================================
bool selectFieldBuildPlanPosition(int planID = -1, int baseID = -1)
{
   static int granaryQuery = -1;

   if (granaryQuery < 0)
   {
      granaryQuery = kbUnitQueryCreate("Granary query for field placement");
      kbUnitQuerySetPlayerID(granaryQuery, cMyID);
      kbUnitQuerySetUnitType(granaryQuery, cUnitTypedeGranary);
      kbUnitQuerySetMaximumDistance(granaryQuery, 200.0);
      kbUnitQuerySetAscendingSort(granaryQuery, true);
   }
   kbUnitQuerySetPosition(granaryQuery, kbBaseGetLocation(cMyID, baseID));
   kbUnitQueryResetResults(granaryQuery);
   int granaryCount = kbUnitQueryExecute(granaryQuery);
   int granaryID = -1;
   vector location = cInvalidVector;
   bool goodPlaceFound = false;
   int size = xsArrayGetSize(gFullGranaries);
   aiEcho("**** Starting Field placement search, found " + granaryCount + " granaries.");
   for (i = 0; < granaryCount)
   {
      granaryID = kbUnitQueryGetResult(granaryQuery, i);
      location = kbUnitGetPosition(granaryID);
      // Where should I build?
      if (getUnitCountByLocation(cUnitTypedeField, cMyID, cUnitStateABQ, location, 10.0) >= 8)
         continue;
      bool full = false;
      for (j = 0; < size)
      {
         if (granaryID == xsArrayGetInt(gFullGranaries, j))
         {
            full = true;
            break;
         }
      }
      if (full == true)
         continue;
      goodPlaceFound = true;
      break;
   }

   if (goodPlaceFound == true)
   {
      aiPlanSetVariableVector(planID, cBuildPlanCenterPosition, 0, location);
      aiPlanSetVariableFloat(planID, cBuildPlanCenterPositionDistance, 0, 10.0);
      aiPlanSetVariableFloat(planID, cBuildPlanCenterPositionStep, 0, 0.25);

      aiPlanSetVariableVector(planID, cBuildPlanInfluencePosition, 0, location);     // Influence toward position
      aiPlanSetVariableFloat(planID, cBuildPlanInfluencePositionDistance, 0, 100.0); // 100m range.
      aiPlanSetVariableFloat(planID, cBuildPlanInfluencePositionValue, 0, 200.0);    // 200 points max
      aiPlanSetVariableInt(planID, cBuildPlanInfluencePositionFalloff, 0, cBPIFalloffLinear); // Linear slope falloff
      gFieldGranaryID = granaryID;
   }
   else
   {
      // Build another granary before building a field.
      planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypedeGranary);
      if (planID < 0)
      {
         planID = createSimpleBuildPlan(cUnitTypedeGranary, 1, 70, false, cEconomyEscrowID, kbBaseGetMainID(cMyID), 1);
         aiPlanSetDesiredResourcePriority(planID, 60);
      }
      return (false);
   }

   return (true);
}

//==============================================================================
// selectMountainMonasteryBuildPlanPosition
//==============================================================================
void selectMountainMonasteryBuildPlanPosition(int planID = -1, int baseID = -1)
{
   static int mineQuery = -1;
   float maxDistance = kbBaseGetMaximumResourceDistance(cMyID, baseID);

   if (mineQuery < 0)
   {
      mineQuery = kbUnitQueryCreate("Mine query for mountain monastery placement");
      kbUnitQuerySetPlayerID(mineQuery, 0);
      kbUnitQuerySetUnitType(mineQuery, cUnitTypeAbstractMine);
      kbUnitQuerySetMaximumDistance(mineQuery, maxDistance);
      kbUnitQuerySetAscendingSort(mineQuery, true);
   }
   kbUnitQuerySetPosition(mineQuery, kbBaseGetLocation(cMyID, baseID));
   kbUnitQueryResetResults(mineQuery);
   int mineCount = kbUnitQueryExecute(mineQuery);
   int mineID = -1;
   vector location = cInvalidVector;
   bool goodPlaceFound = false;

   aiEcho("**** Starting mountain monastery placement search, found " + mineCount + " mines.");
   for (i = 0; < mineCount)
   {
      mineID = kbUnitQueryGetResult(mineQuery, i);
      location = kbUnitGetPosition(mineID);
      // Where should I build?
      if (getUnitCountByLocation(cUnitTypedeMountainMonastery, cPlayerRelationAny, cUnitStateABQ, location, 5.0) > 0)
         continue;
      goodPlaceFound = true;
      break;
   }

   if (goodPlaceFound == true)
   {
      aiPlanSetVariableInt(planID, cBuildPlanSocketID, 0, mineID);
   }
   else
   {
      // Base ID.
      aiPlanSetBaseID(planID, baseID);
   }
}

//==============================================================================
// selectGranaryBuildPlanPosition
// Build the first Granary close to the starting Town Center and in the direction of the starting hunt.
// Build subsequent Granaries or if we can't find Hunt anymore just in the base.
//==============================================================================
void selectGranaryBuildPlanPosition(int planID = -1, int baseID = -1)
{
	// This is enough to place the Granary in the base if we already have a Granary or the Hunt check fails.
	aiPlanSetBaseID(planID, baseID);

   if (kbUnitCount(cMyID, cUnitTypedeGranary, cUnitStateABQ) < 1) // Only use this logic for the first Granary (or if we lose all).
   {
      vector townCenterLocation = kbGetPlayerStartingPosition(cMyID);
      int huntableUnitID = -1;
      vector huntLocation = cInvalidVector;
		vector placeGranaryHere = cInvalidVector;
		
		huntableUnitID = getClosestUnitByLocation(cUnitTypeHuntable, cCivNature, cUnitStateAlive, townCenterLocation, 50.0);
		if (huntableUnitID != -1) // If we find something within 50 range let's base our Granary position of that otherwise just randomly in our base again.
		{
			huntLocation = kbUnitGetPosition(huntableUnitID);
			placeGranaryHere = townCenterLocation + (xsVectorNormalize(huntLocation - townCenterLocation)) * 5.0;
			
			aiPlanSetVariableVector(planID, cBuildPlanCenterPosition, 0, placeGranaryHere);
			aiPlanSetVariableFloat(planID, cBuildPlanCenterPositionDistance, 0, 30.0);
			aiPlanSetVariableVector(planID, cBuildPlanInfluencePosition, 0, placeGranaryHere);     // Influence toward position
			aiPlanSetVariableFloat(planID, cBuildPlanInfluencePositionDistance, 0, 100.0); // 100m range.
			aiPlanSetVariableFloat(planID, cBuildPlanInfluencePositionValue, 0, 200.0);    // 200 points max
			aiPlanSetVariableInt(planID, cBuildPlanInfluencePositionFalloff, 0, cBPIFalloffLinear); // Linear slope falloff

			aiPlanSetVariableInt(planID, cBuildPlanInfluenceUnitTypeID, 0, cUnitTypedeGranary);
			aiPlanSetVariableFloat(planID, cBuildPlanInfluenceUnitDistance, 0, 30.0);
			aiPlanSetVariableFloat(planID, cBuildPlanInfluenceUnitValue, 0, -20.0);
			aiPlanSetVariableInt(planID, cBuildPlanInfluenceUnitFalloff, 0, cBPIFalloffLinear);
			aiEcho("**** Granary build plan created by looking at Hunt positions, loc: " + placeGranaryHere);
		}
		else
			aiEcho("**** Granary build plan created but couldn't find Hunt");
	}
	else
	{
		aiEcho("**** Granary build plan created for another Granary");
	}

	// If the Granary is meant for Hunt we want less spacing so it can be closer to the Hunt if it's a Granary for Fields we want more spacing to have room for the actual Fields.
	aiPlanSetVariableFloat(planID, cBuildPlanBuildingBufferSpace, 0, huntableUnitID >= 0 ? 5.0 : 15.0);
}

//==============================================================================
// selectClosestBuildPlanPosition
//
// Find the closest location to the unit to build.
//==============================================================================
void selectClosestBuildPlanPosition(int planID = -1, int baseID = -1)
{
   aiPlanSetVariableBool(planID, cBuildPlanInfluenceAtBuilderPosition, 0, true);
   aiPlanSetVariableFloat(planID, cBuildPlanInfluenceBuilderPositionValue, 0, 100.0);    // 100m range.
   aiPlanSetVariableFloat(planID, cBuildPlanInfluenceBuilderPositionDistance, 0, 200.0); // 200 points max
   aiPlanSetVariableInt(planID, cBuildPlanInfluenceBuilderPositionFalloff, 0,
                        cBPIFalloffLinear); // Linear slope falloff
   // Base ID.
   aiPlanSetBaseID(planID, baseID);
}

//==============================================================================
/* Shrine Tactic Monitor

   Every 60 seconds we evaluate which resources we want our shrines to generate.

*/
//==============================================================================
rule shrineTacticMonitor
inactive
minInterval 60
{
   if (cMyCiv != cCivJapanese)
   {
      xsDisableSelf();
      return;
   }

   int shrineQueryID = -1;
   shrineQueryID = kbUnitQueryCreate("shrineGetUnitQuery");
   kbUnitQuerySetIgnoreKnockedOutUnits(shrineQueryID, true);
   // Find a shrine to change tactic on.
   if (shrineQueryID != -1)
   {
      kbUnitQuerySetPlayerRelation(shrineQueryID, -1);
      kbUnitQuerySetPlayerID(shrineQueryID, cMyID);
      kbUnitQuerySetUnitType(shrineQueryID, cUnitTypeypShrineJapanese);
      kbUnitQuerySetState(shrineQueryID, cUnitStateAlive);

      kbUnitQueryResetResults(shrineQueryID);
      int numberFound = kbUnitQueryExecute(shrineQueryID);
      if (numberFound > 0)
      {
         int shrineTactic = -1;
         // Default to food before Age 3, coin afterwards.
         if (kbGetAge() < cAge3)
         {
            shrineTactic = cTacticShrineFood;
         }
         else
         {
            shrineTactic = cTacticShrineCoin;
         }
         float totalResources =
             kbResourceGet(cResourceFood) + kbResourceGet(cResourceWood) + kbResourceGet(cResourceGold);
         // Check for resource imbalances, except when we're short on everything.
         if ((totalResources >= 900.0) &&
             ((kbGetAge() > cAge1) || (kbResourceGet(cResourceFood) >= 800.0) || (agingUp() == true)))
         {
            if (kbResourceGet(cResourceFood) < (totalResources / 9.0))
            {
               shrineTactic = cTacticShrineFood;
            }
            if (kbResourceGet(cResourceGold) < (totalResources / 9.0))
            {
               shrineTactic = cTacticShrineCoin;
            }
            if (kbResourceGet(cResourceWood) < (totalResources / 9.0))
            {
               shrineTactic = cTacticShrineWood;
            }
         }
         aiUnitSetTactic(kbUnitQueryGetResult(shrineQueryID, 0), shrineTactic);
      }
   }
}

//==============================================================================
/* rule defenseReflex

   Monitor each VP site that we own, plus our main base.  Move and reconfigure
   the defense and reserve plans as needed.

   At rest, the defend plan has only one unit, is centered on the main base, and
   is used to send one unit after trivial invasions, typically a scouting unit.
   The reserve plan has a much larger MAX number, so it gets all the remaining units.
   It is centered on the military gather point with a conservative radius, to avoid
   engaging units far in front of the main base.

   When defending a base in a defense reflex, the defend plan gets a high MAX number
   so that it takes units from the reserve plan.  The low unit count in reserve
   acts as a signal to not launch new attacks, as troops aren't available.  The
   defend plan and reserve plan are relocated to the endangered base, with an aggressive
   engage radius.

   The search, active engage and passive engage radii are set by global
   control variables, cvDefenseReflexRadiusActive, cvDefenseReflexRadiusPassive, and
   cvDefenseReflexSearchRadius.

   Once in a defense reflex, the AI stays in it until that base is cleared, unless
   it's defending a non-main base, and the main base requires defense.  In that case,
   the defense reflex moves back to the main base.

   pauseDefenseReflex() can only be used when already in a defense reflex.  So valid
   state transitions are:

   none to defending       // start reflex with moveDefenseReflex(), sets all the base/location globals.
   defending to paused     // use pauseDefenseReflex(), takes no parms, uses vars set in prior moveDefenseReflex call.
   defending to end        // use endDefenseReflex(), clears global vars
   paused to end           // use endDefenseReflex(), clears global vars
   paused to defending     // use moveDefenseReflex(), set global vars again.

*/
//==============================================================================
//

rule defenseReflex
inactive
minInterval 10
group startup
{

   int armySize = aiPlanGetNumberUnits(gLandDefendPlan0, cUnitTypeLogicalTypeLandMilitary) +
                  aiPlanGetNumberUnits(gLandReservePlan, cUnitTypeLogicalTypeLandMilitary);
   int enemyArmySize = -1;
   static int lastHelpTime = -60000;
   static int lastHelpBaseID = -1;
   int i = 0;
   int unitID = -1;
   int protoUnitID = -1;
   bool panic = false; // Indicates need for call for help
   int planID = -1;
   int mainBaseID = kbBaseGetMainID(cMyID);

   static int enemyArmyQuery = -1;
   if (enemyArmyQuery < 0)
   { // Initialize the queryID
      enemyArmyQuery = kbUnitQueryCreate("Enemy army query");
      kbUnitQuerySetIgnoreKnockedOutUnits(enemyArmyQuery, true);
      kbUnitQuerySetPlayerRelation(enemyArmyQuery, cPlayerRelationEnemyNotGaia);
      kbUnitQuerySetUnitType(enemyArmyQuery, cUnitTypeLogicalTypeLandMilitary);
      kbUnitQuerySetState(enemyArmyQuery, cUnitStateAlive);
      kbUnitQuerySetSeeableOnly(enemyArmyQuery, true); // Ignore units we think are under fog
   }

   if ((gRevolutionType & cRevolutionFinland) == cRevolutionFinland)
   {
      int numberPlans = aiPlanGetActiveCount();
      for (i = 0; < numberPlans)
      {
         planID = aiPlanGetIDByActiveIndex(i);
         if (aiPlanGetType(planID) != cPlanGather)
            continue;
         armySize = armySize + aiPlanGetNumberUnits(planID, gEconUnit);
      }
   }

   // Check main base first
   kbUnitQuerySetPosition(enemyArmyQuery, kbBaseGetLocation(cMyID, mainBaseID));
   kbUnitQuerySetMaximumDistance(enemyArmyQuery, cvDefenseReflexSearchRadius);
   kbUnitQuerySetSeeableOnly(enemyArmyQuery, true);
   kbUnitQuerySetState(enemyArmyQuery, cUnitStateAlive);
   kbUnitQueryResetResults(enemyArmyQuery);
   enemyArmySize = kbUnitQueryExecute(enemyArmyQuery);
   // Bump up by 1 to just avoid running into this when the enemy explorer and its companion get in our base...
   if (enemyArmySize >= 3)
   { // Main base is under attack
      aiEcho("******** Main base (" + mainBaseID + ") under attack.");
      aiEcho("******** Enemy count " + enemyArmySize + ", my army count " + armySize);
      if (gDefenseReflexBaseID == mainBaseID)
      { // We're already in a defense reflex for the main base
         if (((armySize * 3.0) < enemyArmySize) &&
             (enemyArmySize > 6.0)) // Army at least 3x my size and more than 6 units total.
         {                          // Too big to handle
            if ((gDefenseReflexPaused == false) && (kbUnitCount(cMyID, cUnitTypeMinuteman, cUnitStateAlive) < 1) &&
                (kbUnitCount(cMyID, cUnitTypeypIrregular, cUnitStateAlive) < 1) &&
                (kbUnitCount(cMyID, cUnitTypeypPeasant, cUnitStateAlive) < 1) &&
                (kbUnitCount(cMyID, cUnitTypexpWarrior, cUnitStateAlive) < 2))
            { // We weren't paused and don't have emergency soldiers with decaying health, do it
               pauseDefenseReflex();
            }
            // Consider a call for help
            panic = true;
            if (((xsGetTime() - lastHelpTime) < 300000) &&
                (lastHelpBaseID ==
                 gDefenseReflexBaseID)) // We called for help in the last five minutes, and it was this base
               panic = false;
            if (((xsGetTime() - lastHelpTime) < 60000) &&
                (lastHelpBaseID != gDefenseReflexBaseID)) // We called for help anywhere in the last minute
               panic = false;

            if (panic == true)
            {
               sendStatement(cPlayerRelationAlly, cAICommPromptToAllyINeedHelpMyBase,
                             kbBaseGetLocation(cMyID, gDefenseReflexBaseID));
               aiEcho("     I'm calling for help.");
               lastHelpTime = xsGetTime();
            }

            // Call back our attack if any.
            planID = aiPlanGetIDByTypeAndVariableType(cPlanAttack, cAttackPlanBaseAttackMode,
                                                      cAttackPlanBaseAttackModeExplicit);
            if (planID >= 0)
               aiPlanDestroy(planID);
         }
         else
         {                                    // Size is OK to handle, shouldn't be in paused mode.
            if (gDefenseReflexPaused == true) // Need to turn it active
            {
               moveDefenseReflex(kbBaseGetLocation(cMyID, mainBaseID), cvDefenseReflexRadiusActive,
                                 mainBaseID);
            }
         }
      }
      else // Defense reflex wasn't set to main base.
      {    // Need to set the defense reflex to home base...doesn't matter if it was inactive or guarding another base,
           // home base trumps all.
         moveDefenseReflex(kbBaseGetLocation(cMyID, mainBaseID), cvDefenseReflexRadiusActive,
                           mainBaseID);
         // This is a new defense reflex in the main base.  Consider making a chat about it.
         int enemyPlayerID = kbUnitGetPlayerID(kbUnitQueryGetResult(enemyArmyQuery, 0));
         if ((enemyPlayerID > 0) && (kbGetAge() > cAge1))
         { // Consider sending a chat as long as we're out of age 1.
            int enemyPlayerUnitCount =
                getUnitCountByLocation(cUnitTypeLogicalTypeLandMilitary, enemyPlayerID, cUnitStateAlive,
                                       kbBaseGetLocation(cMyID, gDefenseReflexBaseID), 50.0);
            if ((enemyPlayerUnitCount > (2 * gGoodArmyPop)) && (enemyPlayerUnitCount > (3 * armySize)))
            { // Enemy army is big, and we're badly outnumbered
               sendStatement(enemyPlayerID, cAICommPromptToEnemyISpotHisArmyMyBaseOverrun,
                             kbBaseGetLocation(cMyID, gDefenseReflexBaseID));
               aiEcho("Sending OVERRUN prompt to player " + enemyPlayerID + ", he has " + enemyPlayerUnitCount +
                      " units.");
               aiEcho("I have " + armySize + " units, and " + gGoodArmyPop + " is a good army size.");
               return;
            }
            if (enemyPlayerUnitCount > (2 * gGoodArmyPop))
            { // Big army, but I'm still in the fight
               sendStatement(enemyPlayerID, cAICommPromptToEnemyISpotHisArmyMyBaseLarge,
                             kbBaseGetLocation(cMyID, gDefenseReflexBaseID));
               aiEcho("Sending LARGE ARMY prompt to player " + enemyPlayerID + ", he has " + enemyPlayerUnitCount +
                      " units.");
               aiEcho("I have " + armySize + " units, and " + gGoodArmyPop + " is a good army size.");
               return;
            }
            if (enemyPlayerUnitCount > gGoodArmyPop)
            {
               // Moderate size
               sendStatement(enemyPlayerID, cAICommPromptToEnemyISpotHisArmyMyBaseMedium,
                             kbBaseGetLocation(cMyID, gDefenseReflexBaseID));
               aiEcho("Sending MEDIUM ARMY prompt to player " + enemyPlayerID + ", he has " + enemyPlayerUnitCount +
                      " units.");
               aiEcho("I have " + armySize + " units, and " + gGoodArmyPop + " is a good army size.");
               return;
            }
            if ((enemyPlayerUnitCount < gGoodArmyPop) && (enemyPlayerUnitCount < armySize))
            { // Small, and under control
               sendStatement(enemyPlayerID, cAICommPromptToEnemyISpotHisArmyMyBaseSmall,
                             kbBaseGetLocation(cMyID, gDefenseReflexBaseID));
               aiEcho("Sending SMALL ARMY prompt to player " + enemyPlayerID + ", he has " + enemyPlayerUnitCount +
                      " units.");
               aiEcho("I have " + armySize + " units, and " + gGoodArmyPop + " is a good army size.");
               return;
            }
         }
      }
      return; // Do not check other bases
   }

   // If we're this far, the main base is OK.  If we're in a defense reflex, see if we should stay in it, or change from
   // passive to active.

   if (gDefenseReflex == true) // Currently in a defense mode, let's see if it should remain
   {
      kbUnitQuerySetPosition(enemyArmyQuery, gDefenseReflexLocation);
      kbUnitQuerySetMaximumDistance(enemyArmyQuery, cvDefenseReflexSearchRadius);
      kbUnitQuerySetSeeableOnly(enemyArmyQuery, true);
      kbUnitQuerySetState(enemyArmyQuery, cUnitStateAlive);
      kbUnitQueryResetResults(enemyArmyQuery);
      enemyArmySize = kbUnitQueryExecute(enemyArmyQuery);
      aiEcho("******** Defense reflex in base " + gDefenseReflexBaseID + " at " + gDefenseReflexLocation);
      aiEcho("******** Enemy unit count: " + enemyArmySize + ", my unit count (defend+reserve) = " + armySize);
      for (i = 0; < enemyArmySize)
      {
         unitID = kbUnitQueryGetResult(enemyArmyQuery, i);
         protoUnitID = kbUnitGetProtoUnitID(unitID);
         if (i < 2)
            aiEcho("    " + unitID + " " + kbGetProtoUnitName(protoUnitID) + " " + kbUnitGetPosition(unitID));
      }

      if (enemyArmySize < 2)
      { // Abort, no enemies, or just one scouting unit
         if (xsGetTime() >= gDefenseReflexTimeout || armySize >= gGoodArmyPop ||
             (gRevolutionType & cRevolutionFinland) == cRevolutionFinland)
         { // Wait for a random period before moving to the forward base.
            aiEcho("******** Ending defense reflex, no enemies remain.");
            endDefenseReflex();
         }
         return;
      }

      if (baseBuildingCount(gDefenseReflexBaseID, cPlayerRelationAlly, cUnitStateAlive) <= 0)
      { // Abort, no alive ally buildings
         aiEcho("******** Ending defense reflex, base " + gDefenseReflexBaseID + " has no buildings.");
         endDefenseReflex();
         return;
      }

      if (kbBaseGetOwner(gDefenseReflexBaseID) <= 0)
      { // Abort, base doesn't exist
         aiEcho("******** Ending defense reflex, base " + gDefenseReflexBaseID + " doesn't exist.");
         endDefenseReflex();
         return;
      }

      // The defense reflex for this base should remain in effect.
      // Check whether to start/end paused mode.
      int unitsNeeded = gGoodArmyPop;        // At least a credible army to fight them
      if (unitsNeeded > (enemyArmySize / 2)) // Or half their force, whichever is less.
         unitsNeeded = enemyArmySize / 2;
      bool shouldPause = false;
      if (((armySize < unitsNeeded) && ((armySize * 3.0) < enemyArmySize)) &&
          (kbUnitCount(cMyID, cUnitTypeMinuteman, cUnitStateAlive) < 1) &&
          (kbUnitCount(cMyID, cUnitTypeypIrregular, cUnitStateAlive) < 1) &&
          (kbUnitCount(cMyID, cUnitTypeypPeasant, cUnitStateAlive) < 1) &&
          (kbUnitCount(cMyID, cUnitTypexpWarrior, cUnitStateAlive) < 2))
         shouldPause = true; // We should pause if not paused, or stay paused if we are

      if (gDefenseReflexPaused == false)
      { // Not currently paused, do it
         if (shouldPause == true)
         {
            pauseDefenseReflex();
            aiEcho("******** Enemy count " + enemyArmySize + ", my army count " + armySize);
         }
      }
      else
      { // Currently paused...should we remain paused, or go active?
         if (shouldPause == false)
         {
            moveDefenseReflex(gDefenseReflexLocation, cvDefenseReflexRadiusActive, gDefenseReflexBaseID); // Activate it
            aiEcho("******** Enemy count " + enemyArmySize + ", my army count " + armySize);
         }
      }
      if (shouldPause == true)
      { // Consider a call for help
         panic = true;
         if (((xsGetTime() - lastHelpTime) < 300000) &&
             (lastHelpBaseID ==
              gDefenseReflexBaseID)) // We called for help in the last five minutes, and it was this base
            panic = false;
         if (((xsGetTime() - lastHelpTime) < 60000) &&
             (lastHelpBaseID != gDefenseReflexBaseID)) // We called for help anywhere in the last minute
            panic = false;

         if (panic == true)
         {
            sendStatement(cPlayerRelationAlly, cAICommPromptToAllyINeedHelpMyBase,
                          kbBaseGetLocation(cMyID, gDefenseReflexBaseID));
            aiEcho("     I'm calling for help.");
            lastHelpTime = xsGetTime();
         }

         // Call back our attack if any.
         // TODO: Not main base, maybe not always worth defending?
         planID = aiPlanGetIDByTypeAndVariableType(cPlanAttack, cAttackPlanBaseAttackMode,
                                                   cAttackPlanBaseAttackModeExplicit);
         if (planID >= 0)
            aiPlanDestroy(planID);
      }
      return; // Done...we're staying in defense mode for this base, and have paused or gone active as needed.
   }

   // Not in a defense reflex, see if one is needed

   // Check other bases
   int baseCount = -1;
   int baseIndex = -1;
   int baseID = -1;
   vector baseLoc = cInvalidVector;
   int defendBaseID = aiPlanGetVariableInt(gLandDefendPlan0, cDefendPlanDefendBaseID, 0);

   if (defendBaseID < 0)
      defendBaseID = aiPlanGetVariableInt(gLandReservePlan, cDefendPlanDefendBaseID, 0);

   vector defendLoc = kbBaseGetLocation(cMyID, defendBaseID);
   int defendAreaGroup = kbAreaGroupGetIDByPosition(defendLoc);
   int baseAreaGroup = -1;

   baseCount = kbBaseGetNumber(cMyID);
   unitsNeeded = gGoodArmyPop / 2;
   if (baseCount > 0)
   {
      for (baseIndex = 0; < baseCount)
      {
         baseID = kbBaseGetIDByIndex(cMyID, baseIndex);
         if (baseID == kbBaseGetMainID(cMyID))
            continue; // Already checked main at top of function

         if (baseBuildingCount(baseID, cPlayerRelationAlly, cUnitStateAlive) <= 0)
         {
            aiEcho("Base " + baseID + " has no alive buildings.");
            continue; // Skip bases that have no buildings
         }

         // Check for overrun base
         baseLoc = kbBaseGetLocation(cMyID, baseID);         
         kbUnitQuerySetPosition(enemyArmyQuery, baseLoc);
         kbUnitQuerySetMaximumDistance(enemyArmyQuery, cvDefenseReflexSearchRadius);
         kbUnitQuerySetSeeableOnly(enemyArmyQuery, true);
         kbUnitQuerySetState(enemyArmyQuery, cUnitStateAlive);
         kbUnitQueryResetResults(enemyArmyQuery);
         enemyArmySize = kbUnitQueryExecute(enemyArmyQuery);
         // Do I need to call for help?

         if ((enemyArmySize >= 2))
         { // More than just a scout...set defense reflex for this base
            moveDefenseReflex(baseLoc, cvDefenseReflexRadiusActive, baseID);

            aiEcho("******** Enemy count is " + enemyArmySize + ", my army size is " + armySize);

            if ((enemyArmySize > (armySize * 2.0)) && (enemyArmySize > 6)) // Double my size, get help...
            {
               panic = true;
               if (((xsGetTime() - lastHelpTime) < 300000) &&
                   (lastHelpBaseID == baseID)) // We called for help in the last five minutes, and it was this base
                  panic = false;
               if (((xsGetTime() - lastHelpTime) < 60000) &&
                   (lastHelpBaseID != baseID)) // We called for help anywhere in the last minute
                  panic = false;

               if (panic == true)
               {
                  // Don't kill other missions, this isn't the main base.  Just call for help.
                  sendStatement(cPlayerRelationAlly, cAICommPromptToAllyINeedHelpMyBase,
                                kbBaseGetLocation(cMyID, baseID));
                  aiEcho("     I'm calling for help.");
                  lastHelpTime = xsGetTime();
               }
            }
            else
            {
               // Too far away? create an attack plan instead.
               if (distance(defendLoc, baseLoc) >= kbBaseGetDistance(cMyID, defendBaseID) + 50.0)
               {
                  // TODO: temporary workaround for defend plans not aware of enemy units when moving units from a location to another.
                  if (aiPlanGetNumber(cPlanAttack, -1, true) > 0)
                  {
                     // We already have active attack plans, abort.
                     return;
                  }

                  planID = aiPlanCreate("Attack Location " + baseLoc, cPlanAttack);

                  aiPlanSetVariableInt(planID, cAttackPlanPlayerID, 0, kbUnitGetPlayerID(kbUnitQueryGetResult(enemyArmyQuery, 0)));
                  aiPlanSetVariableInt(planID, cAttackPlanRefreshFrequency, 0, 30);
                  aiPlanSetNumberVariableValues(planID, cAttackPlanTargetTypeID, 2, true);
                  aiPlanSetVariableInt(planID, cAttackPlanTargetTypeID, 0, cUnitTypeUnit);
                  aiPlanSetVariableInt(planID, cAttackPlanTargetTypeID, 1, cUnitTypeBuilding);
                  aiPlanSetVariableVector(planID, cAttackPlanGatherPoint, 0, defendLoc);
                  aiPlanSetVariableVector(planID, cAttackPlanAttackPoint, 0, baseLoc);
                  aiPlanSetVariableFloat(planID, cAttackPlanAttackPointEngageRange, 0, kbBaseGetDistance(cMyID, baseID));
                  aiPlanSetVariableFloat(planID, cAttackPlanGatherDistance, 0, 40.0);

                  baseAreaGroup = kbAreaGroupGetIDByPosition(baseLoc);
                  if (defendAreaGroup == baseAreaGroup)
                  {
                     aiPlanSetVariableInt(planID, cAttackPlanAttackRoutePattern, 0, cAttackPlanAttackRoutePatternBest);
                     aiPlanSetVariableInt(planID, cAttackPlanRetreatMode, 0, cAttackPlanRetreatModeOutnumbered);
                  }
                  else
                  {
                     aiPlanSetVariableInt(planID, cAttackPlanAttackRoutePattern, 0, cAttackPlanAttackRoutePatternRandom);
                     aiPlanSetNumberVariableValues(planID, cAttackPlanTargetAreaGroups, 2, true);
                     aiPlanSetVariableInt(planID, cAttackPlanTargetAreaGroups, 0, defendAreaGroup);
                     aiPlanSetVariableInt(planID, cAttackPlanTargetAreaGroups, 0, baseAreaGroup);
                     aiPlanSetVariableInt(planID, cAttackPlanRetreatMode, 0, cAttackPlanRetreatModeNone);
                  }
                  //if (aiGetWorldDifficulty() >= gDifficultyExpert)
                     aiPlanSetVariableBool(planID, cAttackPlanAllowMoreUnitsDuringAttack, 0, true);
                  aiPlanSetBaseID(planID, defendBaseID);
                  aiPlanSetInitialPosition(planID, defendLoc);
                  aiPlanSetOrphan(planID, true);

                  addUnitsToMilitaryPlan(planID);

                  aiPlanSetActive(planID);
                  aiEcho("***** LAUNCHING ATTACK on location "+baseLoc);
                  return;
               }

               moveDefenseReflex(baseLoc, cvDefenseReflexRadiusActive, baseID);            
            }
            return; // If we're in trouble in any base, ignore the others.
         }
      } // For baseIndex...
   }
}

//==============================================================================
/*
   selectCaptain

   Updates the global gIAmCaptain bool.  Also sets the gCaptainPlayerNumber int.
   Algorithm is brain-dead simple.
   I am captain if I am the lowest-numbered AI player on a team with no
   human players.  Otherwise, I am not captain.

*/
//==============================================================================
rule selectCaptain
inactive
minInterval 30
{
   int player = -1;
   bool amCaptain = false;     // Unless proven otherwise
   bool humanTeammate = false; // Set true if/when a human teammate is found
   int captainsNumber = -1;    // Set when we find a captain

   for (player = 1; < cNumberPlayers)
   {
      if (kbHasPlayerLost(player) == false)
      {
         if (kbIsPlayerAlly(player) == true)
         {
            // if this player is human, that's the captainsNumber
            if ((kbIsPlayerHuman(player) == true) && (kbHasPlayerLost(player) == false) && (humanTeammate == false))
            {
               amCaptain = false; // AI player is definitely not human
               captainsNumber = player;
               humanTeammate = true;
            }
            else
            { // This is an AI player or a human player other than the first.  If it's not me and has a lower number and
              // there's no human yet, he's captain.
               if ((kbIsPlayerHuman(player) == false) && (kbHasPlayerLost(player) == false) && (humanTeammate == false))
               {
                  if ((player <= cMyID) && (captainsNumber < 0)) // He's <= me and there's no captain yet
                  {
                     captainsNumber = player;
                     if (player == cMyID)
                        amCaptain = true; // I'm the captain...unless human player is found later.
                  }
               }
            }
         }
      }
   } // End for(player) loop.
   if ((captainsNumber != gCaptainPlayerNumber) || (gIAmCaptain != amCaptain))
   { // Something changed
      aiEcho("***  Old captain was " + gCaptainPlayerNumber + ", new captain is " + captainsNumber);
      gCaptainPlayerNumber = captainsNumber;
      gIAmCaptain = amCaptain;
   }
}

int getMapID(void)
{
   int mapIndex = 0;
   for (mapIndex = 0; < xsArrayGetSize(gMapNames))
   {
      if (xsArrayGetString(gMapNames, mapIndex) == cRandomMapName)
      {
         return (mapIndex);
      }
   }
   return (-1);
}

//==============================================================================
/* initPersonality()

   A function to set defaults that need to be in place before the loader file's
   preInit() function is called.
*/
//==============================================================================
void initPersonality(void)
{

   int civ = cMyCiv;
   if (civ == cCivTheCircle)
      civ = cCivBritish;
   if (civ == cCivPirate)
      civ = cCivBritish;
   if (civ == cCivSPCAct3)
      civ = cCivBritish;
   // Set behavior traits
   aiEcho("My civ is " + civ);
   switch (civ)
   {
   case cCivBritish:    // Elizabeth:  Infantry oriented rusher, ignore trade routes.
	{
		btRushBoom = 0.9; //0.0; // was -1.0
      if (aiRandInt(10) < 5)
         btRushBoom = 0.9; //0.5;
		btOffenseDefense = 0.0; //0.5;
		btBiasCav = 0.0;
		btBiasInf = 0.2;
		btBiasArt = 0.0;
		btBiasNative = .2; //0.8;
		btBiasTrade = 0.9; //-0.5;
		break;
	}
	case cCivFrench:     // Napoleon:  Cav oriented, balanced
	{
		btRushBoom = 0.9; //0.0;
      if (aiRandInt(10) < 3)
         btRushBoom = 0.9; //0.5;      
		btOffenseDefense = 0.0; //0.0;
		btBiasCav = 0.2;
		btBiasInf = 0.0;
		btBiasArt = 0.0;
		btBiasNative = .2; //0.8;
		btBiasTrade = 0.9; //0.0;
		break;
	}
	case cCivSpanish:    // Isabella: Fast Fortress
	{
		btRushBoom = 0.9; //0.0;
      if (aiRandInt(10) < 1)
         btRushBoom = 0.9; //0.5;      
		btOffenseDefense = 0.0; //1.0;
		btBiasCav = 0.0;
		btBiasInf = 0.0;
		btBiasArt = 0.0;
		btBiasNative = .2; //-0.9;
		btBiasTrade = 0.9; //0.0;
		break;
	}
	case cCivRussians:   // Ivan:  Infantry oriented rusher
	{
		btRushBoom = 0.9; //0.0;
      if (aiRandInt(10) < 9)
         btRushBoom = 0.9; //0.5;      
		btOffenseDefense = 0.0; //0.5;
		btBiasCav = 0.0;
		btBiasInf = 0.2;
		btBiasArt = 0.0;
		btBiasNative = .2; //0.0;
		btBiasTrade = 0.9; //0.0;
		break;
	}
	case cCivGermans:    // Fast fortress, cavalry oriented
	{
		btRushBoom = 0.9; //0.0;
      if (aiRandInt(10) < 2)
         btRushBoom = 0.9; //0.5;      
		btOffenseDefense = 0.0; //0.0;
		btBiasCav = 0.0;
		btBiasInf = 0.2;
		btBiasArt = 0.0;
		btBiasNative = .2; //-0.5;
		btBiasTrade = 0.9; //0.0;
		break;
	}
	case cCivDutch:      // Fast fortress, ignore trade routes.
	{
		btRushBoom = 0.9; //0.0;
      if (aiRandInt(10) < 3)
         btRushBoom = 0.9; //0.5;      
		btOffenseDefense = 0.0; //0.0;
		btBiasCav = 0.0;
		btBiasInf = 0.0;
		btBiasArt = 0.0;
		btBiasNative = .2; //0.0;
		btBiasTrade = 0.9; //-1.0;
		break;
	}
	case cCivPortuguese: // Fast fortress, artillery oriented
	{
		btRushBoom = 0.9; //0.0;
      if (aiRandInt(10) < 2)
         btRushBoom = 0.9; //0.5;      
		btOffenseDefense = 0.0; //0.0;
		btBiasCav = 0.0;
		btBiasInf = 0.0;
		btBiasArt = 0.1;
		btBiasNative = .2; //0.0;
		btBiasTrade = 0.9; //0.0;
		break;
	}
	case cCivOttomans:   // Artillery oriented, rusher
	{
		btRushBoom = 0.9; //0.0;
      if (aiRandInt(10) < 8)
         btRushBoom = 0.9; //0.5;      
		btOffenseDefense = 0.0; //0.5;
		btBiasCav = 0.0;
		btBiasInf = 0.0;
		btBiasArt = 0.1;
		btBiasNative = .2; //0.0;
		btBiasTrade = 0.9; //0.0;
		break;
	}
	case cCivXPSioux:   // Extreme rush
	{
		btRushBoom = 0.9; //0.8;
      if (aiRandInt(10) < 1)
         btRushBoom = 0.9; //0.0;      
		btOffenseDefense = 0.0; //0.5;
		btBiasCav = 0.2;
		btBiasInf = 0.0;
		btBiasArt = 0.0;
		btBiasNative = .2; //0.0;
		btBiasTrade = 0.9; //1.0;
		break;
	}
	case cCivXPIroquois:   // Fast fortress, trade and native bias.
	{
		btRushBoom = 0.9; //0.0;
      if (aiRandInt(10) < 4)
         btRushBoom = 0.9; //0.5;      
		btOffenseDefense = 0.0; //0.0;
		btBiasCav = 0.0;
		btBiasInf = 0.0;
		btBiasArt = 0.0;
		btBiasNative = .2; //0.8;
		btBiasTrade = 0.9; //1.0;
		break;
	}
	case cCivXPAztec:   // Rusher.
	{
		btRushBoom = 0.9; //0.0;
		btOffenseDefense = 0.0; //0.0; // was -1.0
		if (aiRandInt(10) < 8)
		{
			btRushBoom = 0.9; //0.5;
			btOffenseDefense = 0.0; //1.0;
		}
		btBiasCav = 0.0;
		btBiasInf = 0.0;
		btBiasArt = 0.0;
		btBiasNative = .2; //0.0;
      if (aiRandInt(10) < 3)
         btBiasNative = .2; //1.0;      
		btBiasTrade = 0.9; //1.0;
		break;
	}
	case cCivChinese:   // Kangxi:  Fast fortress, infantry oriented
	{
		btRushBoom = 0.9; //0.0;
      if (aiRandInt(10) < 4)
         btRushBoom = 0.9; //0.5;         
		btOffenseDefense = 0.0; //0.0;   
		btBiasCav = 0.0;
		btBiasInf = 0.2;
		btBiasArt = 0.0;
		btBiasNative = .2; //0.0;
		btBiasTrade = 0.9; //0.0;
		break;
	}
	case cCivJapanese:   // Shogun Tokugawa Ieyasu: Rusher, ignores trade routes
	{
		btRushBoom = 0.9; //0.5;
      if (aiRandInt(10) < 3)
         btRushBoom = 0.9; //0.0;          
		btOffenseDefense = 0.0; //0.0;  
		btBiasCav = 0.0;
		btBiasInf = 0.0;
		btBiasArt = 0.0;
		btBiasNative = .2; //0.0;
		btBiasTrade = 0.9; //-0.9;
		break;
	}
	case cCivIndians:    // Rusher, balanced
	{
		btRushBoom = 0.9; //0.5;
      if (aiRandInt(10) < 5)
         btRushBoom = 0.9; //0.0;          
		btOffenseDefense = 0.0; //0.0;
		btBiasCav = 0.0; // was 0.2
		btBiasInf = 0.0;
		btBiasArt = 0.0;
		btBiasNative = .2; //0.0;
		btBiasTrade = 0.9; //0.5;
		break;
	}
	case cCivDEInca:   // Huayna Capac: Rusher, trade and strong native bias.
	{
		btRushBoom = 0.9; //0.5;
		if (aiRandInt(2) > 0)
			btRushBoom = 0.9; //0.0;
		btOffenseDefense = 0.0; //0.0;
		btBiasCav = 0.0;
		btBiasInf = 0.0;
		btBiasArt = 0.0;
		btBiasNative = .2; //1.0;
		btBiasTrade = 0.9; //-0.5;
		break;
	}
	case cCivDESwedish:   // Gustav the Great: Rusher, small artillery focus.
	{
		btRushBoom = 0.9; //0.7;
      if (aiRandInt(10) < 3)
         btRushBoom = 0.9; //0.0;          
		btOffenseDefense = 0.0; //0.6;
		btBiasCav = 0.0;
		btBiasInf = 0.0;
		btBiasArt = 0.1;
		btBiasNative = .2; //0.0;
		btBiasTrade = 0.9; //-0.5;
	}
	case cCivDEAmericans:   // George Washington: Balanced.
	{
		btRushBoom = 0.9; //0.7;    
		btOffenseDefense = 0.0; //0.6;
		btBiasCav = 0.0;
		btBiasInf = 0.0;
		btBiasArt = 0.1;
		btBiasNative = .2; //0.0;
		btBiasTrade = 0.9; //-0.5;
	}	
   case cCivDEEthiopians: // Emperor Tewodros: Balanced.
   {
        btRushBoom = 0.9; //0.7;    
		btOffenseDefense = 0.0; //0.6;
		btBiasCav = 0.0;
		btBiasInf = 0.0;
		btBiasArt = 0.0;
		btBiasNative = .5; //0.0;
		btBiasTrade = 0.9; //-0.5;
      break;
   }
   case cCivDEHausa: // Queen Amina: Balanced.
   {
        btRushBoom = 0.9; //0.7;    
		btOffenseDefense = 0.0; //0.6;
		btBiasCav = 0.0;
		btBiasInf = 0.0;
		btBiasArt = 0.0;
		btBiasNative = .5; //0.0;
		btBiasTrade = 0.9; //-0.5;
      break;
   }
   }

   if (gSPC == false)
   { // Occasionally adjust AI preferences for more replayability without going overboard.
      int strategyRandomizer = aiRandInt(20);
      /*if (strategyRandomizer == 0)
        btRushBoom = btRushBoom - 0.5;
     else if (strategyRandomizer == 1)
        btRushBoom = btRushBoom - 0.4;
     else if (strategyRandomizer == 2)
        btRushBoom = btRushBoom - 0.3;
     else if (strategyRandomizer == 3)
        btRushBoom = btRushBoom - 0.2;
     else if (strategyRandomizer == 4)
        btRushBoom = btRushBoom - 0.1;
     else if (strategyRandomizer == 5)
        btRushBoom = btRushBoom + 0.1;
     else if (strategyRandomizer == 6)
        btRushBoom = btRushBoom + 0.2;
     else if (strategyRandomizer == 7)
        btRushBoom = btRushBoom + 0.3;
     else if (strategyRandomizer == 8)
        btRushBoom = btRushBoom + 0.4;
     else if (strategyRandomizer == 9)
        btRushBoom = btRushBoom + 0.5;

     if (strategyRandomizer <= 2)
        btOffenseDefense = btOffenseDefense - 0.2;
     else if (strategyRandomizer <= 4)
        btOffenseDefense = btOffenseDefense - 0.1;
     else if (strategyRandomizer <= 6)
        btOffenseDefense = btOffenseDefense + 0.1;
     else if (strategyRandomizer <= 9)
         btOffenseDefense = btOffenseDefense + 0.2;*/

      strategyRandomizer = aiRandInt(16);
      if (strategyRandomizer == 0)
         btBiasCav = btBiasCav + 0.2;
      else if (strategyRandomizer == 1)
         btBiasCav = btBiasCav + 0.1;
      else if (strategyRandomizer == 2)
         btBiasCav = btBiasCav - 0.1;
      else if (strategyRandomizer == 3)
         btBiasCav = btBiasCav - 0.2;
      else if (strategyRandomizer == 4)
         btBiasInf = btBiasInf + 0.2;
      else if (strategyRandomizer == 5)
         btBiasInf = btBiasInf + 0.1;
      else if (strategyRandomizer == 6)
         btBiasInf = btBiasInf - 0.1;
      else if (strategyRandomizer == 7)
         btBiasInf = btBiasInf - 0.2;

      /*strategyRandomizer = aiRandInt(12);
     if (strategyRandomizer == 0)
        btBiasNative = btBiasNative + 0.3;
     else if (strategyRandomizer == 1)
        btBiasNative = btBiasNative + 0.2;
     else if (strategyRandomizer == 2)
        btBiasNative = btBiasNative + 0.1;
     else if (strategyRandomizer == 3)
        btBiasNative = btBiasNative - 0.1;
     else if (strategyRandomizer == 4)
        btBiasNative = btBiasNative - 0.2;
     else if (strategyRandomizer == 5)
        btBiasNative = btBiasNative - 0.3;

      strategyRandomizer = aiRandInt(12);
     if (strategyRandomizer == 0)
        btBiasTrade = btBiasTrade + 0.3;
     else if (strategyRandomizer == 1)
        btBiasTrade = btBiasTrade + 0.2;
     else if (strategyRandomizer == 2)
        btBiasTrade = btBiasTrade + 0.1;
     else if (strategyRandomizer == 3)
        btBiasTrade = btBiasTrade - 0.1;
     else if (strategyRandomizer == 4)
        btBiasTrade = btBiasTrade - 0.2;
     else if (strategyRandomizer == 5)
         btBiasTrade = btBiasTrade - 0.3;*/
   }

   if ((aiTreatyActive() == true || aiGetGameMode() == cGameModeDeathmatch) && (btRushBoom > 0.0))
      btRushBoom = 0.0; // Don't attempt to rush in treaty games.

   if (btRushBoom > 1.0)
      btRushBoom = 1.0;
   if (btRushBoom < -1.0)
      btRushBoom = -1.0;

   if (btBiasCav > 1.0)
      btBiasCav = 1.0;
   if (btBiasCav < -1.0)
      btBiasCav = -1.0;

   if (btBiasInf > 1.0)
      btBiasInf = 1.0;
   if (btBiasInf < -1.0)
      btBiasInf = -1.0;

   if (btBiasNative > 1.0)
      btBiasNative = 1.0;
   if (btBiasNative < -1.0)
      btBiasNative = -1.0;

   if (btBiasTrade > 1.0)
      btBiasTrade = 1.0;
   if (btBiasTrade < -1.0)
      btBiasTrade = -1.0;

   //-- See who we are playing against.  If we have played against these players before, seed out unitpicker data, and
   // then chat some. XS_HELP("float aiPersonalityGetGameResource(int playerHistoryIndex, int gameIndex, int
   // resourceID):
   // Returns the given resource from the gameIndex game. If gameIndex is -1, this will return the avg of all games
   // played.") XS_HELP("int aiPersonalityGetGameUnitCount(int playerHistoryIndex, int gameIndex, int unitType): Returns
   // the unit count from the gameIndex game. If gameIndex is -1, this will return the avg of all games played.")
   // TODO:  To understand my opponent's unit biases, I'll have to do the following:
   //          1)  Store the opponents civ each game
   //          2)  On game start, look up his civ from last game
   //          3)  Based on his civ, look up how many units he made of each class (inf, cav, art), compare to 'normal'.
   //          4)  Set unitPicker biases to counter what he's likely to send.

   int numPlayerHistories = aiPersonalityGetNumberPlayerHistories();
   aiEcho("PlayerHistories: " + numPlayerHistories);
   for (pid = 1; < cNumberPlayers)
   {
      //-- Skip ourself.
      if (pid == cMyID)
         continue;

      //-- get player name
      string playerName = kbGetPlayerName(pid);
      aiEcho("PlayerName: " + playerName);

      //-- have we played against them before.
      int playerHistoryID = aiPersonalityGetPlayerHistoryIndex(playerName);
      if (playerHistoryID == -1)
      {
         aiEcho("PlayerName: Never played against");
         //-- Lets make a new player history.
         playerHistoryID = aiPersonalityCreatePlayerHistory(playerName);
         if (kbIsPlayerAlly(pid) == true)
            sendStatement(pid, cAICommPromptToAllyIntro);
         else
            sendStatement(pid, cAICommPromptToEnemyIntro);
         if (playerHistoryID == -1)
         {
            aiEcho("PlayerName: Failed to create player history for " + playerName);
            continue;
         }
         aiEcho("PlayerName: Created new history for " + playerName);
      }
      else
      {
         //-- get how many times we have played against them.
         float totalGames = aiPersonalityGetPlayerGamesPlayed(playerHistoryID, cPlayerRelationAny);
         float numberGamePlayedAgainst = aiPersonalityGetPlayerGamesPlayed(playerHistoryID, cPlayerRelationEnemy);
         float numberGamesTheyWon = aiPersonalityGetTotalGameWins(playerHistoryID, cPlayerRelationEnemy);
         float myWinLossRatio = 1.0 - (numberGamesTheyWon / numberGamePlayedAgainst);
         aiEcho("PlayedAgainst: " + numberGamePlayedAgainst);
         aiEcho("TimesTheyWon: " + numberGamesTheyWon);
         aiEcho("MyWinLossRatio: " + myWinLossRatio);

         bool iWonOurLastGameAgainstEachOther = aiPersonalityGetDidIWinLastGameVS(playerHistoryID);
         // bool weWonOurLastGameTogether; <-- cant do yet.

         //-- get how fast they like to attack
         // Minus one game index gives an average.
         int avgFirstAttackTime = aiPersonalityGetGameFirstAttackTime(playerHistoryID, -1);
         aiEcho("Player's Avg first Attack time: " + avgFirstAttackTime);

         int lastFirstAttackTime = aiPersonalityGetGameFirstAttackTime(playerHistoryID, totalGames - 1);
         aiEcho("Player's Last game first Attack time: " + lastFirstAttackTime);

         //-- save some info.
         aiPersonalitySetPlayerUserVar(playerHistoryID, "myWinLossPercentage", myWinLossRatio);
         //-- test, get the value back out
         float tempFloat = aiPersonalityGetPlayerUserVar(playerHistoryID, "myWinLossPercentage");

         // Consider chats based on player history...
         // First, combinations of "was ally last time" and "am ally this time"
         bool wasAllyLastTime = true;
         bool isAllyThisTime = true;
         if (aiPersonalityGetPlayerUserVar(playerHistoryID, "wasMyAllyLastGame") == 0.0)
            wasAllyLastTime = false;
         if (kbIsPlayerAlly(pid) == false)
            isAllyThisTime = false;
         bool difficultyIsHigher = false;
         bool difficultyIsLower = false;
         float lastDifficulty = aiPersonalityGetPlayerUserVar(playerHistoryID, "lastGameDifficulty");
         if (lastDifficulty >= 0.0)
         {
            if (lastDifficulty > aiGetWorldDifficulty())
               difficultyIsLower = true;
            if (lastDifficulty < aiGetWorldDifficulty())
               difficultyIsHigher = true;
         }
         bool iBeatHimLastTime = false;
         bool heBeatMeLastTime = false;
         bool iCarriedHimLastTime = false;
         bool heCarriedMeLastTime = false;

         if (aiPersonalityGetPlayerUserVar(playerHistoryID, "heBeatMeLastTime") == 1.0) // STORE ME
            heBeatMeLastTime = true;
         if (aiPersonalityGetPlayerUserVar(playerHistoryID, "iBeatHimLastTime") == 1.0) // STORE ME
            iBeatHimLastTime = true;
         if (aiPersonalityGetPlayerUserVar(playerHistoryID, "iCarriedHimLastTime") == 1.0) // STORE ME
            iCarriedHimLastTime = true;
         if (aiPersonalityGetPlayerUserVar(playerHistoryID, "heCarriedMeLastTime") == 1.0) // STORE ME
            heCarriedMeLastTime = true;

         if (wasAllyLastTime == false)
         {
            if (aiPersonalityGetPlayerUserVar(playerHistoryID, "iBeatHimLastTime") == 1.0) // STORE ME
               iBeatHimLastTime = true;
            if (aiPersonalityGetPlayerUserVar(playerHistoryID, "heBeatMeLastTime") == 1.0) // STORE ME
               heBeatMeLastTime = true;
         }

         bool iWonLastGame = false;
         if (aiPersonalityGetPlayerUserVar(playerHistoryID, "iWonLastGame") == 1.0) // STORE ME
            iWonLastGame = true;

         if (isAllyThisTime)
         { // We are allies
            if (difficultyIsHigher == true)
               sendStatement(pid, cAICommPromptToAllyIntroWhenDifficultyHigher);
            if (difficultyIsLower == true)
               sendStatement(pid, cAICommPromptToAllyIntroWhenDifficultyLower);
            if (iCarriedHimLastTime == true)
               sendStatement(pid, cAICommPromptToAllyIntroWhenICarriedHimLastGame);
            if (heCarriedMeLastTime == true)
               sendStatement(pid, cAICommPromptToAllyIntroWhenHeCarriedMeLastGame);
            if (iBeatHimLastTime == true)
               sendStatement(pid, cAICommPromptToAllyIntroWhenIBeatHimLastGame);
            if (heBeatMeLastTime == true)
               sendStatement(pid, cAICommPromptToAllyIntroWhenHeBeatMeLastGame);

            aiEcho("Last map ID was " + aiPersonalityGetPlayerUserVar(playerHistoryID, "lastMapID"));
            if ((getMapID() >= 0) && (getMapID() == aiPersonalityGetPlayerUserVar(playerHistoryID, "lastMapID")))
            {
               sendStatement(pid, cAICommPromptToAllyIntroWhenMapRepeats);
               aiEcho("Last map ID was " + aiPersonalityGetPlayerUserVar(playerHistoryID, "lastMapID"));
            }
            if (wasAllyLastTime)
            {
               aiEcho(playerName + " was my ally last game and is my ally this game.");
               if (iWonLastGame == false)
                  sendStatement(pid, cAICommPromptToAllyIntroWhenWeLostLastGame);
               else
                  sendStatement(pid, cAICommPromptToAllyIntroWhenWeWonLastGame);
            }
            else
            {
               aiEcho(playerName + " was my enemy last game and is my ally this game.");
            }
         }
         else
         { // We are enemies
            if (difficultyIsHigher == true)
               sendStatement(pid, cAICommPromptToEnemyIntroWhenDifficultyHigher);
            if (difficultyIsLower == true)
               sendStatement(pid, cAICommPromptToEnemyIntroWhenDifficultyLower);
            if ((getMapID() >= 0) && (getMapID() == aiPersonalityGetPlayerUserVar(playerHistoryID, "lastMapID")))
               sendStatement(pid, cAICommPromptToEnemyIntroWhenMapRepeats);
            if (wasAllyLastTime)
            {
               aiEcho(playerName + " was my ally last game and is my enemy this game.");
            }
            else
            {
               aiEcho(playerName + " was my enemy last game and is my enemy this game.");
               // Check if he changed the odds
               int enemyCount = aiPersonalityGetPlayerUserVar(playerHistoryID, "myEnemyCount");
               int allyCount = aiPersonalityGetPlayerUserVar(playerHistoryID, "myAllyCount");
               if (enemyCount == getEnemyCount())
               {                                  // Check if enemyCount is the same, but ally count is down
                  if (allyCount > getAllyCount()) // I have fewer allies now
                     sendStatement(pid, cAICommPromptToEnemyIntroWhenTeamOddsEasier); // He wimped out
                  if (allyCount < getAllyCount())                                     // I have more allies now
                     sendStatement(pid, cAICommPromptToEnemyIntroWhenTeamOddsHarder); // He upped the difficulty
               }
               else if (allyCount == getAllyCount())
               {                                    // Else, check if allyCount is the same, but enemyCount is smaller
                  if (enemyCount > getEnemyCount()) // I have fewer enemies now
                     sendStatement(pid, cAICommPromptToEnemyIntroWhenTeamOddsHarder); // He upped the difficulty
                  if (enemyCount < getEnemyCount())                                   // I have more enemies now
                     sendStatement(pid, cAICommPromptToEnemyIntroWhenTeamOddsEasier); // He wimped out
               }
            }
         }
      }

      // Save info about this game
      aiPersonalitySetPlayerUserVar(playerHistoryID, "lastGameDifficulty", aiGetWorldDifficulty());
      int wasAlly = 0;
      if (kbIsPlayerAlly(pid) == true)
         wasAlly = 1;
      else
      { // He is an enemy, remember the odds (i.e. 1v3, 2v2, etc.)
         aiPersonalitySetPlayerUserVar(playerHistoryID, "myAllyCount", getAllyCount());
         aiPersonalitySetPlayerUserVar(playerHistoryID, "myEnemyCount", getEnemyCount());
      }
      aiPersonalitySetPlayerUserVar(playerHistoryID, "wasMyAllyLastGame", wasAlly);
      aiPersonalitySetPlayerUserVar(playerHistoryID, "lastMapID", getMapID());
   }
}

void gameOverHandler(int nothing = 0)
{
   bool iWon = false;
   if (kbHasPlayerLost(cMyID) == false)
      iWon = true;

   aiEcho("Game is over.");
   aiEcho("Have I lost returns " + kbHasPlayerLost(cMyID));
   if (iWon == false)
      aiEcho("I lost.");
   else
      aiEcho("I won.");

   for (pid = 1; < cNumberPlayers)
   {
      //-- Skip ourself.
      if (pid == cMyID)
         continue;

      //-- get player name
      string playerName = kbGetPlayerName(pid);
      aiEcho("PlayerName: " + playerName);

      //-- Does a record exist?
      int playerHistoryID = aiPersonalityGetPlayerHistoryIndex(playerName);
      if (playerHistoryID == -1)
      {
         aiEcho("PlayerName: Never played against");
         //-- Lets make a new player history.
         playerHistoryID = aiPersonalityCreatePlayerHistory(playerName);
      }

      /* Store the following user vars:
            heBeatMeLastTime
            iBeatHimLastTime
            iCarriedHimLastTime
            heCarriedMeLastTime
            iWonLastGame
      */
      if (iWon == true)
      { // I won
         aiPersonalitySetPlayerUserVar(playerHistoryID, "iWonLastGame", 1.0);
         if (kbIsPlayerEnemy(pid) == true)
         {
            aiPersonalitySetPlayerUserVar(playerHistoryID, "iBeatHimLastTime", 1.0);
            aiPersonalitySetPlayerUserVar(playerHistoryID, "heBeatMeLastTime", 0.0);
            aiEcho("This player was my enemy.");
         }
      }
      else
      { // I lost
         aiPersonalitySetPlayerUserVar(playerHistoryID, "iWonLastGame", 0.0);
         if (kbIsPlayerEnemy(pid) == true)
         {
            aiPersonalitySetPlayerUserVar(playerHistoryID, "iBeatHimLastTime", 0.0);
            aiPersonalitySetPlayerUserVar(playerHistoryID, "heBeatMeLastTime", 1.0);
            aiEcho("This player was my enemy.");
         }
      }
      if (kbIsPlayerAlly(pid) == true)
      { // Was my ally
         if (aiGetScore(cMyID) > (2 * aiGetScore(pid)))
         { // I outscored him badly
            aiPersonalitySetPlayerUserVar(playerHistoryID, "iCarriedHimLastTime", 1.0);
            aiEcho("I carried my ally.");
         }
         else
            aiPersonalitySetPlayerUserVar(playerHistoryID, "iCarriedHimLastTime", 0.0);
         if (aiGetScore(pid) > (2 * aiGetScore(cMyID)))
         { // My ally carried me.
            aiEcho("My ally carried me.");
            aiPersonalitySetPlayerUserVar(playerHistoryID, "heCarriedMeLastTime", 1.0);
         }
         else
            aiPersonalitySetPlayerUserVar(playerHistoryID, "heCarriedMeLastTime", 0.0);
      }
      else
      {
         aiPersonalitySetPlayerUserVar(playerHistoryID, "iCarriedHimLastTime", 0.0);
         aiPersonalitySetPlayerUserVar(playerHistoryID, "heCarriedMeLastTime", 0.0);
      }
   }
}

//==============================================================================
// chooseEuropeanPolitician()
// Chooses age-up politicians or revolutions for European civilizations
//==============================================================================
int chooseEuropeanPolitician()
{
   int position = 0;
   int randomizer = -1;
   int numChoices = -1;
   int politician = -1;
   int bestChoice = 0;
   int bestScore = 0;
   int puid = -1;
   
   // Reset score array
   for (i=0; < 10)
      xsArraySetInt(gPoliticianScores, i, 0);

   // Choose politician
   switch (kbGetAge())
   {
      case cAge1:
      {  // Governor for turtler, resources or settlers for rusher
         randomizer = aiRandInt(10); // 0-9

         // Create array of politicians to choose from
         for (i=0; <xsArrayGetSize(gAge2PoliticianList))
         {
             politician = xsArrayGetInt(gAge2PoliticianList, i);
             if (kbTechGetStatus(politician) == cTechStatusObtainable)
             {
                xsArraySetInt(gAgeUpPoliticians, position, politician);
                position = position + 1;
             }
         }

         // Weight politicians as appropriate
         numChoices = position;
         for (i=0; <numChoices)
         {
            politician = xsArrayGetInt(gAgeUpPoliticians, i);
			if (politician == cTechDEPoliticianFederalPennsylvania)
				{
					xsArraySetInt(gPoliticianScores, i, xsArrayGetInt(gPoliticianScores, i) + 10);
				}
            if (politician == cTechDEPoliticianInventor && (kbUnitCount(cMyID, cUnitTypeHomeCityWaterSpawnFlag) > 0))
            {
               xsArraySetInt(gPoliticianScores, i, xsArrayGetInt(gPoliticianScores, i) + 10);
            }
            else if (btOffenseDefense < 0.0)
            {
               if (politician == cTechPoliticianGovernor)
               {
                  xsArraySetInt(gPoliticianScores, i, xsArrayGetInt(gPoliticianScores, i) + 0);
               }
            }
            //else
            //{
               if ((politician == cTechDEPoliticianLogisticianSwedish) || (politician == cTechDEPoliticianLogisticianPortuguese))
               {
                  xsArraySetInt(gPoliticianScores, i, xsArrayGetInt(gPoliticianScores, i) + 100);
               }   
               if (politician == cTechPoliticianQuartermaster)
               {
                  xsArraySetInt(gPoliticianScores, i, xsArrayGetInt(gPoliticianScores, i) + 100);
               }            
            //}
            if (btRushBoom > 0.0)
            {
               if ((politician == cTechPoliticianGovernor) ||
                   (politician == cTechPoliticianNaturalist))
               {
                  xsArraySetInt(gPoliticianScores, i, xsArrayGetInt(gPoliticianScores, i) - 100);
               }
            }
         }
         // Add random bonus
         randomizer = aiRandInt(numChoices);
         xsArraySetInt(gPoliticianScores, randomizer, xsArrayGetInt(gPoliticianScores, randomizer) + 5);

         // Choose politician with best score
         for (i=0; <numChoices)
         {
            if (xsArrayGetInt(gPoliticianScores, i) >= bestScore)
            {
               bestScore = xsArrayGetInt(gPoliticianScores, i);
               bestChoice = i;
            }
         }
         politician = xsArrayGetInt(gAgeUpPoliticians, bestChoice);
         break;
      }
      case cAge2:
      {  // Randomized, but heavily biased towards Admiral or Pirate for water maps
         randomizer = aiRandInt(10); // 0-9

         // Create array of politicians to choose from
         for (i=0; <xsArrayGetSize(gAge3PoliticianList))
         {
             politician = xsArrayGetInt(gAge3PoliticianList, i);
             if (kbTechGetStatus(politician) == cTechStatusObtainable)
             {
                xsArraySetInt(gAgeUpPoliticians, position, politician);
                position = position + 1;
             }
         }

         // Weight politicians as appropriate
         numChoices = position;
         for (i=0; <numChoices)
         {
            politician = xsArrayGetInt(gAgeUpPoliticians, i);
            if ((mapIsIsland() == true) ||
                ((randomizer < 5) && (kbUnitCount(cMyID, cUnitTypeHomeCityWaterSpawnFlag) > 0)))
            {
               if ((politician == cTechPoliticianAdmiral) ||
                   (politician == cTechPoliticianAdmiralOttoman) ||
                   (politician == cTechPoliticianPirate))
               {
                  xsArraySetInt(gPoliticianScores, i, xsArrayGetInt(gPoliticianScores, i) + 10);
               }
            }
			if (politician == cTechDEPoliticianFederalNewHampshire)
				{
					xsArraySetInt(gPoliticianScores, i, xsArrayGetInt(gPoliticianScores, i) + 5);
				}
            if (kbUnitCount(cMyID, cUnitTypeHomeCityWaterSpawnFlag) == 0)
            {
               if ((politician == cTechPoliticianAdmiral) ||
                   (politician == cTechPoliticianAdmiralOttoman) ||
                   (politician == cTechPoliticianPirate))
               {
                  xsArraySetInt(gPoliticianScores, i, xsArrayGetInt(gPoliticianScores, i) - 10);
               }
            }
			if ((politician == cTechDEPoliticianMercContractorFortressOttoman) && (kbGetCiv() == cCivOttomans))
			{
               xsArraySetInt(gPoliticianScores, i, xsArrayGetInt(gPoliticianScores, i) + 200);
            }
            if (politician == cTechPoliticianBishopFortress && btRushBoom < 0.0)
               xsArraySetInt(gPoliticianScores, i, xsArrayGetInt(gPoliticianScores, i) + 10);  
            if (randomizer < 7)
            {
               puid = kbTechGetProtoUnitID(politician);
               if (politician == cTechDEPoliticianPapalGuardBritish &&
                  (kbUnitPickGetResult(gLandUnitPicker, 0) == cUnitTypePikeman ||
                   kbUnitPickGetResult(gLandUnitPicker, 1) == cUnitTypePikeman ||
                   kbUnitPickGetResult(gLandUnitPicker, 0) == cUnitTypeLongbowman ||
                   kbUnitPickGetResult(gLandUnitPicker, 1) == cUnitTypeLongbowman))
                  xsArraySetInt(gPoliticianScores, i, xsArrayGetInt(gPoliticianScores, i) + 5);
               else if (puid == kbUnitPickGetResult(gLandUnitPicker, 0) ||
                        puid == kbUnitPickGetResult(gLandUnitPicker, 1))
                  xsArraySetInt(gPoliticianScores, i, xsArrayGetInt(gPoliticianScores, i) + 5);      
            }
            if (politician == cTechDEPoliticianInventorFortress &&
                (kbTechGetStatus(cTechdeEnableBalloonPower) == cTechStatusActive ||
                aiGetFallenExplorerID() >= 0))
               xsArraySetInt(gPoliticianScores, i, xsArrayGetInt(gPoliticianScores, i) - 10);  
         }
         // Add random bonus
         randomizer = aiRandInt(numChoices);
         xsArraySetInt(gPoliticianScores, randomizer, xsArrayGetInt(gPoliticianScores, randomizer) + 5);

         // Choose politician with best score
         for (i=0; <numChoices)
         {
            if (xsArrayGetInt(gPoliticianScores, i) >= bestScore)
            {
               bestScore = xsArrayGetInt(gPoliticianScores, i);
               bestChoice = i;
            }
         }
         politician = xsArrayGetInt(gAgeUpPoliticians, bestChoice);
         break;
      }
      case cAge3:
      {  // Randomized, but slightly biased towards the Engineer and Papal Guard
         randomizer = aiRandInt(10); // 0-9

         // Create array of politicians to choose from
         for (i=0; <xsArrayGetSize(gAge4PoliticianList))
         {
             politician = xsArrayGetInt(gAge4PoliticianList, i);
             if (kbTechGetStatus(politician) == cTechStatusObtainable)
             {
                xsArraySetInt(gAgeUpPoliticians, position, politician);
                position = position + 1;
             }
         }

         // Weight politicians as appropriate
         numChoices = position;
         for (i=0; <numChoices)
         {
            politician = xsArrayGetInt(gAgeUpPoliticians, i);
            if (randomizer < 3)
            {
               puid = kbTechGetProtoUnitID(politician);
               if (puid == kbUnitPickGetResult(gLandUnitPicker, 0) ||
                   puid == kbUnitPickGetResult(gLandUnitPicker, 1))
                  xsArraySetInt(gPoliticianScores, i, xsArrayGetInt(gPoliticianScores, i) + 5);   
            }
            else
            {
               if ((politician == cTechDEPoliticianPapalGuard ||
                    politician == cTechDEPoliticianPapalGuardPortuguese ||
                    politician == cTechDEPoliticianPapalGuardSwedish) &&
                   (kbUnitPickGetResult(gLandUnitPicker, 0) == cUnitTypePikeman ||
                    kbUnitPickGetResult(gLandUnitPicker, 1) == cUnitTypePikeman ||
                    kbUnitPickGetResult(gLandUnitPicker, 0) == cUnitTypeCrossbowman ||
                    kbUnitPickGetResult(gLandUnitPicker, 1) == cUnitTypeCrossbowman))
               {
                  xsArraySetInt(gPoliticianScores, i, xsArrayGetInt(gPoliticianScores, i) + 5);
               }               
            }
            if (politician == cTechDEPoliticianFederalNewJersey || politician == cTechDEPoliticianFederalCalifornia)
				{
					xsArraySetInt(gPoliticianScores, i, xsArrayGetInt(gPoliticianScores, i) + 10);
				}
               if ((politician == cTechDEPoliticianLogisticianOttoman) || 
			   (politician == cTechDEPoliticianLogisticianRussian) ||
			   (politician == cTechDEPoliticianLogistician))
               {
                  xsArraySetInt(gPoliticianScores, i, xsArrayGetInt(gPoliticianScores, i) + 300);
               }  
            
         }
         
         // Add random bonus
         randomizer = aiRandInt(numChoices);
         xsArraySetInt(gPoliticianScores, randomizer, xsArrayGetInt(gPoliticianScores, randomizer) + 5);

         // Choose politician with best score
         for (i=0; <numChoices)
         {
            if (xsArrayGetInt(gPoliticianScores, i) >= bestScore)
            {
               bestScore = xsArrayGetInt(gPoliticianScores, i);
               bestChoice = i;
            }
         }
         politician = xsArrayGetInt(gAgeUpPoliticians, bestChoice);
         break;
      }
      case cAge4:
	{  // Randomized, but slightly biased towards the General and Mercenary Contractor
		randomizer = aiRandInt(10); // 0-9

		// Create array of politicians to choose from
		for (i = 0; < xsArrayGetSize(gAge5PoliticianList))
		{
			politician = xsArrayGetInt(gAge5PoliticianList, i);
			if (kbTechGetStatus(politician) == cTechStatusObtainable)
			{
				xsArraySetInt(gAgeUpPoliticians, position, politician);
				position = position + 1;
			}
		}

		// Weight politicians as appropriate
		numChoices = position;
		for (i = 0; < numChoices)
		{
			politician = xsArrayGetInt(gAgeUpPoliticians, i);
			if (aiGetWorldDifficulty() >= gDifficultyExpert)
			{
				if ((politician == cTechDEPoliticianMercContractor) && (xsGetTime() > 24 * 60 * 1000))
				{
					xsArraySetInt(gPoliticianScores, i, xsArrayGetInt(gPoliticianScores, i) + 300);
				}
				if ((politician == cTechDEPoliticianMercContractor) && (xsGetTime() < 24 * 60 * 1000))
				{
					xsArraySetInt(gPoliticianScores, i, xsArrayGetInt(gPoliticianScores, i) + 20);
				}
			}
			else
				if (politician == cTechDEPoliticianMercContractor)
				{
					xsArraySetInt(gPoliticianScores, i, xsArrayGetInt(gPoliticianScores, i) + 20);
				}
		}

            if (politician == cTechDEPoliticianFederalNewYork || politician == cTechDEPoliticianFederalFlorida || politician == cTechDEPoliticianFederalIllinois)
				{
					xsArraySetInt(gPoliticianScores, i, xsArrayGetInt(gPoliticianScores, i) + 5);
				}
				
		if (gSPC == false)
		{
			// Create array of revolutions to choose from
			for (i = 0; < xsArrayGetSize(gRevolutionList))
			{
				politician = xsArrayGetInt(gRevolutionList, i);
				if (kbTechGetStatus(politician) == cTechStatusObtainable)
				{
					xsArraySetInt(gAgeUpPoliticians, position, politician);
					position = position + 1;
				}
			}

			// Weight revolutions as appropriate
			for (i = numChoices; < position)
			{
				politician = xsArrayGetInt(gAgeUpPoliticians, i);
				// Avoid revolting when we played more than 30 minutes or started to farm
					if (aiTreatyActive() == true)
					xsArraySetInt(gPoliticianScores, i, xsArrayGetInt(gPoliticianScores, i) - 900);
					else
						if ((gRevolutionType & cRevolutionEconomic) == cRevolutionEconomic)
					xsArraySetInt(gPoliticianScores, i, xsArrayGetInt(gPoliticianScores, i) - 900);
				else
						if (aiGetWorldDifficulty() >= gDifficultyExpert)
			{
				if (xsGetTime() < 22 * 60 * 1000)
					xsArraySetInt(gPoliticianScores, i, xsArrayGetInt(gPoliticianScores, i) + 10);
					else
					xsArraySetInt(gPoliticianScores, i, xsArrayGetInt(gPoliticianScores, i) + 5);
					if ((politician == cTechDERevolutionEgypt) && (kbGetCiv() == cCivOttomans))
					xsArraySetInt(gPoliticianScores, i, xsArrayGetInt(gPoliticianScores, i) + 5);
			}
			else
				xsArraySetInt(gPoliticianScores, i, xsArrayGetInt(gPoliticianScores, i) + 15);
			}
			numChoices = position;
		}

		// Add random bonus
		randomizer = aiRandInt(numChoices);
		xsArraySetInt(gPoliticianScores, randomizer, xsArrayGetInt(gPoliticianScores, randomizer) + 5);

		// Choose politician with best score
		for (i = 0; < numChoices)
		{
			if (xsArrayGetInt(gPoliticianScores, i) >= bestScore)
			{
				bestScore = xsArrayGetInt(gPoliticianScores, i);
				bestChoice = i;
			}
		}
		politician = xsArrayGetInt(gAgeUpPoliticians, bestChoice);
		break;
	}
	}

	if (gAgeUpResearchPlan < 0 || aiPlanGetVariableInt(gAgeUpResearchPlan, cResearchPlanTechID, 0) != politician)
		aiEcho("Chosen age-up politician: " + kbGetTechName(politician));
	return(politician);
}

//==============================================================================
// chooseNativeCouncilMember()
// Chooses age-up council members for native civilizations
//==============================================================================
int chooseNativeCouncilMember()
{
   int randomizer = -1;
   int numChoices = -1;
   int politician = -1;
   int bestChoice = 0;
   int bestScore = 0;

   for (i = 0; < 6)
      xsArraySetInt(gNatCouncilScores, i, 0); // reset array

   switch (kbGetAge())
   {
   case cAge1:
   { // Aztec and Inca wise woman to be avoided
      numChoices = aiGetPoliticianListCount(cAge2);
      for (i = 0; < numChoices)
      {
         politician = aiGetPoliticianListByIndex(cAge2, i);
         if ((aiGetWorldDifficulty() >= cDifficultyModerate) &&
             ((politician == cTechTribalAztecWisewoman2) || (politician == cTechTribalIncaWisewoman2)))
         {
            xsArraySetInt(gNatCouncilScores, i, xsArrayGetInt(gNatCouncilScores, i) - 10);
         }
      }
      randomizer = aiRandInt(numChoices);
      xsArraySetInt(gNatCouncilScores, randomizer, xsArrayGetInt(gNatCouncilScores, randomizer) + 5);
      for (i = 0; < numChoices)
      {
         if (xsArrayGetInt(gNatCouncilScores, i) >= bestScore)
         {
            bestScore = xsArrayGetInt(gNatCouncilScores, i);
            bestChoice = i;
         }
      }
      politician = aiGetPoliticianListByIndex(cAge2, bestChoice);
      break;
   }
   case cAge2:
   { // Aztec chief to be avoided
      numChoices = aiGetPoliticianListCount(cAge3);
      for (i = 0; < numChoices)
      {
         politician = aiGetPoliticianListByIndex(cAge3, i);
         if ((aiGetWorldDifficulty() >= cDifficultyModerate) && (politician == cTechTribalAztecChief3))
         {
            xsArraySetInt(gNatCouncilScores, i, xsArrayGetInt(gNatCouncilScores, i) - 10);
         }
         if (kbTechGetStatus(politician) != cTechStatusObtainable)
         {
            xsArraySetInt(gNatCouncilScores, i, xsArrayGetInt(gNatCouncilScores, i) - 50);
         }
         xsArraySetInt(gNatCouncilScores, i, xsArrayGetInt(gNatCouncilScores, i) + aiRandInt(10));
      }
      for (i = 0; < numChoices)
      {
         if (xsArrayGetInt(gNatCouncilScores, i) >= bestScore)
         {
            bestScore = xsArrayGetInt(gNatCouncilScores, i);
            bestChoice = i;
         }
      }
      politician = aiGetPoliticianListByIndex(cAge3, bestChoice);
      break;
   }
   case cAge3:
   { // Aztec chief, Iroquois shaman, Sioux wise woman and all messengers to be avoided if possible
      numChoices = aiGetPoliticianListCount(cAge4);
      for (i = 0; < numChoices)
      {
         politician = aiGetPoliticianListByIndex(cAge4, i);
         if ((aiGetWorldDifficulty() >= cDifficultyModerate) &&
             ((politician == cTechTribalAztecChief4) || (politician == cTechTribalIroquoisShaman4) ||
              (politician == cTechTribalSiouxWisewoman4) || (politician == cTechTribalAztecYouth4) ||
              (politician == cTechTribalIncaYouth4) || (politician == cTechTribalIroquoisYouth4) ||
              (politician == cTechTribalSiouxYouth4)))
         {
            xsArraySetInt(gNatCouncilScores, i, xsArrayGetInt(gNatCouncilScores, i) - 10);
         }
         if (kbTechGetStatus(politician) != cTechStatusObtainable)
         {
            xsArraySetInt(gNatCouncilScores, i, xsArrayGetInt(gNatCouncilScores, i) - 50);
         }
         xsArraySetInt(gNatCouncilScores, i, xsArrayGetInt(gNatCouncilScores, i) + aiRandInt(10));
      }
      for (i = 0; < numChoices)
      {
         if (xsArrayGetInt(gNatCouncilScores, i) >= bestScore)
         {
            bestScore = xsArrayGetInt(gNatCouncilScores, i);
            bestChoice = i;
         }
      }
      politician = aiGetPoliticianListByIndex(cAge4, bestChoice);
      break;
   }
   case cAge4:
   { // Aztec chief, Iroquois shaman, Sioux wise woman and all messengers to be avoided if possible
      numChoices = aiGetPoliticianListCount(cAge5);
      for (i = 0; < numChoices)
      {
         politician = aiGetPoliticianListByIndex(cAge5, i);
         if ((aiGetWorldDifficulty() >= cDifficultyModerate) &&
             ((politician == cTechTribalAztecChief5) || (politician == cTechTribalIroquoisShaman5) ||
              (politician == cTechTribalSiouxWisewoman5) || (politician == cTechTribalAztecYouth5) ||
              (politician == cTechTribalIncaYouth5) || (politician == cTechTribalIroquoisYouth5) ||
              (politician == cTechTribalSiouxYouth5)))
         {
            xsArraySetInt(gNatCouncilScores, i, xsArrayGetInt(gNatCouncilScores, i) - 10);
         }
         if (kbTechGetStatus(politician) != cTechStatusObtainable)
         {
            xsArraySetInt(gNatCouncilScores, i, xsArrayGetInt(gNatCouncilScores, i) - 50);
         }
         xsArraySetInt(gNatCouncilScores, i, xsArrayGetInt(gNatCouncilScores, i) + aiRandInt(10));
      }
      for (i = 0; < numChoices)
      {
         if (xsArrayGetInt(gNatCouncilScores, i) >= bestScore)
         {
            bestScore = xsArrayGetInt(gNatCouncilScores, i);
            bestChoice = i;
         }
      }
      politician = aiGetPoliticianListByIndex(cAge5, bestChoice);
      break;
   }
   }

   return (politician);
}

//==============================================================================
// chooseAsianWonder()
// Chooses age-up wonders for Asian civilizations
//==============================================================================
int chooseAsianWonder()
{
   int numChoices = -1;
   int politician = -1;
   int ageUpWonder = -1;
   int bestChoice = 0;
   int bestScore = 0;

   for (i=0; <6)
      xsArraySetInt(gAsianWonderScores, i, 0);   // reset array

   switch (kbGetAge())
   {
      case cAge1:
      {
         numChoices = aiGetPoliticianListCount(cAge2);
         for (i=0; <numChoices)
         {
            politician = aiGetPoliticianListByIndex(cAge2, i);
            if (politician == cTechYPWonderIndianAgra2) // bias towards agra fort
            {
               xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) + 5);
            }
            else if (politician == cTechYPWonderJapaneseToshoguShrine2) // bias towards toshogu shrine
            {
               xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) + 500);
            }
            else if (politician == cTechYPWonderChineseSummerPalace2) // bias towards summer palace
            {
               xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) + 5);
            }
            else if (politician == cTechYPWonderChinesePorcelainTower2) // bias against porcelain tower
            {
               xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) - 5);
            }
            else if (politician == cTechYPWonderIndianTajMahal2) // bias against taj mahal
            {
               xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) - 5);
            }
            else if (politician == cTechYPWonderJapaneseGiantBuddha2) // bias against giant buddha
            {
               xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) - 5);
            }
            else if (politician == cTechYPWonderJapaneseShogunate2) // bias against shogunate
            {
               xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) - 5);
            }
            xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) + aiRandInt(10));
         }
         for (i=0; <numChoices)
         {
            if (xsArrayGetInt(gAsianWonderScores, i) >= bestScore)
            {
               bestScore = xsArrayGetInt(gAsianWonderScores, i);
               bestChoice = i;
            }
         }
         politician = aiGetPoliticianListByIndex(cAge2, bestChoice);
         aiEcho("Chosen age-up wonder: "+kbGetTechName(politician));

         // Find building corresponding to chosen tech (i.e. "politician")
         for (i=0; <15)
         {
            if (xsArrayGetInt(gAge2WonderTechList, i) == politician)
            {
               ageUpWonder = xsArrayGetInt(gAge2WonderList, i);
            }
         }
         break;
      }
      case cAge2:
      {
         numChoices = aiGetPoliticianListCount(cAge3);
         for (i=0; <numChoices)
         {
            politician = aiGetPoliticianListByIndex(cAge3, i);
            if (kbTechGetStatus(politician) != cTechStatusObtainable)
            {
               xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) - 50);
            }
            else if (politician == cTechYPWonderIndianKarniMata3) // bias towards karni mata
            {
               xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) + 5);
            }
            else if (politician == cTechYPWonderIndianCharminar3) // bias towards charminar gate
            {
               xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) + 5);
            }
            else if (politician == cTechYPWonderJapaneseToshoguShrine3) // bias towards toshogu shrine
            {
               xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) + 5);
            }
            else if (politician == cTechYPWonderJapaneseToriiGates3) // bias towards golden pavillion
            {
               xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) + 500);
            }
            else if (politician == cTechYPWonderJapaneseShogunate3) // slight bias towards shogunate
            {
               xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) + 2);
            }
            else if (politician == cTechYPWonderChineseSummerPalace3) // strong bias towards summer palace
            {
               xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) + 10);
            }
            else if (politician == cTechYPWonderChineseConfucianAcademy3) // slight bias towards confucian academy
            {
               xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) + 2);
            }
            else if (politician == cTechYPWonderChinesePorcelainTower3) // slight bias towards porcelain tower
            {
               xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) + 2);
            }
            else if (politician == cTechYPWonderChineseWhitePagoda3) // slight bias against white pagoda
            {
               xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) - 2);
            }
            xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) + aiRandInt(10));
         }
         for (i=0; <numChoices)
         {
            if (xsArrayGetInt(gAsianWonderScores, i) >= bestScore)
            {
               bestScore = xsArrayGetInt(gAsianWonderScores, i);
               bestChoice = i;
            }
         }
         politician = aiGetPoliticianListByIndex(cAge3, bestChoice);
         aiEcho("Chosen age-up wonder: "+kbGetTechName(politician));

         // Find building corresponding to chosen tech (i.e. "politician")
         for (i=0; <15)
         {
            if (xsArrayGetInt(gAge3WonderTechList, i) == politician)
            {
               ageUpWonder = xsArrayGetInt(gAge3WonderList, i);
            }
         }
         break;
      }
      case cAge3:
      {
         numChoices = aiGetPoliticianListCount(cAge4);
         for (i=0; <numChoices)
         {
            politician = aiGetPoliticianListByIndex(cAge4, i);
            if (kbTechGetStatus(politician) != cTechStatusObtainable)
            {
               xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) - 50);
            }
            else if (politician == cTechYPWonderIndianKarniMata4) // bias towards karni mata
            {
               xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) + 5);
            }
            else if (politician == cTechYPWonderIndianCharminar4) // bias towards charminar gate
            {
               xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) + 5);
            }
            else if (politician == cTechYPWonderJapaneseGoldenPavillion4) // strong bias towards toshogu shrine
            {
               xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) + 500);
            }
            else if (politician == cTechYPWonderJapaneseGoldenPavillion4) // strong bias towards golden pavillion
            {
               xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) + 10);
            }
            else if (politician == cTechYPWonderJapaneseShogunate4) // bias towards shogunate
            {
               xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) + 5);
            }
            else if (politician == cTechYPWonderChineseSummerPalace4) // bias towards summer palace
            {
               xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) + 5);
            }
            else if (politician == cTechYPWonderChinesePorcelainTower4) // strong bias towards porcelain tower
            {
               xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) + 10);
            }
            else if (politician == cTechYPWonderChineseConfucianAcademy4) // bias towards confucian academy
            {
               xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) + 5);
            }
            else if (politician == cTechYPWonderChineseTempleOfHeaven4) // slight bias against temple of heaven
            {
               xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) - 2);
            }
            else if (politician == cTechYPWonderChineseWhitePagoda4) // slight bias against white pagoda
            {
               xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) - 2);
            }
            xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) + aiRandInt(10));
         }
         for (i=0; <numChoices)
         {
            if (xsArrayGetInt(gAsianWonderScores, i) >= bestScore)
            {
               bestScore = xsArrayGetInt(gAsianWonderScores, i);
               bestChoice = i;
            }
         }
         politician = aiGetPoliticianListByIndex(cAge4, bestChoice);
         aiEcho("Chosen age-up wonder: "+kbGetTechName(politician));

         // Find building corresponding to chosen tech (i.e. "politician")
         for (i=0; <15)
         {
            if (xsArrayGetInt(gAge4WonderTechList, i) == politician)
            {
               ageUpWonder = xsArrayGetInt(gAge4WonderList, i);
            }
         }
         break;
      }
      case cAge4:
      {
         numChoices = aiGetPoliticianListCount(cAge5);
         for (i=0; <numChoices)
         {
            politician = aiGetPoliticianListByIndex(cAge5, i);
            if (kbTechGetStatus(politician) != cTechStatusObtainable)
            {
               xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) - 50);
            }
            else if (politician == cTechYPWonderIndianKarniMata5) // bias towards karni mata
            {
               xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) + 5);
            }
            else if (politician == cTechYPWonderIndianCharminar5) // bias towards charminar gate
            {
               xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) + 5);
            }
            else if (politician == cTechYPWonderJapaneseToshoguShrine5) // strong bias towards toshogu shrine
            {
               xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) + 10);
            }
            else if (politician == cTechYPWonderJapaneseGoldenPavillion5) // strong bias towards golden pavillion
            {
               xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) + 10);
            }
            else if (politician == cTechYPWonderJapaneseShogunate5) // strong bias towards shogunate
            {
               xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) + 500);
            }
            else if (politician == cTechYPWonderChineseSummerPalace5) // bias towards summer palace
            {
               xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) + 5);
            }
            else if (politician == cTechYPWonderChinesePorcelainTower5) // strong bias towards porcelain tower
            {
               xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) + 10);
            }
            else if (politician == cTechYPWonderChineseConfucianAcademy5) // bias towards confucian academy
            {
               xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) + 5);
            }
            else if (politician == cTechYPWonderChineseTempleOfHeaven5) // slight bias against temple of heaven
            {
               xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) - 2);
            }
            else if (politician == cTechYPWonderChineseWhitePagoda5) // slight bias against white pagoda
            {
               xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) - 2);
            }
            xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) + aiRandInt(10));
         }
         for (i=0; <numChoices)
         {
            if (xsArrayGetInt(gAsianWonderScores, i) >= bestScore)
            {
               bestScore = xsArrayGetInt(gAsianWonderScores, i);
               bestChoice = i;
            }
         }
         politician = aiGetPoliticianListByIndex(cAge5, bestChoice);
         aiEcho("Chosen age-up wonder: "+kbGetTechName(politician));

         // Find building corresponding to chosen tech (i.e. "politician")
         for (i=0; <15)
         {
            if (xsArrayGetInt(gAge5WonderTechList, i) == politician)
            {
               ageUpWonder = xsArrayGetInt(gAge5WonderList, i);
            }
         }
         break;
      }
   }

   if (gAgeUpResearchPlan < 0 || aiPlanGetVariableInt(gAgeUpResearchPlan, cBuildPlanBuildingTypeID, 0) != ageUpWonder)
      aiEcho("Chosen age-up wonder: "+kbGetProtoUnitName(ageUpWonder));
   return(ageUpWonder);
}

//==============================================================================
// chooseAfricanAlliance()
// Chooses age-up alliance for African civilizations
//==============================================================================
int chooseAfricanAlliance()
{
   int age = kbGetAge();
   int numAllianceChoices = aiGetPoliticianListCount(age + 1);
	int numValidAlliances = 0;
   int alliance = -1;

   for (i = 0; < 8)
      xsArraySetInt(gAfricanAlliances, i, 0); // reset array

	// Fill the array with Alliances that are deemed suitable to chose from. (exclude the ones we don't want is what's done below)
   switch (age)
   {
   case cAge1:
   {
      for (i = 0; < numAllianceChoices)
      {
         alliance = aiGetPoliticianListByIndex(cAge2, i);
         if ((alliance != cTechDEAllegianceJesuit2) && (alliance != cTechDEAllegianceHabesha2) &&
             (alliance != cTechDEAllegianceMoroccan2) && (alliance != cTechDEAllegianceAkan2))
         {
            xsArraySetInt(gAfricanAlliances, numValidAlliances, alliance);
				numValidAlliances++;
         }
      }
      break;
   }
   case cAge2:
   {
      for (i = 0; < numAllianceChoices)
      {
         alliance = aiGetPoliticianListByIndex(cAge3, i);
         if ((alliance != cTechDEAllegianceHabesha3) && (alliance != cTechDEAllegianceIndian3) &&
             (alliance != cTechDEAllegianceMoroccan3) && (alliance != cTechDEAllegianceFulani3))
         {
            xsArraySetInt(gAfricanAlliances, numValidAlliances, alliance);
				numValidAlliances++;
         }
      }
      break;
   }
   case cAge3:
   {
      for (i = 0; < numAllianceChoices)
      {
         alliance = aiGetPoliticianListByIndex(cAge4, i);
         if ((alliance != cTechDEAllegianceHabesha4) && (alliance != cTechDEAllegianceIndian4) &&
             (alliance != cTechDEAllegianceFulani4) && (alliance != cTechDEAllegianceMoroccan4) &&
             (alliance != cTechDEAllegianceYoruba4))
         {
            xsArraySetInt(gAfricanAlliances, numValidAlliances, alliance);
				numValidAlliances++;
         }
      }
      break;
   }
   case cAge4:
   {
      for (i = 0; < numAllianceChoices)
      {
         alliance = aiGetPoliticianListByIndex(cAge5, i);
         if ((alliance != cTechDEAllegianceHabesha5) && (alliance != cTechDEAllegianceIndian5) &&
             (alliance != cTechDEAllegianceArab5) && (alliance != cTechDEAllegianceFulani5) &&
             (alliance != cTechDEAllegianceMoroccan5) && (alliance != cTechDEAllegianceYoruba5))
         {
            xsArraySetInt(gAfricanAlliances, numValidAlliances, alliance);
				numValidAlliances++;
         }
      }
      break;
   }
   }
   int randomizer = aiRandInt(numValidAlliances);
   alliance = xsArrayGetInt(gAfricanAlliances, randomizer);
	
	for (i = 0; < numValidAlliances)
		aiEcho("Valid Alliance: "+ kbGetTechName(xsArrayGetInt(gAfricanAlliances, i)));
	
   return (alliance);
}

//==============================================================================
/* SPCInit()

   A function to set defaults that need to be in place before the loader file's
   preInit() function is called.
*/
//==============================================================================
void SPCInit(void)
{
   // Taunt defaults to true, but needs to be false in scenario games.
   if (gSPC == true)
      cvOkToTaunt = false;
   else // Always build a deck for non SPC games.
      cvOkToBuildDeck = true;



   if ((gStartOnDifferentIslands == true) || (cRandomMapName == "Borneo") || (cRandomMapName == "Honshu"))
   {
      aiSetWaterMap(true);
      gWaterMap = true;
   }
}

int gCardNames = -1;  // Array of strings, handy name for this card.
int gCardStates = -1; // Array of chars (strings), A = avail, N = Not avail, P = Purchased, D = in deck (and purchased)
int gCardPriorities = -1;     // Array of ints, used for selecting cards into deck.
int gPremadeDeckTechIDs = -1; // Array of ints, used for storing tech IDs from a premade deck.

const int maxCards = 150;
const int deckSize = 25;
const int pointsForLevel2 = 5;  // First five cards must be level 1
const int pointsForLevel3 = 25; // Cards 6..25 must be levels 1 or 2

bool addCardToDeck(int deckIndex = -1, int cardIndex = -1)
{
   if (cvOkToBuildDeck == false)
   {
      // Due to a bug (or perhaps hack) in the Legacy game code, aiHCDeckAddCardToDeck() fails to add cards to the
      // AI's deck in SPC games. As a consequence, the game always reports 0 cards in the deck, and the AI does not
      // play any HC cards in Campaigns or Scenarios. The same behaviour was carried forward to the TWC and TAD
      // expansions.
      // This bug was fixed in the DE version, so the AI can and will play cards in SPC games. Obviously this has a
      // huge impact on the behaviour and difficulty. Therefore, in order to preserve the legacy AI behaviour, we
      // refrain from adding cards to the deck if this is an SPC game.
      aiEcho("  Skipping card " + xsArrayGetString(gCardNames, cardIndex));
      return (false);
   }

   aiEcho("  Adding card " + xsArrayGetString(gCardNames, cardIndex));
   bool added = aiHCDeckAddCardToDeck(deckIndex, cardIndex);
   return (added);
}

rule buyCards
inactive
minInterval 1
{
   static int pass = 0; // Pass 0, init arrays.  Pass 1, buy cards.  Pass 2, create deck.
   static int startingSP = -1;
   if (startingSP < 0)
      startingSP = kbResourceGet(cResourceSkillPoints) -
                   15; // XS won't allow float initialization of const ints, also subtract first 15 free cards.
   int remainingSP = kbResourceGet(cResourceSkillPoints) - 15;
   int SPSpent = startingSP - remainingSP;
   int myLevel = 0;
   if (SPSpent >= 10)
      myLevel = 10;
   if (SPSpent >= 25)
      myLevel = 25;
   int totalCardCount = aiHCCardsGetTotal();
   aiEcho("My starting level is " + myLevel + ", my SP remaining is " + remainingSP);

   switch (pass) // Break processing load into 3 passes:  init, buy, deck.
   {
   case 0: // Init arrays
   {
      gCardNames = xsArrayCreateString(maxCards, " ", "Card names");
      gCardStates = xsArrayCreateString(maxCards, "P", "Card states");
      gCardPriorities = xsArrayCreateInt(maxCards, 0, "Card priorities");

      int premadeDeckID = -1;
      int numCardsPremadeDeck = -1;
      int premadeCardTechID = -1;
      int numPremadeDecks = aiHCPreMadeDeckGetNumber();
      // Get appropriate premade deck
      if ((gNavyMap == false) && (numPremadeDecks >= 1))
      {
         premadeDeckID = aiHCPreMadeDeckGetIndex("Land");
      }
      else if ((gNavyMap == true) && (numPremadeDecks >= 1))
      {
         premadeDeckID = aiHCPreMadeDeckGetIndex("Naval");
      }
      if (premadeDeckID >= 0)
      {
         numCardsPremadeDeck = aiHCPreMadeDeckGetNumberCards(premadeDeckID);
         gPremadeDeckTechIDs = xsArrayCreateInt(numCardsPremadeDeck, 0, "Premade deck tech IDs");
         for (premadeCardID = 0; < numCardsPremadeDeck)
         {
            premadeCardTechID = aiHCPreMadeDeckGetCardTechID(premadeDeckID, premadeCardID);
            xsArraySetInt(gPremadeDeckTechIDs, premadeCardID, premadeCardTechID);
            /*sendChatToAllies("Decks: " + numPremadeDecks);
            sendChatToAllies("Deck Index: " + premadeDeckID);
            sendChatToAllies("Cards in Deck: " + numCardsPremadeDeck);
            sendChatToAllies("Tech ID" + premadeCardID + premadeCardTechID);
         */
         }
      }

      for (i = 0; < totalCardCount)
      { // Set priorities for the cards based on unit type.
         string tempString = "";
         int cardPriority = 0;
         int flags = aiHCCardsGetCardFlags(i);
         int unit = aiHCCardsGetCardUnitType(i);
         int tech = aiHCCardsGetCardTechID(i);
         string techName = kbGetTechName(aiHCCardsGetCardTechID(i));
         if (((flags & cHCCardFlagVillager) == cHCCardFlagVillager) || (unit == cUnitTypeSettler) ||
             (unit == cUnitTypeCoureur) || (unit == cUnitTypeSettlerWagon) || (unit == cUnitTypeSettlerNative) ||
             (unit == cUnitTypeypSettlerAsian))
         {
            cardPriority = 8 - aiHCCardsGetCardAgePrereq(i);
            if (cardPriority < 5)
               cardPriority = 5;
            xsArraySetInt(gCardPriorities, i, cardPriority); // Settler card, pri 5-8 depending on age req
         }
         if (xsArrayGetInt(gCardPriorities, i) == 0)
         {
            // Prefer kalmar castle over ship fort wagon card
            if ((unit == cUnitTypeFortWagon) ||
                (unit == cUnitTypeFactoryWagon) ||
                (unit == cUnitTypeypArsenalWagon) ||
                (unit == cUnitTypeYPDojoWagon))
               xsArraySetInt(gCardPriorities, i, 10); // Fort, Factory, Arsenal and Dojo Wagons, pri 7
            if (unit == cUnitTypeBankWagon)
               xsArraySetInt(gCardPriorities, i, 6); // Bank Wagon, pri 6
            if ((unit == cUnitTypeOutpostWagon) || (unit == cUnitTypeYPCastleWagon) ||
                ((xsArrayGetInt(gCardPriorities, i) == 0) && ((flags & cHCCardFlagWagon) == cHCCardFlagWagon)))
            {
               if (btRushBoom <= 0) // Outpost and castle wagon, pri 1 for rushers, pri 5 otherwise
                  xsArraySetInt(gCardPriorities, i, 5);
               else
                  xsArraySetInt(gCardPriorities, i, 1);
            }
         }
         if ((xsArrayGetInt(gCardPriorities, i) == 0) && (unit >= 0))
         { // Some type of unit, pri 6 for resources, 5 for others
            if (((flags & cHCCardFlagResourceCrate) == cHCCardFlagResourceCrate) ||
                (kbProtoUnitIsType(cMyID, unit, cUnitTypeAbstractResourceCrate) == true))
            {
               if ((cMyCiv == cCivPortuguese) && (tech == cTechHCXPEconomicTheory) || (tech == cTechHCShipWoodCrates3) ||
                   (tech == cTechHCShipCoinCrates3))
                  xsArraySetInt(gCardPriorities, i, 7); // Resource crates, 7 for 700 res shipments for portuguese
               else if (aiHCCardsGetCardAgePrereq(i) == cAge1)
                  xsArraySetInt(gCardPriorities, i, 4); // Only pick age1 resources crates when there isn't anything else better
               else
                  xsArraySetInt(gCardPriorities, i, 6); // Resource crates, 6 otherwise
               if ((aiHCCardsGetCardAgePrereq(i) >= cAge3) && (aiHCCardsGetCardCount(i) >= 1))
               { // Demote finite age 3+ resource crate shipments to prio 5-6
                  cardPriority = xsArrayGetInt(gCardPriorities, i);
                  cardPriority = cardPriority - 1;
                  xsArraySetInt(gCardPriorities, i, cardPriority);
               }
            }
            else
               xsArraySetInt(gCardPriorities, i, 5); // Generic unit
         }
         if ((xsArrayGetInt(gCardPriorities, i) == 0) && ((flags & cHCCardFlagUnitUpgrade) == cHCCardFlagUnitUpgrade))
            xsArraySetInt(gCardPriorities, i, 4); // Some type of unit upgrade, prio 4.
         if ((xsArrayGetInt(gCardPriorities, i) == 0) && (flags == 0))
            xsArraySetInt(gCardPriorities, i, 4); // Some type of other upgrade, prio 4.
         if (xsArrayGetInt(gCardPriorities, i) == 0)
            xsArraySetInt(gCardPriorities, i, 3); // ???, prio 3.
         if ((xsArrayGetInt(gCardPriorities, i) == 4) && (unit >= 0) &&
             ((flags & cHCCardFlagResourceCrate) != cHCCardFlagResourceCrate))
         { // Demote shipments of non-mil units to 4; cows, sheep and surgeons to 0.
            if (((flags & cHCCardFlagMilitary) != cHCCardFlagMilitary) &&
                (kbProtoUnitIsType(cMyID, unit, cUnitTypeLogicalTypeLandMilitary) == false))
               xsArraySetInt(gCardPriorities, i, 4);
            if ((kbProtoUnitIsType(cMyID, unit, cUnitTypeHerdable) == true) ||
                (kbProtoUnitIsType(cMyID, unit, cUnitTypeMissionary) == true) ||
                (kbProtoUnitIsType(cMyID, unit, cUnitTypeSurgeon) == true))
               xsArraySetInt(gCardPriorities, i, 0);
         }
         if (unit == gCoveredWagonUnit)
            xsArraySetInt(gCardPriorities, i, 5); // Covered Wagon, pri 5
         // Set priority to 0 for Recruit Wokou Cards
         if ((aiGetWorldDifficulty() >= cDifficultyModerate) &&
             ((xsArrayGetInt(gCardPriorities, i) >= 1) &&
              ((tech == cTechYPHCWokouChinese1) || (tech == cTechYPHCWokouChinese2) ||
               (tech == cTechYPHCWokouChinese3) || (tech == cTechYPHCWokouJapanese1) ||
               (tech == cTechYPHCWokouJapanese2) || (tech == cTechYPHCWokouJapanese3) ||
               (tech == cTechYPHCWokouIndians1) || (tech == cTechYPHCWokouIndians2) ||
               (tech == cTechYPHCWokouIndians3Double))))
            xsArraySetInt(gCardPriorities, i, 0);

         if ((xsArrayGetInt(gCardPriorities, i) == 0) && (xsArrayGetString(gCardStates, i) == "P"))
         { // We own this card, but it's not in the categories above, and won't be flagged when we do our purchases.
            // So, give it a P1 just to distinguish it from others.
            xsArraySetInt(gCardPriorities, i, 1);
         }

         // Raise priority of water related cards and upgrades on water maps.
         if ((xsArrayGetInt(gCardPriorities, i) < 10) &&
             ((gNavyMap == true) &&
              (((flags & cHCCardFlagWater) == cHCCardFlagWater) || (tech == cTechHCCoastalDefensesTeam) ||
               (tech == cTechHCNavalCombat) || (tech == cTechHCNavalCombatGerman) ||
               (tech == cTechYPHCNavalCombatTeam) || (tech == cTechYPHCNavalCombatIndians) ||
               (tech == cTechHCAdmirality) || (tech == cTechHCAdmiralityGerman) ||
               (tech == cTechYPHCAdmiralityIndians) || (tech == cTechHCFishMarket) || (tech == cTechHCFishMarketTeam) ||
               (tech == cTechHCFishMarketGerman) || (tech == cTechYPHCFishMarketIndians) ||
               (tech == cTechypHCFishMarket) || (tech == cTechHCRenderingPlant) ||
               (tech == cTechHCRenderingPlantGerman) || (tech == cTechYPHCRenderingPlantIndians) ||
               (tech == cTechHCCoastalDefensesTeam) ||
               (kbProtoUnitIsType(cMyID, unit, cUnitTypeAbstractWarShip) == true) ||
               (kbProtoUnitIsType(cMyID, unit, cUnitTypeAbstractFishingBoat) == true))))
         {
            cardPriority = xsArrayGetInt(gCardPriorities, i);
            if (cardPriority < 3)
               cardPriority = 3;
            cardPriority = cardPriority + 1;
            if (cardPriority > 10)
               cardPriority = 10;
            xsArraySetInt(gCardPriorities, i, cardPriority);
         }

         if (premadeDeckID >= 0)
         { // Raise priority of cards in premade decks.
            for (premadeCardID = 0; < numCardsPremadeDeck)
            {
               if ((xsArrayGetInt(gCardPriorities, i) < 10) &&
                   (xsArrayGetInt(gPremadeDeckTechIDs, premadeCardID) == tech))
               {
                  cardPriority = xsArrayGetInt(gCardPriorities, i);
                  if (cardPriority < 4)
                     cardPriority = 4;
                  int randInt = -1;
                  if (aiGetWorldDifficulty() >= cDifficultyModerate)
                     randInt = aiRandInt(2);
                  if (((flags & cHCCardFlagTeam) == cHCCardFlagTeam) && (getAllyCount() <= 0))
                     cardPriority = cardPriority + 1 + randInt;
                  else
                     cardPriority = cardPriority + 2 + randInt;
                  if (cardPriority > 10)
                     cardPriority = 10;
                  xsArraySetInt(gCardPriorities, i, cardPriority);
               }
            }
         }

         // Raise priority of cards with infinite use when priority still < 7.
         /*if ((aiGetWorldDifficulty() >= cDifficultyModerate) &&
             ((xsArrayGetInt(gCardPriorities, i) < 7) && (aiHCCardsGetCardCount(i) < 0)))
         {
            cardPriority = xsArrayGetInt(gCardPriorities, i);
            cardPriority = cardPriority + 1;
            if (cardPriority > 10)
               cardPriority = 10;
            xsArraySetInt(gCardPriorities, i, cardPriority);
         }
		 */
		 if ((cMyCiv == cCivOttomans) && (tech == cTechHCShipCoveredWagons2))
                  xsArraySetInt(gCardPriorities, i, 7);
			  
			 if ((techName == "HCRoyalDecreeDutch") ||
                (techName == "HCRoyalDecreeBritish") ||
                (techName == "HCRoyalDecreeFrench") ||
                (techName == "HCRoyalDecreeGerman") ||
                (techName == "HCRoyalDecreeOttoman") ||
                (techName == "HCRoyalDecreePortuguese") ||
                //(techName == "HCShipJanissaries1") ||
                (techName == "HCRoyalDecreeSpanish") ||
                (techName == "DEHCRoyalDecreeSwedish") ||
                (techName == "DEHCPlatoonFire") ||
			    //(techName == "HCShipFoodCrates3") ||
			    //(techName == "HCShipFoodCrates3German") ||
                (techName == "HCShipWoodCrates3") ||
                (techName == "HCShipWoodCrates3German") ||
                (techName == "HCShipCoinCrates3") ||
                (techName == "HCShipCoinCrates3German") ||
                (techName == "HCShipCoinCrates4") ||
                (techName == "HCShipCoinCrates4German") ||
                (techName == "DEHCSnaplocks") ||
                (techName == "DEHCCronstedtReforms") ||
                (techName == "DEHCBlueberries") ||
                (techName == "DEHCBlackberries") ||
                (techName == "DEHCSveaLifeguard") ||
                (techName == "DEHCBeekeepers") ||
                (techName == "DEHCFazogli") ||
                (techName == "DEHCJesuitInfluence") ||
                //(techName == "DEHCLalibelaRockChurch") ||
                (techName == "DEHCChewaWarriors") ||
                (techName == "DEHCZebenyas") ||
                //(techName == "DEHCCartridgeCurrency") ||
                (techName == "DEHCTigrayMekonnen") ||
                (techName == "DEHCGascenyaDamage") ||
                (techName == "DEHCGascenyaHitpoints") ||
                (techName == "DEHCShewaRiders") ||
                (techName == "DEHCFasterTrainingUnitsAfrican") ||
                (techName == "DEHCBalambaras") ||
                (techName == "DEHCFirearmsBritish") ||
                (techName == "DEHCFirearmsItalian") ||
                (techName == "DEHCGondarineArchitecture") ||
                (techName == "DEHCJesuitSpirituality") ||
                (techName == "DEHCAdvancedLivestockMarket") ||
                (techName == "DEHCRoofAfrica") ||
                (techName == "DEHCMercsGatlingCamels") ||
                (techName == "DEHCFulaniPulaakuCode") ||
                (techName == "DEHCFodioTactics") ||
                //(techName == "DEHCDaneGuns") ||
                //(techName == "DEHCSarkinDogarai") ||
                (techName == "DEHCDurbarParade") ||
                (techName == "DEHCSahelianKingdoms") ||
                (techName == "DEHCKolaNutCultivation") ||
                (techName == "DEHCFulaniCattleFertilizer") ||
                (techName == "DEHCRanoIndigoProduction") ||
                (techName == "DEHCTextileWorkshops") ||
                (techName == "DEHCKoose") ||
                (techName == "DEHCHabbanaya") ||
                (techName == "DEHCCounterCavalry") ||
                (techName == "DEHCHandCavalryDamageHausa") ||
                (techName == "DEHCHandCavalryHitpointsHausa") ||
                (techName == "DEHCFulaniArcherCombat") ||
                (techName == "DEHCSveaLifeguard") ||
                (techName == "DEHCSveaLifeguard") ||
                (techName == "DEHCSveaLifeguard") ||
                (techName == "DEHCSveaLifeguard") ||
                //(techName == "DEHCLoyalWarriors") ||
                //(techName == "DEHCKingKings") ||
                (techName == "DEHCTemenyas") ||
                (techName == "DEHCTerraceFarming") ||
                (techName == "DEHCEarlyKallanka") ||
                (techName == "DEHCAutarky") ||
                (techName == "DEHCCaseShot") ||
                //(techName == "YPHCShipUrumi1") ||
                //(techName == "YPHCShipUrumi2") ||
                (techName == "YPHCShipUrumiTeam") ||
                (techName == "YPHCShipUrumiRegiment") ||
                (techName == "HCAdvancedArsenal") ||
                (techName == "HCShipSettlers3") ||
                (techName == "HCShipCoureurs3") ||
                (techName == "HCXPShipVillagers3") ||
                (techName == "HCShipSettlerWagons3") ||
                (techName == "HCShipSettlerWagons4") ||
                (techName == "HCRoyalDecreeFrench") ||
                (techName == "HCXPNewWaysIroquois") ||
                (techName == "HCXPNewWaysSioux") ||
                (techName == "HCShipWoodCrates3") ||
                (techName == "HCShipWoodCrates3German") ||
                (techName == "HCGermantownFarmers") ||
                (techName == "YPHCShipShogunate") ||
                (techName == "YPHCShipDaimyoAizu") ||
                (techName == "HCImprovedLongbows") ||
                (techName == "YPHCShipDaimyoSatsuma")||
                (techName == "HCDuelingSchoolTeam") ||
                (techName == "HCFencingSchool")||
                (techName == "YPHCBannerSchool") ||
                (techName == "YPHCAccupuncture")||
                   (techName == "HCShipWoodCrates3") ||
                   (techName == "ypHCShipWoodCrates2") ||
                   (techName == "ypHCShipWoodCrates4") ||
                   (techName == "HCXPOnikare") ||
                   (techName == "HCXPSiouxNakotaSupport") ||
                (techName == "HCRidingSchool") ||
                (techName == "YPHCFencingSchoolIndians") ||
                (techName == "YPHCRidingSchoolIndians") ||
                (techName == "HCFencingSchoolGerman") ||
                (techName == "HCRidingSchoolGerman") ||
                (techName == "HCRidingSchoolGerman2") ||
				//(techName == "YPHCArtilleryCombatChinese") ||
		        //(techName == "YPHCArtilleryDamageChinese") ||
				(techName == "HCShipWoodCrates3") ||
				(techName == "HCShipWoodCrates4") ||
				(techName == "HCShipWoodCrates3German") ||
                (techName == "YPHCAdvancedConsulate") ||
                (techName == "YPHCAdvancedConsulateIndians") ||
                (techName == "YPHCIncreasedTribute") ||
                //(techName == "YPHCOldHanArmyReforms") ||
                (techName == "HCMercenaryCombatGerman") ||
                (techName == "YPHCWesternReforms") ||
                (techName == "HCRoyalDecreeDutch") ||
                (techName == "HCRoyalDecreeFrench") ||
                (techName == "HCUnlockFactory") ||
                (techName == "HCRobberBarons") ||
                (techName == "HCUnlockFactoryGerman") ||
                (techName == "HCRobberBaronsGerman") ||
                (techName == "HCImprovedLongbows") ||
                (techName == "HCShipCoinCrates3") ||                 
                (techName == "HCShipCoinCrates3German") ||
				(techName == "HCGuildArtisans") ||
                (techName == "HCBanks2") ||
				(techName == "HCBanks1") ||                 
                (techName == "HCXPThoroughbreds") ||
                (techName == "HCCavalryCombatFrench") ||
                (techName == "HCHandCavalryHitpointsFrench") ||
                (techName == "HCHandCavalryDamageFrenchTeam") ||
                (techName == "HCXPKnightCombat") ||
                (techName == "HCXPKnightDamage") ||
                (techName == "HCXPKnightHitpoints") ||
                (techName == "HCXPWarHutTraining") ||
                (techName == "HCXPCavalryDamageIroquois") ||
                (techName == "HCXPInfantryCombatIroquois") ||
                (techName == "HCXPInfantryHitpointsIroquois") ||
                (techName == "HCXPInfantryDamageIroquoisIroquois") ||
                (techName == "HCInfantryCombatDutch") ||
                (techName == "HCInfantryHitpointsDutchTeam") ||
                (techName == "HCInfantryDamageDutch") ||
                (techName == "HCXPSiegeDiscipline") ||
                (techName == "HCXPConservativeTactics") ||         
                (techName == "YPHCTerritorialArmyCombat") ||
                (techName == "YPHCHanAntiCavalryBonus") ||
                (techName == "YPHCForbiddenArmyArmor") ||
                (techName == "YPHCManchuCombat") ||
				(techName == "YPHCYumiDamage") ||
				(techName == "YPHCAshigaruDamage") ||
				//(techName == "YPHCShipAshigaru2") ||
				(techName == "YPHCAshigaruAntiCavalryDamage") ||
				(techName == "YPHCYumiRange") ||
				(techName == "YPHCNaginataAntiInfantryDamage") ||
				(techName == "YPHCNaginataHitpoints") ||
                (techName == "YPHCGurkhaAid") ||                
                (techName == "YPHCEastIndiaCompany") ||
                (techName == "YPHCCamelFrightening") ||
                (techName == "YPHCInfantrySpeedHitpointsTeam") ||
                (techName == "YPHCElephantLimit") ||
				(techName == "YPHCElephantCombatIndians") ||
				(techName == "YPHCElephantTrampling") ||
			    (techName == "YPHCCamelDamageIndians") ||
				(techName == "YPHCMeleeDamageIndians") ||
                (techName == "HCXPCommandSkill") ||	
				(techName == "HCXPCavalryDamageSioux") ||
				(techName == "HCXPCavalryHitpointsSioux") ||
				(techName == "HCXPCavalryCombatSioux") ||
				(techName == "HCXPMustangs") ||
                (techName == "HCXPSiouxYanktonSupport") ||
                (techName == "HCXPSiouxSanteeSupport") ||
				(techName == "HCXPInfantryDamageIroquois") ||
				(techName == "HCXPInfantryHitpointsIroquois") ||		 		
				(techName == "HCXPCavalryHitpointsIroquois") ||
				(techName == "HCXPSiegeCombat") ||		
				(techName == "HCXPKnightDamage") ||		
				(techName == "HCImprovedBuildings") ||
				(techName == "ypHCImprovedBuildings") ||
				(techName == "YPHCImprovedBuildingsTeam") ||		
				(techName == "HCImprovedBuildingsGerman") ||		 
				(techName == "HCXPKnightHitpoints") ||
				//(techName == "HCXPScorchedEarth") ||
				(techName == "HCXPTempleCenteotl") ||
				(techName == "HCXPTempleCenteotl") || 
				(techName == "HCXPTempleXipeTotec") || 
				(techName == "HCXPTempleTlaloc") || 
				(techName == "HCXPGreatTempleQuetzalcoatl") || 
                (techName == "HCMusketeerGrenadierHitpointsBritishTeam") ||                 
				(techName == "HCCavalryCombatBritish") ||
				(techName == "HCMusketeerGrenadierDamageBritish") ||
				(techName == "HCMusketeerGrenadierCombatBritish") ||
				(techName == "HCCavalryDamageBritish") ||
				(techName == "HCCavalryHitpointsBritish") ||
				(techName == "HCRangedInfantryDamageFrenchTeam") ||
                (techName == "HCWildernessWarfare") ||		 
				(techName == "HCHandCavalryHitpointsFrench") ||		                  
                (techName == "HCJanissaryCost") ||
				(techName == "HCJanissaryCombatOttoman") ||
				(techName == "HCCavalryCombatOttoman") ||
				(techName == "HCArtilleryDamageOttoman") ||
                (techName == "HCRangedInfantryHitpointsPortugueseTeam") ||
                (techName == "HCRangedInfantryDamagePortuguese") ||
				(techName == "HCRangedInfantryCombatPortuguese") ||
				(techName == "HCDragoonCombatPortuguese") ||
				(techName == "HCXPGenitours") ||
                (techName == "HCRoyalDecreeDutch") ||
                (techName == "HCDutchEastIndiaCompany") ||
				(techName == "HCInfantryDamageDutch") ||
				(techName == "HCInfantryCombatDutch") ||
				(techName == "HCCavalryCombatDutch") ||	 
				(techName == "HCBetterBanks") ||
                (techName == "HCStreletsCombatRussian") ||
				//(techName == "HCRansack") ||
				(techName == "HCCavalryCombatRussian") ||
				(techName == "HCUniqueCombatRussian") ||
                (techName == "HCXPIndustrialRevolution") ||
				//(techName == "HCHandInfantryHitpointsSpanish") || 
                //(techName == "HCHandInfantryDamageSpanishTeam") ||
                //(techName == "HCHandInfantryCombatSpanish") ||
				(techName == "HCHandCavalryCombatSpanish") ||
				(techName == "HCCaballeros") ||
				(techName == "HCHandCavalryDamageSpanish") ||
				(techName == "HCHandCavalryHitpointsSpanish") ||  
				(techName == "HCCavalryCombatGerman") ||
				(techName == "HCCavalryHitpointsGerman") ||
				(techName == "HCUhlanCombatGerman") ||
				(techName == "HCShipFalconets3") ||
                (techName == "HCCavalryDamageGermanTeam")||   
                (techName == "YPHCAdvancedConsulate") ||      
				//((kbGetCiv() != cCivXPIroquois) && (techName == "HCShipWoodCrates1")) ||
		 (techName == "YPHCAccupuncture") ||
		 (techName == "YPHCBannerSchool") ||
                 (techName == "YPHCAgrarianism") ||
                 (techName == "YPHCIncreasedTribute") ||
                 (techName == "YPHCFencingSchoolIndians") ||
                 (techName == "YPHCRidingSchoolIndians") ||
                 (techName == "HCRidingSchool") ||
                 (techName == "HCFencingSchool") ||
                 (techName == "HCXPMustangs") ||
                 (techName == "HCFencingSchoolGerman") ||
                 (techName == "HCRidingSchoolGerman") ||
                 (techName == "YPHCShipWoodCratesInf4Indians") ||
                 (gNavyMap == true) && ((techName == "YPHCAdmiralityIndians") ||
                 (gNavyMap == true) && (techName == "HCAdmirality")) ||
                 //(techName == "YPHCOldHanArmyReforms") ||
                 (techName == "YPHCWesternReforms") ||
                 (techName == "HCRoyalDecreeDutch") ||
                 (techName == "HCRoyalDecreeFrench") ||
                 (techName == "HCUnlockFactory") ||
                 (techName == "HCRobberBarons") ||
                 (techName == "HCUnlockFactoryGerman") ||
                 (techName == "HCRobberBaronsGerman") ||
                 (techName == "HCImprovedLongbows") ||
                 (techName == "HCShipCoinCrates3") ||                 
                 (techName == "HCShipCoinCrates3German") ||
                 //(techName == "HCXPColbertism") ||
                 (techName == "HCGermantownFarmers") ||
                 (techName == "HCXPCapitalism") ||
		 (techName == "HCGuildArtisans") ||
                 //((civIsAsian() == false) && (techName == "HCXPLandGrab")) ||
                 (techName == "HCBanks2") ||
		 (techName == "HCBanks1") ||                 
                 (techName == "HCXPThoroughbreds") ||
                 (techName == "HCCavalryCombatFrench") ||
                 (techName == "HCHandCavalryDamageFrenchTeam") ||
                 //(techName == "HCXPChinampa2") ||
		 //(techName == "HCXPChinampa1") ||
                 (techName == "HCXPKnightCombat") ||
                 (techName == "HCXPWarHutTraining") ||
                 (techName == "HCXPCavalryDamageIroquois") ||
                 (techName == "HCXPInfantryCombatIroquois") ||
                 (techName == "HCXPSiegeDiscipline") ||
                 (techName == "HCXPGreatHouse") ||
                 (techName == "HCXPConservativeTactics") ||     
                 (techName == "YPHCTerritorialArmyCombat") ||
                 (techName == "YPHCHanAntiCavalryBonus") ||
                 (techName == "YPHCForbiddenArmyArmor") ||
                 (techName == "YPHCManchuCombat") ||
                 ((getAllyCount() > 0) && (techName == "YPHCChonindoTeam")) ||
		 (techName == "YPHCYumiDamage") ||
		 (techName == "YPHCAshigaruDamage") ||
		 (techName == "YPHCAshigaruAntiCavalryDamage") ||
		 (techName == "YPHCYumiRange") ||
		 (techName == "YPHCNaginataAntiInfantryDamage") ||
		 (techName == "DEHCMonumentalArchitecture") ||
		 (techName == "YPHCAdvancedConsulateIndians") ||
		 //(techName == "YPHCShipWoodCrates1Indians") ||
		 (techName == "YPHCShipWoodCrates2Indians") ||
		 (techName == "YPHCShipUrumiRegiment") ||
		 //(techName == "YPHCYabusameDamage") ||
                 (techName == "YPHCGurkhaAid") ||                
                 (techName == "YPHCEastIndiaCompany") ||
                 (techName == "YPHCCamelFrightening") ||
                 (getAllyCount() > 0) && ((techName == "YPHCRainbowTrickleTeam") ||
                 (techName == "YPHCInfantrySpeedHitpointsTeam")) ||
		 (techName == "YPHCElephantCombatIndians") ||
		 (techName == "YPHCElephantTrampling") ||
		 (techName == "YPHCCamelDamageIndians") ||
		 (techName == "YPHCMeleeDamageIndians") ||
                 (techName == "HCXPEarthBounty") ||
                 (techName == "HCXPCommandSkill") ||
		 (techName == "HCXPWarChiefSioux1") ||		 
		 (techName == "HCXPNewWaysSioux") ||
		 //(techName == "HCXPShipWarHutTravois1") ||
		 (techName == "HCXPCavalryDamageSioux") ||
		 (techName == "HCXPCavalryHitpointsSioux") ||
		 (techName == "HCXPCavalryCombatSioux") ||
                 (techName == "HCXPSiouxYanktonSupport") ||
                 (techName == "HCXPSiouxSanteeSupport") ||
                 (techName == "HCXPWarChiefIroquois2") ||
		 (techName == "HCXPWarChiefIroquois1") ||
		 (techName == "HCXPNewWaysIroquois") ||		 
		 (techName == "HCXPInfantryDamageIroquois") ||
		 (techName == "HCXPInfantryHitpointsIroquois") ||		 		
		 (techName == "HCXPCavalryHitpointsIroquois") ||
		 (techName == "HCXPSiegeCombat") ||		 
		 (techName == "HCXPStoneTowers") ||
                 (techName == "HCXPWarChiefAztec1") ||
		 (techName == "HCXPKnightDamage") ||		 
		 (techName == "HCXPKnightHitpoints") ||
		 //(techName == "HCXPScorchedEarth") ||
		 //(techName == "HCXPRuthlessness") ||
		 (techName == "HCXPTempleXolotl") || 
                 ((getAllyCount() > 0) && (gNavyMap == true) && (techName == "HCCheapDocksTeam")) ||
                 ((getAllyCount() > 0) && (gNavyMap == true) && (techName == "HCFishMarketTeam")) ||
                 ((getAllyCount() > 0) && (techName == "HCMusketeerGrenadierHitpointsBritishTeam")) ||                 
		 (techName == "HCCavalryCombatBritish") ||
		 (techName == "HCMusketeerGrenadierDamageBritish") ||
		 (techName == "HCMusketeerGrenadierCombatBritish") ||
		 (techName == "HCCavalryDamageBritish") ||
		 (techName == "HCCavalryHitpointsBritish") ||
                 ((getAllyCount() > 0) && (techName == "HCRangedInfantryDamageFrenchTeam")) ||
                 (techName == "HCWildernessWarfare") ||		 
		 (techName == "HCHandCavalryHitpointsFrench") ||		                  
                 (techName == "HCJanissaryCost") ||
		 (techName == "HCJanissaryCombatOttoman") ||
		 (techName == "HCCavalryCombatOttoman") ||
		 (techName == "HCArtilleryDamageOttoman") ||
                 (techName == "HCRangedInfantryDamagePortuguese") ||
		 (techName == "HCRangedInfantryCombatPortuguese") ||
		 (techName == "HCDragoonCombatPortuguese") ||
		 (techName == "HCXPGenitours") ||
                 ((gNavyMap == true) && (techName == "HCNavigationSchool")) ||
                 (techName == "HCRoyalDecreeDutch") ||
                 (techName == "HCDutchEastIndiaCompany") ||
		 (techName == "HCInfantryDamageDutch") ||
		 (techName == "HCInfantryCombatDutch") ||
		 (techName == "HCCavalryCombatDutch") ||
		 //((gNavyMap == false) && (techName == "HCXPMilitaryReforms")) ||		 
		 (techName == "HCBetterBanks") ||
                 (techName == "HCStreletsCombatRussian") ||
		 //(techName == "HCRansack") ||
                 ((gNavyMap == true) && (getAllyCount() > 0) && (techName == "HCColdWaterPortTeam")) ||
		 (techName == "HCSpawnStrelet") ||
		 (techName == "HCCavalryCombatRussian") ||
		 (techName == "HCUniqueCombatRussian") ||
                 (techName == "HCXPIndustrialRevolution") ||
                 //((gNavyMap == false) && (techName == "HCXPSevastopol")) ||
                 ((getAllyCount() > 0) && (techName == "HCDuelingSchoolTeam")) ||
                 ((getAllyCount() > 0) && (techName == "HCArchaicTrainingTeam")) ||
		 (techName == "HCDuelingSchoolTeam") ||   
		 //(techName == "HCHandInfantryHitpointsSpanish")) ||   
                 //(techName == "HCHandInfantryDamageSpanishTeam")) ||
                 //(techName == "HCHandInfantryCombatSpanish") ||
                 ((gNavyMap == true) && (techName == "HCArmada")) ||
		 (techName == "HCHandCavalryCombatSpanish") ||
		 (techName == "HCCaballeros") ||
		 (techName == "HCHandCavalryDamageSpanish") ||
		 (techName == "HCHandCavalryHitpointsSpanish") ||              
		 (techName == "HCTextileMillsGerman") || 
		 (techName == "HCCavalryCombatGerman") ||
		 (techName == "HCCavalryHitpointsGerman") ||
		 (techName == "DEHCChasquisMessengers") ||
		 (techName == "HCXPExtensiveFortificationsAztec") ||
		 (techName == "YPHCMongolianScourge") ||
		 (techName == "HCXPShipMixedCrates2") ||
         ((getAllyCount() > 0) && (techName == "HCShipSpahisTeam")) ||
         ((getAllyCount() > 0) && (techName == "DEHCFalunMineTeam")) ||
		 (techName == "HCShipSpahis3") ||
		 //(techName == "HCSilkRoadTeam") ||
		 //(techName == "HCShipSpahis2") ||
		       (techName == "YPHCShipBerryWagon2") ||
		       (techName == "YPHCShipGroveWagonIndians2") ||
		       (techName == "DEHCKosciuszkoFortifications") ||
		       (techName == "DEHCShipCapturedRockets") ||
		       (techName == "DEHCImmigrantsDutch") ||
			   (techName == "DEHCBuffaloSoldiers") ||
			   (techName == "DEHCKnoxArtilleryTrain") ||
		       (techName == "DEHCGermanMercenaryContracts") ||
		       (techName == "DEHCFinnhorses") ||
			   //(techName == "DEHCHandUnitDamage") ||
		       //(techName == "DEHCHandUnitHitpoints") ||
		       (techName == "DEHCHeavyInfHitpointsTeam") ||
		       (techName == "DEHCRangedCavalryCombat") ||
		       (techName == "DEHCContinentalRangers") ||
		       (techName == "DEHCSpringfieldArmory") ||
		       (techName == "DEHCLegionHungarian") ||
		       (techName == "DEHCRegularCombat") ||
     		       (techName == "DEHCTrainTimeUS") ||
     		       (techName == "DEHCCurare") ||
     		       //(techName == "DEHCChachapoyaSupport") ||
     		       (techName == "DEHCChimuSupport") ||
     		       //(techName == "DEHCCanariSupport") ||
     		       //(techName == "DEHCAymaraSupport") ||
     		       (techName == "DEHCCajamarcaSupport") ||
     		       (techName == "DEHCCollaSupport") ||
     		       (techName == "DEHCWarChiefInca1") ||
     		       (techName == "DEHCWarChiefInca2") ||
                   (techName == "HCShipWoodCrates3") ||
                   (techName == "HCXPNationalRedoubt") ||
                   (techName == "DEHCShipJanissariesRepeat") ||
                   (techName == "HCShipWoodCrates3") ||
                (techName == "HCUnlockFactory") ||
                (techName == "HCRobberBarons") ||
		 (techName == "HCXPShipTomahawk1") ||
		 (techName == "HCXPShipAennas2") ||
		 (techName == "HCXPShipAennas5") ||
		 (techName == "HCShipCrossbowmen3German") ||
         (techName == "HCXPShipMacehualtins1") ||
         (techName == "HCXPShipMacehualtins3") ||
				(techName == "DEHCShipLeatherCannons1") ||
                 ((gNavyMap == true) && (techName == "HCSchooners")) ||
                 ((gNavyMap == true) && (techName == "YPHCSchoonersIndians")) ||
                 ((gNavyMap == true) && (techName == "YPHCSchoonersJapanese")) ||
                 ((gNavyMap == true) && (getAllyCount() > 0) && (techName == "HCXPCheapFishingBoatTeam")) ||
                 ((getAllyCount() > 0) && (techName == "HCCavalryDamageGermanTeam")) ||                 
                 ((gNavyMap == true) && (techName == "HCAdmiralityGerman")))  
            xsArraySetInt(gCardPriorities, i, 10);
			
			
			// Raise priority of specific cards important to the AI. Rush version
         if (
		     ((xsArrayGetInt(gCardPriorities, i) < 7) &&
		      ((techName == "YPHCShipQiangPikeman2") ||
		       (techName == "HCExtensiveFortifications") ||
		       (techName == "HCXPExtensiveFortifications2") ||
		       (techName == "YPHCShipChuKoNu1") ||
		       (techName == "YPHCShipMandarinDuckSquad") ||
		       (techName == "HCShipCrossbowmen1") ||
		       //(techName == "HCShipPikemen1") ||
		       (techName == "YPHCShipSepoy1") ||
                //(techName == "DEHCSveaLifeguard") ||
               (techName == "DEHCShipSudaneseAllies1") ||
               (techName == "DEHCShipSudaneseAllies2") ||
               (techName == "DEHCShipSebastopolMortarTeam") ||
               (techName == "DEHCShipSebastopolMortar1") ||
               (techName == "DEHCShipSebastopolMortar2") ||
               (techName == "DEHCMercsSennarHorsemen") ||
               (techName == "DEHCMercsDahomeyAmazons") ||
               (techName == "DEHCMercsCannoneers") ||
               (techName == "YPHCShipYumi1") ||
		       (techName == "YPHCShipAshigaru2") ||
		       (techName == "HCShipCossacks4") ||
		       (techName == "HCShipStrelets1") ||
		       (techName == "HCShipUhlans1") ||
               (techName == "YPHCShipSettlersAsian2") ||
		       (techName == "YPHCShipSettlersAsian1") ||
		       (techName == "HCShipCoureurs2") ||
		       (techName == "DEHCShipVillagers4") ||
		       (techName == "HCXPShipVillagers2") ||
                (techName == "HCShipSettlers2") ||
               (techName == "HCShipSettlers4") ||
		       (techName == "HCXPShipVillagers4") ||
		       (techName == "DEHCShipVillagers2") ||
		       (techName == "DEHCShipVillagers4") ||
		       (techName == "HCXPShipVillagers2") ||
                (techName == "HCXPShipVillagers4") ||
                (techName == "HCXPShipVillagers4") ||
		       (techName == "HCXPShipVillagers4"))))
		 {
		    cardPriority = xsArrayGetInt(gCardPriorities, i);
		    if (cardPriority < 7)
		       cardPriority = 7;
		    if (cardPriority > 7)
		       cardPriority = 7;
		    xsArraySetInt(gCardPriorities, i, cardPriority);
		 }
			
			if (getAllyCount() > 0)
         { // Raise priority of TEAM cards when we have an ally.
            if ((xsArrayGetInt(gCardPriorities, i) < 10) && ((flags & cHCCardFlagTeam) == cHCCardFlagTeam))
            {
               cardPriority = xsArrayGetInt(gCardPriorities, i);
               if (getAllyCount() > 1)
                  cardPriority = cardPriority + 1; // +2 for 2+ allies
               else
                  cardPriority = cardPriority + 0; // +1 for 1 ally
               if (cardPriority > 10)
                  cardPriority = 10;
               xsArraySetInt(gCardPriorities, i, cardPriority);
            }
         }
         else
         { // Decrease priority of TEAM cards without ally.
            if ((xsArrayGetInt(gCardPriorities, i) > 0) && ((flags & cHCCardFlagTeam) == cHCCardFlagTeam))
            {
               cardPriority = xsArrayGetInt(gCardPriorities, i);
               cardPriority = cardPriority - 2;
               if (cardPriority < 0)
                  cardPriority = 0;
               xsArraySetInt(gCardPriorities, i, cardPriority);
            }
         }
			
         if ((aiGetWorldDifficulty() >= cDifficultySandbox) &&
		     ((xsArrayGetInt(gCardPriorities, i) >= 1) &&
		      ((techName == "HCFrontierDefenses2") ||
	           (techName == "HCShipCoveredWagons2") ||
	           (techName == "HCConestogaWagonsTeam") ||
	           (techName == "HCBastionsTeam") ||
	           (techName == "HCShipHussars1") ||
	           //(techName == "HCUnlockFortVauban") ||
	           //(techName == "HCXPUnlockFort2") ||
	           //(techName == "HCXPUnlockFort2German") ||
	           (techName == "HCShipFalconets1German") ||
	           (techName == "HCShipMortars1") ||
	           (techName == "HCShipPikemen1") ||
	           (techName == "HCMosqueConstruction") ||
	           (techName == "DEHCShipBolasWarriorsRepeat") ||
	           (techName == "DEHCShipIncaRunnersRepeat") ||
	           (techName == "HCShipMortars2") ||
				(techName == "HCHandInfantryHitpointsSpanish") || 
                (techName == "HCHandInfantryDamageSpanishTeam") ||
                (techName == "HCHandInfantryCombatSpanish") ||
	           (techName == "HCXPSuvorovReforms") ||
	           (techName == "YPHCBannerReforms") ||
	           (techName == "DEHCShipFatLlamas1") ||
	           (techName == "YPHCSpawnSaigaHerd") ||
	           (techName == "HCXPWarChiefSioux2") ||
	           (techName == "HCNativeCombat") ||
	           (techName == "HCNativeTreaties") ||
	           (techName == "DEHCImmigrantsIrish") ||
		       (techName == "DEHCLongRifles") ||
	           (techName == "HCNativeTreatiesGerman") ||
	           (techName == "DEHCShipDragoonsRepeat") ||
	           (techName == "HCShipMortars1German") ||
	           (techName == "HCShipMortars2German") ||
	           (techName == "HCShipMortarsTeam") ||
	           (techName == "HCXPShipPetards1") ||
	           (techName == "HCXPShipDemolitionSquadGerman") ||
	           (techName == "HCXPShipRams1") ||
	           (techName == "HCXPIroquoisMohawkSupport") ||
	           (techName == "HCXPShipSiege") ||
	           (techName == "HCXPShipSpies1") ||
	           (techName == "HCXPShipSpies2") ||
	           (techName == "HCXPShipSpies3") ||
	           (techName == "HCXPShipSpies1German") ||
	           (techName == "HCXPShipSpiesTeam") ||
	           (techName == "HCXPGreatTempleTezcatlipoca") ||
	           (techName == "HCXPShipBears") ||
	           (techName == "HCXPShipBearsTeam") ||
	           (techName == "HCHouseEstates") ||
	           (techName == "HCXPShipCougars") ||
	           (techName == "HCXPShipCoyotes") ||
	           (techName == "HCXPShipCoyotesTeam") ||
	           (techName == "HCXPShipGrizzlies") ||
	           (techName == "HCXPShipJaguars1") ||
	           (techName == "HCXPShipJaguars2") ||
	           (techName == "HCXPShipJaguars3") ||
	           (techName == "HCXPShipJaguarsTeam") ||
	           (techName == "HCXPShipWolves") ||
	           (techName == "HCXPWarChiefIroquois2") ||
	           (techName == "HCXPCoinCratesAztec4") ||
	           (techName == "HCXPCoinCratesAztec5") ||
	           (techName == "HCXPShipMixedCrates4") ||
               (techName == "YPHCShipMonitorLizard1") ||
               (techName == "YPHCShipMonitorLizard2") ||
	           (techName == "YPHCShipWoodCratesInf1Indians") ||
	           (techName == "YPHCShipWoodCratesInf2Indians") ||
	           (techName == "YPHCShipWoodCratesInf3Indians") ||
	           (techName == "YPHCShipWoodCratesInf4Indians") ||
	           (techName == "YPHCShipCoveredWagonsChina") ||
	           (techName == "YPHCShipCoveredWagons2Indians") ||
	           (techName == "YPHCSacredFieldHealing") ||
	           (techName == "YPHCBazaar") ||
	           (techName == "YPHCExpandedMarket") ||
	           (techName == "YPHCCommoditiesMarket") ||
	           (techName == "YPHCAdvancedMonastery") ||
	           (techName == "YPHCAdvancedMonasteryIndians") ||
		  	   (techName == "YPHCShipRhino1") ||
	           (techName == "HCXPSilentStrike") ||
	           (techName == "HCXPDanceHall") ||
	           (techName == "DEHCShipWoodCratesInfInca") ||
	           //(techName == "DEHCMachuPicchu") ||
	           (techName == "HCXPDanceHallGerman") ||
			   (techName == "HCEarlyDragoonsTeam") ||
	           //(techName == "YPHCShipBerryWagon1") ||
	           //(techName == "YPHCShipBerryWagon2") ||
			   (techName == "YPHCShipSettlersAsian1") ||
	           (techName == "YPHCShipMongolScoutTeam") ||
	           //(techName == "YPHCShipRicePaddyWagon1") ||
	           //(techName == "YPHCShipRicePaddyWagon2") ||
	           //(techName == "YPHCShipRicePaddyWagon3") ||
	           (techName == "YPHCShipMorutaru1") ||
			   //(techName == "HCXPEconomicTheory") ||
			   (techName == "HCShipFoodCrates1") ||
			   (techName == "HCShipCoinCrates1") ||
			   (techName == "HCXPBuffaloTeam") ||
			   (techName == "HCXPAdoption") ||
			   //(techName == "DEHCSeasonalLaborTeam") ||
			   (techName == "YPHCSpawnRefugees1") ||
			   (techName == "YPHCSpawnRefugees2") ||
			   (techName == "YPHCSpawnMigrants1") ||
			   (techName == "HCXPShipTradingPostTravois") ||
			   (techName == "HCXPShipDogsoldiers3") ||
		       (techName == "HCXPTownDance") ||
		       (techName == "HCXPShipAxeRidersRepeat") ||
			   (techName == "HCXPScorchedEarth") ||
			   (techName == "HCXPImprovedGrenades") ||
			   (techName == "HCShipSurgeons") ||
			   (techName == "HCXPRuthlessness") ||
			   (techName == "HCShipBandeirantes") ||
		       (techName == "HCXPGreatHunter") ||
	           (techName == "YPHCShipMorutaru2"))))
         { // Decrease priority of specific cards to be avoided.
            cardPriority = xsArrayGetInt(gCardPriorities, i);
            cardPriority = cardPriority - 4;
            if (cardPriority < 0)
               cardPriority = 0;
            xsArraySetInt(gCardPriorities, i, cardPriority);
         }
         else if ((aiGetWorldDifficulty() >= cDifficultyModerate) &&
                  ((xsArrayGetInt(gCardPriorities, i) >= 6) && (tech == cTechHCXPCoinCratesAztec2)))
         { // Slightly decrease priority of other specific cards if rated too highly.
            cardPriority = xsArrayGetInt(gCardPriorities, i);
            cardPriority = cardPriority - 1;
            xsArraySetInt(gCardPriorities, i, cardPriority);
         }
         else if ((aiGetWorldDifficulty() >= cDifficultyModerate) && (aiHCCardsGetCardAgePrereq(i) >= cAge3))
         { // Decrease priority of archaic soldier cards from age 3 and up.
            if ((xsArrayGetInt(gCardPriorities, i) >= 1) && ((aiHCCardsGetCardUnitType(i) == cUnitTypePikeman) ||
            (aiHCCardsGetCardUnitType(i) == cUnitTypeCrossbowman) ||
            (aiHCCardsGetCardUnitType(i) == cUnitTypeLongbowman) ||
            (aiHCCardsGetCardUnitType(i) == cUnitTypeStrelet) ||
            (aiHCCardsGetCardUnitType(i) == cUnitTypeypYumi) ||
            (aiHCCardsGetCardUnitType(i) == cUnitTypeypQiangPikeman) ||
            (aiHCCardsGetCardUnitType(i) == cUnitTypeAbstractHealer) ||
            (aiHCCardsGetCardUnitType(i) == cUnitTypeAbstractPet) ||
            (aiHCCardsGetCardUnitType(i) == cUnitTypeypChuKoNu)))
            {
               cardPriority = xsArrayGetInt(gCardPriorities, i);
               cardPriority = cardPriority - 3;
               if (cardPriority < 0)
                  cardPriority = 0;
               xsArraySetInt(gCardPriorities, i, cardPriority);
            }
         }
		 
			if ((xsArrayGetInt(gCardPriorities, i) >= 1) && ((aiHCCardsGetCardUnitType(i) == cUnitTypeAbstractHealer) ||
                                                             (aiHCCardsGetCardUnitType(i) == cUnitTypeAbstractPet)))
            {
               cardPriority = xsArrayGetInt(gCardPriorities, i);
               cardPriority = cardPriority - 4;
               if (cardPriority < 0)
                  cardPriority = 0;
               xsArraySetInt(gCardPriorities, i, cardPriority);
            }

         
		 
		 if (aiHCCardsGetCardAgePrereq(i) >= cAge3)
		 {  // Decrease priority of archaic soldier cards from age 3 and up.
		    if ((xsArrayGetInt(gCardPriorities, i) >= 1) &&
			    ((aiHCCardsGetCardUnitType(i) == cUnitTypePikeman) ||
		         (aiHCCardsGetCardUnitType(i) == cUnitTypeCrossbowman) ||
		         (aiHCCardsGetCardUnitType(i) == cUnitTypeLongbowman) ||
		         (aiHCCardsGetCardUnitType(i) == cUnitTypeStrelet) ||
		         (aiHCCardsGetCardUnitType(i) == cUnitTypeypYumi) ||
		         (aiHCCardsGetCardUnitType(i) == cUnitTypeDragoon) ||
		         (aiHCCardsGetCardUnitType(i) == cUnitTypeypSiegeElephant) ||
		         (aiHCCardsGetCardUnitType(i) == cUnitTypeypQiangPikeman) ||
		         (aiHCCardsGetCardUnitType(i) == cUnitTypeypChuKoNu)))
			{
		    cardPriority = xsArrayGetInt(gCardPriorities, i);
		    cardPriority = cardPriority - 3;
		    if (cardPriority < 0)
		       cardPriority = 0;
		    xsArraySetInt(gCardPriorities, i, cardPriority);
			}
		 }
		 
		 if ((xsArrayGetInt(gCardPriorities, i) >= 1) &&
			    ((aiHCCardsGetCardUnitType(i) == cUnitTypeAbstractHealer) ||
		         (aiHCCardsGetCardUnitType(i) == cUnitTypeAbstractPet) ||
		         (aiHCCardsGetCardUnitType(i) == cUnitTypedeMaceman) ||
		         (aiHCCardsGetCardUnitType(i) == cUnitTypexpSkullKnight) ||
		         (aiHCCardsGetCardUnitType(i) == cUnitTypedeShotelWarrior) ||
		         (aiHCCardsGetCardUnitType(i) == cUnitTypedeOromoWarrior) ||
		         (aiHCCardsGetCardUnitType(i) == cUnitTypeypRajput) ||
		         (aiHCCardsGetCardUnitType(i) == cUnitTypedeRifleman) ||
		         (aiHCCardsGetCardUnitType(i) == cUnitTypeSurgeon)))
			{
		    cardPriority = xsArrayGetInt(gCardPriorities, i);
		    cardPriority = cardPriority - 6;
		    if (cardPriority < 0)
		       cardPriority = 0;
		    xsArraySetInt(gCardPriorities, i, cardPriority);
			}
			
			if (((xsArrayGetInt(gCardPriorities, i) < 10) &&
		      ((techName == "HCRoyalMint") ||
		       (techName == "HCRoyalMintGerman") ||
		       (techName == "YPHCRoyalMintIndians") ||
		       (techName == "HCXPAztecMining") ||
		       //(techName == "HCXPChinampa1") ||
		       (techName == "HCXPChinampa2") ||
               (techName == "DEHCSveaLifeguard") ||
		       (techName == "HCRefrigeration") ||
		       (techName == "HCXPEconomicTheory") ||
		       (techName == "DEHCCoffeeConsumption") ||
		       (techName == "HCShipCossacks4") ||
		       (techName == "HCXPExtensiveFortifications2") ||
                (techName == "DEHCSveaLifeguard") ||
		       (techName == "HCShipStrelets1") ||
		       (techName == "HCRefrigerationGerman"))))
		 {
		    cardPriority = xsArrayGetInt(gCardPriorities, i);
		    if (cardPriority < 7)
		       cardPriority = 7;
		    cardPriority = cardPriority + 1;
		    if (cardPriority > 10)
		       cardPriority = 10;
		    xsArraySetInt(gCardPriorities, i, cardPriority);
		 }
		 
		/*
         if (btBiasNative >= 0.5)
         { // Raise priority of native related cards when we have a native bias.
            if ((xsArrayGetInt(gCardPriorities, i) < 10) && (tech == cTechHCXPBloodBrothers) ||
                (tech == cTechHCXPBloodBrothersGerman) || (tech == cTechHCNativeLore) ||
                (tech == cTechHCNativeLoreGerman) || (tech == cTechHCNativeTreaties) ||
                (tech == cTechHCNativeTreatiesGerman) || (tech == cTechHCNativeWarriors) ||
                (tech == cTechHCNativeWarriorsGerman) || (tech == cTechHCNativeCombat) ||
                (tech == cTechHCNativeCombatTeam) ||
                //(tech == cTechYPHCNativeTradeTax) ||
                //(tech == cTechYPHCNativeTradeTaxIndians) ||
                (tech == cTechYPHCNativeLearning) || (tech == cTechYPHCNativeLearningIndians) ||
                (tech == cTechYPHCNativeDamage) || (tech == cTechYPHCNativeDamageIndians) ||
                (tech == cTechYPHCNativeHitpoints) || (tech == cTechYPHCNativeHitpointsIndians) ||
                (tech == cTechYPHCNativeIncorporation) || (tech == cTechYPHCNativeIncorporationIndians) ||
                (tech == cTechHCWildernessWarfare) || (tech == cTechHCXPBlackArrow) ||
                (tech == cTechHCNativeChampionsDutchTeam))
            {
               cardPriority = xsArrayGetInt(gCardPriorities, i);
               cardPriority = cardPriority + 1;
               if (cardPriority > 10)
                  cardPriority = 10;
               xsArraySetInt(gCardPriorities, i, cardPriority);
            }
         }
         else if (btBiasNative <= -0.5)
         { // Decrease priority of native related cards when we have a native aversion.
            if ((xsArrayGetInt(gCardPriorities, i) > 0) && (tech == cTechHCXPBloodBrothers) ||
                (tech == cTechHCXPBloodBrothersGerman) || (tech == cTechHCNativeLore) ||
                (tech == cTechHCNativeLoreGerman) || (tech == cTechHCNativeTreaties) ||
                (tech == cTechHCNativeTreatiesGerman) || (tech == cTechHCNativeWarriors) ||
                (tech == cTechHCNativeWarriorsGerman) || (tech == cTechHCNativeCombat) ||
                (tech == cTechHCNativeCombatTeam) || (tech == cTechYPHCNativeTradeTax) ||
                (tech == cTechYPHCNativeTradeTaxIndians) || (tech == cTechYPHCNativeLearning) ||
                (tech == cTechYPHCNativeLearningIndians) || (tech == cTechYPHCNativeDamage) ||
                (tech == cTechYPHCNativeDamageIndians) || (tech == cTechYPHCNativeHitpoints) ||
                (tech == cTechYPHCNativeHitpointsIndians) || (tech == cTechYPHCNativeIncorporation) ||
                (tech == cTechYPHCNativeIncorporationIndians) ||
                //(tech == cTechHCWildernessWarfare) ||
                (tech == cTechHCXPBlackArrow) || (tech == cTechHCNativeChampionsDutchTeam))
            {
               cardPriority = xsArrayGetInt(gCardPriorities, i);
               cardPriority = cardPriority - 1;
               if (cardPriority < 0)
                  cardPriority = 0;
               xsArraySetInt(gCardPriorities, i, cardPriority);
            }
         }
		*/
		
         /*if (btBiasTrade >= 0.5)
          {  // Raise priority of trade related cards when we have a trade bias.
              if ((xsArrayGetInt(gCardPriorities, i) < 10) &&
               //(unit == cUnitTypeypTradingPostWagon) ||
               //(unit == cUnitTypeTradingPostTravois) ||
                 //(tech == cTechYPHCExpandedTradingPost) ||
                 //(tech == cTechYPHCExpandedTradingPostIndians) ||
                 //(tech == cTechHCXPShipTradingPostTravois) ||
                 //(tech == cTechDEHCShipTamboTravois) ||
                 (tech == cTechDEHCAdvancedTambos) ||
                 (tech == cTechHCAdvancedTradingPost) ||
                 (tech == cTechHCCheapTradingPostTeam))
            {
               cardPriority = xsArrayGetInt(gCardPriorities, i);
               cardPriority = cardPriority + 1;
               if (cardPriority > 10)
                  cardPriority = 10;
               xsArraySetInt(gCardPriorities, i, cardPriority);
            }
          }
         else if (btBiasTrade <= -0.5)
         { // Decrease priority of trade related cards when we have a trade aversion.
            if ((xsArrayGetInt(gCardPriorities, i) > 0) && (unit == cUnitTypeypTradingPostWagon) ||
                (unit == cUnitTypeTradingPostTravois) || (tech == cTechYPHCExpandedTradingPost) ||
                (tech == cTechYPHCExpandedTradingPostIndians) ||
                //(tech == cTechHCXPShipTradingPostTravois) ||
                (tech == cTechDEHCShipTamboTravois) || (tech == cTechDEHCAdvancedTambos) ||
                (tech == cTechHCAdvancedTradingPost) || (tech == cTechHCCheapTradingPostTeam))
            {
               cardPriority = xsArrayGetInt(gCardPriorities, i);
               cardPriority = cardPriority - 1;
               if (cardPriority < 0)
                  cardPriority = 0;
               xsArraySetInt(gCardPriorities, i, cardPriority);
            }
         }
		 */

         // Raise priority of specific important cards.
         if ((aiGetWorldDifficulty() >= cDifficultyModerate) &&
             ((xsArrayGetInt(gCardPriorities, i) < 10) &&
              ((tech == cTechHCXPEconomicTheory) || (tech == cTechYPHCEconomicTheoryAsia) ||
               (tech == cTechHCAdvancedArsenal) || (tech == cTechHCAdvancedArsenalGerman) ||
               (tech == cTechHCXPNewWaysIroquois) || (tech == cTechHCXPNewWaysSioux) ||
               (tech == cTechYPHCSpawnRefugees1) || (tech == cTechYPHCShipBerryWagon2) ||
               (tech == cTechYPHCShipGroveWagonIndians2) || (tech == cTechYPHCShipShogunate))))
         {
            cardPriority = xsArrayGetInt(gCardPriorities, i);
            if (cardPriority < 5)
               cardPriority = 5;
            cardPriority = cardPriority + 2;
            if (cardPriority > 10)
               cardPriority = 10;
            xsArraySetInt(gCardPriorities, i, cardPriority);
         }

         // Raise priority of specific cards important to the AI.
         if ((aiGetWorldDifficulty() >= cDifficultyModerate) &&
             ((xsArrayGetInt(gCardPriorities, i) < 10) &&
              ((tech == cTechHCRobberBarons) || (tech == cTechHCRobberBaronsGerman) ||
               (tech == cTechHCXPIndustrialRevolution) || (tech == cTechHCXPIndustrialRevolutionGerman) ||
               (tech == cTechHCUnlockFactory) || (tech == cTechHCUnlockFactoryGerman) || (tech == cTechHCXPBankWagon) ||
               (tech == cTechHCBanks1) || (tech == cTechHCBanks2) || (tech == cTechHCBetterBanks) ||
               (tech == cTechDEHCChichaBrewing) || ((flags & cHCCardFlagTrickleGold) == cHCCardFlagTrickleGold) ||
               ((flags & cHCCardFlagTrickleWood) == cHCCardFlagTrickleWood) ||
               ((flags & cHCCardFlagTrickleFood) == cHCCardFlagTrickleFood) ||
               //((flags & cHCCardFlagGatherRate) == cHCCardFlagGatherRate) ||
               (tech == cTechHCXPEarthBounty) || (tech == cTechYPHCRainbowTrickle) ||
               //(tech == cTechYPHCRainbowTrickleIndians) || (tech == cTechYPHCRainbowTrickleTeam) ||
               (tech == cTechHCXPCapitalism) || (tech == cTechHCXPDistributivism) || (tech == cTechYPHCAgrarianism) ||
               (tech == cTechYPHCForeignLogging) || (tech == cTechDEHCGidanSarkin))))
         {
            cardPriority = xsArrayGetInt(gCardPriorities, i);
            if (cardPriority < 6)
               cardPriority = 6;
            cardPriority = cardPriority + 1;
            if (cardPriority > 10)
               cardPriority = 10;
            xsArraySetInt(gCardPriorities, i, cardPriority);
         }
         // Slightly raise priority of specific cards when not rated highly.
         else if ((aiGetWorldDifficulty() >= cDifficultyModerate) &&
                  ((xsArrayGetInt(gCardPriorities, i) < 7) &&
                   ((tech == cTechHCRoyalDecreeBritish) || (tech == cTechHCRoyalDecreeDutch) ||
                    (tech == cTechHCRoyalDecreeFrench) || (tech == cTechHCRoyalDecreeGerman) ||
                    (tech == cTechHCRoyalDecreeOttoman) || (tech == cTechHCRoyalDecreePortuguese) ||
                    (tech == cTechHCRoyalDecreeRussian) || (tech == cTechHCRoyalDecreeSpanish) ||
                    (tech == cTechDEHCCequeSystem) || (tech == cTechDEHCCurare) || (tech == cTechDEHCRoadBuilding) ||
                    (tech == cTechDEHCHuankaSupport) || (tech == cTechDEHCMonumentalArchitecture) ||
                    (tech == cTechDEHCResettlements) || (tech == cTechDEHCMeleeInfCombatInca) ||
                    (tech == cTechDEHCRangedInfDamageInca) || (tech == cTechDEHCRangedInfHitpointsInca) ||
                    /*(tech == cTechDEHCMachuPicchu) ||*/ (tech == cTechDEHCTerraceFarming) ||
                    //(tech == cTechHCXPWaterDance) ||
                    (tech == cTechDEHCFloatingIslands) || (tech == cTechDEHCChinchaSupport) ||
                    (tech == cTechDEHCTupiAllies1) || (tech == cTechDEHCShipWoodCratesInfInca) ||
                    (tech == cTechYPHCIncreasedTribute))))
         {
            cardPriority = xsArrayGetInt(gCardPriorities, i);
            if (cardPriority < 5)
               cardPriority = 5;
            cardPriority = cardPriority + 1;
            if (cardPriority > 10)
               cardPriority = 10;
            xsArraySetInt(gCardPriorities, i, cardPriority);
         }

         if (kbGetAge() > aiHCCardsGetCardAgePrereq(i))
         { // Decrease priority of cards with lower required age than us (higher starting age).
            if (xsArrayGetInt(gCardPriorities, i) > 0)
            {
               cardPriority = xsArrayGetInt(gCardPriorities, i);
               cardPriority = cardPriority - 1;
               if (cardPriority < 0)
                  cardPriority = 0;
               xsArraySetInt(gCardPriorities, i, cardPriority);
            }
         }

         // Set priority for water map related units and upgrades to 0 on land maps.
         if ((gNavyMap == false) &&
             (((flags & cHCCardFlagWater) == cHCCardFlagWater) || (tech == cTechHCCoastalDefensesTeam) ||
              (tech == cTechHCNavalCombat) || (tech == cTechHCNavalCombatGerman) ||
              (tech == cTechYPHCNavalCombatTeam) || (tech == cTechYPHCNavalCombatIndians) ||
              (tech == cTechHCAdmirality) || (tech == cTechHCAdmiralityGerman) ||
              (tech == cTechYPHCAdmiralityIndians) || (tech == cTechHCFishMarket) || (tech == cTechHCFishMarketTeam) ||
              (tech == cTechHCFishMarketGerman) || (tech == cTechYPHCFishMarketIndians) ||
              (tech == cTechypHCFishMarket) || (tech == cTechHCRenderingPlant) ||
              (tech == cTechHCRenderingPlantGerman) || (tech == cTechYPHCRenderingPlantIndians) ||
              (tech == cTechHCCoastalDefensesTeam) ||
              (kbProtoUnitIsType(cMyID, unit, cUnitTypeAbstractWarShip) == true) ||
              (kbProtoUnitIsType(cMyID, unit, cUnitTypeAbstractFishingBoat) == true)))
            xsArraySetInt(gCardPriorities, i, 0);

         if ((cMyCiv == cCivSPCJapanese) || (cMyCiv == cCivSPCJapaneseEnemy))
         {
            if ((tech == cTechYPHCShipDaimyoAizu) || (tech == cTechYPHCShipDaimyoSatsuma) ||
                (tech == cTechYPHCShipDaimyoTokushima) || (tech == cTechYPHCShipShogunate) ||
                (tech == cTechYPSPCHCShipDaimyoKiyomasa) || (tech == cTechYPSPCHCShipDaimyoMasamune) ||
                (tech == cTechYPSPCHCShipDaimyoTadaoki))
            {
               xsArraySetInt(gCardPriorities, i, 0); // BHG: don't want spcjapanese sending in unapproved daimyos
            }
         }
         if (cMyCiv == cCivSPCIndians)
         {
            if ((tech == cTechYPHCShipSepoy1) || (tech == cTechYPHCShipSepoy2) || (tech == cTechYPHCShipSepoy3) ||
                (tech == cTechYPHCShipSepoy4))
            {
               xsArraySetInt(gCardPriorities, i, 0); // BHG: don't want spcindians sending in unapproved sepoys
            }
         }
         /*if (unit == cUnitTypeFortWagon &&
             (btOffenseDefense >= 0.0 || (cMyCiv == cCivDESwedish && tech != cTechDEHCKalmarCastle)))
            xsArraySetInt(gCardPriorities, i, 1); // Don't want fort wagons when we are not turtling.
         if (//(tech == cTechHCXPShipTradingPostTravois) || (tech == cTechHCXPNomadicExpansion) ||
             (tech == cTechHCXPTercioTactics) || (tech == cTechHCXPTirailleurs) || (tech == cTechHCXPSuvorovReforms) ||
             (tech == cTechHCXPEveningStar) || (tech == cTechYPHCBannerReforms) || (tech == cTechYPHCSepoyRebellion) ||
             (tech == cTechDEHCDalecarlianRebellion) || //(tech == cTechDEHCHakkapelitMarch) ||
             //(tech == cTechHCExtensiveFortifications) || (tech == cTechHCXPExtensiveFortifications2) ||
             //(tech == cTechHCXPExtensiveFortificationsAztec) || (tech == cTechYPHCExtensiveFortifications) ||
             (tech == cTechYPHCConscriptSepoys))
            xsArraySetInt(gCardPriorities, i, 0); // Don't want cards that cannot be used properly.
         // Priorities 2-4 will be set when the card is purchased, based on "find best" category that gets them.
*/
         if (aiHCCardsIsCardBought(i) == true)
            xsArraySetString(gCardStates, i, "P"); // Purchased
         else
         {
            if (aiHCCardsCanIBuyThisCard(-1, i) == true)
               xsArraySetString(gCardStates, i, "A"); // Available
            else
               xsArraySetString(gCardStates, i, "N"); // Not available
         }
         if (cMyCiv == cCivSPCIndians)
         {
            if ((tech == cTechYPHCShipSepoy1) || (tech == cTechYPHCShipSepoy2) || (tech == cTechYPHCShipSepoy3) ||
                (tech == cTechYPHCShipSepoy4))
            {
               xsArraySetString(gCardStates, i, "N"); // BHG: don't want spcindians sending in unapproved sepoys
            }
         }

         if (aiHCCardsGetCardCount(i) < 0)
            tempString = " Infinite";
         else
            tempString = "   " + aiHCCardsGetCardCount(i) + " use";
         tempString = tempString + " Pri " + xsArrayGetInt(gCardPriorities, i) + " ";
         tempString = tempString + " " + xsArrayGetString(gCardStates, i);
         tempString = tempString + "  L" + aiHCCardsGetCardLevel(i);
         tempString = tempString + "  A" + aiHCCardsGetCardAgePrereq(i);
         tempString = tempString + " (" + tech + ") " + kbGetTechName(tech);
         if (unit >= 0)
         {
            tempString = tempString + " " + aiHCCardsGetCardUnitCount(i) + " " + kbGetProtoUnitName(unit);
         }

         xsArraySetString(gCardNames, i, tempString);
         aiEcho(i + " " + tempString);
      }
      pass = 1; // Buy cards next time
      break;
   }
   case 1: // Buy cards
   {
      for (attempt = 0; < 10)
      {
         aiEcho("Purchase attempt " + attempt);
         if (remainingSP <= 0) // Have no points to spend...
            break;

         bool result = false;

         int boughtCardIndex = -1;
         int highestPriority = 0; // Priority higher than this will be bought.
         // First, scan for the high-priority cards.
         for (index = 0; < totalCardCount)
         { // Scan the list, looking for the highest-priority card still available
            if ((aiHCCardsGetCardLevel(index) > myLevel) || (aiHCCardsCanIBuyThisCard(-1, index) == false) ||
                (xsArrayGetString(gCardStates, index) == "P"))
               continue; // Skip it.  Note...I use the "P" (purchased) flag to indicate ones that are purchased, AND
                         // ones that have failed in a buy attempt.
            // It is legal and available
            if (xsArrayGetInt(gCardPriorities, index) > highestPriority)
            {
               boughtCardIndex = index;
               highestPriority = xsArrayGetInt(gCardPriorities, index);
            }
         }
         if (boughtCardIndex >= 0)
         {
            result = aiHCCardsBuyCard(boughtCardIndex);
            aiEcho("Buying priority " + highestPriority + " card " + xsArrayGetString(gCardNames, boughtCardIndex));
         }

         int cardIndex = -1;
         if (boughtCardIndex < 0)
         { // No special cards remain, look for best one in each category.
            cardIndex = aiHCCardsFindBestCard(cHCCardTypeEcon, myLevel);
            if (cardIndex >= 0)
            { // Any econ card
               result = aiHCCardsBuyCard(cardIndex);
               aiEcho("Buying econ card " + xsArrayGetString(gCardNames, cardIndex));
               boughtCardIndex = cardIndex;
               // xsArraySetInt(gCardPriorities, cardIndex, 3);   // Pri 3, econ card
               break;
            }
            cardIndex = aiHCCardsFindBestCard(cHCCardTypeMilitary, myLevel);
            if (cardIndex >= 0)
            { // Any military card
               result = aiHCCardsBuyCard(cardIndex);
               aiEcho("Buying econ card " + xsArrayGetString(gCardNames, cardIndex));
               boughtCardIndex = cardIndex;
               // xsArraySetInt(gCardPriorities, cardIndex, 2);   // Pri 2, military card
               break;
            }
            cardIndex = aiHCCardsFindBestCard(cHCCardTypeWagon, myLevel);
            if (cardIndex >= 0)
            { // Any wagon card
               result = aiHCCardsBuyCard(cardIndex);
               aiEcho("Buying econ card " + xsArrayGetString(gCardNames, cardIndex));
               boughtCardIndex = cardIndex;
               // xsArraySetInt(gCardPriorities, cardIndex, 7);   // Pri 7, wagon card...shouldn't get any hits here.
               break;
            }
            cardIndex = aiHCCardsFindBestCard(cHCCardTypeTeam, myLevel);
            if (cardIndex >= 0)
            { // Any team card
               result = aiHCCardsBuyCard(cardIndex);
               aiEcho("Buying econ card " + xsArrayGetString(gCardNames, cardIndex));
               boughtCardIndex = cardIndex;
               // xsArraySetInt(gCardPriorities, cardIndex, 1);   // Pri 1, team card
               break;
            }
         }

         // If we're here, we've either selected a card, or exhausted the list.
         if (boughtCardIndex < 0)
         { // Nothing to buy?!
            aiEcho("  ERROR!  We have points to spend, but no cards to buy.");
            pass = 2; // go on to deck picking
            return;
         }
         // We've selected a card.  Did the purchase work?
         if (result == false)
         { // It failed, blacklist this card by marking it owned in the array.
            aiEcho("  ERROR!  Failed to buy card " + xsArrayGetString(gCardNames, boughtCardIndex));
         }
         xsArraySetString(gCardStates, boughtCardIndex, "P"); // Even if purchase failed, mark it purchased so we don't get stuck on it.
         remainingSP = remainingSP - 1;
         SPSpent = SPSpent + 1;
         if (SPSpent >= 10)
            myLevel = 10;
         if (SPSpent >= 25)
            myLevel = 25;
      } // For attempt 0..9

      if (remainingSP <= 0)
         pass = 2;
   }       // case 1
   case 2: // Make deck
   {
      aiEcho("Making deck");
      /*if (gSPC == true)
      {
         if (gDefaultDeck < 0)
         {
            gDefaultDeck = aiHCDeckCreate("The AI Deck");
            aiEcho("Creating new deck at index " + gDefaultDeck);
         }
      }
      else
      {*/
         //-- In non spc games, the game will make an empty deck for AI's at index 0.
         gDefaultDeck = 0;
         aiEcho("Using deck at index " + gDefaultDeck);
      //}

      aiEcho("Building Deck");
      int cardsRemaining = 25;
      int cardsAge1 = 0;
      int cardsAge2 = 0;
      int cardsAge3 = 0;
      int cardsAge4 = 0;

      float totalValueCurrent = 0.0;
      float totalValueBest = 0.0;
      float totalCost = 0.0;
      int cardsPicked = 0;
      bool addedVillager = false;
      bool addedInfUnit = false;

      int toPick = 4;
      if (aiGetWorldDifficulty() >= cDifficultyHard)
         toPick = 1;
      // First, 1-4 age 1 cards.
      for (i = 0; < toPick)
      {
         int bestCard = -1;
         int bestCardPri = -1;
         int currentCardFlags = 0;
         int bestCardFlags = -1;
         totalValueCurrent = 0.0;
         totalValueBest = 0.0;
         totalCost = 0.0;
         for (card = 0; < maxCards)
         {
            if (xsArrayGetString(gCardStates, card) != "P")
               continue; // Only consider purchased cards not already in deck.
            if (aiHCCardsGetCardAgePrereq(card) != cAge1)
               continue;
            currentCardFlags = aiHCCardsGetCardFlags(card);
            if ((addedVillager == true) && ((currentCardFlags & cHCCardFlagVillager) == cHCCardFlagVillager))
               continue; // Don't add more than one villager card in age 1 for now
            if (((currentCardFlags & cHCCardFlagResourceCrate) == cHCCardFlagResourceCrate) &&
                (xsArrayGetInt(gCardPriorities, card) < 10))
               continue; // Avoid resource crates in age 1
            if ((aiTreatyActive() == true) && ((currentCardFlags & cHCCardFlagMilitary) == cHCCardFlagMilitary) &&
                ((currentCardFlags & cHCCardFlagUnit) == cHCCardFlagUnit))
               continue; // Avoid military units in age 1 when a treaty is active.
            if ((addedInfUnit == true) && (aiHCCardsGetCardCount(card) < 0) &&
                (xsArrayGetInt(gCardPriorities, card) < 10))
               continue; // Don't add more than 1 infinite military card for now.
            if ((xsArrayGetInt(gCardPriorities, card) == bestCardPri) &&
                ((currentCardFlags & cHCCardFlagMilitary) == cHCCardFlagMilitary) &&
                ((currentCardFlags & cHCCardFlagUnit) == cHCCardFlagUnit))
            { // If it's a military unit calculate a value for this card.
               totalValueCurrent = aiHCCardsGetCardValuePerResource(card, cResourceWood) +
                                   aiHCCardsGetCardValuePerResource(card, cResourceFood) +
                                   aiHCCardsGetCardValuePerResource(card, cResourceGold);
               totalCost = kbTechCostPerResource(aiHCCardsGetCardTechID(card), cResourceWood) +
                           kbTechCostPerResource(aiHCCardsGetCardTechID(card), cResourceFood) +
                           kbTechCostPerResource(aiHCCardsGetCardTechID(card), cResourceGold);
               totalValueCurrent = totalValueCurrent - totalCost;
               if (totalValueCurrent < 0.0)
                  totalValueCurrent = 0.0;
            }
            if (xsArrayGetInt(gCardPriorities, card) > bestCardPri)
            {
               bestCardPri = xsArrayGetInt(gCardPriorities, card);
               bestCard = card;
               bestCardFlags = currentCardFlags;
            }
            else if ((((currentCardFlags & cHCCardFlagVillager) == cHCCardFlagVillager) &&
                      ((bestCardFlags & cHCCardFlagVillager) == cHCCardFlagVillager) &&
                      (xsArrayGetInt(gCardPriorities, card) >= bestCardPri)) &&
                     (((aiHCCardsGetCardValuePerResource(bestCard, cResourceWood) > 0.0) &&
                       (aiHCCardsGetCardValuePerResource(card, cResourceWood) >
                        aiHCCardsGetCardValuePerResource(bestCard, cResourceWood))) ||
                      ((aiHCCardsGetCardValuePerResource(bestCard, cResourceFood) > 0.0) &&
                       (aiHCCardsGetCardValuePerResource(card, cResourceFood) >
                        aiHCCardsGetCardValuePerResource(bestCard, cResourceFood))) ||
                      ((aiHCCardsGetCardValuePerResource(bestCard, cResourceGold) > 0.0) &&
                       (aiHCCardsGetCardValuePerResource(card, cResourceGold) >
                        aiHCCardsGetCardValuePerResource(bestCard, cResourceGold)))))
            { // make sure more valuable villager cards win
               bestCardPri = xsArrayGetInt(gCardPriorities, card);
               bestCard = card;
               bestCardFlags = currentCardFlags;
            }
            else if ((xsArrayGetInt(gCardPriorities, card) == bestCardPri) &&
                     ((currentCardFlags & cHCCardFlagMilitary) == cHCCardFlagMilitary) &&
                     ((currentCardFlags & cHCCardFlagUnit) == cHCCardFlagUnit) && (totalValueCurrent > totalValueBest))
            { // If it's the same priority of a military unit card, take the one with the better value.
               bestCardPri = xsArrayGetInt(gCardPriorities, card);
               bestCard = card;
               totalValueBest = totalValueCurrent;
            }
         }
         if (bestCard >= 0)
         {
            if ((aiGetWorldDifficulty() >= cDifficultyModerate) &&
                (((xsArrayGetInt(gCardPriorities, bestCard) < 6) && (cardsAge1 >= 1)) ||
                 ((xsArrayGetInt(gCardPriorities, bestCard) < 7) && (cardsAge1 >= 2))))
               continue; // After the first card, only pick more if they're good.
            addCardToDeck(gDefaultDeck, bestCard);
            cardsRemaining = cardsRemaining - 1;
            xsArraySetString(gCardStates, bestCard, "D");
            // aiEcho("  0Adding card "+xsArrayGetString(gCardNames, bestCard));
            cardsPicked = cardsPicked + 1;
            cardsAge1 = cardsAge1 + 1;
            if (((bestCardFlags & cHCCardFlagVillager) == cHCCardFlagVillager) && (addedVillager == false))
               addedVillager = true;
            if (((bestCardFlags & cHCCardFlagUnit) == cHCCardFlagUnit) && (aiHCCardsGetCardCount(bestCard) < 0) &&
                (addedInfUnit == false))
               addedInfUnit = true;
         }
      } //  21-24 remaining.

      addedInfUnit = false;
      cardsPicked = 0;
      toPick = 0; // 1 + ((btRushBoom + 1.0) * 1.51);
      // Next, age 2 military cards.  1 for a boomer, up to 4 for a rusher.
      for (i = 0; < toPick)
      {
         bestCard = -1;
         bestCardPri = -1;
         currentCardFlags = 0;
         totalValueCurrent = 0.0;
         totalValueBest = 0.0;
         totalCost = 0.0;
         for (card = 0; < maxCards)
         {
            if (xsArrayGetString(gCardStates, card) != "P")
               continue; // Only consider purchased cards not already in deck.
            if (aiHCCardsGetCardAgePrereq(card) != cAge2)
               continue;
            currentCardFlags = aiHCCardsGetCardFlags(card);
            if ((currentCardFlags & cHCCardFlagMilitary) != cHCCardFlagMilitary)
               continue; // Only look at military units and upgrades
            if (((currentCardFlags & cHCCardFlagUnit) != cHCCardFlagUnit) && (cardsPicked <= 0))
               continue; // Pick at least 1 unit
            if ((addedInfUnit == true) && (aiHCCardsGetCardCount(card) < 0) &&
                (xsArrayGetInt(gCardPriorities, card) < 10))
               continue; // Don't add more than 1 infinite military card for now.
            if ((aiTreatyActive() == true) && ((currentCardFlags & cHCCardFlagMilitary) == cHCCardFlagMilitary) &&
                ((currentCardFlags & cHCCardFlagUnit) == cHCCardFlagUnit))
               continue; // Avoid military units in age 2 when a treaty is active.
            if ((xsArrayGetInt(gCardPriorities, card) == bestCardPri) &&
                ((currentCardFlags & cHCCardFlagUnit) == cHCCardFlagUnit))
            { // If it's a military unit calculate a value for this card.
               totalValueCurrent = aiHCCardsGetCardValuePerResource(card, cResourceWood) +
                                   aiHCCardsGetCardValuePerResource(card, cResourceFood) +
                                   aiHCCardsGetCardValuePerResource(card, cResourceGold);
               totalCost = kbTechCostPerResource(aiHCCardsGetCardTechID(card), cResourceWood) +
                           kbTechCostPerResource(aiHCCardsGetCardTechID(card), cResourceFood) +
                           kbTechCostPerResource(aiHCCardsGetCardTechID(card), cResourceGold);
               totalValueCurrent = totalValueCurrent - totalCost;
               if (totalValueCurrent < 0.0)
                  totalValueCurrent = 0.0;
            }
            if (xsArrayGetInt(gCardPriorities, card) > bestCardPri)
            {
               bestCardPri = xsArrayGetInt(gCardPriorities, card);
               bestCard = card;
            }
            else if ((xsArrayGetInt(gCardPriorities, card) == bestCardPri) &&
                     ((currentCardFlags & cHCCardFlagUnit) == cHCCardFlagUnit) && (totalValueCurrent > totalValueBest))
            { // If it's the same priority of a military unit card, take the one with the better value.
               bestCardPri = xsArrayGetInt(gCardPriorities, card);
               bestCard = card;
               totalValueBest = totalValueCurrent;
            }
         }
         if (bestCard >= 0)
         {
            if ((xsArrayGetInt(gCardPriorities, bestCard) < 6) && (cardsPicked >= 2))
               continue; // After the first two cards, only pick more if they're good.
            addCardToDeck(gDefaultDeck, bestCard);
            cardsRemaining = cardsRemaining - 1;
            xsArraySetString(gCardStates, bestCard, "D");
            // aiEcho("  1Adding card "+xsArrayGetString(gCardNames, bestCard));
            cardsPicked = cardsPicked + 1;
            cardsAge2 = cardsAge2 + 1;
            if (((bestCardFlags & cHCCardFlagUnit) == cHCCardFlagUnit) && (aiHCCardsGetCardCount(bestCard) < 0) &&
                (addedInfUnit == false))
               addedInfUnit = true;
         }
      } // 17-23 remaining.

      cardsPicked = 0;
      addedVillager = false;
      int addedCrates = 0;
      toPick = 0; // + ((btRushBoom + 1.0) * 1.51);
      // Next, age 2 non-military cards.  1 for a rusher, up to 4 for a boomer.
      for (i = 0; < toPick)
      {
         bestCard = -1;
         bestCardPri = -1;
         currentCardFlags = 0;
         bestCardFlags = -1;
         for (card = 0; < maxCards)
         {
            if (xsArrayGetString(gCardStates, card) != "P")
               continue; // Only consider purchased cards not already in deck.
            if (aiHCCardsGetCardAgePrereq(card) != cAge2)
               continue;
            currentCardFlags = aiHCCardsGetCardFlags(card);
            if ((currentCardFlags & cHCCardFlagMilitary) == cHCCardFlagMilitary)
               continue; // Don't look at military units (and upgrades)
            if ((addedVillager == true) && ((currentCardFlags & cHCCardFlagVillager) == cHCCardFlagVillager))
               continue; // Don't add more than 1 villager card in age 2 for now
            if ((addedCrates >= 3) && ((currentCardFlags & cHCCardFlagResourceCrate) == cHCCardFlagResourceCrate) &&
                (xsArrayGetInt(gCardPriorities, card) < 10))
               continue; // Don't add more than 3 resource crates in age 2
            if ((addedInfUnit == true) && (aiHCCardsGetCardCount(card) < 0) &&
                (xsArrayGetInt(gCardPriorities, card) < 10))
               continue; // Don't add more than 1 infinite military card for now.
            if (xsArrayGetInt(gCardPriorities, card) > bestCardPri)
            {
               bestCardPri = xsArrayGetInt(gCardPriorities, card);
               bestCard = card;
               bestCardFlags = currentCardFlags;
            }
            else if ((((currentCardFlags & cHCCardFlagVillager) == cHCCardFlagVillager) &&
                      ((bestCardFlags & cHCCardFlagVillager) == cHCCardFlagVillager) &&
                      (xsArrayGetInt(gCardPriorities, card) >= bestCardPri)) &&
                     (((aiHCCardsGetCardValuePerResource(bestCard, cResourceWood) > 0.0) &&
                       (aiHCCardsGetCardValuePerResource(card, cResourceWood) >
                        aiHCCardsGetCardValuePerResource(bestCard, cResourceWood))) ||
                      ((aiHCCardsGetCardValuePerResource(bestCard, cResourceFood) > 0.0) &&
                       (aiHCCardsGetCardValuePerResource(card, cResourceFood) >
                        aiHCCardsGetCardValuePerResource(bestCard, cResourceFood))) ||
                      ((aiHCCardsGetCardValuePerResource(bestCard, cResourceGold) > 0.0) &&
                       (aiHCCardsGetCardValuePerResource(card, cResourceGold) >
                        aiHCCardsGetCardValuePerResource(bestCard, cResourceGold)))))
            { // make sure more valuable villager cards win
               bestCardPri = xsArrayGetInt(gCardPriorities, card);
               bestCard = card;
               bestCardFlags = currentCardFlags;
            }
            else if ((((currentCardFlags & cHCCardFlagResourceCrate) == cHCCardFlagResourceCrate) &&
                      ((bestCardFlags & cHCCardFlagResourceCrate) == cHCCardFlagResourceCrate)) &&
                     (((aiHCCardsGetCardValuePerResource(bestCard, cResourceWood) > 0.0) &&
                       (aiHCCardsGetCardValuePerResource(card, cResourceWood) >
                        aiHCCardsGetCardValuePerResource(bestCard, cResourceWood))) ||
                      ((aiHCCardsGetCardValuePerResource(bestCard, cResourceFood) > 0.0) &&
                       (aiHCCardsGetCardValuePerResource(card, cResourceFood) >
                        aiHCCardsGetCardValuePerResource(bestCard, cResourceFood))) ||
                      ((aiHCCardsGetCardValuePerResource(bestCard, cResourceGold) > 0.0) &&
                       (aiHCCardsGetCardValuePerResource(card, cResourceGold) >
                        aiHCCardsGetCardValuePerResource(bestCard, cResourceGold)))))
            { // make sure more valuable resource cards for the same resource win
               bestCardPri = xsArrayGetInt(gCardPriorities, card);
               bestCard = card;
               bestCardFlags = currentCardFlags;
            }
            else if (((((currentCardFlags & cHCCardFlagResourceCrate) == cHCCardFlagResourceCrate) &&
                       ((bestCardFlags & cHCCardFlagResourceCrate) == cHCCardFlagResourceCrate)) &&
                      (xsArrayGetInt(gCardPriorities, card) >= bestCardPri)) &&
                     (((aiHCCardsGetCardValuePerResource(card, cResourceWood) > 0.0) &&
                       (aiHCCardsGetCardValuePerResource(card, cResourceWood) >=
                        aiHCCardsGetCardValuePerResource(bestCard, cResourceFood))) ||
                      ((aiHCCardsGetCardValuePerResource(card, cResourceGold) > 0.0) &&
                       (aiHCCardsGetCardValuePerResource(card, cResourceGold) >=
                        aiHCCardsGetCardValuePerResource(bestCard, cResourceFood)))))
            { // prioritize coin & wood, food
               bestCardPri = xsArrayGetInt(gCardPriorities, card);
               bestCard = card;
               bestCardFlags = currentCardFlags;
            }
         }
         if (bestCard >= 0)
         {
            if ((xsArrayGetInt(gCardPriorities, bestCard) < 6) && (cardsPicked >= 2))
               continue; // After the first two cards, only pick more if they're good.
            addCardToDeck(gDefaultDeck, bestCard);
            cardsRemaining = cardsRemaining - 1;
            xsArraySetString(gCardStates, bestCard, "D");
            // aiEcho("  2Adding card "+xsArrayGetString(gCardNames, bestCard));
            cardsPicked = cardsPicked + 1;
            cardsAge2 = cardsAge2 + 1;
            if (((bestCardFlags & cHCCardFlagVillager) == cHCCardFlagVillager) && (addedVillager == false))
               addedVillager = true;
            if (((bestCardFlags & cHCCardFlagResourceCrate) == cHCCardFlagResourceCrate) && (addedCrates < 4))
               addedCrates = addedCrates + 1;
            if (((bestCardFlags & cHCCardFlagUnit) == cHCCardFlagUnit) && (aiHCCardsGetCardCount(bestCard) < 0) &&
                (addedInfUnit == false))
               addedInfUnit = true;
         }
      } // 16-22 remaining.

      cardsPicked = 0;
      toPick = 0;
      // Next, 1-2 more possible age 2 cards.
      for (i = 0; < toPick)
      {
         bestCardPri = -1;
         currentCardFlags = 0;
         bestCardFlags = -1;
         totalValueCurrent = 0.0;
         totalValueBest = 0.0;
         totalCost = 0.0;
         for (card = 0; < maxCards)
         {
            if (xsArrayGetString(gCardStates, card) != "P")
               continue; // Only consider purchased cards not already in deck.
            if (aiHCCardsGetCardAgePrereq(card) != cAge2)
               continue;
            if (xsArrayGetInt(gCardPriorities, card) < 7)
               continue; // Only pick one if it's really good.
            currentCardFlags = aiHCCardsGetCardFlags(card);
            if ((currentCardFlags & cHCCardFlagVillager) == cHCCardFlagVillager)
               continue; // Ignore villager cards here
            if ((currentCardFlags & cHCCardFlagResourceCrate) == cHCCardFlagResourceCrate)
               continue; // Ignore resource crate cards here
            if ((addedInfUnit == true) && (aiHCCardsGetCardCount(card) < 0) &&
                (xsArrayGetInt(gCardPriorities, card) < 10))
               continue; // Don't add more than 1 infinite military card for now.
            if ((aiTreatyActive() == true) && ((currentCardFlags & cHCCardFlagMilitary) == cHCCardFlagMilitary) &&
                ((currentCardFlags & cHCCardFlagUnit) == cHCCardFlagUnit))
               continue; // Avoid military units in age 2 when a treaty is active.
            if ((xsArrayGetInt(gCardPriorities, card) == bestCardPri) &&
                ((currentCardFlags & cHCCardFlagMilitary) == cHCCardFlagMilitary) &&
                ((currentCardFlags & cHCCardFlagUnit) == cHCCardFlagUnit))
            { // If it's a military unit calculate a value for this card.
               totalValueCurrent = aiHCCardsGetCardValuePerResource(card, cResourceWood) +
                                   aiHCCardsGetCardValuePerResource(card, cResourceFood) +
                                   aiHCCardsGetCardValuePerResource(card, cResourceGold);
               totalCost = kbTechCostPerResource(aiHCCardsGetCardTechID(card), cResourceWood) +
                           kbTechCostPerResource(aiHCCardsGetCardTechID(card), cResourceFood) +
                           kbTechCostPerResource(aiHCCardsGetCardTechID(card), cResourceGold);
               totalValueCurrent = totalValueCurrent - totalCost;
               if (totalValueCurrent < 0.0)
                  totalValueCurrent = 0.0;
            }
            if (xsArrayGetInt(gCardPriorities, card) > bestCardPri)
            {
               bestCardPri = xsArrayGetInt(gCardPriorities, card);
               bestCard = card;
               bestCardFlags = currentCardFlags;
            }
            else if ((xsArrayGetInt(gCardPriorities, card) == bestCardPri) &&
                     ((currentCardFlags & cHCCardFlagMilitary) == cHCCardFlagMilitary) &&
                     ((currentCardFlags & cHCCardFlagUnit) == cHCCardFlagUnit) && (totalValueCurrent > totalValueBest))
            { // If it's the same priority of a military unit card, take the one with the better value.
               bestCardPri = xsArrayGetInt(gCardPriorities, card);
               bestCard = card;
               totalValueBest = totalValueCurrent;
            }
         }
         if (bestCard >= 0)
         {
            if ((xsArrayGetInt(gCardPriorities, bestCard) < 6) && (cardsPicked >= 1))
               continue; // After the first card, only pick another if it's good.
            addCardToDeck(gDefaultDeck, bestCard);
            cardsRemaining = cardsRemaining - 1;
            xsArraySetString(gCardStates, bestCard, "D");
            // aiEcho("  3Adding card "+xsArrayGetString(gCardNames, bestCard));
            cardsPicked = cardsPicked + 1;
            cardsAge2 = cardsAge2 + 1;
            if (((bestCardFlags & cHCCardFlagUnit) == cHCCardFlagUnit) && (aiHCCardsGetCardCount(bestCard) < 0) &&
                (addedInfUnit == false))
               addedInfUnit = true;
         }
      } // 14-22 remaining.

      addedInfUnit = false;
      toPick = 0;
      // 1-2 age-3 military cards
      for (i = 0; < toPick)
      {
         bestCard = -1;
         bestCardPri = -1;
         currentCardFlags = 0;
         totalValueCurrent = 0.0;
         totalValueBest = 0.0;
         totalCost = 0.0;
         for (card = 0; < maxCards)
         {
            if (xsArrayGetString(gCardStates, card) != "P")
               continue; // Only consider purchased cards not already in deck.
            if (aiHCCardsGetCardAgePrereq(card) != cAge3)
               continue;
            currentCardFlags = aiHCCardsGetCardFlags(card);
            if ((currentCardFlags & cHCCardFlagMilitary) != cHCCardFlagMilitary)
               continue; // Only look at military units (and upgrades).
            if ((addedInfUnit == true) && (aiHCCardsGetCardCount(card) < 0) &&
                (xsArrayGetInt(gCardPriorities, card) < 10))
               continue; // Don't add more than 1 infinite military card for now.
            if ((xsArrayGetInt(gCardPriorities, card) == bestCardPri) &&
                ((currentCardFlags & cHCCardFlagUnit) == cHCCardFlagUnit))
            { // If it's a military unit calculate a value for this card.
               totalValueCurrent = aiHCCardsGetCardValuePerResource(card, cResourceWood) +
                                   aiHCCardsGetCardValuePerResource(card, cResourceFood) +
                                   aiHCCardsGetCardValuePerResource(card, cResourceGold);
               totalCost = kbTechCostPerResource(aiHCCardsGetCardTechID(card), cResourceWood) +
                           kbTechCostPerResource(aiHCCardsGetCardTechID(card), cResourceFood) +
                           kbTechCostPerResource(aiHCCardsGetCardTechID(card), cResourceGold);
               totalValueCurrent = totalValueCurrent - totalCost;
               if (totalValueCurrent < 0.0)
                  totalValueCurrent = 0.0;
            }
            if (xsArrayGetInt(gCardPriorities, card) > bestCardPri)
            {
               bestCardPri = xsArrayGetInt(gCardPriorities, card);
               bestCard = card;
            }
            else if ((xsArrayGetInt(gCardPriorities, card) == bestCardPri) &&
                     ((currentCardFlags & cHCCardFlagUnit) == cHCCardFlagUnit) && (totalValueCurrent > totalValueBest))
            { // If it's the same priority of a military unit card, take the one with the better value.
               bestCardPri = xsArrayGetInt(gCardPriorities, card);
               bestCard = card;
               totalValueBest = totalValueCurrent;
            }
         }
         if (bestCard >= 0)
         {
            if ((xsArrayGetInt(gCardPriorities, bestCard) < 6) && (cardsPicked >= 1))
               continue; // After the first card, only pick another if it's good.
            addCardToDeck(gDefaultDeck, bestCard);
            cardsRemaining = cardsRemaining - 1;
            xsArraySetString(gCardStates, bestCard, "D");
            // aiEcho("  4Adding card "+xsArrayGetString(gCardNames, bestCard));
            cardsPicked = cardsPicked + 1;
            cardsAge3 = cardsAge3 + 1;
            if (((bestCardFlags & cHCCardFlagUnit) == cHCCardFlagUnit) && (aiHCCardsGetCardCount(bestCard) < 0) &&
                (addedInfUnit == false))
               addedInfUnit = true;
         }
      } // 12-21 remaining.

      addedVillager = false;
      addedCrates = 0;
      toPick = 2;
      // Next, 5-6 age 3 cards.
      for (i = 0; < toPick)
      {
         bestCard = -1;
         bestCardPri = -1;
         currentCardFlags = 0;
         bestCardFlags = -1;
         totalValueCurrent = 0.0;
         totalValueBest = 0.0;
         totalCost = 0.0;
         for (card = 0; < maxCards)
         {
            if (xsArrayGetString(gCardStates, card) != "P")
               continue; // Only consider purchased cards not already in deck.
            if (aiHCCardsGetCardAgePrereq(card) != cAge3)
               continue;
            currentCardFlags = aiHCCardsGetCardFlags(card);
            if ((addedVillager == true) && ((currentCardFlags & cHCCardFlagVillager) == cHCCardFlagVillager))
               continue; // Don't add more than 1 villager card in age 3 for now
            if ((addedCrates >= 2) && ((currentCardFlags & cHCCardFlagResourceCrate) == cHCCardFlagResourceCrate) &&
                (xsArrayGetInt(gCardPriorities, card) < 10))
               continue; // Don't add more than 2 resource crates in age 3
            if ((addedInfUnit == true) && (aiHCCardsGetCardCount(card) < 0) &&
                (xsArrayGetInt(gCardPriorities, card) < 10))
               continue; // Don't add more than 1 infinite military card for now.
            if ((xsArrayGetInt(gCardPriorities, card) == bestCardPri) &&
                ((currentCardFlags & cHCCardFlagMilitary) == cHCCardFlagMilitary) &&
                ((currentCardFlags & cHCCardFlagUnit) == cHCCardFlagUnit))
            { // If it's a military unit calculate a value for this card.
               totalValueCurrent = aiHCCardsGetCardValuePerResource(card, cResourceWood) +
                                   aiHCCardsGetCardValuePerResource(card, cResourceFood) +
                                   aiHCCardsGetCardValuePerResource(card, cResourceGold);
               totalCost = kbTechCostPerResource(aiHCCardsGetCardTechID(card), cResourceWood) +
                           kbTechCostPerResource(aiHCCardsGetCardTechID(card), cResourceFood) +
                           kbTechCostPerResource(aiHCCardsGetCardTechID(card), cResourceGold);
               totalValueCurrent = totalValueCurrent - totalCost;
               if (totalValueCurrent < 0.0)
                  totalValueCurrent = 0.0;
            }
            if (xsArrayGetInt(gCardPriorities, card) > bestCardPri)
            {
               bestCardPri = xsArrayGetInt(gCardPriorities, card);
               bestCard = card;
               bestCardFlags = currentCardFlags;
            }
            else if ((((currentCardFlags & cHCCardFlagVillager) == cHCCardFlagVillager) &&
                      ((bestCardFlags & cHCCardFlagVillager) == cHCCardFlagVillager) &&
                      (xsArrayGetInt(gCardPriorities, card) >= bestCardPri)) &&
                     (((aiHCCardsGetCardValuePerResource(bestCard, cResourceWood) > 0.0) &&
                       (aiHCCardsGetCardValuePerResource(card, cResourceWood) >
                        aiHCCardsGetCardValuePerResource(bestCard, cResourceWood))) ||
                      ((aiHCCardsGetCardValuePerResource(bestCard, cResourceFood) > 0.0) &&
                       (aiHCCardsGetCardValuePerResource(card, cResourceFood) >
                        aiHCCardsGetCardValuePerResource(bestCard, cResourceFood))) ||
                      ((aiHCCardsGetCardValuePerResource(bestCard, cResourceGold) > 0.0) &&
                       (aiHCCardsGetCardValuePerResource(card, cResourceGold) >
                        aiHCCardsGetCardValuePerResource(bestCard, cResourceGold)))))
            { // make sure more valuable villager cards win
               bestCardPri = xsArrayGetInt(gCardPriorities, card);
               bestCard = card;
               bestCardFlags = currentCardFlags;
            }
            else if ((((currentCardFlags & cHCCardFlagResourceCrate) == cHCCardFlagResourceCrate) &&
                      ((bestCardFlags & cHCCardFlagResourceCrate) == cHCCardFlagResourceCrate)) &&
                     (((aiHCCardsGetCardValuePerResource(bestCard, cResourceWood) > 0.0) &&
                       (aiHCCardsGetCardValuePerResource(card, cResourceWood) >
                        aiHCCardsGetCardValuePerResource(bestCard, cResourceWood))) ||
                      ((aiHCCardsGetCardValuePerResource(bestCard, cResourceFood) > 0.0) &&
                       (aiHCCardsGetCardValuePerResource(card, cResourceFood) >
                        aiHCCardsGetCardValuePerResource(bestCard, cResourceFood))) ||
                      ((aiHCCardsGetCardValuePerResource(bestCard, cResourceGold) > 0.0) &&
                       (aiHCCardsGetCardValuePerResource(card, cResourceGold) >
                        aiHCCardsGetCardValuePerResource(bestCard, cResourceGold)))))
            { // make sure more valuable resource cards for the same resource win
               bestCardPri = xsArrayGetInt(gCardPriorities, card);
               bestCard = card;
               bestCardFlags = currentCardFlags;
            }
            else if (((((currentCardFlags & cHCCardFlagResourceCrate) == cHCCardFlagResourceCrate) &&
                       ((bestCardFlags & cHCCardFlagResourceCrate) == cHCCardFlagResourceCrate)) &&
                      (xsArrayGetInt(gCardPriorities, card) >= bestCardPri)) &&
                     (((aiHCCardsGetCardValuePerResource(card, cResourceWood) > 0.0) &&
                       (aiHCCardsGetCardValuePerResource(card, cResourceWood) >=
                        aiHCCardsGetCardValuePerResource(bestCard, cResourceFood))) ||
                      ((aiHCCardsGetCardValuePerResource(card, cResourceGold) > 0.0) &&
                       (aiHCCardsGetCardValuePerResource(card, cResourceGold) >=
                        aiHCCardsGetCardValuePerResource(bestCard, cResourceFood)))))
            { // prioritize coin & wood, food
               bestCardPri = xsArrayGetInt(gCardPriorities, card);
               bestCard = card;
               bestCardFlags = currentCardFlags;
            }
            else if ((xsArrayGetInt(gCardPriorities, card) == bestCardPri) &&
                     ((currentCardFlags & cHCCardFlagMilitary) == cHCCardFlagMilitary) &&
                     ((currentCardFlags & cHCCardFlagUnit) == cHCCardFlagUnit) && (totalValueCurrent > totalValueBest))
            { // If it's the same priority of a military unit card, take the one with the better value.
               bestCardPri = xsArrayGetInt(gCardPriorities, card);
               bestCard = card;
               totalValueBest = totalValueCurrent;
            }
         }
         if (bestCard >= 0)
         {
            if ((xsArrayGetInt(gCardPriorities, bestCard) < 6) && (cardsPicked >= 5))
               continue; // After the first five cards, only pick another if it's good.
            addCardToDeck(gDefaultDeck, bestCard);
            cardsRemaining = cardsRemaining - 1;
            xsArraySetString(gCardStates, bestCard, "D");
            // aiEcho("  5Adding card "+xsArrayGetString(gCardNames, bestCard));
            cardsPicked = cardsPicked + 1;
            cardsAge3 = cardsAge3 + 1;
            if (((bestCardFlags & cHCCardFlagVillager) == cHCCardFlagVillager) && (addedVillager == false))
               addedVillager = true;
            if (((bestCardFlags & cHCCardFlagResourceCrate) == cHCCardFlagResourceCrate) && (addedCrates < 2))
               addedCrates = addedCrates + 1;
            if (((bestCardFlags & cHCCardFlagUnit) == cHCCardFlagUnit) && (aiHCCardsGetCardCount(bestCard) < 0) &&
                (addedInfUnit == false))
               addedInfUnit = true;
         }
      } // 6-15 remaining.

      addedInfUnit = false;
      toPick = 0;
      // 1-2 age-4 military cards
      for (i = 0; < toPick)
      {
         bestCard = -1;
         bestCardPri = -1;
         currentCardFlags = 0;
         totalValueCurrent = 0.0;
         totalValueBest = 0.0;
         totalCost = 0.0;
         for (card = 0; < maxCards)
         {
            if (xsArrayGetString(gCardStates, card) != "P")
               continue; // Only consider purchased cards not already in deck.
            if (aiHCCardsGetCardAgePrereq(card) != cAge4)
               continue;
            currentCardFlags = aiHCCardsGetCardFlags(card);
            if ((currentCardFlags & cHCCardFlagMilitary) != cHCCardFlagMilitary)
               continue; // Only look at military units (and upgrades).
            if ((addedInfUnit == true) && (aiHCCardsGetCardCount(card) < 0) &&
                (xsArrayGetInt(gCardPriorities, card) < 10))
               continue; // Don't add more than 1 infinite military card for now.
            if ((xsArrayGetInt(gCardPriorities, card) == bestCardPri) &&
                ((currentCardFlags & cHCCardFlagUnit) == cHCCardFlagUnit))
            { // If it's a military unit calculate a value for this card.
               totalValueCurrent = aiHCCardsGetCardValuePerResource(card, cResourceWood) +
                                   aiHCCardsGetCardValuePerResource(card, cResourceFood) +
                                   aiHCCardsGetCardValuePerResource(card, cResourceGold);
               totalCost = kbTechCostPerResource(aiHCCardsGetCardTechID(card), cResourceWood) +
                           kbTechCostPerResource(aiHCCardsGetCardTechID(card), cResourceFood) +
                           kbTechCostPerResource(aiHCCardsGetCardTechID(card), cResourceGold);
               totalValueCurrent = totalValueCurrent - totalCost;
               if (totalValueCurrent < 0.0)
                  totalValueCurrent = 0.0;
            }
            if (xsArrayGetInt(gCardPriorities, card) > bestCardPri)
            {
               bestCardPri = xsArrayGetInt(gCardPriorities, card);
               bestCard = card;
            }
            else if ((xsArrayGetInt(gCardPriorities, card) == bestCardPri) &&
                     ((currentCardFlags & cHCCardFlagUnit) == cHCCardFlagUnit) && (totalValueCurrent > totalValueBest))
            { // If it's the same priority of a military unit card, take the one with the better value.
               bestCardPri = xsArrayGetInt(gCardPriorities, card);
               bestCard = card;
               totalValueBest = totalValueCurrent;
            }
         }
         if (bestCard >= 0)
         {
            if ((xsArrayGetInt(gCardPriorities, bestCard) < 6) && (cardsPicked >= 1))
               continue; // After the first card, only pick another if it's good.
            addCardToDeck(gDefaultDeck, bestCard);
            cardsRemaining = cardsRemaining - 1;
            xsArraySetString(gCardStates, bestCard, "D");
            // aiEcho("  6Adding card "+xsArrayGetString(gCardNames, bestCard));
            cardsPicked = cardsPicked + 1;
            cardsAge4 = cardsAge4 + 1;
            if ((aiHCCardsGetCardCount(bestCard) < 0) && (addedInfUnit == false))
               addedInfUnit = true;
         }
      } // 4-13 remaining.

      addedVillager = false;
      addedCrates = 0;
      toPick = 0;
      // Next, 2-3 age 4 cards.
      for (i = 0; < toPick)
      {
         bestCard = -1;
         bestCardPri = -1;
         currentCardFlags = 0;
         bestCardFlags = -1;
         totalValueCurrent = 0.0;
         totalValueBest = 0.0;
         totalCost = 0.0;
         for (card = 0; < maxCards)
         {
            if (xsArrayGetString(gCardStates, card) != "P")
               continue; // Only consider purchased cards not already in deck.
            if (aiHCCardsGetCardAgePrereq(card) != cAge4)
               continue;
            currentCardFlags = aiHCCardsGetCardFlags(card);
            if ((addedVillager == true) && ((currentCardFlags & cHCCardFlagVillager) == cHCCardFlagVillager))
               continue; // Don't add more than 1 villager card in age 4 for now
            if ((addedCrates >= 1) && ((currentCardFlags & cHCCardFlagResourceCrate) == cHCCardFlagResourceCrate) &&
                (xsArrayGetInt(gCardPriorities, card) < 10))
               continue; // Don't add more than 1 resource crate in age 4
            if (((currentCardFlags & cHCCardFlagUnit) == cHCCardFlagUnit) && (addedInfUnit == true) &&
                (aiHCCardsGetCardCount(card) < 0) && (xsArrayGetInt(gCardPriorities, card) < 10))
               continue; // Don't add more than 1 infinite military card for now.
            if ((xsArrayGetInt(gCardPriorities, card) == bestCardPri) &&
                ((currentCardFlags & cHCCardFlagMilitary) == cHCCardFlagMilitary) &&
                ((currentCardFlags & cHCCardFlagUnit) == cHCCardFlagUnit))
            { // If it's a military unit calculate a value for this card.
               totalValueCurrent = aiHCCardsGetCardValuePerResource(card, cResourceWood) +
                                   aiHCCardsGetCardValuePerResource(card, cResourceFood) +
                                   aiHCCardsGetCardValuePerResource(card, cResourceGold);
               totalCost = kbTechCostPerResource(aiHCCardsGetCardTechID(card), cResourceWood) +
                           kbTechCostPerResource(aiHCCardsGetCardTechID(card), cResourceFood) +
                           kbTechCostPerResource(aiHCCardsGetCardTechID(card), cResourceGold);
               totalValueCurrent = totalValueCurrent - totalCost;
               if (totalValueCurrent < 0.0)
                  totalValueCurrent = 0.0;
            }
            if (xsArrayGetInt(gCardPriorities, card) > bestCardPri)
            {
               bestCardPri = xsArrayGetInt(gCardPriorities, card);
               bestCard = card;
               bestCardFlags = currentCardFlags;
            }
            else if ((((currentCardFlags & cHCCardFlagVillager) == cHCCardFlagVillager) &&
                      ((bestCardFlags & cHCCardFlagVillager) == cHCCardFlagVillager) &&
                      (xsArrayGetInt(gCardPriorities, card) >= bestCardPri)) &&
                     (((aiHCCardsGetCardValuePerResource(bestCard, cResourceWood) > 0.0) &&
                       (aiHCCardsGetCardValuePerResource(card, cResourceWood) >
                        aiHCCardsGetCardValuePerResource(bestCard, cResourceWood))) ||
                      ((aiHCCardsGetCardValuePerResource(bestCard, cResourceFood) > 0.0) &&
                       (aiHCCardsGetCardValuePerResource(card, cResourceFood) >
                        aiHCCardsGetCardValuePerResource(bestCard, cResourceFood))) ||
                      ((aiHCCardsGetCardValuePerResource(bestCard, cResourceGold) > 0.0) &&
                       (aiHCCardsGetCardValuePerResource(card, cResourceGold) >
                        aiHCCardsGetCardValuePerResource(bestCard, cResourceGold)))))
            { // make sure more valuable villager cards win
               bestCardPri = xsArrayGetInt(gCardPriorities, card);
               bestCard = card;
               bestCardFlags = currentCardFlags;
            }
            else if ((((currentCardFlags & cHCCardFlagResourceCrate) == cHCCardFlagResourceCrate) &&
                      ((bestCardFlags & cHCCardFlagResourceCrate) == cHCCardFlagResourceCrate)) &&
                     (((aiHCCardsGetCardValuePerResource(bestCard, cResourceWood) > 0.0) &&
                       (aiHCCardsGetCardValuePerResource(card, cResourceWood) >
                        aiHCCardsGetCardValuePerResource(bestCard, cResourceWood))) ||
                      ((aiHCCardsGetCardValuePerResource(bestCard, cResourceFood) > 0.0) &&
                       (aiHCCardsGetCardValuePerResource(card, cResourceFood) >
                        aiHCCardsGetCardValuePerResource(bestCard, cResourceFood))) ||
                      ((aiHCCardsGetCardValuePerResource(bestCard, cResourceGold) > 0.0) &&
                       (aiHCCardsGetCardValuePerResource(card, cResourceGold) >
                        aiHCCardsGetCardValuePerResource(bestCard, cResourceGold)))))
            { // make sure more valuable resource cards for the same resource win
               bestCardPri = xsArrayGetInt(gCardPriorities, card);
               bestCard = card;
               bestCardFlags = currentCardFlags;
            }
            else if (((((currentCardFlags & cHCCardFlagResourceCrate) == cHCCardFlagResourceCrate) &&
                       ((bestCardFlags & cHCCardFlagResourceCrate) == cHCCardFlagResourceCrate)) &&
                      (xsArrayGetInt(gCardPriorities, card) >= bestCardPri)) &&
                     (((aiHCCardsGetCardValuePerResource(card, cResourceWood) > 0.0) &&
                       (aiHCCardsGetCardValuePerResource(card, cResourceWood) >=
                        aiHCCardsGetCardValuePerResource(bestCard, cResourceFood))) ||
                      ((aiHCCardsGetCardValuePerResource(card, cResourceGold) > 0.0) &&
                       (aiHCCardsGetCardValuePerResource(card, cResourceGold) >=
                        aiHCCardsGetCardValuePerResource(bestCard, cResourceFood)))))
            { // prioritize coin & wood, food
               bestCardPri = xsArrayGetInt(gCardPriorities, card);
               bestCard = card;
               bestCardFlags = currentCardFlags;
            }
            else if ((xsArrayGetInt(gCardPriorities, card) == bestCardPri) &&
                     ((currentCardFlags & cHCCardFlagMilitary) == cHCCardFlagMilitary) &&
                     ((currentCardFlags & cHCCardFlagUnit) == cHCCardFlagUnit) && (totalValueCurrent > totalValueBest))
            { // If it's the same priority of a military unit card, take the one with the better value.
               bestCardPri = xsArrayGetInt(gCardPriorities, card);
               bestCard = card;
               totalValueBest = totalValueCurrent;
            }
         }
         if (bestCard >= 0)
         {
            if ((xsArrayGetInt(gCardPriorities, bestCard) < 6) && (cardsPicked >= 2))
               continue; // After the first two cards, only pick another if it's good.
            addCardToDeck(gDefaultDeck, bestCard);
            cardsRemaining = cardsRemaining - 1;
            xsArraySetString(gCardStates, bestCard, "D");
            // aiEcho("  7Adding card "+xsArrayGetString(gCardNames, bestCard));
            cardsPicked = cardsPicked + 1;
            cardsAge4 = cardsAge4 + 1;
            if (((bestCardFlags & cHCCardFlagVillager) == cHCCardFlagVillager) && (addedVillager == false))
               addedVillager = true;
            if (((bestCardFlags & cHCCardFlagResourceCrate) == cHCCardFlagResourceCrate) && (addedCrates < 2))
               addedCrates = addedCrates + 1;
            if (((bestCardFlags & cHCCardFlagUnit) == cHCCardFlagUnit) && (aiHCCardsGetCardCount(bestCard) < 0) &&
                (addedInfUnit == false))
               addedInfUnit = true;
         }
      } // 1-10 remaining.

      totalValueCurrent = 0.0;
      totalValueBest = 0.0;
      totalCost = 0.0;
      // Finally, remaining cards from any age, usually military units
      // Villagers, Resource Crates, Mercenaries and Allies will be ignored here
      for (i = 0; < cardsRemaining)
      {
         bestCard = -1;
         bestCardPri = -1;
         currentCardFlags = 0;
         totalValueCurrent = 0.0;
         totalValueBest = 0.0;
         totalCost = 0.0;
         for (card = 0; < maxCards)
         {
            if (xsArrayGetString(gCardStates, card) != "P")
               continue; // Only consider purchased cards not already in deck.
            currentCardFlags = aiHCCardsGetCardFlags(card);
            if (((currentCardFlags & cHCCardFlagMercenary) == cHCCardFlagMercenary) ||
                (kbProtoUnitIsType(cMyID, aiHCCardsGetCardUnitType(card), cUnitTypeMercenary) == true))
               continue; // Ignore any mercenary cards
            if ((currentCardFlags & cHCCardFlagVillager) == cHCCardFlagVillager)
               continue; // Ignore villager cards
            if ((currentCardFlags & cHCCardFlagResourceCrate) == cHCCardFlagResourceCrate &&
                (btRushBoom <= 0.0 || aiHCCardsGetCardAgePrereq(card) != cAge2))
               continue; // Ignore resource crate cards
            if (kbProtoUnitIsType(cMyID, aiHCCardsGetCardUnitType(card), cUnitTypeypMercArsonist) == true)
               continue; // Ignore any arsonist cards (wrongly not classified as mercenary)
            if (((civIsNative() == true) || (civIsAsian() == true)) &&
                (kbProtoUnitIsType(cMyID, aiHCCardsGetCardUnitType(card), cUnitTypeMercType1) == true) &&
                (kbProtoUnitIsType(cMyID, aiHCCardsGetCardUnitType(card), cUnitTypexpSkullKnight) == false) &&
                (kbProtoUnitIsType(cMyID, aiHCCardsGetCardUnitType(card), cUnitTypexpDogSoldier) == false))
               continue; // For natives and Asians, ignore any native allies cards (excluding skull knights and dog
                         // soldiers, both wrongly classified as MercType1)
            if ((civIsNative() == true) &&
                ((kbProtoUnitIsType(cMyID, aiHCCardsGetCardUnitType(card), cUnitTypeRodelero) == true) ||
                 (kbProtoUnitIsType(cMyID, aiHCCardsGetCardUnitType(card), cUnitTypeCuirassier) == true) ||
                 (kbProtoUnitIsType(cMyID, aiHCCardsGetCardUnitType(card), cUnitTypeHalberdier) == true)))
               continue; // For natives, ignore any renegade cards
            if ((kbProtoUnitIsType(cMyID, aiHCCardsGetCardUnitType(card), cUnitTypeSaloonOutlawPistol) == true) ||
                (kbProtoUnitIsType(cMyID, aiHCCardsGetCardUnitType(card), cUnitTypeSaloonOutlawRider) == true) ||
                (kbProtoUnitIsType(cMyID, aiHCCardsGetCardUnitType(card), cUnitTypeSaloonOutlawRifleman) == true))
               continue; // Ignore any outlaw cards
            if (((currentCardFlags & cHCCardFlagUnit) == cHCCardFlagUnit) && (addedInfUnit == true) &&
                (aiHCCardsGetCardCount(card) < 0) && (xsArrayGetInt(gCardPriorities, card) < 10))
               continue; // Don't add more than one infinite military card for now.
            if (((aiHCCardsGetCardAgePrereq(card) == cAge1) && (cardsAge1 >= 10)) ||
                ((aiHCCardsGetCardAgePrereq(card) == cAge2) && (cardsAge2 >= 10)) ||
                ((aiHCCardsGetCardAgePrereq(card) == cAge3) && (cardsAge3 >= 10)) ||
                ((aiHCCardsGetCardAgePrereq(card) == cAge4) && (cardsAge4 >= 10)))
               continue; // Continue as we're already at our card limit for this age.
            if ((xsArrayGetInt(gCardPriorities, card) == bestCardPri) &&
                ((currentCardFlags & cHCCardFlagUnit) == cHCCardFlagUnit))
            { // If it's a unit calculate a value for this card.
               totalValueCurrent = aiHCCardsGetCardValuePerResource(card, cResourceWood) +
                                   aiHCCardsGetCardValuePerResource(card, cResourceFood) +
                                   aiHCCardsGetCardValuePerResource(card, cResourceGold);
               totalCost = kbTechCostPerResource(aiHCCardsGetCardTechID(card), cResourceWood) +
                           kbTechCostPerResource(aiHCCardsGetCardTechID(card), cResourceFood) +
                           kbTechCostPerResource(aiHCCardsGetCardTechID(card), cResourceGold);
               totalValueCurrent = totalValueCurrent - (totalCost / 2);
               if (totalValueCurrent < 0.0)
                  totalValueCurrent = 0.0;
            }
            if (xsArrayGetInt(gCardPriorities, card) > bestCardPri)
            {
               bestCardPri = xsArrayGetInt(gCardPriorities, card);
               bestCard = card;
               totalValueBest = totalValueCurrent;
            }
            else if ((xsArrayGetInt(gCardPriorities, card) == bestCardPri) &&
                     ((currentCardFlags & cHCCardFlagUnit) == cHCCardFlagUnit) && (totalValueCurrent > totalValueBest))
            { // If it's the same priority of a unit card, take the one with the better value.
               bestCardPri = xsArrayGetInt(gCardPriorities, card);
               bestCard = card;
               totalValueBest = totalValueCurrent;
            }
            else if ((xsArrayGetInt(gCardPriorities, card) == bestCardPri) &&
                     (aiHCCardsGetCardAgePrereq(bestCard) <= cAge2) &&
                     ((aiHCCardsGetCardAgePrereq(card) == cAge3) ||
                      ((cardsAge3 >= 10) && (aiHCCardsGetCardAgePrereq(card) >= cAge4) && (cardsAge4 < 10))))
            { // Prefer age 3 cards over 1 and 2.
               bestCardPri = xsArrayGetInt(gCardPriorities, card);
               bestCard = card;
               totalValueBest = totalValueCurrent;
            }
         }
         if (bestCard >= 0)
         {
            addCardToDeck(gDefaultDeck, bestCard);
            // cardsRemaining = cardsRemaining - 1;
            xsArraySetString(gCardStates, bestCard, "D");
            // aiEcho("  8Adding card "+xsArrayGetString(gCardNames, bestCard));
            if (aiHCCardsGetCardAgePrereq(bestCard) == cAge1)
               cardsAge1 = cardsAge1 + 1;
            if (aiHCCardsGetCardAgePrereq(bestCard) == cAge2)
               cardsAge2 = cardsAge2 + 1;
            if (aiHCCardsGetCardAgePrereq(bestCard) == cAge3)
               cardsAge3 = cardsAge3 + 1;
            if (aiHCCardsGetCardAgePrereq(bestCard) == cAge4)
               cardsAge4 = cardsAge4 + 1;
            if (((bestCardFlags & cHCCardFlagUnit) == cHCCardFlagUnit) && (aiHCCardsGetCardCount(bestCard) < 0) &&
                (addedInfUnit == false))
               addedInfUnit = true;
         }
      } // All done, no cards remaining.

      aiEcho("Activating deck");
      aiHCDeckActivate(gDefaultDeck);

      xsDisableSelf();
      break;
   }
   }
}

//==============================================================================
// init...Called once we have units in the new world.
//==============================================================================
void init(void)
{
   // Set the Explore Danger Threshold.
   aiSetExploreDangerThreshold(110.0);

   // Set the gIAmCaptain bool and gCaptainPlayerNumber vars.
   // selectCaptain();

   // Setup the resign handler
   aiSetHandler("resignHandler", cXSResignHandler);

   // Setup the nugget handler
   aiSetHandler("nuggetHandler", cXSNuggetHandler);

   // Set up the age-up chat handler
   //   aiSetHandler("ageUpHandler", cXSAgeHandler);

   aiSetHandler("ageUpHandler", cXSPlayerAgeHandler);

   //-- set the ScoreOppHandler
   aiSetHandler("scoreOpportunity", cXSScoreOppHandler);

   // Set up the communication handler
   aiCommsSetEventHandler("commHandler");

   // This handler runs when you have a shipment available in the home city
   aiSetHandler("shipGrantedHandler", cXSShipResourceGranted);

   // Handlers for mission start/end
   aiSetHandler("missionStartHandler", cXSMissionStartHandler);
   aiSetHandler("missionEndHandler", cXSMissionEndHandler);

   // Game ending handler, to save game-to-game data before game ends
   aiSetHandler("gameOverHandler", cXSGameOverHandler);

   // Handler when a player starts the monopoly victory timer
   aiSetHandler("monopolyStartHandler", cXSMonopolyStartHandler);

   // And when a monopoly timer prematurely ends
   aiSetHandler("monopolyEndHandler", cXSMonopolyEndHandler);

   // Handler when a player starts the KOTH victory timer
   aiSetHandler("KOTHVictoryStartHandler", cXSKOTHVictoryStartHandler);

   // And when a KOTH timer prematurely ends
   aiSetHandler("KOTHVictoryEndHandler", cXSKOTHVictoryEndHandler);

   aiSetHandler("autoCreatePlanHandler", cXSAutoCreatePlanHandler);

   aiSetHandler("revoltedHandler", cXSRevoltedHandler);

   aiSetHandler("buildingPlacementFailedHandler", cXSBuildingPlacementFailedHandler);

   //-- init Econ and Military stuff.
   initEcon();
   initMil();

   if ((aiGetGameType() == cGameTypeScenario) || (aiGetGameType() == cGameTypeScenario))
      cvOkToResign = false; // Default is to not allow resignation in scenarios.  Can override in postInit().

   // Fishing always viable on these maps
   /*if ((cRandomMapName == "carolina") ||
      (cRandomMapName == "carolinalarge") ||
      (cRandomMapName == "new england") ||
      (cRandomMapName == "caribbean") ||
      (cRandomMapName == "patagonia") ||
      (cRandomMapName == "yucatan") ||
      (cRandomMapName == "hispaniola") ||
      (cRandomMapName == "araucania") ||
      (cRandomMapName == "california") ||
      (cRandomMapName == "northwest territory") ||
      (cRandomMapName == "saguenay") ||
      (cRandomMapName == "saguenaylarge") ||
      (cRandomMapName == "unknown") ||
      (cRandomMapName == "Ceylon") ||
      (cRandomMapName == "Borneo") ||
      (cRandomMapName == "Honshu") ||
      (cRandomMapName == "HonshuRegicide") ||
      (cRandomMapName == "Yellow riverWet"))
   {
      gGoodFishingMap = true;
   }
   if (cRandomMapName == "great lakes")
      if (kbUnitCount(cMyID, cUnitTypeHomeCityWaterSpawnFlag) > 0)   // We have a flag, the lake isn't frozen
         gGoodFishingMap = true;
   */

   if (gSPC == true)
   {
      if (aiIsMapType("AIFishingUseful") == true)
         gGoodFishingMap = true;
      else
         gGoodFishingMap = false;
   }
   else
   {
      if (kbUnitCount(cMyID, cUnitTypeHomeCityWaterSpawnFlag) > 0)
         gGoodFishingMap = true;
   }

   if (kbUnitCount(cMyID, cUnitTypeHomeCityWaterSpawnFlag) > 0)
      gNavyMap = true;

   if (gSPC == true)
   {
      if (kbUnitCount(cMyID, cUnitTypeHomeCityWaterSpawnFlag) > 0) // We have a flag, there must be water...
         gNavyMap = true;
      else
         gNavyMap = false;
   }

   // Create a temporary main base so the plans have something to deal with.
   // If there is a scenarioStart object, use it.  If not, use the TC, if any.
   // Failing that, use an explorer, a war chief, a monk, a settlerWagon, or a Settler.
   // Failing that, select any freakin' unit and use it.
   vector tempBaseVec = cInvalidVector;
   int unitID = -1;
   unitID = getUnit(cUnitTypeAIStart, cMyID, cUnitStateAlive);
   if (unitID < 0)
      unitID = getUnit(cUnitTypeTownCenter, cMyID, cUnitStateAlive);
   if (unitID < 0)
      unitID = getUnit(cUnitTypeExplorer, cMyID, cUnitStateAlive);
   if (unitID < 0)
      unitID = getUnit(cUnitTypexpAztecWarchief, cMyID, cUnitStateAlive);
   if (unitID < 0)
      unitID = getUnit(cUnitTypexpIroquoisWarChief, cMyID, cUnitStateAlive);
   if (unitID < 0)
      unitID = getUnit(cUnitTypexpLakotaWarchief, cMyID, cUnitStateAlive);
   if (unitID < 0)
      unitID = getUnit(cUnitTypedeIncaWarChief, cMyID, cUnitStateAlive);
   if (unitID < 0)
      unitID = getUnit(cUnitTypeypMonkChinese, cMyID, cUnitStateAlive);
   if (unitID < 0)
      unitID = getUnit(cUnitTypeypMonkIndian, cMyID, cUnitStateAlive);
   if (unitID < 0)
      unitID = getUnit(cUnitTypeypMonkIndian2, cMyID, cUnitStateAlive);
   if (unitID < 0)
      unitID = getUnit(cUnitTypeypMonkJapanese, cMyID, cUnitStateAlive);
   if (unitID < 0)
      unitID = getUnit(cUnitTypeypMonkJapanese2, cMyID, cUnitStateAlive);
   if (unitID < 0)
      unitID = getUnit(gCoveredWagonUnit, cMyID, cUnitStateAlive);
   if (unitID < 0)
      unitID = getUnit(cUnitTypeSettler, cMyID, cUnitStateAlive);
   if (unitID < 0)
      unitID = getUnit(gEconUnit, cMyID, cUnitStateAlive);

   if (unitID < 0)
      aiEcho(
          "**** I give up...I can't find an aiStart unit, TC, wagon, explorer or settler.  How do you expect me to play?!");
   else
      tempBaseVec = kbUnitGetPosition(unitID);

   // This will create an interim main base at this location.
   // Only done if there is no TC, otherwise we rely on the auto-created base
   if ((gStartMode == cStartModeScenarioNoTC) || (getUnit(cUnitTypeTownCenter, cMyID, cUnitStateAlive) < 0))
      gMainBase = createMainBase(tempBaseVec);

   // If we have a covered wagon, let's pick a spot for the TC search to begin, and a TC start time to activate the
   // build plan.
   int coveredWagon = getUnit(gCoveredWagonUnit, cMyID, cUnitStateAlive);
   if (coveredWagon >= 0)
   {
      vector coveredWagonPos = kbUnitGetPosition(coveredWagon);
      vector normalVec = xsVectorNormalize(kbGetMapCenter() - coveredWagonPos);
      int offset = 40;
      gTCSearchVector = coveredWagonPos + (normalVec * offset);

      while (kbAreaGroupGetIDByPosition(gTCSearchVector) != kbAreaGroupGetIDByPosition(coveredWagonPos))
      {
         // Try for a goto point 40 meters toward center.  Fall back 5m at a time if that's on another continent/ocean.
         // If under 5, we'll take it.
         offset = offset - 5;
         gTCSearchVector = coveredWagonPos + (normalVec * offset);
         if (offset < 5)
            break;
      }

      // Note...if this is a scenario, we should use the AIStart object's position, NOT the covered wagon position.
      // Override...
      int aiStart = getUnit(cUnitTypeAIStart, cMyID, cUnitStateAny);
      if (aiStart >= 0)
      {
         gTCSearchVector = kbUnitGetPosition(aiStart);
         aiEcho("Using aiStart object at " + gTCSearchVector + " to start TC placement search");
      }
   }

   // Set up the generic land explore plan.
   if (cvOkToExplore == true)
   {
      if (cMyCiv == cCivDutch)
      { // Keep the envoy busy.
         int envoyExplore = aiPlanCreate("Envoy Explore", cPlanExplore);
         aiPlanSetDesiredPriority(envoyExplore, 75);
         aiPlanAddUnitType(envoyExplore, cUnitTypeEnvoy, 0, 1, 1);
         aiPlanSetEscrowID(envoyExplore, cEconomyEscrowID);
         aiPlanSetBaseID(envoyExplore, kbBaseGetMainID(cMyID));
         aiPlanSetVariableBool(envoyExplore, cExplorePlanDoLoops, 0, false);
         aiPlanSetActive(envoyExplore);
      }
   }

   // Disables early groups, starts nugget hunting, moves explorer later.
   xsEnableRule("exploreMonitor");

   if ((gStartMode == cStartModeScenarioWagon) || (gStartMode == cStartModeLandWagon) || (gStartMode == cStartModeBoat))
   {
      aiEcho("Creating a TC build plan.");
      // Make a town center, pri 100, econ, main base, 1 builder.
      int buildPlan = aiPlanCreate("TC Build plan ", cPlanBuild);
      // What to build
      aiPlanSetVariableInt(buildPlan, cBuildPlanBuildingTypeID, 0, cUnitTypeTownCenter);
      // Priority.
      aiPlanSetDesiredPriority(buildPlan, 100);
      // Mil vs. Econ.
      aiPlanSetMilitary(buildPlan, false);
      aiPlanSetEconomy(buildPlan, true);
      // Escrow.
      aiPlanSetEscrowID(buildPlan, cEconomyEscrowID);
      // Builders.
      aiPlanAddUnitType(buildPlan, gCoveredWagonUnit, 1, 1, 1);

      // Instead of base ID or areas, use a center position and falloff.
      if (gTCSearchVector == cInvalidVector)
         aiPlanSetVariableVector(buildPlan, cBuildPlanCenterPosition, 0, coveredWagonPos);
      else
         aiPlanSetVariableVector(buildPlan, cBuildPlanCenterPosition, 0, gTCSearchVector);
      aiPlanSetVariableFloat(buildPlan, cBuildPlanCenterPositionDistance, 0, 40.00);

      // Add position influences for trees, gold
      aiPlanSetNumberVariableValues(buildPlan, cBuildPlanInfluenceUnitTypeID, 3, true);
      aiPlanSetNumberVariableValues(buildPlan, cBuildPlanInfluenceUnitDistance, 3, true);
      aiPlanSetNumberVariableValues(buildPlan, cBuildPlanInfluenceUnitValue, 3, true);
      aiPlanSetNumberVariableValues(buildPlan, cBuildPlanInfluenceUnitFalloff, 3, true);
      aiPlanSetVariableInt(buildPlan, cBuildPlanInfluenceUnitTypeID, 0, cUnitTypeWood);
      aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluenceUnitDistance, 0, 30.0);           // 30m range.
      aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluenceUnitValue, 0, 10.0);              // 10 points per tree
      aiPlanSetVariableInt(buildPlan, cBuildPlanInfluenceUnitFalloff, 0, cBPIFalloffLinear); // Linear slope falloff
      aiPlanSetVariableInt(buildPlan, cBuildPlanInfluenceUnitTypeID, 1, cUnitTypeMine);
      aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluenceUnitDistance, 1, 50.0);           // 50 meter range for gold
      aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluenceUnitValue, 1, 300.0);             // 300 points each
      aiPlanSetVariableInt(buildPlan, cBuildPlanInfluenceUnitFalloff, 1, cBPIFalloffLinear); // Linear slope falloff
      aiPlanSetVariableInt(buildPlan, cBuildPlanInfluenceUnitTypeID, 2, cUnitTypeMine);
      aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluenceUnitDistance, 2,
                             20.0); // 20 meter inhibition to keep some space
      aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluenceUnitValue, 2, -300.0);          // -300 points each
      aiPlanSetVariableInt(buildPlan, cBuildPlanInfluenceUnitFalloff, 2, cBPIFalloffNone); // Cliff falloff

      // Two position weights
      aiPlanSetNumberVariableValues(buildPlan, cBuildPlanInfluencePosition, 2, true);
      aiPlanSetNumberVariableValues(buildPlan, cBuildPlanInfluencePositionDistance, 2, true);
      aiPlanSetNumberVariableValues(buildPlan, cBuildPlanInfluencePositionValue, 2, true);
      aiPlanSetNumberVariableValues(buildPlan, cBuildPlanInfluencePositionFalloff, 2, true);

      // Give it a positive but wide-range prefernce for the search area, and a more intense but smaller negative to
      // avoid the landing area. Weight it to prefer the general starting neighborhood
      aiPlanSetVariableVector(buildPlan, cBuildPlanInfluencePosition, 0,
                              gTCSearchVector); // Position influence for search position
      aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluencePositionDistance, 0, 200.0);          // 200m range.
      aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluencePositionValue, 0, 300.0);             // 300 points max
      aiPlanSetVariableInt(buildPlan, cBuildPlanInfluencePositionFalloff, 0, cBPIFalloffLinear); // Linear slope falloff

      // Add negative weight to avoid initial drop-off beach area
      aiPlanSetVariableVector(
          buildPlan, cBuildPlanInfluencePosition, 1,
          kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID))); // Position influence for landing position
      aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluencePositionDistance, 1, 50.0);           // Smaller, 50m range.
      aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluencePositionValue, 1, -400.0);            // -400 points max
      aiPlanSetVariableInt(buildPlan, cBuildPlanInfluencePositionFalloff, 1, cBPIFalloffLinear); // Linear slope falloff
      // This combo will make it dislike the immediate landing (-100), score +25 at 50m, score +150 at 100m, then
      // gradually fade to +0 at 200m.

      // Wait to activate TC build plan, to allow adequate exploration
      gTCBuildPlanID = buildPlan; // Save in a global var so the rule can access it.
      aiPlanSetEventHandler(buildPlan, cPlanEventStateChange, "tcPlacedEventHandler");

      xsEnableRule("tcBuildPlanDelay");
   }

   xsEnableRule("buyCards");

   xsEnableRule("townCenterComplete"); // Rule to build other buildings after TC completion
   xsEnableRule("wagonMonitor");
   xsEnableRule("ageUpgradeMonitor"); // Make sure we freeze spending to allow age-ups at certain villie pop levels

   xsEnableRule("envoyMonitor");
   xsEnableRule("nativeScoutMonitor");
   xsEnableRule("mongolScoutMonitor");
   xsEnableRule("chasquiMonitor");

   xsEnableRule("rescueExplorer");
   xsEnableRule("ransomExplorer");

   postInit(); // All normal initialization is done, let loader file clean up what it needs to.

   aiEcho("INITIAL BEHAVIOR SETTINGS");
   aiEcho("    Rush " + btRushBoom);
   aiEcho("    Offense " + btOffenseDefense);
   aiEcho("    Cav " + btBiasCav);
   aiEcho("    Inf " + btBiasInf);
   aiEcho("    Art " + btBiasArt);
   aiEcho("    Natives " + btBiasNative);
   aiEcho("    Trade " + btBiasTrade);
	
}

//==============================================================================
// initRule
// Add a brief delay to make sure the covered wagon (if any) has time to unload
//==============================================================================
rule initRule
inactive
minInterval 3
{
   if (cvInactiveAI == true)
      return; // Wait forever unless this changes
   init();
   xsDisableSelf();
}

//==============================================================================
// ottomanMonitor
// Make sure they always have a mosque, get techs as available
//==============================================================================
rule ottomanMonitor
inactive
minInterval 25
{
   int speedPlanID = -1; // Plan for improving vill training speed.
   int capPlanID = -1;   // Plan for raising settler pop limit.
   int mosquePlanID = -1;
   int villagerImprovementPlan = -1;

   // Disable rule once all techs have been researched
   if ((kbTechGetStatus(cTechChurchMilletSystem) == cTechStatusActive) &&
       (kbTechGetStatus(cTechChurchKopruluViziers) == cTechStatusActive) &&
       (kbTechGetStatus(cTechChurchAbbassidMarket) == cTechStatusActive) &&
       (kbTechGetStatus(cTechChurchGalataTowerDistrict) == cTechStatusActive) &&
       (kbTechGetStatus(cTechChurchTopkapi) == cTechStatusActive) &&
       (kbTechGetStatus(cTechChurchTanzimat) == cTechStatusActive))
   {
      xsDisableSelf();
      return;
   }

   // If no mosque and no build plan, build one, exit.
   if (kbUnitCount(cMyID, cUnitTypeChurch, cUnitStateAlive) < 1)
   { // No mosque, check for build plan, add one if needed
      mosquePlanID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeChurch);
      if (mosquePlanID < 0)
      {
         aiEcho(" ");
         aiEcho("Creating mosque build plan");
         aiEcho(" ");
         createSimpleBuildPlan(cUnitTypeChurch, 1, 93, true, cEconomyEscrowID, kbBaseGetMainID(cMyID), 1);
      }
      return;
   }

   // We have a mosque, continue...
   // Check for each of their techs.  If it's obtainable and there's
   // no plan, get it.

   if (kbTechGetStatus(cTechChurchMilletSystem) == cTechStatusObtainable)
   {
      speedPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchMilletSystem);
      if (speedPlanID < 0)
      {
         villagerImprovementPlan =
             createSimpleResearchPlan(cTechChurchMilletSystem, getUnit(cUnitTypeChurch), cEconomyEscrowID, 91);
         aiPlanSetDesiredResourcePriority(villagerImprovementPlan, 70);
      }
   }

   if (kbTechGetStatus(cTechChurchKopruluViziers) == cTechStatusObtainable)
   {
      speedPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchKopruluViziers);
      if (speedPlanID < 0)
      {
         villagerImprovementPlan =
             createSimpleResearchPlan(cTechChurchKopruluViziers, getUnit(cUnitTypeChurch), cEconomyEscrowID, 91);
         aiPlanSetDesiredResourcePriority(villagerImprovementPlan, 70);
      }
   }

   if ((kbTechGetStatus(cTechChurchAbbassidMarket) == cTechStatusObtainable) && (kbGetAge() >= cAge2))
   {
      speedPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchAbbassidMarket);
      if (speedPlanID < 0)
      {
         villagerImprovementPlan =
             createSimpleResearchPlan(cTechChurchAbbassidMarket, getUnit(cUnitTypeChurch), cEconomyEscrowID, 91);
         aiPlanSetDesiredResourcePriority(villagerImprovementPlan, 70);
      }
   }

   if ((kbTechGetStatus(cTechChurchGalataTowerDistrict) == cTechStatusObtainable) && (kbGetAge() >= cAge2))
   {
      capPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchGalataTowerDistrict);
      if (capPlanID < 0)
      {
         villagerImprovementPlan =
             createSimpleResearchPlan(cTechChurchGalataTowerDistrict, getUnit(cUnitTypeChurch), cEconomyEscrowID, 91);
         aiPlanSetDesiredResourcePriority(villagerImprovementPlan, 65);
         for (i = 0; <= cvMaxAge)
         {
            xsArraySetInt(gTargetSettlerCounts, i, 45);
         }
      }
   }

   if ((kbTechGetStatus(cTechChurchTopkapi) == cTechStatusObtainable) && (kbGetAge() >= cAge3) &&
       (aiGetWorldDifficulty() >= cDifficultyModerate))
   {
      capPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchTopkapi);
      if (capPlanID < 0)
      {
         villagerImprovementPlan =
             createSimpleResearchPlan(cTechChurchTopkapi, getUnit(cUnitTypeChurch), cEconomyEscrowID, 91);
         aiPlanSetDesiredResourcePriority(villagerImprovementPlan, 60);
         for (i = 0; <= cvMaxAge)
         {
            xsArraySetInt(gTargetSettlerCounts, i, 70);
         }
      }
   }

   if ((kbTechGetStatus(cTechChurchTanzimat) == cTechStatusObtainable) && (kbGetAge() >= cAge4) &&
       (aiGetWorldDifficulty() >= cDifficultyHard))
   {
      capPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchTanzimat);
      if (capPlanID < 0)
      {
         villagerImprovementPlan =
             createSimpleResearchPlan(cTechChurchTanzimat, getUnit(cUnitTypeChurch), cEconomyEscrowID, 91);
         aiPlanSetDesiredResourcePriority(villagerImprovementPlan, 55);
         for (i = 0; <= cvMaxAge)
         {
            xsArraySetInt(gTargetSettlerCounts, i, 99);
         }
      }
   }
}

rule herdMonitor
inactive
group startup
minInterval 20
{
   // Activated when a livestock pen is being built.  Wait for completion, and then
   // move the herd plan to the livestock pen.
   if (civIsNative() == true)
   {
      if (kbUnitCount(cMyID, cUnitTypeFarm, cUnitStateAlive) > 0)
      {
         aiPlanSetVariableInt(gHerdPlanID, cHerdPlanBuildingTypeID, 0, cUnitTypeFarm);
         aiPlanSetVariableBool(gHerdPlanID, cHerdPlanUseMultipleBuildings, 0, true);
         return;
      }
   }
   else
   {
      if (cMyCiv == cCivJapanese || cMyCiv == cCivSPCJapanese || cMyCiv == cCivSPCJapaneseEnemy)
      {
         if (kbUnitCount(cMyID, cUnitTypeAbstractShrine, cUnitStateAlive) > 0)
         {
            aiPlanSetVariableInt(gHerdPlanID, cHerdPlanBuildingTypeID, 0, cUnitTypeAbstractShrine);
            aiPlanSetVariableBool(gHerdPlanID, cHerdPlanUseMultipleBuildings, 0, true);
            return;
         }
      }
      else
      {
         if (kbUnitCount(cMyID, gLivestockPenUnit, cUnitStateAlive) > 0)
         {
            aiPlanSetVariableInt(gHerdPlanID, cHerdPlanBuildingTypeID, 0, gLivestockPenUnit);
            aiPlanSetVariableBool(gHerdPlanID, cHerdPlanUseMultipleBuildings, 0, true);
            return;
         }
      }
   }

   // Gather at TC as fallback.
   int tcID = getUnit(cUnitTypeTownCenter);
   aiPlanSetVariableInt(gHerdPlanID, cHerdPlanBuildingTypeID, 0, cUnitTypeTownCenter);
   if (aiPlanGetVariableInt(gHerdPlanID, cHerdPlanBuildingID, 0) != tcID)
      aiPlanSetVariableInt(gHerdPlanID, cHerdPlanBuildingID, 0, tcID);
   aiPlanSetVariableBool(gHerdPlanID, cHerdPlanUseMultipleBuildings, 0, false);
}

rule backHerdMonitor
inactive
priority 100
minInterval 10
{
   static int planID = -1;
   static int herdResourceID = -1;
   static int herdUnitID = -1;
   static vector herdUnitPosition = cInvalidVector;
   static float herdUnitHitpoints = 0.0;

   if (gTimeToFarm == true)
   {
      if (planID > 0)
         aiPlanDestroy(planID);
      xsDisableSelf();
      return;
   }

   if (planID < 0)
   {
      planID = aiPlanCreate("Backherd plan", cPlanReserve);
      aiPlanAddUnitType(planID, gEconUnit, 1, 1, 1);
      aiPlanSetDesiredPriority(planID, 95);
   }

   int workerUnitID = aiPlanGetUnitByIndex(planID, 0);

   if (workerUnitID < 0)
      return;

   int numberResources = 0;
   int resourceID = -1;
   int numberUnits = 0;
   int unitID = -1;
   vector position = cInvalidVector;
   float hitpoints = 0.0;
   int mainBaseID = kbBaseGetMainID(cMyID);
   float dist = 0.0;
   float maxDist = kbBaseGetMaximumResourceDistance(cMyID, mainBaseID);
   int baseID = -1;
   int baseOwner = -1;
	vector mainBaseLocation = cInvalidVector;
	
	// We herd towards our first Granary when we're an African civ (if we have one).
	if (civIsAfrican())
	{
		int granaryID = getUnit(cUnitTypedeGranary, cMyID, cUnitStateABQ);
		if (granaryID != -1)
			mainBaseLocation = kbUnitGetPosition(granaryID);
		else
		{
			aiPlanDestroy(planID);
			planID = -1;
			return;
		}
	}
	else 
		mainBaseLocation = kbBaseGetLocation(cMyID, mainBaseID);
	
   if (herdResourceID < 0)
   {
      if (getResourcePerGatherer(cResourceFood, 30.0, false) >= 2 * cMinResourcePerGatherer)
      {
         aiPlanDestroy(planID);
         planID = -1;
         return;
      }

      numberResources = kbResourceGetNumber();
      for (i = 0; < numberResources)
      {
         resourceID = kbResourceGetIDByIndex(i);
         if (kbResourceGetType(resourceID) != cResourceFood ||
             kbResourceGetSubType(resourceID) != cAIResourceSubTypeHunt)
            continue;
         unitID = kbResourceGetUnit(resourceID, 0);
         if (unitID < 0)
            continue;
         position = kbUnitGetPosition(unitID);
         dist = distance(position, mainBaseLocation);
         if (dist < 30.0 || dist >= maxDist)
            continue;
         baseID = kbFindClosestBase(cPlayerRelationAlly, position);
         // dont herd ally's hunts.
         if (baseID >= 0)
         {
            baseOwner = kbBaseGetOwner(baseID);
            if (baseOwner != cMyID)
            {
               dist = distance(position, kbBaseGetLocation(baseOwner, baseID));
               if (dist < 30.0)
                  continue;
            }
         }
         numberUnits = kbResourceGetNumberUnits(resourceID);
         for (j = 0; < numberUnits)
         {
            unitID = kbResourceGetUnit(resourceID, j);
            hitpoints = kbUnitGetCurrentHitpoints(unitID);
            if (unitID < 0 || hitpoints <= 10.0)
            {
               unitID = -1;
               continue;
            }
            break;
         }
         if (unitID < 0)
            continue;
         herdResourceID = resourceID;
         aiPlanSetActive(planID, true);
         xsSetRuleMinIntervalSelf(1);
         xsSetRuleMaxIntervalSelf(1);
         break;
      }
   }

   if (herdResourceID < 0)
   {
      aiPlanDestroy(planID);
      planID = -1;
      return;
   }

   if (herdUnitID < 0)
   {
      unitID = kbResourceGetUnit(herdResourceID, 0);
      position = kbUnitGetPosition(unitID);
      if (distance(position, mainBaseLocation) < 15.0)
      {
         herdResourceID = -1;
         return;
      }
      numberUnits = kbResourceGetNumberUnits(herdResourceID);
      for (i = 0; < numberUnits)
      {
         unitID = kbResourceGetUnit(herdResourceID, i);
         hitpoints = kbUnitGetCurrentHitpoints(unitID);
         if (unitID < 0 || hitpoints <= 10.0)
            continue;

         herdUnitID = unitID;
         herdUnitPosition = kbUnitGetPosition(unitID);
         herdUnitHitpoints = hitpoints;

         aiTaskUnitMove(workerUnitID, herdUnitPosition + (xsVectorNormalize(herdUnitPosition - mainBaseLocation) *
                                                          aiRandFloat(16.0, 20.0)));
         aiTaskUnitWork(workerUnitID, herdUnitID, true);
         return;
      }
      herdResourceID = -1;
      return;
   }

   if (herdUnitID < 0)
   {
      herdResourceID = -1;
      xsSetRuleMinIntervalSelf(10);
      xsSetRuleMaxIntervalSelf(20);
      return;
   }

   position = kbUnitGetPosition(herdUnitID);
   if (position != herdUnitPosition)
   {
      herdUnitPosition = position;
      aiTaskUnitMove(workerUnitID, herdUnitPosition + (xsVectorNormalize(herdUnitPosition - mainBaseLocation) *
                                                       aiRandFloat(16.0, 20.0)));
      aiTaskUnitWork(workerUnitID, herdUnitID, true);
      return;
   }

   hitpoints = kbUnitGetCurrentHitpoints(herdUnitID);
   if (hitpoints < herdUnitHitpoints)
   {
      aiTaskUnitMove(workerUnitID, kbUnitGetPosition(workerUnitID));
      herdUnitID = -1;
      herdUnitHitpoints = 0.0;
      return;
   }
}

rule rescueExplorer
inactive
minInterval 120
{
   static int rescuePlan = -1;

   // Destroy old rescue plan (if any)
   if (rescuePlan >= 0)
   {
      aiPlanDestroy(rescuePlan);
      rescuePlan = -1;
      aiEcho("Killing old rescue plan");
   }

   // Use only in Age 2 and above
   if ((kbGetAge() < cAge2) || (aiGetFallenExplorerID() < 0))
      return;

   // Ransom explorer instead if we have excess coin
   if (kbResourceGet(cResourceGold) >= 1300)
   {
      aiEcho("Ransom explorer instead of attempting to rescue.");
      return;
   }

   // Use only when explorer is strong enough
   if (kbUnitGetHealth(aiGetFallenExplorerID()) < 0.3)
   {
      aiEcho("Explorer too weak to be rescued");
      return;
   }

   // Decide on which unit type to use for rescue attempt
   // If possible, converted guardians or cheap infantry units are used
   int scoutType = -1;
   if (kbUnitCount(cMyID, cUnitTypeGuardian, cUnitStateAlive) >= 1)
      scoutType = cUnitTypeGuardian;
   else if (kbUnitCount(cMyID, cUnitTypeCrossbowman, cUnitStateAlive) >= 1)
      scoutType = cUnitTypeCrossbowman;
   else if (kbUnitCount(cMyID, cUnitTypePikeman, cUnitStateAlive) >= 1)
      scoutType = cUnitTypePikeman;
   else if (kbUnitCount(cMyID, cUnitTypeStrelet, cUnitStateAlive) >= 1)
      scoutType = cUnitTypeStrelet;
   else if (kbUnitCount(cMyID, cUnitTypeLongbowman, cUnitStateAlive) >= 1)
      scoutType = cUnitTypeLongbowman;
   else if (kbUnitCount(cMyID, cUnitTypeMusketeer, cUnitStateAlive) >= 1)
      scoutType = cUnitTypeMusketeer;
   else if (kbUnitCount(cMyID, cUnitTypexpWarrior, cUnitStateAlive) >= 1)
      scoutType = cUnitTypexpWarrior;
   else if (kbUnitCount(cMyID, cUnitTypexpAenna, cUnitStateAlive) >= 1)
      scoutType = cUnitTypexpAenna;
   else if (kbUnitCount(cMyID, cUnitTypexpTomahawk, cUnitStateAlive) >= 1)
      scoutType = cUnitTypexpTomahawk;
   else if (kbUnitCount(cMyID, cUnitTypexpMacehualtin, cUnitStateAlive) >= 1)
      scoutType = cUnitTypexpMacehualtin;
   else if (kbUnitCount(cMyID, cUnitTypexpPumaMan, cUnitStateAlive) >= 1)
      scoutType = cUnitTypexpPumaMan;
   else if (kbUnitCount(cMyID, cUnitTypexpWarBow, cUnitStateAlive) >= 1)
      scoutType = cUnitTypexpWarBow;
   else if (kbUnitCount(cMyID, cUnitTypexpWarClub, cUnitStateAlive) >= 1)
      scoutType = cUnitTypexpWarClub;
   else if (kbUnitCount(cMyID, cUnitTypeSaloonOutlawPistol, cUnitStateAlive) >= 1)
      scoutType = cUnitTypeSaloonOutlawPistol;
   else if (kbUnitCount(cMyID, cUnitTypeSaloonOutlawRifleman, cUnitStateAlive) >= 1)
      scoutType = cUnitTypeSaloonOutlawRifleman;
   else if (kbUnitCount(cMyID, cUnitTypeJanissary, cUnitStateAlive) >= 1)
      scoutType = cUnitTypeJanissary;
   else if (kbUnitCount(cMyID, cUnitTypeypQiangPikeman, cUnitStateAlive) >= 1)
      scoutType = cUnitTypeypQiangPikeman;
   else if (kbUnitCount(cMyID, cUnitTypeypChuKoNu, cUnitStateAlive) >= 1)
      scoutType = cUnitTypeypChuKoNu;
   else if (kbUnitCount(cMyID, cUnitTypeypMonkDisciple, cUnitStateAlive) >= 1)
      scoutType = cUnitTypeypMonkDisciple;
   else if (kbUnitCount(cMyID, cUnitTypeypArquebusier, cUnitStateAlive) >= 1)
      scoutType = cUnitTypeypArquebusier;
   else if (kbUnitCount(cMyID, cUnitTypeypChangdao, cUnitStateAlive) >= 1)
      scoutType = cUnitTypeypChangdao;
   else if (kbUnitCount(cMyID, cUnitTypeypSepoy, cUnitStateAlive) >= 1)
      scoutType = cUnitTypeypSepoy;
   else if (kbUnitCount(cMyID, cUnitTypeypNatMercGurkha, cUnitStateAlive) >= 1)
      scoutType = cUnitTypeypNatMercGurkha;
   else if (kbUnitCount(cMyID, cUnitTypeypRajput, cUnitStateAlive) >= 1)
      scoutType = cUnitTypeypRajput;
   else if (kbUnitCount(cMyID, cUnitTypeypYumi, cUnitStateAlive) >= 1)
      scoutType = cUnitTypeypYumi;
   else if (kbUnitCount(cMyID, cUnitTypeypAshigaru, cUnitStateAlive) >= 1)
      scoutType = cUnitTypeypAshigaru;
   else
      scoutType = cUnitTypeLogicalTypeValidSharpshoot;

   // Get position of fallen explorer and send scout unit there
   vector fallenExplorerLocation = kbUnitGetPosition(aiGetFallenExplorerID());
   rescuePlan = aiPlanCreate("Rescue Explorer", cPlanExplore);
   if (rescuePlan >= 0)
   {
      aiPlanAddUnitType(rescuePlan, scoutType, 1, 1, 1);
      aiPlanAddWaypoint(rescuePlan, fallenExplorerLocation);
      aiPlanSetVariableBool(rescuePlan, cExplorePlanDoLoops, 0, false);
      aiPlanSetVariableBool(rescuePlan, cExplorePlanAvoidingAttackedAreas, 0, false);
      aiPlanSetVariableInt(rescuePlan, cExplorePlanNumberOfLoops, 0, -1);
      aiPlanSetRequiresAllNeedUnits(rescuePlan, true);
      aiPlanSetDesiredPriority(rescuePlan, 42);
      aiPlanSetActive(rescuePlan);
      aiEcho("Trying to rescue explorer");
   }
}

rule ransomExplorer
inactive
minInterval 120
{
   // Disable rule for native or Asian civs
   if (civIsNative() == true || civIsAsian() == true)
   {
      xsDisableSelf();
      return;
   }

   // Use only in Age 2 and above when we have sufficient coin reserves
   if ((kbGetAge() < cAge2) || (aiGetFallenExplorerID() < 0) || (kbResourceGet(cResourceGold) < 1300))
   {
      return;
   }

   aiRansomExplorer(aiGetFallenExplorerID(), cMilitaryEscrowID, getUnit(cUnitTypeTownCenter));
   aiEcho("Ransoming explorer");
}

rule tradingPostMonitor
inactive
minInterval 1
group tcComplete
{
   if (aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeTradingPost) >= 0)
   {
      return;
   }

   int socketQuery = createSimpleUnitQuery(cUnitTypeSocket, 0, cUnitStateAlive);
   int numberFound = kbUnitQueryExecute(socketQuery);
   int unitID = -1;
   int puid = -1;
   int mainBaseID = kbBaseGetMainID(cMyID);
   vector mainBaseLocation = kbBaseGetLocation(cMyID, mainBaseID);
   int mainAreaGroup = kbAreaGroupGetIDByPosition(mainBaseLocation);
   int socketAreaGroup = -1;
   int socketID = -1;
   vector socketPosition = cInvalidVector;
   float militaryPower = 0.0;
   float distancePenalty = 0.0;
   int bestTradeSocketID = -1;
   int bestTradeDistancePenalty = 0.0;
   int bestNativeSocketID = -1;
   int bestNativeDistancePenalty = 0.0;
   static int enemyQuery = -1;
   bool earlyTrade = false;
   bool hasTradingPostWagon = false;
   bool hasTradingPostRickshaw = false;

   if (kbUnitCount(cMyID, cUnitTypedeTradingPostWagon, cUnitStateAlive) > 0)
      hasTradingPostWagon = true;
   else if (kbUnitCount(cMyID, cUnitTypeypTradingPostWagon, cUnitStateAlive) > 0)
      hasTradingPostRickshaw = true;

   if (enemyQuery < 0)
   {
      enemyQuery = kbUnitQueryCreate("tradingPostEnemyQuery");
      kbUnitQuerySetIgnoreKnockedOutUnits(enemyQuery, true);
      // Run before house monitor to claim a trading post at the start of the game.
      xsSetRuleMinIntervalSelf(30);
   }

   for (i = 0; < numberFound)
   {
      socketID = kbUnitQueryGetResult(socketQuery, i);
      socketPosition = kbUnitGetPosition(socketID);

      // already claimed, skipping.
      if (getUnitByLocation(cUnitTypeTradingPost, cPlayerRelationAny, cUnitStateABQ, socketPosition, 10.0) >= 0)
         continue;

      kbUnitQuerySetPlayerRelation(enemyQuery, cPlayerRelationEnemyNotGaia);
      kbUnitQuerySetState(enemyQuery, cUnitStateABQ);
      kbUnitQuerySetPosition(enemyQuery, socketPosition);
      kbUnitQuerySetMaximumDistance(enemyQuery, 50.0);

      kbUnitQuerySetUnitType(enemyQuery, cUnitTypeHasBountyValue);
      kbUnitQueryResetResults(enemyQuery);
      numberFound = kbUnitQueryExecute(enemyQuery);

      for (j = 0; < numberFound)
      {
         unitID = kbUnitQueryGetResult(enemyQuery, j);
         puid = kbUnitGetProtoUnitID(unitID);

         militaryPower = 0.0;

         switch (puid)
         {
         case cUnitTypeTownCenter:
         {
            militaryPower = militaryPower + 4.0;
            break;
         }
         case cUnitTypeFortFrontier:
         {
            militaryPower = militaryPower + 10.0;
            break;
         }
         case cUnitTypeOutpost:
         {
            militaryPower = militaryPower + 3.0;
            break;
         }
         case cUnitTypeBlockhouse:
         {
            militaryPower = militaryPower + 3.0;
            break;
         }
         case cUnitTypeNoblesHut:
         {
            militaryPower = militaryPower + 4.0;
            break;
         }
         case cUnitTypeypWIAgraFort2:
         {
            militaryPower = militaryPower + 4.0;
            break;
         }
         case cUnitTypeypWIAgraFort3:
         {
            militaryPower = militaryPower + 4.0;
            break;
         }
         case cUnitTypeypWIAgraFort4:
         {
            militaryPower = militaryPower + 4.0;
            break;
         }
         case cUnitTypeypWIAgraFort5:
         {
            militaryPower = militaryPower + 4.0;
            break;
         }
         case cUnitTypeypCastle:
         {
            militaryPower = militaryPower + 3.5;
            break;
         }
         case cUnitTypeYPOutpostAsian:
         {
            militaryPower = militaryPower + 3.0;
            break;
         }
         case cUnitTypedeIncaStronghold:
         {
            militaryPower = militaryPower + 4.0;
            break;
         }
         }

         if (kbProtoUnitIsType(cMyID, puid, cUnitTypeLogicalTypeLandMilitary) == true)
            militaryPower = militaryPower + getMilitaryUnitStrength(puid);
      }

      // Skip when there are too many military units around.
      if (militaryPower >= 5.0)
         continue;

      // Adjust for distance. If < 100m, leave as is.  Over 100m to 400m, penalize 10% per 100m.
      distancePenalty = distance(mainBaseLocation, socketPosition) / 1000.0;
      if (distancePenalty > 0.4)
         distancePenalty = 0.4;
      // Increase penalty by 40% if transporting is required.
      socketAreaGroup = kbAreaGroupGetIDByPosition(socketPosition);
      if (mainAreaGroup != socketAreaGroup)
         distancePenalty = distancePenalty + 0.4;
      distancePenalty = 1.0 - distancePenalty;

      if (kbUnitIsType(socketID, cUnitTypeNativeSocket) == true)
      {
         if (cvOkToAllyNatives == true && distancePenalty > bestNativeDistancePenalty)
         {
            bestNativeSocketID = socketID;
            bestNativeDistancePenalty = distancePenalty;
         }
      }
      else
      {
         if (cvOkToClaimTrade == true && distancePenalty > bestTradeDistancePenalty)
         {
            bestTradeSocketID = socketID;
            bestTradeDistancePenalty = distancePenalty;
         }
      }
   }

   if (bestNativeSocketID >= 0 || bestTradeSocketID >= 0)
   {
      socketID = -1;

      if (bestNativeSocketID >= 0)
      {
         if (xsGetTime() - gLastClaimNativeMissionTime >= (1.0 - btBiasNative) * gClaimNativeMissionInterval ||
             hasTradingPostWagon || hasTradingPostRickshaw)
            socketID = bestNativeSocketID;
      }

      if (bestTradeSocketID >= 0)
      {
         if (kbGetAge() == cAge1 && agingUp() == false)
         {
            // build an early TP if we have enough wood at start, exclude Indians because we need wood to continue
            // villager production.
            if ((isProtoUnitAffordable(cUnitTypeTradingPost) == true || hasTradingPostWagon ||
                 hasTradingPostRickshaw) &&
                cMyCiv != cCivIndians && cMyCiv != cCivSPCIndians)
               earlyTrade = true;
            else
               return;
         }
         if (xsGetTime() - gLastClaimTradeMissionTime >= (1.0 - btBiasTrade) * gClaimTradeMissionInterval ||
             hasTradingPostWagon || hasTradingPostRickshaw)
            socketID = bestTradeSocketID;
      }

      if (socketID < 0)
         return;

      int planID = aiPlanCreate("Trading Post Build Plan", cPlanBuild);
      int heroQuery = createSimpleUnitQuery(cUnitTypeHero, cMyID, cUnitStateAlive);
      int heroNumberFound = kbUnitQueryExecute(heroQuery);
      int heroID = -1;

      for (i = 0; < heroNumberFound)
      {
         unitID = kbUnitQueryGetResult(heroQuery, i);
         if (unitID < 0)
            continue;
         if (kbProtoUnitCanTrain(kbUnitGetProtoUnitID(unitID), cUnitTypeTradingPost) == false)
            continue;
         heroID = unitID;
         break;
      }

      aiPlanSetVariableInt(planID, cBuildPlanBuildingTypeID, 0, cUnitTypeTradingPost);
      aiPlanSetVariableInt(planID, cBuildPlanSocketID, 0, socketID);

      if (hasTradingPostWagon || hasTradingPostRickshaw)
      {
         aiEcho("***** AI PlAYER HAS WAGONS");
         int tpWagonQueryID = -1;

         if (hasTradingPostRickshaw)
         {
            aiPlanAddUnitType(planID, cUnitTypeypTradingPostWagon, 1, 1, 1);
            tpWagonQueryID = createSimpleUnitQuery(cUnitTypeypTradingPostWagon, cMyID, cUnitStateAlive);
         }
         else
         {
            aiEcho("***** AMERICAN/EURO TP WAGONS");
            aiPlanAddUnitType(planID, cUnitTypedeTradingPostWagon, 1, 1, 1);
            tpWagonQueryID = createSimpleUnitQuery(cUnitTypedeTradingPostWagon, cMyID, cUnitStateAlive);
         }

         int wagonNumberFound = kbUnitQueryExecute(tpWagonQueryID);
         int wagon = -1;

         for (w = 0; < wagonNumberFound)
         {
            wagon = kbUnitQueryGetResult(tpWagonQueryID, w);
            if (kbUnitGetPlanID(wagon) >= 0)
               continue;

            aiPlanAddUnit(planID, wagon);
            break;
         }
      }
      else if (heroID >= 0)
      {
         int heroPlanID = kbUnitGetPlanID(heroID);
         if (heroPlanID < 0 || aiPlanGetType(heroPlanID) == cPlanDefend)
         {
            aiPlanAddUnitType(planID, cUnitTypeHero, 1, 1, 1);
            aiPlanAddUnit(planID, heroID);
         }
         else
         {
            heroID = -1;
         }
      }

      if (heroID < 0 && ((gRevolutionType & cRevolutionMilitary) == 0 ||
                         (gRevolutionType & cRevolutionFinland) == cRevolutionFinland))
      {
         aiPlanAddUnitType(planID, gEconUnit, 1, 1, 1);
      }

      // Priority.
      aiPlanSetDesiredPriority(planID, 97);
      // Very high priority so we claim a trading post right after start up.
      if (earlyTrade == true)
         aiPlanSetDesiredResourcePriority(planID, 70);
      else
         aiPlanSetDesiredResourcePriority(planID, 55);

      // Mil vs. Econ.
      aiPlanSetMilitary(planID, false);
      aiPlanSetEconomy(planID, true);
      // Escrow.
      aiPlanSetEscrowID(planID, cEconomyEscrowID);

      // Go.
      aiPlanSetActive(planID);

      aiEcho("***** STARTING a TRADING POST build plan.");

      if (socketID == bestNativeSocketID)
         gLastClaimNativeMissionTime = xsGetTime();
      else
         gLastClaimTradeMissionTime = xsGetTime();
   }
}

rule tradeRouteUpgradeMonitor
inactive
minInterval 90
{
   if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechTradeRouteUpgrade1) >= 0 ||
       aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechTradeRouteUpgrade2) >= 0 ||
       aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypTradeRouteUpgrade1) >= 0 ||
       aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypTradeRouteUpgrade2) >= 0)
      return;

   int routeIndex = 0;
   int postIndex = 0;
   int numberRoutes = 0;
   int numberTradingPosts = 0;
   int tradingPostID = -1;
   int playerID = -1;
   int ownedTradingPostID = -1;
   int numberAllyTradingPosts = 0;
   int numberEnemyTradingPosts = 0;
   int tradeRoutePlan = -1;
   int tradeRoutePrio = 44;
   float tradeRouteBias = 0.0;

   numberRoutes = kbGetNumberTradeRoutes();
   for (routeIndex = 0; < numberRoutes)
   {
      numberTradingPosts = kbTradeRouteGetNumberTradingPosts(routeIndex);
      ownedTradingPostID = -1;
      numberAllyTradingPosts = 0;
      numberEnemyTradingPosts = 0;
      if (numberTradingPosts == 0)
         continue;
      for (postIndex = 0; < numberTradingPosts)
      {
         tradingPostID = kbTradeRouteGetTradingPostID(routeIndex, postIndex);
         if (tradingPostID < 0)
            continue;
         playerID = kbUnitGetPlayerID(tradingPostID);
         if (playerID == cMyID)
         {
            ownedTradingPostID = tradingPostID;
            numberAllyTradingPosts = numberAllyTradingPosts + 1;
            continue;
         }
         if (kbIsPlayerAlly(playerID) == true)
         {
            numberAllyTradingPosts = numberAllyTradingPosts + 1;
            continue;
         }
         if (kbIsPlayerAlly(playerID) == false)
            numberEnemyTradingPosts = numberEnemyTradingPosts + 1;
      }
      if (ownedTradingPostID >= 0)
      {
         float villCount = kbUnitCount(cMyID, gEconUnit, cUnitStateABQ);
         tradeRouteBias = (btBiasTrade * 5.0);
         if ((tradeRouteBias < 0.5) || (villCount >= 40))
            tradeRoutePrio = tradeRoutePrio + tradeRouteBias;
         if (kbUnitIsType(ownedTradingPostID, cUnitTypeypTradingPostAsian) == true)
         {
            if ((kbBuildingTechGetStatus(cTechypTradeRouteUpgrade1, ownedTradingPostID) == cTechStatusObtainable) &&
                (kbGetAge() >= cAge2))
            {
               tradeRoutePlan =
                   createSimpleResearchPlan(cTechypTradeRouteUpgrade1, ownedTradingPostID, cEconomyEscrowID, 50);
               aiPlanSetDesiredResourcePriority(tradeRoutePlan, tradeRoutePrio);
               break;
            }
            if ((kbBuildingTechGetStatus(cTechypTradeRouteUpgrade2, ownedTradingPostID) == cTechStatusObtainable) &&
                (kbGetAge() >= cAge4))
            {
               if ((numberAllyTradingPosts >= 2) || (numberEnemyTradingPosts <= 0))
               {
                  tradeRoutePlan =
                      createSimpleResearchPlan(cTechypTradeRouteUpgrade2, ownedTradingPostID, cEconomyEscrowID, 50);
                  aiPlanSetDesiredResourcePriority(tradeRoutePlan, tradeRoutePrio);
                  break;
               }
            }
         }
         else
         {
            if ((kbBuildingTechGetStatus(cTechTradeRouteUpgrade1, ownedTradingPostID) == cTechStatusObtainable) &&
                (kbGetAge() >= cAge2))
            {
               tradeRoutePlan =
                   createSimpleResearchPlan(cTechTradeRouteUpgrade1, ownedTradingPostID, cEconomyEscrowID, 50);
               aiPlanSetDesiredResourcePriority(tradeRoutePlan, tradeRoutePrio);
               break;
            }
            if ((kbBuildingTechGetStatus(cTechTradeRouteUpgrade2, ownedTradingPostID) == cTechStatusObtainable) &&
                (kbGetAge() >= cAge4))
            {
               if ((numberAllyTradingPosts >= 2) || (numberEnemyTradingPosts <= 0))
               {
                  tradeRoutePlan =
                      createSimpleResearchPlan(cTechTradeRouteUpgrade2, ownedTradingPostID, cEconomyEscrowID, 50);
                  aiPlanSetDesiredResourcePriority(tradeRoutePlan, tradeRoutePrio);
                  break;
               }
            }
         }
      }
   }
}

rule tradeRouteTacticMonitor
inactive
minInterval 60
{

   int routeIndex = 0;
   int postIndex = 0;
   int numberRoutes = 0;
   int numberTradingPosts = 0;
   int tradingPostID = -1;
   int playerID = -1;
   float totalResources = kbResourceGet(cResourceFood) + kbResourceGet(cResourceWood) + kbResourceGet(cResourceGold);

   numberRoutes = kbGetNumberTradeRoutes();
   for (routeIndex = 0; < numberRoutes)
   {
      numberTradingPosts = kbTradeRouteGetNumberTradingPosts(routeIndex);
      if (numberTradingPosts == 0)
         continue;
      for (postIndex = 0; < numberTradingPosts)
      {
         tradingPostID = kbTradeRouteGetTradingPostID(routeIndex, postIndex);
         if (tradingPostID < 0)
            continue;
         playerID = kbUnitGetPlayerID(tradingPostID);
         if (playerID == cMyID)
         {
            if (kbUnitIsType(tradingPostID, cUnitTypeypTradingPostAsian) == true)
            {
               if ((kbBuildingTechGetStatus(cTechypTradeRouteUpgrade1, tradingPostID) == cTechStatusActive) ||
                   (kbBuildingTechGetStatus(cTechypTradeRouteUpgrade2, tradingPostID) == cTechStatusActive))
               {
                  if (totalResources >= 10000)
                     aiSetTradingPostUnitType(tradingPostID, cUnitTypeCrateofXP);
                  else if (kbResourceGet(cResourceWood) < (totalResources / 9.0))
                     aiSetTradingPostUnitType(tradingPostID, cUnitTypeypCrateofWood);
                  else if (kbResourceGet(cResourceFood) < (totalResources / 9.0))
                     aiSetTradingPostUnitType(tradingPostID, cUnitTypeypCrateofFood);
                  else if (kbResourceGet(cResourceGold) < (totalResources / 9.0) ||
                           (kbResourceGet(cResourceShips) >= 2.0))
                     aiSetTradingPostUnitType(tradingPostID, cUnitTypeypCrateofCoin);
                  else
                     aiSetTradingPostUnitType(tradingPostID, cUnitTypeCrateofXP);
               }
            }
            else
            {
               if ((kbBuildingTechGetStatus(cTechTradeRouteUpgrade1, tradingPostID) == cTechStatusActive) ||
                   (kbBuildingTechGetStatus(cTechTradeRouteUpgrade2, tradingPostID) == cTechStatusActive))
               {
                  if (totalResources >= 10000)
                     aiSetTradingPostUnitType(tradingPostID, cUnitTypeCrateofXP);
                  else if (kbResourceGet(cResourceWood) < (totalResources / 9.0))
                     aiSetTradingPostUnitType(tradingPostID, cUnitTypeCrateofWood);
                  else if (kbResourceGet(cResourceFood) < (totalResources / 9.0))
                     aiSetTradingPostUnitType(tradingPostID, cUnitTypeCrateofFood);
                  else if (kbResourceGet(cResourceGold) < (totalResources / 9.0) ||
                           (kbResourceGet(cResourceShips) >= 2.0))
                     aiSetTradingPostUnitType(tradingPostID, cUnitTypeCrateofCoin);
                  else
                     aiSetTradingPostUnitType(tradingPostID, cUnitTypeCrateofXP);
               }
            }
         }
      }
   }
}

rule tamboMonitor
inactive
minInterval 90
{
   if (cMyCiv != cCivDEInca)
   {
      xsDisableSelf();
      return;
   }

   static int tamboPlan = -1;

   // Destroy existing plan (cleanup)
   if (tamboPlan >= 0)
   {
      aiPlanDestroy(tamboPlan);
      tamboPlan = -1;
      aiEcho("Destroying old tambo upgrade plan");
   }
   if ((kbTechGetStatus(cTechdeMightyTambos) == cTechStatusObtainable) &&
       (kbUnitCount(cMyID, cUnitTypeTradingPost, cUnitStateAlive) >= 1) && (kbGetAge() >= cAge4))
   {
      tamboPlan = createSimpleResearchPlan(
          cTechdeMightyTambos, getUnitByTech(cUnitTypeTradingPost, cTechdeMightyTambos), cMilitaryEscrowID, 50);
      return;
   }
}

rule strongholdUpgradeMonitor
inactive
minInterval 90
{
   static int strongholdPlan = -1;

   // Destroy existing plan (cleanup)
   if (strongholdPlan >= 0)
   {
      aiPlanDestroy(strongholdPlan);
      strongholdPlan = -1;
      aiEcho("Destroying old stronghold upgrade plan");
   }
   if ((kbTechGetStatus(cTechdePukaras) == cTechStatusObtainable) &&
       (kbUnitCount(cMyID, cUnitTypedeIncaStronghold, cUnitStateAlive) >= 1))
   {
      strongholdPlan = createSimpleResearchPlan(
          cTechdePukaras, getUnitByTech(cUnitTypedeIncaStronghold, cTechdePukaras), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechdeSacsayhuaman) == cTechStatusObtainable) &&
       (kbUnitCount(cMyID, cUnitTypedeIncaStronghold, cUnitStateAlive) >= 1) && (kbGetAge() >= cAge4))
   {
      strongholdPlan = createSimpleResearchPlan(
          cTechdeSacsayhuaman, getUnitByTech(cUnitTypedeIncaStronghold, cTechdeSacsayhuaman), cMilitaryEscrowID, 50);
      return;
   }
}

rule strongholdConstructionMonitor
inactive
minInterval 75
{
   if ((cvOkToBuildForts == false) && (cvOkToFortify == false)) // was OR
      return;

   if ((kbUnitCount(cMyID, cUnitTypedeIncaStrongholdTravois, cUnitStateAlive) <= 0) && (aiGetFallenExplorerID() >= 0))
      return; // No builder

   static int strongholdBuildPlanID = -1;

   strongholdBuildPlanID =
       aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypedeIncaStronghold);

   if (kbGetBuildLimit(cMyID, cUnitTypedeIncaStronghold) <=
       kbUnitCount(cMyID, cUnitTypedeIncaStronghold, cUnitStateAlive))
   {
      if (strongholdBuildPlanID >= 0)
      {
         aiPlanDestroy(strongholdBuildPlanID);
         strongholdBuildPlanID = -1;
      }
      return; // Don't build if we're at limit.
   }

   if (strongholdBuildPlanID < 0)
   {
      aiEcho("Creating a stronghold build plan.");
      strongholdBuildPlanID = aiPlanCreate("Stronghold build plan ", cPlanBuild);
      aiPlanSetVariableInt(strongholdBuildPlanID, cBuildPlanBuildingTypeID, 0, cUnitTypedeIncaStronghold);
      // Priority.
      aiPlanSetDesiredPriority(strongholdBuildPlanID, 91); // higher than explorerControlPlan
      // Mil vs. Econ.
      aiPlanSetMilitary(strongholdBuildPlanID, true);
      aiPlanSetEconomy(strongholdBuildPlanID, false);
      // Escrow.
      aiPlanSetEscrowID(strongholdBuildPlanID, cMilitaryEscrowID);
      // Builders.
      if (kbUnitCount(cMyID, cUnitTypedeIncaStrongholdTravois, cUnitStateAlive) > 0)
         aiPlanAddUnitType(strongholdBuildPlanID, cUnitTypedeIncaStrongholdTravois, 1, 1, 1);
      else if (aiGetFallenExplorerID() == -1)
         aiPlanAddUnitType(strongholdBuildPlanID, cUnitTypedeIncaWarChief, 1, 1, 1);
      else
      {
         aiPlanDestroy(strongholdBuildPlanID);
         strongholdBuildPlanID = -1;
         return;
      }
      vector mainBaseVec = cInvalidVector;
      mainBaseVec = kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID));
      if (mainBaseVec == cInvalidVector)
      {
         aiPlanDestroy(strongholdBuildPlanID);
         strongholdBuildPlanID = -1;
         return;
      }
      aiPlanSetBaseID(strongholdBuildPlanID, kbBaseGetMainID(cMyID));
      aiPlanSetVariableFloat(strongholdBuildPlanID, cBuildPlanBuildingBufferSpace, 0, 4.5);
      aiPlanSetVariableVector(strongholdBuildPlanID, cBuildPlanCenterPosition, 0, mainBaseVec);
      aiPlanSetVariableFloat(strongholdBuildPlanID, cBuildPlanCenterPositionDistance, 0, 40.0);
      aiPlanSetVariableVector(strongholdBuildPlanID, cBuildPlanInfluencePosition, 0,
                              mainBaseVec); // Influence toward position
      aiPlanSetVariableFloat(strongholdBuildPlanID, cBuildPlanInfluencePositionDistance, 0, 100.0); // 100m range.
      aiPlanSetVariableFloat(strongholdBuildPlanID, cBuildPlanInfluencePositionValue, 0, 200.0);    // 200 points max
      aiPlanSetVariableInt(strongholdBuildPlanID, cBuildPlanInfluencePositionFalloff, 0,
                           cBPIFalloffLinear); // Linear slope falloff
      // Go.
      aiPlanSetActive(strongholdBuildPlanID);
   }
}

rule minorTribeTechMonitor
inactive
minInterval 90
{
   int techPlanID = -1;

   // Get techs from different minor tribes one at a time as they become available
   // Unavailable tribes and techs are simply ignored

   // Quit if there is no appropriate trading post
   if (kbUnitCount(cMyID, cUnitTypeTradingPost, cUnitStateAlive) < 1)
      return;

   // Apache techs
   if (kbTechGetStatus(cTechNatXPApacheCactus) == cTechStatusObtainable)
   {
      if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatXPApacheCactus) >= 0)
         return;
      createSimpleResearchPlan(cTechNatXPApacheCactus, getUnitByTech(cUnitTypeTradingPost, cTechNatXPApacheCactus),
                               cEconomyEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechNatXPApacheRaiding) == cTechStatusObtainable)
   {
      if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatXPApacheRaiding) >= 0)
         return;
      createSimpleResearchPlan(cTechNatXPApacheRaiding, getUnitByTech(cUnitTypeTradingPost, cTechNatXPApacheRaiding),
                               cMilitaryEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechNatXPApacheEndurance) == cTechStatusObtainable)
   {
      if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatXPApacheEndurance) >= 0)
         return;
      createSimpleResearchPlan(cTechNatXPApacheEndurance,
                               getUnitByTech(cUnitTypeTradingPost, cTechNatXPApacheEndurance), cMilitaryEscrowID, 50);
      return;
   }

   // Carib techs
   if ((kbTechGetStatus(cTechNatCeremonialFeast) == cTechStatusObtainable) &&
       (kbUnitCount(cMyID, cUnitTypeNatBlowgunWarrior, cUnitStateAlive) +
            kbUnitCount(cMyID, cUnitTypeNatBlowgunAmbusher, cUnitStateAlive) +
            kbUnitCount(cMyID, cUnitTypeNatMercBlowgunWarrior, cUnitStateAlive) >=
        10))
   {
      if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatCeremonialFeast) >= 0)
         return;
      createSimpleResearchPlan(cTechNatCeremonialFeast, getUnitByTech(cUnitTypeTradingPost, cTechNatCeremonialFeast),
                               cMilitaryEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechNatKasiriBeer) == cTechStatusObtainable)
   {
      if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatKasiriBeer) >= 0)
         return;
      createSimpleResearchPlan(cTechNatKasiriBeer, getUnitByTech(cUnitTypeTradingPost, cTechNatKasiriBeer),
                               cMilitaryEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechNatCeremonialFeast) == cTechStatusObtainable)
   {
      if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatCeremonialFeast) >= 0)
         return;
      createSimpleResearchPlan(cTechNatCeremonialFeast, getUnitByTech(cUnitTypeTradingPost, cTechNatCeremonialFeast),
                               cMilitaryEscrowID, 50);
      return;
   }

   // Cherokee techs
   if (kbTechGetStatus(cTechNatBasketweaving) == cTechStatusObtainable)
   {
      if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatBasketweaving) >= 0)
         return;
      createSimpleResearchPlan(cTechNatBasketweaving, getUnitByTech(cUnitTypeTradingPost, cTechNatBasketweaving),
                               cEconomyEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechNatSequoyahSyllabary) == cTechStatusObtainable)
   {
      if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatSequoyahSyllabary) >= 0)
         return;
      createSimpleResearchPlan(cTechNatSequoyahSyllabary,
                               getUnitByTech(cUnitTypeTradingPost, cTechNatSequoyahSyllabary), cEconomyEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechNatWarDance) == cTechStatusObtainable)
   {
      if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatWarDance) >= 0)
         return;
      createSimpleResearchPlan(cTechNatWarDance, getUnitByTech(cUnitTypeTradingPost, cTechNatWarDance),
                               cMilitaryEscrowID, 50);
      return;
   }

   // Cheyenne techs
   if (kbTechGetStatus(cTechNatXPCheyenneHuntingGrounds) == cTechStatusObtainable)
   {
      if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatXPCheyenneHuntingGrounds) >= 0)
         return;
      createSimpleResearchPlan(cTechNatXPCheyenneHuntingGrounds,
                               getUnitByTech(cUnitTypeTradingPost, cTechNatXPCheyenneHuntingGrounds), cEconomyEscrowID,
                               50);
      return;
   }
   if (kbTechGetStatus(cTechNatXPCheyenneHorseTrading) == cTechStatusObtainable)
   {
      if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatXPCheyenneHorseTrading) >= 0)
         return;
      createSimpleResearchPlan(cTechNatXPCheyenneHorseTrading,
                               getUnitByTech(cUnitTypeTradingPost, cTechNatXPCheyenneHorseTrading), cMilitaryEscrowID,
                               50);
      return;
   }
   if (kbTechGetStatus(cTechNatXPCheyenneFury) == cTechStatusObtainable)
   {
      if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatXPCheyenneFury) >= 0)
         return;
      createSimpleResearchPlan(cTechNatXPCheyenneFury, getUnitByTech(cUnitTypeTradingPost, cTechNatXPCheyenneFury),
                               cMilitaryEscrowID, 50);
      return;
   }

   // Comanche techs
   if (kbTechGetStatus(cTechNatTradeLanguage) == cTechStatusObtainable)
   {
      if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatTradeLanguage) >= 0)
         return;
      createSimpleResearchPlan(cTechNatTradeLanguage, getUnitByTech(cUnitTypeTradingPost, cTechNatTradeLanguage),
                               cEconomyEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechNatHorseBreeding) == cTechStatusObtainable)
   {
      if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatHorseBreeding) >= 0)
         return;
      createSimpleResearchPlan(cTechNatHorseBreeding, getUnitByTech(cUnitTypeTradingPost, cTechNatHorseBreeding),
                               cMilitaryEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechNatMustangs) == cTechStatusObtainable)
   {
      if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatMustangs) >= 0)
         return;
      createSimpleResearchPlan(cTechNatMustangs, getUnitByTech(cUnitTypeTradingPost, cTechNatMustangs),
                               cMilitaryEscrowID, 50);
      return;
   }

   // Cree techs
   if (kbTechGetStatus(cTechNatTextileCraftsmanship) == cTechStatusObtainable)
   {
      if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatTextileCraftsmanship) >= 0)
         return;
      createSimpleResearchPlan(cTechNatTextileCraftsmanship,
                               getUnitByTech(cUnitTypeTradingPost, cTechNatTextileCraftsmanship), cEconomyEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechNatTanning) == cTechStatusObtainable)
   {
      if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatTanning) >= 0)
         return;
      createSimpleResearchPlan(cTechNatTanning, getUnitByTech(cUnitTypeTradingPost, cTechNatTanning), cMilitaryEscrowID,
                               50);
      return;
   }

   // Huron techs
   if ((kbTechGetStatus(cTechNatXPHuronTradeMonopoly) == cTechStatusObtainable) &&
       (xsGetTime() > 20 * 60 * 1000)) // Use only after at least 20 minutes of game time (i.e. 10 units)
   {
      if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatXPHuronTradeMonopoly) >= 0)
         return;
      createSimpleResearchPlan(cTechNatXPHuronTradeMonopoly,
                               getUnitByTech(cUnitTypeTradingPost, cTechNatXPHuronTradeMonopoly), cEconomyEscrowID, 50);
      return;
   }

   // Inca techs
   if (kbTechGetStatus(cTechNatMetalworking) == cTechStatusObtainable)
   {
      if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatMetalworking) >= 0)
         return;
      createSimpleResearchPlan(cTechNatMetalworking, getUnitByTech(cUnitTypeTradingPost, cTechNatMetalworking),
                               cEconomyEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechNatChasquisMessengers) == cTechStatusObtainable)
   {
      if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatChasquisMessengers) >= 0)
         return;
      createSimpleResearchPlan(cTechNatChasquisMessengers,
                               getUnitByTech(cUnitTypeTradingPost, cTechNatChasquisMessengers), cMilitaryEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechNatRoadbuilding) == cTechStatusObtainable)
   {
      if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatRoadbuilding) >= 0)
         return;
      createSimpleResearchPlan(cTechNatRoadbuilding, getUnitByTech(cUnitTypeTradingPost, cTechNatRoadbuilding),
                               cMilitaryEscrowID, 50);
      return;
   }

   // Klamath techs
   if (kbTechGetStatus(cTechNatXPKlamathWorkEthos) == cTechStatusObtainable)
   {
      if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatXPKlamathWorkEthos) >= 0)
         return;
      createSimpleResearchPlan(cTechNatXPKlamathWorkEthos,
                               getUnitByTech(cUnitTypeTradingPost, cTechNatXPKlamathWorkEthos), cEconomyEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechNatXPKlamathStrategy) == cTechStatusObtainable)
   {
      if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatXPKlamathStrategy) >= 0)
         return;
      createSimpleResearchPlan(cTechNatXPKlamathStrategy,
                               getUnitByTech(cUnitTypeTradingPost, cTechNatXPKlamathStrategy), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechNatXPKlamathHuckleberryFeast) == cTechStatusObtainable) &&
       (xsGetTime() > 21 * 60 * 1000)) // Use only after at least 21 minutes of game time (i.e. 7 crates)
   {
      if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatXPKlamathHuckleberryFeast) >= 0)
         return;
      createSimpleResearchPlan(cTechNatXPKlamathHuckleberryFeast,
                               getUnitByTech(cUnitTypeTradingPost, cTechNatXPKlamathHuckleberryFeast), cEconomyEscrowID,
                               50);
      return;
   }

   // Mapuche techs
   if (kbTechGetStatus(cTechNatXPMapucheTactics) == cTechStatusObtainable)
   {
      if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatXPMapucheTactics) >= 0)
         return;
      createSimpleResearchPlan(cTechNatXPMapucheTactics, getUnitByTech(cUnitTypeTradingPost, cTechNatXPMapucheTactics),
                               cMilitaryEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechNatXPMapucheAdMapu) == cTechStatusObtainable)
   {
      if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatXPMapucheAdMapu) >= 0)
         return;
      createSimpleResearchPlan(cTechNatXPMapucheAdMapu, getUnitByTech(cUnitTypeTradingPost, cTechNatXPMapucheAdMapu),
                               cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechNatXPMapucheTreatyOfQuillin) == cTechStatusObtainable) &&
       (xsGetTime() > 20 * 60 * 1000)) // Use only after at least 20 minutes of game time (i.e. 10 crates)
   {
      if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatXPMapucheTreatyOfQuillin) >= 0)
         return;
      createSimpleResearchPlan(cTechNatXPMapucheTreatyOfQuillin,
                               getUnitByTech(cUnitTypeTradingPost, cTechNatXPMapucheTreatyOfQuillin), cEconomyEscrowID,
                               50);
      return;
   }

   // Maya techs
   if (kbTechGetStatus(cTechNatCalendar) == cTechStatusObtainable)
   {
      if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatCalendar) >= 0)
         return;
      createSimpleResearchPlan(cTechNatCalendar, getUnitByTech(cUnitTypeTradingPost, cTechNatCalendar),
                               cEconomyEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechNatCottonArmor) == cTechStatusObtainable)
   {
      if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatCottonArmor) >= 0)
         return;
      createSimpleResearchPlan(cTechNatCottonArmor, getUnitByTech(cUnitTypeTradingPost, cTechNatCottonArmor),
                               cMilitaryEscrowID, 50);
      return;
   }

   // Navajo techs
   if (kbTechGetStatus(cTechNatXPNavajoCraftsmanship) == cTechStatusObtainable)
   {
      if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatXPNavajoCraftsmanship) >= 0)
         return;
      createSimpleResearchPlan(cTechNatXPNavajoCraftsmanship,
                               getUnitByTech(cUnitTypeTradingPost, cTechNatXPNavajoCraftsmanship), cEconomyEscrowID,
                               50);
      return;
   }

   // Seminole techs
   if (kbTechGetStatus(cTechNatBowyery) == cTechStatusObtainable)
   {
      if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatBowyery) >= 0)
         return;
      createSimpleResearchPlan(cTechNatBowyery, getUnitByTech(cUnitTypeTradingPost, cTechNatBowyery), cMilitaryEscrowID,
                               50);
      return;
   }

   // Tupi techs
   if (kbTechGetStatus(cTechNatPoisonArrowFrogs) == cTechStatusObtainable)
   {
      if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatPoisonArrowFrogs) >= 0)
         return;
      createSimpleResearchPlan(cTechNatPoisonArrowFrogs, getUnitByTech(cUnitTypeTradingPost, cTechNatPoisonArrowFrogs),
                               cMilitaryEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechNatForestBurning) == cTechStatusObtainable)
   {
      if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatForestBurning) >= 0)
         return;
      createSimpleResearchPlan(cTechNatForestBurning, getUnitByTech(cUnitTypeTradingPost, cTechNatForestBurning),
                               cEconomyEscrowID, 50);
      return;
   }

   // Zapotec techs
   if (kbTechGetStatus(cTechNatXPZapotecCultOfTheDead) == cTechStatusObtainable)
   {
      if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatXPZapotecCultOfTheDead) >= 0)
         return;
      createSimpleResearchPlan(cTechNatXPZapotecCultOfTheDead,
                               getUnitByTech(cUnitTypeTradingPost, cTechNatXPZapotecCultOfTheDead), cMilitaryEscrowID,
                               50);
      return;
   }
   if (kbTechGetStatus(cTechNatXPZapotecFoodOfTheGods) == cTechStatusObtainable)
   {
      if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatXPZapotecFoodOfTheGods) >= 0)
         return;
      createSimpleResearchPlan(cTechNatXPZapotecFoodOfTheGods,
                               getUnitByTech(cUnitTypeTradingPost, cTechNatXPZapotecFoodOfTheGods), cEconomyEscrowID,
                               50);
      return;
   }
   if ((kbTechGetStatus(cTechNatXPZapotecCloudPeople) == cTechStatusObtainable) &&
       (xsGetTime() > 20 * 60 * 1000)) // Use only after at least 20 minutes of game time (i.e. 10 crates)
   {
      if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatXPZapotecCloudPeople) >= 0)
         return;
      createSimpleResearchPlan(cTechNatXPZapotecCloudPeople,
                               getUnitByTech(cUnitTypeTradingPost, cTechNatXPZapotecCloudPeople), cEconomyEscrowID, 50);
      return;
   }
}

rule minorAsianTribeTechMonitor
inactive
minInterval 90
{
   int techPlanID = -1;

   // Get techs from different minor Asian tribes one at a time as they become available
   // Unavailable tribes and techs are simply ignored

   // Quit if there is no appropriate trading post
   if (kbUnitCount(cMyID, cUnitTypeypTradingPostAsian, cUnitStateAlive) < 1)
      return;

   // Bhakti techs
   if (kbTechGetStatus(cTechYPNatBhaktiYoga) == cTechStatusObtainable)
   {
      if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPNatBhaktiYoga) >= 0)
         return;
      createSimpleResearchPlan(cTechYPNatBhaktiYoga, getUnitByTech(cUnitTypeypTradingPostAsian, cTechYPNatBhaktiYoga),
                               cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechYPNatBhaktiReinforcedGuantlets) == cTechStatusObtainable) && (kbGetAge() > cAge3) &&
       (kbUnitCount(cMyID, cUnitTypeypNatTigerClaw, cUnitStateAlive) >= 10))
   {
      if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPNatBhaktiReinforcedGuantlets) >=
          0)
         return;
      createSimpleResearchPlan(cTechYPNatBhaktiReinforcedGuantlets,
                               getUnitByTech(cUnitTypeypTradingPostAsian, cTechYPNatBhaktiReinforcedGuantlets),
                               cMilitaryEscrowID, 50);
      return;
   }

   // Jesuit techs
   if (kbTechGetStatus(cTechYPNatJesuitSmokelessPowder) == cTechStatusObtainable)
   {
      if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPNatJesuitSmokelessPowder) >= 0)
         return;
      createSimpleResearchPlan(cTechYPNatJesuitSmokelessPowder,
                               getUnitByTech(cUnitTypeypTradingPostAsian, cTechYPNatJesuitSmokelessPowder),
                               cMilitaryEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechYPNatJesuitFlyingButtress) == cTechStatusObtainable)
   {
      if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPNatJesuitFlyingButtress) >= 0)
         return;
      createSimpleResearchPlan(cTechYPNatJesuitFlyingButtress,
                               getUnitByTech(cUnitTypeypTradingPostAsian, cTechYPNatJesuitFlyingButtress),
                               cMilitaryEscrowID, 50);
      return;
   }

   // Shaolin techs
   if (kbTechGetStatus(cTechYPNatShaolinWoodClearing) == cTechStatusObtainable)
   {
      if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPNatShaolinWoodClearing) >= 0)
         return;
      createSimpleResearchPlan(cTechYPNatShaolinWoodClearing,
                               getUnitByTech(cUnitTypeypTradingPostAsian, cTechYPNatShaolinWoodClearing),
                               cEconomyEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechYPNatShaolinClenchedFist) == cTechStatusObtainable)
   {
      if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPNatShaolinClenchedFist) >= 0)
         return;
      createSimpleResearchPlan(cTechYPNatShaolinClenchedFist,
                               getUnitByTech(cUnitTypeypTradingPostAsian, cTechYPNatShaolinClenchedFist),
                               cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechYPNatShaolinDimMak) == cTechStatusObtainable) && (kbGetAge() > cAge3) &&
       (kbUnitCount(cMyID, cUnitTypeypNatRattanShield, cUnitStateAlive) >= 10))
   {
      if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPNatShaolinDimMak) >= 0)
         return;
      createSimpleResearchPlan(cTechYPNatShaolinDimMak,
                               getUnitByTech(cUnitTypeypTradingPostAsian, cTechYPNatShaolinDimMak), cMilitaryEscrowID,
                               50);
      return;
   }

   // Sufi techs
   if (kbTechGetStatus(cTechYPNatSufiFasting) == cTechStatusObtainable)
   {
      if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPNatSufiFasting) >= 0)
         return;
      createSimpleResearchPlan(cTechYPNatSufiFasting, getUnitByTech(cUnitTypeypTradingPostAsian, cTechYPNatSufiFasting),
                               cEconomyEscrowID, 50);
      return;
   }

   // Udasi techs
   if (kbTechGetStatus(cTechYPNatUdasiNewYear) == cTechStatusObtainable)
   {
      if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPNatUdasiNewYear) >= 0)
         return;
      createSimpleResearchPlan(cTechYPNatUdasiNewYear,
                               getUnitByTech(cUnitTypeypTradingPostAsian, cTechYPNatUdasiNewYear), cEconomyEscrowID,
                               50);
      return;
   }
   if (kbTechGetStatus(cTechYPNatUdasiGurus) == cTechStatusObtainable)
   {
      if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPNatUdasiGurus) >= 0)
         return;
      createSimpleResearchPlan(cTechYPNatUdasiGurus, getUnitByTech(cUnitTypeypTradingPostAsian, cTechYPNatUdasiGurus),
                               cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechYPNatUdasiArmyOfThePure) == cTechStatusObtainable) && (kbGetAge() > cAge3) &&
       (kbUnitCount(cMyID, cUnitTypeypNatChakram, cUnitStateAlive) +
            kbUnitCount(cMyID, cUnitTypeypNatMercChakram, cUnitStateAlive) >=
        10))
   {
      if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPNatUdasiArmyOfThePure) >= 0)
         return;
      createSimpleResearchPlan(cTechYPNatUdasiArmyOfThePure,
                               getUnitByTech(cUnitTypeypTradingPostAsian, cTechYPNatUdasiArmyOfThePure),
                               cMilitaryEscrowID, 50);
      return;
   }

   // Zen techs
   if (kbTechGetStatus(cTechYPNatZenMasterLessons) == cTechStatusObtainable)
   {
      if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPNatZenMasterLessons) >= 0)
         return;
      createSimpleResearchPlan(cTechYPNatZenMasterLessons,
                               getUnitByTech(cUnitTypeypTradingPostAsian, cTechYPNatZenMasterLessons),
                               cMilitaryEscrowID, 50);
      return;
   }
}

rule balloonMonitor
inactive
minInterval 10
{
   // Create plan only when balloon available and exploring allowed
   if ((kbUnitCount(cMyID, cUnitTypexpAdvancedBalloon) == 0) || (cvOkToExplore == false))
   {
      return;
   }

   // Create explore plan
   int balloonExplore = aiPlanCreate("Balloon Explore", cPlanExplore);
   aiPlanSetDesiredPriority(balloonExplore, 99);
   aiPlanAddUnitType(balloonExplore, cUnitTypexpAdvancedBalloon, 1, 1, 1);
   aiPlanSetEscrowID(balloonExplore, cEconomyEscrowID);
   aiPlanSetBaseID(balloonExplore, kbBaseGetMainID(cMyID));
   aiPlanSetVariableBool(balloonExplore, cExplorePlanDoLoops, 0, false);
   aiPlanSetActive(balloonExplore);

   // Disable rule
   xsDisableSelf();
}

rule envoyMonitor
inactive
minInterval 10
{
   static int envoyPlan = -1;

   // Create maintain plan (for Dutch only)
   if (cMyCiv == cCivDutch)
   {
      if (envoyPlan < 0)
      {
         envoyPlan = createSimpleMaintainPlan(cUnitTypeEnvoy, 1, false, kbBaseGetMainID(cMyID));
      }
   }

   // Create plan only when envoy available
   if ((kbUnitCount(cMyID, cUnitTypeEnvoy) == 0) || (cvOkToExplore == false))
   {
      return;
   }

   // Create explore plan
   int envoyExplore = aiPlanCreate("Envoy Explore", cPlanExplore);
   aiPlanSetDesiredPriority(envoyExplore, 99);
   aiPlanAddUnitType(envoyExplore, cUnitTypeEnvoy, 1, 1, 1);
   aiPlanSetEscrowID(envoyExplore, cEconomyEscrowID);
   aiPlanSetBaseID(envoyExplore, kbBaseGetMainID(cMyID));
   aiPlanSetVariableBool(envoyExplore, cExplorePlanDoLoops, 0, false);
   aiPlanSetActive(envoyExplore);

   // Disable rule
   xsDisableSelf();
}

rule nativeScoutMonitor
inactive
minInterval 10
{
   // Create plan only when native scout available
   if ((kbUnitCount(cMyID, cUnitTypeNativeScout) == 0) || (cvOkToExplore == false))
   {
      return;
   }

   // Create explore plan
   int nativeExplore = aiPlanCreate("Native Explore", cPlanExplore);
   aiPlanSetDesiredPriority(nativeExplore, 99);
   aiPlanAddUnitType(nativeExplore, cUnitTypeNativeScout, 1, 1, 1);
   aiPlanSetEscrowID(nativeExplore, cEconomyEscrowID);
   aiPlanSetBaseID(nativeExplore, kbBaseGetMainID(cMyID));
   aiPlanSetVariableBool(nativeExplore, cExplorePlanDoLoops, 0, false);
   aiPlanSetActive(nativeExplore);

   // Disable rule
   xsDisableSelf();
}

rule mongolScoutMonitor
inactive
minInterval 10
{
   // Create plan only when mongol scout available
   if ((kbUnitCount(cMyID, cUnitTypeypMongolScout) == 0) || (cvOkToExplore == false))
   {
      return;
   }

   // Create explore plan
   int mongolExplore = aiPlanCreate("Mongol Explore", cPlanExplore);
   aiPlanSetDesiredPriority(mongolExplore, 99);
   aiPlanAddUnitType(mongolExplore, cUnitTypeypMongolScout, 1, 1, 1);
   aiPlanSetEscrowID(mongolExplore, cEconomyEscrowID);
   aiPlanSetBaseID(mongolExplore, kbBaseGetMainID(cMyID));
   aiPlanSetVariableBool(mongolExplore, cExplorePlanDoLoops, 0, false);
   aiPlanSetActive(mongolExplore);

   // Disable rule
   xsDisableSelf();
}

rule chasquiMonitor
inactive
minInterval 10
{
   if (cMyCiv != cCivDEInca)
   {
      xsDisableSelf();
      return;
   }

   static int chasquiPlan = -1;

   // Create maintain plan
   int limit = kbGetBuildLimit(cMyID, cUnitTypedeChasqui);
   if (chasquiPlan < 0)
      chasquiPlan = createSimpleMaintainPlan(cUnitTypedeChasqui, 1, false, kbBaseGetMainID(cMyID));
   if (kbGetAge() >= cAge2)
      aiPlanSetVariableInt(chasquiPlan, cTrainPlanNumberToMaintain, 0, limit);

   // Create plan only when envoy available
   if ((kbUnitCount(cMyID, cUnitTypedeChasqui) == 0) || (cvOkToExplore == false))
   {
      return;
   }

   // Create explore plan
   static int chasquiExplore = -1;
   if (aiPlanGetState(chasquiExplore) < 0)
   {
      chasquiExplore = aiPlanCreate("Chasqui Explore", cPlanExplore);
      aiPlanSetDesiredPriority(chasquiExplore, 99);
      aiPlanAddUnitType(chasquiExplore, cUnitTypedeChasqui, 1, 1, 1);
      aiPlanSetEscrowID(chasquiExplore, cEconomyEscrowID);
      aiPlanSetBaseID(chasquiExplore, kbBaseGetMainID(cMyID));
      aiPlanSetVariableBool(chasquiExplore, cExplorePlanDoLoops, 0, false);
      aiPlanSetActive(chasquiExplore);
   }
}

rule churchUpgradeMonitorAmerican
inactive
minInterval 30
{
	int upgradePlanID = -1;

	// Disable rule once all upgrades are available
	if ((kbTechGetStatus(cTechDEChurchPennsylvaniaPound) == cTechStatusActive) &&
		(kbTechGetStatus(cTechDEChurchPennsylvaniaRifles) == cTechStatusActive) &&
		(kbTechGetStatus(cTechDEChurchPennsylvaniaCavalry) == cTechStatusActive))
	{
		xsDisableSelf();
		return;
	}

	if (kbTechGetStatus(cTechDEPoliticianFederalPennsylvania) != cTechStatusActive)
	{
		xsDisableSelf();
		return;
	}
		
		
	// Quit if there is no church
	if (kbUnitCount(cMyID, cUnitTypeChurch, cUnitStateAlive) < 1)
		return;

	// Get upgrades one at a time as they become available
	if (kbTechGetStatus(cTechDEChurchPennsylvaniaPound) == cTechStatusObtainable)
	{
		if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechDEChurchPennsylvaniaPound) >= 0)
			return;
		upgradePlanID = createSimpleResearchPlan(cTechDEChurchPennsylvaniaPound, cUnitTypeChurch, cMilitaryEscrowID, 50);
		aiPlanSetDesiredResourcePriority(upgradePlanID, 100);
		return;
	}
	
	if (kbTechGetStatus(cTechDEChurchPennsylvaniaRifles) == cTechStatusObtainable)
	{
		if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechDEChurchPennsylvaniaRifles) >= 0)
			return;
		upgradePlanID = createSimpleResearchPlan(cTechDEChurchPennsylvaniaRifles, cUnitTypeChurch, cMilitaryEscrowID, 50);
		aiPlanSetDesiredResourcePriority(upgradePlanID, 55);
		return;
	}
	
	if (kbTechGetStatus(cTechDEChurchPennsylvaniaCavalry) == cTechStatusObtainable)
	{
		if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechDEChurchPennsylvaniaCavalry) >= 0)
			return;
		upgradePlanID = createSimpleResearchPlan(cTechDEChurchPennsylvaniaCavalry, cUnitTypeChurch, cMilitaryEscrowID, 50);
		aiPlanSetDesiredResourcePriority(upgradePlanID, 55);
		return;
	}
}

rule churchUpgradeMonitor
inactive
minInterval 60
{
   int upgradePlanID = -1;

   // Disable rule once all upgrades are available
   if ((kbTechGetStatus(cTechChurchTownWatch) == cTechStatusActive) &&
       (kbTechGetStatus(cTechChurchGasLighting) == cTechStatusActive) &&
       (kbTechGetStatus(cTechChurchStandingArmy) == cTechStatusActive) &&
       (kbTechGetStatus(cTechChurchMassCavalry) == cTechStatusActive))
   {
      xsDisableSelf();
      return;
   }

   // Quit if there is no church
   if (kbUnitCount(cMyID, cUnitTypeChurch, cUnitStateAlive) < 1)
      return;

   // Get upgrades one at a time as they become available
   if (kbTechGetStatus(cTechChurchTownWatch) == cTechStatusObtainable)
   {
      if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchTownWatch) >= 0)
         return;
      upgradePlanID = createSimpleResearchPlan(cTechChurchTownWatch, cUnitTypeChurch, cMilitaryEscrowID, 50);
      aiPlanSetDesiredResourcePriority(upgradePlanID, 35);
      return;
   }
   if (kbTechGetStatus(cTechChurchGasLighting) == cTechStatusObtainable)
   {
      if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchGasLighting) >= 0)
         return;
      upgradePlanID = createSimpleResearchPlan(cTechChurchGasLighting, cUnitTypeChurch, cMilitaryEscrowID, 50);
      aiPlanSetDesiredResourcePriority(upgradePlanID, 35);
      return;
   }
   if (kbTechGetStatus(cTechChurchMassCavalry) == cTechStatusObtainable)
   {
      if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchMassCavalry) >= 0)
         return;
      upgradePlanID = createSimpleResearchPlan(cTechChurchMassCavalry, cUnitTypeChurch, cMilitaryEscrowID, 50);
      aiPlanSetDesiredResourcePriority(upgradePlanID, 35);
      return;
   }
   if (kbTechGetStatus(cTechChurchStandingArmy) == cTechStatusObtainable)
   {
      if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchStandingArmy) >= 0)
         return;
      upgradePlanID = createSimpleResearchPlan(cTechChurchStandingArmy, cUnitTypeChurch, cMilitaryEscrowID, 50);
      aiPlanSetDesiredResourcePriority(upgradePlanID, 35);
      return;
   }
}

rule churchUpgradeAsianMonitor
inactive
minInterval 60
{
   int upgradePlanID = -1;

   // Disable rule once all upgrades are available
   if ((kbTechGetStatus(cTechChurchTownWatch) == cTechStatusActive) &&
       (kbTechGetStatus(cTechChurchGasLighting) == cTechStatusActive) &&
       (kbTechGetStatus(cTechChurchStandingArmy) == cTechStatusActive) &&
       (kbTechGetStatus(cTechChurchMassCavalry) == cTechStatusActive))
   {
      xsDisableSelf();
      return;
   }

   // Quit if there is no special church built from a wagon araound
   if (kbUnitCount(cMyID, cUnitTypeypChurch, cUnitStateAlive) < 1)
   {
      return;
   }

   // Get upgrades one at a time as they become available
   if (kbTechGetStatus(cTechChurchTownWatch) == cTechStatusObtainable)
   {
      if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchTownWatch) >= 0)
         return;
      upgradePlanID = createSimpleResearchPlan(cTechChurchTownWatch, getUnit(cUnitTypeypChurch), cMilitaryEscrowID, 50);
      aiPlanSetDesiredResourcePriority(upgradePlanID, 35);
      return;
   }
   if (kbTechGetStatus(cTechChurchGasLighting) == cTechStatusObtainable)
   {
      if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchGasLighting) >= 0)
         return;
      upgradePlanID =
          createSimpleResearchPlan(cTechChurchGasLighting, getUnit(cUnitTypeypChurch), cMilitaryEscrowID, 50);
      aiPlanSetDesiredResourcePriority(upgradePlanID, 35);
      return;
   }
   if (kbTechGetStatus(cTechChurchMassCavalry) == cTechStatusObtainable)
   {
      if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchMassCavalry) >= 0)
         return;
      upgradePlanID =
          createSimpleResearchPlan(cTechChurchMassCavalry, getUnit(cUnitTypeypChurch), cMilitaryEscrowID, 50);
      aiPlanSetDesiredResourcePriority(upgradePlanID, 35);
      return;
   }
   if (kbTechGetStatus(cTechChurchStandingArmy) == cTechStatusObtainable)
   {
      if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchStandingArmy) >= 0)
         return;
      upgradePlanID =
          createSimpleResearchPlan(cTechChurchStandingArmy, getUnit(cUnitTypeypChurch), cMilitaryEscrowID, 50);
      aiPlanSetDesiredResourcePriority(upgradePlanID, 35);
      return;
   }
}

rule royalDecreeMonitor
inactive
minInterval 40
{
   int decreePlanID = -1;

   // Quit if we didn't ship the required card yet
   if ((kbTechGetStatus(cTechHCRoyalDecreeBritish) != cTechStatusActive) ||
       (kbTechGetStatus(cTechHCRoyalDecreeDutch) != cTechStatusActive) ||
       (kbTechGetStatus(cTechHCRoyalDecreeFrench) != cTechStatusActive) ||
       (kbTechGetStatus(cTechHCRoyalDecreeGerman) != cTechStatusActive) ||
       (kbTechGetStatus(cTechHCRoyalDecreeOttoman) != cTechStatusActive) ||
       (kbTechGetStatus(cTechHCRoyalDecreePortuguese) != cTechStatusActive) ||
       (kbTechGetStatus(cTechHCRoyalDecreeRussian) != cTechStatusActive) ||
       (kbTechGetStatus(cTechDEHCRoyalDecreeSwedish) != cTechStatusActive) ||
       (kbTechGetStatus(cTechHCRoyalDecreeSpanish) != cTechStatusActive))
      return;

   // Quit if there is no church
   if (kbUnitCount(cMyID, cUnitTypeChurch, cUnitStateAlive) < 1)
      return;

   switch(cMyCiv)
   {
      case cCivBritish:
      {
         // Disable rule once all upgrades are available
         if ((kbTechGetStatus(cTechChurchThinRedLine) == cTechStatusActive) &&
             (kbTechGetStatus(cTechChurchBlackWatch) == cTechStatusActive) &&
             (kbTechGetStatus(cTechChurchRogersRangers) == cTechStatusActive))
         {
            xsDisableSelf();
            return;
         }

         // Get upgrades/troops as they become available
         if (kbTechGetStatus(cTechChurchThinRedLine) == cTechStatusObtainable)
         {
            if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchThinRedLine) >= 0)
               return;
            createSimpleResearchPlan(cTechChurchThinRedLine, getUnit(cUnitTypeChurch), cMilitaryEscrowID, 50);
         }
         if (kbTechGetStatus(cTechChurchBlackWatch) == cTechStatusObtainable)
         {
            if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchBlackWatch) >= 0)
               return;
            decreePlanID = createSimpleResearchPlan(cTechChurchBlackWatch, getUnit(cUnitTypeChurch), cMilitaryEscrowID, 50);
	        aiPlanSetDesiredResourcePriority(decreePlanID, 56);
         }
         if (kbTechGetStatus(cTechChurchRogersRangers) == cTechStatusObtainable)
         {
            if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchRogersRangers) >= 0)
               return;
            decreePlanID = createSimpleResearchPlan(cTechChurchRogersRangers, getUnit(cUnitTypeChurch), cMilitaryEscrowID, 50);
	        aiPlanSetDesiredResourcePriority(decreePlanID, 56);
         }
         break;
      }
      case cCivDutch:
      {
         // Disable rule once all upgrades are available
         if ((kbTechGetStatus(cTechChurchCoffeeTrade) == cTechStatusActive) &&
             (kbTechGetStatus(cTechChurchWaardgelders) == cTechStatusActive) &&
             (kbTechGetStatus(cTechChurchStadholders) == cTechStatusActive))
         {
            xsDisableSelf();
            return;
         }

         // Get upgrades/troops as they become available
         if (kbTechGetStatus(cTechChurchCoffeeTrade) == cTechStatusObtainable)
         {
            if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchCoffeeTrade) >= 0)
               return;
            createSimpleResearchPlan(cTechChurchCoffeeTrade, getUnit(cUnitTypeChurch), cEconomyEscrowID, 50);
         }
         if (kbTechGetStatus(cTechChurchWaardgelders) == cTechStatusObtainable)
         {
            if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchWaardgelders) >= 0)
               return;
            decreePlanID = createSimpleResearchPlan(cTechChurchWaardgelders, getUnit(cUnitTypeChurch), cMilitaryEscrowID, 50);
	        aiPlanSetDesiredResourcePriority(decreePlanID, 56);
         }
         if (kbTechGetStatus(cTechChurchStadholders) == cTechStatusObtainable)
         {
            if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchStadholders) >= 0)
               return;
            decreePlanID = createSimpleResearchPlan(cTechChurchStadholders, getUnit(cUnitTypeChurch), cMilitaryEscrowID, 50);
	        aiPlanSetDesiredResourcePriority(decreePlanID, 56);
         }
         break;
      }
      case cCivFrench:
      {
         // Disable rule once all upgrades are available
         if ((kbTechGetStatus(cTechChurchCodeNapoleon) == cTechStatusActive) &&
             (kbTechGetStatus(cTechChurchGardeImperial1) == cTechStatusActive) &&
             (kbTechGetStatus(cTechChurchGardeImperial2) == cTechStatusActive) &&
             (kbTechGetStatus(cTechChurchGardeImperial3) == cTechStatusActive))
         {
            xsDisableSelf();
            return;
         }

         // Get upgrades/troops as they become available
         if ((kbTechGetStatus(cTechChurchCodeNapoleon) == cTechStatusObtainable) && (kbGetAge() >= cAge4))
         {
            if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchCodeNapoleon) >= 0)
               return;
            createSimpleResearchPlan(cTechChurchCodeNapoleon, getUnit(cUnitTypeChurch), cMilitaryEscrowID, 50);
         }
         if (kbTechGetStatus(cTechChurchGardeImperial1) == cTechStatusObtainable)
         {
            if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchGardeImperial1) >= 0)
               return;
            decreePlanID = createSimpleResearchPlan(cTechChurchGardeImperial1, getUnit(cUnitTypeChurch), cEconomyEscrowID, 50);
	        aiPlanSetDesiredResourcePriority(decreePlanID, 56);
         }
         if (kbTechGetStatus(cTechChurchGardeImperial2) == cTechStatusObtainable)
         {
            if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchGardeImperial2) >= 0)
               return;
            decreePlanID = createSimpleResearchPlan(cTechChurchGardeImperial2, getUnit(cUnitTypeChurch), cMilitaryEscrowID, 50);
	        aiPlanSetDesiredResourcePriority(decreePlanID, 56);
         }
         if (kbTechGetStatus(cTechChurchGardeImperial3) == cTechStatusObtainable)
         {
            if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchGardeImperial3) >= 0)
               return;
            decreePlanID = createSimpleResearchPlan(cTechChurchGardeImperial3, getUnit(cUnitTypeChurch), cMilitaryEscrowID, 50);
	        aiPlanSetDesiredResourcePriority(decreePlanID, 56);
         }
         break;
      }
      case cCivGermans:
      {
         // Disable rule once all upgrades are available
         if ((kbTechGetStatus(cTechChurchTillysDiscipline) == cTechStatusActive) &&
             //(kbTechGetStatus(cTechChurchWallensteinsContracts) == cTechStatusActive) &&
             (kbTechGetStatus(cTechChurchZweihander) == cTechStatusActive))
         {
            xsDisableSelf();
            return;
         }

         // Get upgrades/troops as they become available
         if (kbTechGetStatus(cTechChurchTillysDiscipline) == cTechStatusObtainable)
         {
            if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchTillysDiscipline) >= 0)
               return;
            createSimpleResearchPlan(cTechChurchTillysDiscipline, getUnit(cUnitTypeChurch), cMilitaryEscrowID, 50);
         }/*
         if (kbTechGetStatus(cTechChurchWallensteinsContracts) == cTechStatusObtainable)
         {
            if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchWallensteinsContracts) >= 0)
               return;
            decreePlanID = createSimpleResearchPlan(cTechChurchWallensteinsContracts, getUnit(cUnitTypeChurch), cMilitaryEscrowID, 50);
	        aiPlanSetDesiredResourcePriority(decreePlanID, 56);
         }*/
         if (kbTechGetStatus(cTechChurchZweihander) == cTechStatusObtainable)
         {
            if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchZweihander) >= 0)
               return;
            decreePlanID = createSimpleResearchPlan(cTechChurchZweihander, getUnit(cUnitTypeChurch), cMilitaryEscrowID, 50);
	        aiPlanSetDesiredResourcePriority(decreePlanID, 56);
         }
         break;
      }
      case cCivOttomans:
      {
         // Disable rule once all upgrades are available
         if ((kbTechGetStatus(cTechChurchTufanciCorps) == cTechStatusActive) &&
             (kbTechGetStatus(cTechChurchTopcuCorps) == cTechStatusActive))
         {
            xsDisableSelf();
            return;
         }

         // Get upgrades/troops as they become available
         if (kbTechGetStatus(cTechChurchTufanciCorps) == cTechStatusObtainable)
         {
            if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchTufanciCorps) >= 0)
               return;
            decreePlanID = createSimpleResearchPlan(cTechChurchTufanciCorps, getUnit(cUnitTypeChurch), cMilitaryEscrowID, 50);
	        aiPlanSetDesiredResourcePriority(decreePlanID, 56);
         }
         if (kbTechGetStatus(cTechChurchTopcuCorps) == cTechStatusObtainable)
         {
            if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchTopcuCorps) >= 0)
               return;
            decreePlanID = createSimpleResearchPlan(cTechChurchTopcuCorps, getUnit(cUnitTypeChurch), cMilitaryEscrowID, 50);
	        aiPlanSetDesiredResourcePriority(decreePlanID, 56);
         }
         break;
      }
      case cCivPortuguese:
      {
         // Disable rule once all upgrades are available
         if ((kbTechGetStatus(cTechChurchEconmediaManor) == cTechStatusActive) &&
		     (kbTechGetStatus(cTechChurchBestieros) == cTechStatusActive) &&
             (kbTechGetStatus(cTechChurchTowerAndSword) == cTechStatusActive))
         {
            xsDisableSelf();
            return;
         }

         // Get upgrades/troops as they become available
         if ((kbTechGetStatus(cTechChurchEconmediaManor) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeMill, cUnitStateAlive) >= 4) && (gTimeToFarm == true))
         {  // Only get this when we're really focusing on mills
            if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchEconmediaManor) >= 0)
               return;
            createSimpleResearchPlan(cTechChurchEconmediaManor, getUnit(cUnitTypeChurch), cMilitaryEscrowID, 50);
         }
         if (kbTechGetStatus(cTechChurchBestieros) == cTechStatusObtainable)
         {
            if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchBestieros) >= 0)
               return;
            decreePlanID = createSimpleResearchPlan(cTechChurchBestieros, getUnit(cUnitTypeChurch), cMilitaryEscrowID, 50);
	        aiPlanSetDesiredResourcePriority(decreePlanID, 56);
         }
         if (kbTechGetStatus(cTechChurchTowerAndSword) == cTechStatusObtainable)
         {
            if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchTowerAndSword) >= 0)
               return;
            decreePlanID = createSimpleResearchPlan(cTechChurchTowerAndSword, getUnit(cUnitTypeChurch), cMilitaryEscrowID, 50);
	        aiPlanSetDesiredResourcePriority(decreePlanID, 56);
         }
         break;
      }
      case cCivRussians:
      {
         // Disable rule once all upgrades are available
         if ((kbTechGetStatus(cTechChurchWesternization) == cTechStatusActive) &&
             (kbTechGetStatus(cTechChurchPetrineReforms) == cTechStatusActive) &&
             (kbTechGetStatus(cTechChurchKalmucks) == cTechStatusActive) &&
             (kbTechGetStatus(cTechChurchBashkirPonies) == cTechStatusActive))
         {
            xsDisableSelf();
            return;
         }

         // Get upgrades/troops as they become available
         if (kbTechGetStatus(cTechChurchWesternization) == cTechStatusObtainable)
         {
            if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchWesternization) >= 0)
               return;
            decreePlanID = createSimpleResearchPlan(cTechChurchWesternization, getUnit(cUnitTypeChurch), cMilitaryEscrowID, 50);
	        aiPlanSetDesiredResourcePriority(decreePlanID, 56);
         }
         if (kbTechGetStatus(cTechChurchPetrineReforms) == cTechStatusObtainable)
         {
            if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchPetrineReforms) >= 0)
               return;
            decreePlanID = createSimpleResearchPlan(cTechChurchPetrineReforms, getUnit(cUnitTypeChurch), cMilitaryEscrowID, 50);
	        aiPlanSetDesiredResourcePriority(decreePlanID, 56);
         }
         if (kbTechGetStatus(cTechChurchKalmucks) == cTechStatusObtainable)
         {
            if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchKalmucks) >= 0)
               return;
            decreePlanID = createSimpleResearchPlan(cTechChurchKalmucks, getUnit(cUnitTypeChurch), cMilitaryEscrowID, 50);
	        aiPlanSetDesiredResourcePriority(decreePlanID, 56);
         }
         if (kbTechGetStatus(cTechChurchBashkirPonies) == cTechStatusObtainable)
         {
            if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchBashkirPonies) >= 0)
               return;
            decreePlanID = createSimpleResearchPlan(cTechChurchBashkirPonies, getUnit(cUnitTypeChurch), cMilitaryEscrowID, 50);
	        aiPlanSetDesiredResourcePriority(decreePlanID, 56);
         }
         break;
      }
      case cCivSpanish:
      {
         // Disable rule once all upgrades are available
         if ((kbTechGetStatus(cTechChurchCorsolet) == cTechStatusActive) &&
             (kbTechGetStatus(cTechChurchQuatrefage) == cTechStatusActive) &&
             (kbTechGetStatus(cTechChurchWildGeeseSpanish) == cTechStatusActive))
         {
            xsDisableSelf();
            return;
         }

         // Get upgrades/troops as they become available
         if (kbTechGetStatus(cTechChurchCorsolet) == cTechStatusObtainable)
         {
            if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchCorsolet) >= 0)
               return;
            createSimpleResearchPlan(cTechChurchCorsolet, getUnit(cUnitTypeChurch), cMilitaryEscrowID, 50);
         }
         if (kbTechGetStatus(cTechChurchQuatrefage) == cTechStatusObtainable)
         {
            if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchQuatrefage) >= 0)
               return;
            decreePlanID = createSimpleResearchPlan(cTechChurchQuatrefage, getUnit(cUnitTypeChurch), cMilitaryEscrowID, 50);
	        aiPlanSetDesiredResourcePriority(decreePlanID, 56);
         }
         if (kbTechGetStatus(cTechChurchWildGeeseSpanish) == cTechStatusObtainable)
         {
            if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchWildGeeseSpanish) >= 0)
               return;
            decreePlanID = createSimpleResearchPlan(cTechChurchWildGeeseSpanish, getUnit(cUnitTypeChurch), cMilitaryEscrowID, 50);
	        aiPlanSetDesiredResourcePriority(decreePlanID, 56);
         }
         break;
      }
      case cCivDESwedish:
      {
         // Disable rule once all upgrades are available
         if ((kbTechGetStatus(cTechDEChurchPikePush) == cTechStatusActive) &&
             (kbTechGetStatus(cTechDEChurchSavolaxJaegers) == cTechStatusActive) &&
             (kbTechGetStatus(cTechDEChurchGustavianGuards) == cTechStatusActive))
         {
            xsDisableSelf();
            return;
         }

         // Get upgrades/troops as they become available
         if (kbTechGetStatus(cTechDEChurchPikePush) == cTechStatusObtainable)
         {
            if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechDEChurchPikePush) >= 0)
               return;
            createSimpleResearchPlan(cTechDEChurchPikePush, getUnit(cUnitTypeChurch), cMilitaryEscrowID, 50);
         }
         if (kbTechGetStatus(cTechDEChurchSavolaxJaegers) == cTechStatusObtainable)
         {
            if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechDEChurchSavolaxJaegers) >= 0)
               return;
            decreePlanID = createSimpleResearchPlan(cTechDEChurchSavolaxJaegers, getUnit(cUnitTypeChurch), cMilitaryEscrowID, 50);
	        aiPlanSetDesiredResourcePriority(decreePlanID, 56);
         }
         if (kbTechGetStatus(cTechDEChurchGustavianGuards) == cTechStatusObtainable)
         {
            if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechDEChurchGustavianGuards) >= 0)
               return;
            decreePlanID = createSimpleResearchPlan(cTechDEChurchGustavianGuards, getUnit(cUnitTypeChurch), cMilitaryEscrowID, 50);
	        aiPlanSetDesiredResourcePriority(decreePlanID, 56);
         }
         break;
      }
   }
}

rule aztecWarhutUpgradeMonitor
inactive
minInterval 90
{
   int aztecWarhutUpgradePlan = -1;

   // Disable rule for anyone but Aztecs
   if (cMyCiv != cCivXPAztec)
   {
      xsDisableSelf();
      return;
   }

   // Disable rule once both upgrades are available
   if ((kbTechGetStatus(cTechStrongWarHut) == cTechStatusActive) &&
       (kbTechGetStatus(cTechMightyWarHut) == cTechStatusActive))
   {
      xsDisableSelf();
      return;
   }

   // Quit if no fortifications are allowed
   if (cvOkToFortify == false)
      return;

   aztecWarhutUpgradePlan = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechStrongWarHut);
   if (aztecWarhutUpgradePlan < 0)
      aztecWarhutUpgradePlan = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechMightyWarHut);
   if (aztecWarhutUpgradePlan >= 0)
      return;

   // Quit if there is no war hut
   if (kbUnitCount(cMyID, cUnitTypeWarHut, cUnitStateAlive) < 1)
      return;

   // Research both upgrades as they become available, but only if there are enough war huts around
   if ((kbTechGetStatus(cTechStrongWarHut) == cTechStatusObtainable) &&
       (kbUnitCount(cMyID, cUnitTypeWarHut, cUnitStateABQ) >= 3) && (kbGetAge() >= cAge3))
   {
      aztecWarhutUpgradePlan =
          createSimpleResearchPlan(cTechStrongWarHut, getUnit(cUnitTypeWarHut), cMilitaryEscrowID, 50);
      aiPlanSetDesiredResourcePriority(aztecWarhutUpgradePlan, 45);
      return;
   }
   if ((kbTechGetStatus(cTechMightyWarHut) == cTechStatusObtainable) &&
       (kbUnitCount(cMyID, cUnitTypeWarHut, cUnitStateABQ) >= 4) && (kbGetAge() >= cAge4))
   {
      aztecWarhutUpgradePlan =
          createSimpleResearchPlan(cTechMightyWarHut, getUnit(cUnitTypeWarHut), cMilitaryEscrowID, 50);
      aiPlanSetDesiredResourcePriority(aztecWarhutUpgradePlan, 45);
      return;
   }
}

rule settlerUpgradeMonitor
inactive
minInterval 180 // research to be started 3 minutes into Age 2
{
   int villagerHPTechID = -1;

   // Disable rule once the upgrades are available
   if (civIsNative() == true)
      villagerHPTechID = cTechSpiritMedicine;
   else if (civIsAsian() == true)
      villagerHPTechID = cTechypMarketSpiritMedicine;
   else if (cMyCiv == cCivDEAmericans)
      villagerHPTechID = cTechDEFrontiersmen;
   else if (civIsAfrican() == true)
      villagerHPTechID = cTechDEAfricanVillagerHitpoints;
   else
      villagerHPTechID = cTechGreatCoat;

   int villagerHPTechStatus = kbTechGetStatus(villagerHPTechID);

   if (villagerHPTechStatus == cTechStatusActive)
   {
      xsDisableSelf();
      return;
   }

   // Quit if there is no market
   if (kbUnitCount(cMyID, gMarketUnit, cUnitStateAlive) < 1)
      return;

   if (villagerHPTechStatus == cTechStatusObtainable)
   {
      if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, villagerHPTechID) >= 0)
         return;
      createSimpleResearchPlan(villagerHPTechID, getUnit(gMarketUnit), cEconomyEscrowID, 50);
      return;
   }
}

rule arsenalUpgradeMonitor
inactive
minInterval 60
{
   int upgradePlanID = -1;
	int unitCount = -1;
	int researchBuildingID = -1;
   
	// New Ways cards.
	if ((cMyCiv == cCivXPIroquois) || (cMyCiv == cCivXPSioux))
	{
		researchBuildingID = cMyCiv == cCivXPIroquois ? cUnitTypeTeepee : cUnitTypeLonghouse;
		// Disable rule once all upgrades are active.
		if ((kbTechGetStatus(cTechRifling) == cTechStatusActive) &&
			(kbTechGetStatus(cTechInfantryBreastplate) == cTechStatusActive) &&
			(kbTechGetStatus(cTechCavalryCuirass) == cTechStatusActive) &&
			(kbTechGetStatus(cTechCaracole) == cTechStatusActive) &&
			(((cMyCiv == cCivXPIroquois) && ((kbTechGetStatus(cTechHeatedShot) == cTechStatusActive) || (gNavyMap == false))) ||
			((cMyCiv == cCivXPSioux) && (kbTechGetStatus(cTechPillage) == cTechStatusActive))))
		{
			aiEcho("Disabling rule arsenalUpgradeMonitor since we have all upgrades.");
			xsDisableSelf();
			return;
		}
	}
	// Dutch Consulate Arsenal.
	else if ((cMyCiv == cCivJapanese) || (cMyCiv == cCivSPCJapanese) || (cMyCiv == cCivSPCJapaneseEnemy))
	{
		researchBuildingID = cUnitTypeypArsenalAsian;
		// Disable rule once all upgrades are active.
		if ((kbTechGetStatus(cTechInfantryBreastplate) == cTechStatusActive) &&
			(kbTechGetStatus(cTechBayonet) == cTechStatusActive) &&
			(kbTechGetStatus(cTechCavalryCuirass) == cTechStatusActive) &&
			(kbTechGetStatus(cTechGunnersQuadrant) == cTechStatusActive) &&
			((kbTechGetStatus(cTechHeatedShot) == cTechStatusActive) || (gNavyMap == false)))
		{
			aiEcho("Disabling rule arsenalUpgradeMonitor since we have all upgrades.");
			xsDisableSelf();
			return;
		}
	}
	// This means we're either European or Ethiopian (Portuguese Alliance).
	else
	{
		researchBuildingID = cUnitTypeArsenal;
		// Disable rule once all upgrades are active.
		if ((kbTechGetStatus(cTechRifling) == cTechStatusActive) &&
			(kbTechGetStatus(cTechInfantryBreastplate) == cTechStatusActive) &&
			(kbTechGetStatus(cTechBayonet) == cTechStatusActive) &&
			(kbTechGetStatus(cTechCavalryCuirass) == cTechStatusActive) &&
			(kbTechGetStatus(cTechCaracole) == cTechStatusActive) &&
			(kbTechGetStatus(cTechGunnersQuadrant) == cTechStatusActive) &&
			((kbTechGetStatus(cTechHeatedShot) == cTechStatusActive) || (gNavyMap == false)))
		{
			aiEcho("Disabling rule arsenalUpgradeMonitor since we have all upgrades.");
			xsDisableSelf();
			return;
		}
	}

   // Quit if there is no alive Arsenal / Teepee / Longhouse.
   if (kbUnitCount(cMyID, researchBuildingID, cUnitStateAlive) < 1)
      return;

	// Get upgrades one at the time, provided a sufficient number of units to be improved are available.
   // Destroy existing plan if not enough units benefit anymore.
	
	if (kbTechGetStatus(cTechCavalryCuirass) == cTechStatusObtainable)
	{
		unitCount = kbUnitCount(cMyID, cUnitTypeAbstractHeavyCavalry, cUnitStateABQ);
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechCavalryCuirass);		
		if ((upgradePlanID >= 0) && (unitCount < 12))
			aiPlanDestroy(upgradePlanID);
		else if ((upgradePlanID < 0) && (unitCount >= 12))
		{
			createSimpleResearchPlan(cTechCavalryCuirass, researchBuildingID, cMilitaryEscrowID, 50);
			return;
		}
	}
	
   if (kbTechGetStatus(cTechInfantryBreastplate) == cTechStatusObtainable)
	{
		unitCount = kbUnitCount(cMyID, cUnitTypeAbstractHandInfantry, cUnitStateABQ) +
			kbUnitCount(cMyID, cUnitTypeAbstractFootArcher, cUnitStateABQ);
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechInfantryBreastplate);		
		if ((upgradePlanID >= 0) && (unitCount < 12))
			aiPlanDestroy(upgradePlanID);
		else if ((upgradePlanID < 0) && (unitCount >= 12))
		{
			createSimpleResearchPlan(cTechInfantryBreastplate, researchBuildingID, cMilitaryEscrowID, 50);
			return;
		}
	}

	// The Lakota don't have this upgrade.
	if (cMyCiv != cCivXPSioux)
	{
		// Only get 'Heated Shot' upgrade on water maps
		if ((kbTechGetStatus(cTechHeatedShot) == cTechStatusObtainable) && (gNavyMap == true))
		{
			unitCount = kbUnitCount(cMyID, cUnitTypeAbstractArtillery, cUnitStateABQ);									 // Our own artillery
			int unitCount2 = kbUnitCount(cPlayerRelationEnemyNotGaia, cUnitTypeAbstractWarShip, cUnitStateABQ); // Enemy war ships
			upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechHeatedShot);
			if ((upgradePlanID >= 0) && ((unitCount < 2) || (unitCount2 < 2)))		// If there is too few of either of the 2 just destroy
				aiPlanDestroy(upgradePlanID);
			else if ((upgradePlanID < 0) && (unitCount >= 2) && (unitCount2 >= 2))
			{
				createSimpleResearchPlan(cTechHeatedShot, researchBuildingID, cMilitaryEscrowID, 50);
				return;
			}
		}
	}
	
	// The Haudenosaunee and Lakota don't have these 2 upgrades.
	if ((cMyCiv != cCivXPIroquois) && (cMyCiv != cCivXPSioux))
	{
		if (kbTechGetStatus(cTechGunnersQuadrant) == cTechStatusObtainable)
		{
			unitCount = kbUnitCount(cMyID, cUnitTypeAbstractArtillery, cUnitStateABQ);
			upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechGunnersQuadrant);
			if ((upgradePlanID >= 0) && (unitCount < 4))
				aiPlanDestroy(upgradePlanID);
			else if ((upgradePlanID < 0) && (unitCount >= 4))
			{
				createSimpleResearchPlan(cTechGunnersQuadrant, researchBuildingID, cMilitaryEscrowID, 50);
				return;
			}
		}
	
		if (kbTechGetStatus(cTechBayonet) == cTechStatusObtainable)
		{
			unitCount = kbUnitCount(cMyID, cUnitTypeAbstractMusketeer, cUnitStateABQ);
			upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechBayonet);		
			if ((upgradePlanID >= 0) && (unitCount < 12))
				aiPlanDestroy(upgradePlanID);
			else if ((upgradePlanID < 0) && (unitCount >= 12))
			{
				createSimpleResearchPlan(cTechBayonet, researchBuildingID, cMilitaryEscrowID, 50);
				return;
			}
		}
	}
	
	// The Japanese Arsenal doesn't have these 2 upgrades.
	if ((cMyCiv != cCivJapanese) && (cMyCiv != cCivSPCJapanese) && (cMyCiv != cCivSPCJapaneseEnemy))
	{
		if (kbTechGetStatus(cTechRifling) == cTechStatusObtainable)
		{
			unitCount = kbUnitCount(cMyID, cUnitTypeAbstractRifleman, cUnitStateABQ);
			upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechRifling);		
			if ((upgradePlanID >= 0) && (unitCount < 12))
				aiPlanDestroy(upgradePlanID);
			else if ((upgradePlanID < 0) && (unitCount >= 12))
			{
				createSimpleResearchPlan(cTechRifling, researchBuildingID, cMilitaryEscrowID, 50);
				return;
			}
		}
	
		if (kbTechGetStatus(cTechCaracole) == cTechStatusObtainable)
		{
			unitCount = kbUnitCount(cMyID, cUnitTypeAbstractLightCavalry, cUnitStateABQ);
			upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechCaracole);		
			if ((upgradePlanID >= 0) && (unitCount < 12))
				aiPlanDestroy(upgradePlanID);
			else if ((upgradePlanID < 0) && (unitCount >= 12))
			{
				createSimpleResearchPlan(cTechCaracole, researchBuildingID, cMilitaryEscrowID, 50);
				return;
			}
		}
	}
	
	// Other civs can only get this upgrade in the advanced Arsenal but for simplicity for the Lakota it's checked here just for them.
	if (cMyCiv == cCivXPSioux)
	{
		if (kbTechGetStatus(cTechPillage) == cTechStatusObtainable)
		{
			unitCount = kbUnitCount(cMyID, cUnitTypeAbstractHandCavalry, cUnitStateAlive);
			upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechPillage);
			if ((upgradePlanID >= 0) && (unitCount < 8))
				aiPlanDestroy(upgradePlanID);
			if ((upgradePlanID < 0) && (unitCount >= 8))
			{
				createSimpleResearchPlan(cTechPillage, researchBuildingID, cMilitaryEscrowID, 50);
				return;
			}
		}
	}
}

rule advancedArsenalUpgradeMonitor
inactive
minInterval 60
{
   int upgradePlanID = -1;
	int unitCount = -1;
	int researchBuildingID = -1;
	
	if ((cMyCiv == cCivBritish) || (cMyCiv == cCivDutch) || (cMyCiv == cCivOttomans) || (cMyCiv == cCivRussians) || (cMyCiv == cCivDESwedish))
	{
		researchBuildingID = cUnitTypeArsenal;
	   // Disable rule once all upgrades are active.
		if ((kbTechGetStatus(cTechPaperCartridge) == cTechStatusActive) &&
			(kbTechGetStatus(cTechFlintlock) == cTechStatusActive) &&
			(kbTechGetStatus(cTechMilitaryDrummers) == cTechStatusActive) &&
			(kbTechGetStatus(cTechProfessionalGunners) == cTechStatusActive) &&
			(kbTechGetStatus(cTechTrunion) == cTechStatusActive) && 
			(kbTechGetStatus(cTechPillage) == cTechStatusActive) &&
			(kbTechGetStatus(cTechIncendiaryGrenades) == cTechStatusActive)) // We have the Incendiary Grenades upgrade so check for it.
		{
			aiEcho("Disabling rule advancedArsenalUpgradeMonitor since we have all upgrades.");
			xsDisableSelf();
			return;
		}
	}
	// We are Japanese and have a Golden Pavilion.
   else if ((cMyCiv == cCivJapanese) || (cMyCiv == cCivSPCJapanese) || (cMyCiv == cCivSPCJapaneseEnemy))
	{
		// Check for Golden Pavilions.
		if (kbUnitCount(cMyID, cUnitTypeypWJGoldenPavillion2, cUnitStateAlive) > 0)
		{
			researchBuildingID = cUnitTypeypWJGoldenPavillion2;
		}
		else if (kbUnitCount(cMyID, cUnitTypeypWJGoldenPavillion3, cUnitStateAlive) > 0)
		{
			researchBuildingID = cUnitTypeypWJGoldenPavillion3;
		}
		else if (kbUnitCount(cMyID, cUnitTypeypWJGoldenPavillion4, cUnitStateAlive) > 0)
		{
			researchBuildingID = cUnitTypeypWJGoldenPavillion4;
		}
		else if (kbUnitCount(cMyID, cUnitTypeypWJGoldenPavillion5, cUnitStateAlive) > 0)
		{
			researchBuildingID = cUnitTypeypWJGoldenPavillion5;
		}
		// Disable rule once all upgrades are active.
		if((kbTechGetStatus(cTechPaperCartridge) == cTechStatusActive) &&
        (kbTechGetStatus(cTechFlintlock) == cTechStatusActive) &&
        (kbTechGetStatus(cTechProfessionalGunners) == cTechStatusActive) &&
        (kbTechGetStatus(cTechPillage) == cTechStatusActive))
		{
			aiEcho("Disabling rule advancedArsenalUpgradeMonitor since we have all upgrades.");
			xsDisableSelf();
			return;
		}
	}
	// We are European not being one of the civs mentioned above, we don't have access to Incendiary Grenades.
	// Disable rule once all upgrades are active.
	else
	{	
		researchBuildingID = cUnitTypeArsenal;
		if ((kbTechGetStatus(cTechPaperCartridge) == cTechStatusActive) &&
         (kbTechGetStatus(cTechFlintlock) == cTechStatusActive) &&
         (kbTechGetStatus(cTechMilitaryDrummers) == cTechStatusActive) &&
         (kbTechGetStatus(cTechProfessionalGunners) == cTechStatusActive) &&
         (kbTechGetStatus(cTechTrunion) == cTechStatusActive) && 
		   (kbTechGetStatus(cTechPillage) == cTechStatusActive))
		{
			aiEcho("Disabling rule advancedArsenalUpgradeMonitor since we have all upgrades.");
			xsDisableSelf();
			return;
		}
	}
	
   // Quit if there is no Arsenal or Golden Pavilion.
   if (kbUnitCount(cMyID, researchBuildingID, cUnitStateAlive) < 1)
      return;

   // Get upgrades one at the time, provided a sufficient number of units to be improved are available.
   // Destroy existing plan if not enough units benefit anymore.
	
   if (kbTechGetStatus(cTechPaperCartridge) == cTechStatusObtainable)
	{
		unitCount = kbUnitCount(cMyID, cUnitTypeAbstractGunpowderTrooper, cUnitStateABQ);
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechPaperCartridge);		
		if ((upgradePlanID >= 0) && (unitCount < 12))
			aiPlanDestroy(upgradePlanID);
		else if ((upgradePlanID < 0) && (unitCount >= 12))
		{
			createSimpleResearchPlan(cTechPaperCartridge, researchBuildingID, cMilitaryEscrowID, 50);
			return;
		}
	}
	
	if (kbTechGetStatus(cTechFlintlock) == cTechStatusObtainable)
	{
		unitCount = kbUnitCount(cMyID, cUnitTypeAbstractGunpowderTrooper, cUnitStateABQ);
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechFlintlock);		
		if ((upgradePlanID >= 0) && (unitCount < 12))
			aiPlanDestroy(upgradePlanID);
		else if ((upgradePlanID < 0) && (unitCount >= 12))
		{
			createSimpleResearchPlan(cTechFlintlock, researchBuildingID, cMilitaryEscrowID, 50);
			return;
		}
	}
		
   if (kbTechGetStatus(cTechProfessionalGunners) == cTechStatusObtainable)
	{
		unitCount = kbUnitCount(cMyID, cUnitTypeAbstractArtillery, cUnitStateABQ);
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechProfessionalGunners);		
		if ((upgradePlanID >= 0) && (unitCount < 6))
			aiPlanDestroy(upgradePlanID);
		else if ((upgradePlanID < 0) && (unitCount >= 6))
		{
			createSimpleResearchPlan(cTechProfessionalGunners, researchBuildingID, cMilitaryEscrowID, 50);
			return;
		}
	}
	
   if (kbTechGetStatus(cTechPillage) == cTechStatusObtainable)
	{
		unitCount = kbUnitCount(cMyID, cUnitTypeAbstractHandCavalry, cUnitStateABQ) + kbUnitCount(cMyID, cUnitTypeAbstractCoyoteMan, cUnitStateABQ);
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechPillage);		
		if ((upgradePlanID >= 0) && (unitCount < 8))
			aiPlanDestroy(upgradePlanID);
		else if ((upgradePlanID < 0) && (unitCount >= 8))
		{
			createSimpleResearchPlan(cTechPillage, researchBuildingID, cMilitaryEscrowID, 50);
			return;
		}
	}
	// The Golden Pavilion doesn't have the following upgrades so don't check.
	if ((cMyCiv != cCivJapanese) || (cMyCiv != cCivSPCJapanese) || (cMyCiv != cCivSPCJapaneseEnemy))
	{
		if (kbTechGetStatus(cTechMilitaryDrummers) == cTechStatusObtainable)
		{
			unitCount = kbUnitCount(cMyID, cUnitTypeAbstractInfantry, cUnitStateABQ);
			upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechMilitaryDrummers);		
			if ((upgradePlanID >= 0) && (unitCount < 12))
				aiPlanDestroy(upgradePlanID);
			else if ((upgradePlanID < 0) && (unitCount >= 12))
			{
				createSimpleResearchPlan(cTechMilitaryDrummers, researchBuildingID, cMilitaryEscrowID, 50);
				return;
			}
		}

		if (kbTechGetStatus(cTechTrunion) == cTechStatusObtainable)
		{
			unitCount = kbUnitCount(cMyID, cUnitTypeAbstractArtillery, cUnitStateABQ);
			upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechTrunion);		
			if ((upgradePlanID >= 0) && (unitCount < 6))
				aiPlanDestroy(upgradePlanID);
			else if ((upgradePlanID < 0) && (unitCount >= 6))
			{
				createSimpleResearchPlan(cTechTrunion, researchBuildingID, cMilitaryEscrowID, 50);
				return;
			}
		}
		
		// Only these civs have access to this upgrade from all the European civs.
		if ((cMyCiv == cCivBritish) || (cMyCiv == cCivDutch) || (cMyCiv == cCivOttomans) || (cMyCiv == cCivRussians) || (cMyCiv == cCivDESwedish))
		{	
			if (kbTechGetStatus(cTechIncendiaryGrenades) == cTechStatusObtainable)
			{
				unitCount = kbUnitCount(cMyID, cUnitTypeGrenadier, cUnitStateABQ);
				upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechIncendiaryGrenades);		
				if ((upgradePlanID >= 0) && (unitCount < 12))
					aiPlanDestroy(upgradePlanID);
				else if ((upgradePlanID < 0) && (unitCount >= 12))
				{
					createSimpleResearchPlan(cTechIncendiaryGrenades, getUnit(cUnitTypeArsenal), cMilitaryEscrowID, 50);
					return;
				}
			}
		}
	}
}

rule maintainCreeCoureurs
inactive
minInterval 30
{
   static int creePlan = -1;
   int limit = 0;

   if (kbUnitCount(0, cUnitTypeSocketCree, cUnitStateAny) == 0)
      return;

   // Check build limit
   limit = kbGetBuildLimit(cMyID, cUnitTypeCoureurCree);

   if (kbUnitCount(cMyID, cUnitTypeTradingPost, cUnitStateAlive) < 1)
      limit = 0;

   // Create/update maintain plan
   if ((creePlan < 0) && (limit >= 1))
   {
      creePlan = createSimpleMaintainPlan(cUnitTypeCoureurCree, limit, true, kbBaseGetMainID(cMyID), 1);
   }
   else
   {
      aiPlanSetVariableInt(creePlan, cTrainPlanNumberToMaintain, 0, limit);
   }
}

rule maintainBerberNomads
inactive
minInterval 30
{
   static int nomadPlan = -1;
   int limit = 0;

	// Berber Nomads are bad at anything but natural resources, so don't bother with them if we've ran out of those.
	if ((gTimeForPlantations == true) && (gTimeToFarm == true))
	{
		if (nomadPlan > 0)
			aiPlanDestroy(nomadPlan);
		xsDisableSelf();
	}
	
	if ((cMyCiv != cCivDEHausa) || (kbTechGetStatus(cTechDEAllegianceBerberUnlockShadow) != cTechStatusActive) && (kbUnitCount(0, cUnitTypedeSocketBerbers, cUnitStateAny) == 0))
		return;

   // Check build limit.
   limit = kbGetBuildLimit(cMyID, cUnitTypedeNatNomad);

   if ((kbUnitCount(cMyID, cUnitTypeTradingPost, cUnitStateAlive) < 1) && 
	    (kbTechGetStatus(cTechDEAllegianceBerberUnlockShadow) != cTechStatusActive))
      limit = 0;

   // Create/update maintain plan.
   if ((nomadPlan < 0) && (limit >= 1))
   {
      nomadPlan = createSimpleMaintainPlan(cUnitTypedeNatNomad, limit, true, kbBaseGetMainID(cMyID), 1);
   }
   else
   {
      aiPlanSetVariableInt(nomadPlan, cUnitTypedeNatNomad, 0, limit);
   }
}

//==============================================================================
// tcBuildPlanDelay
/*
   Allows delayed activation of the TC build plan, so that the explorer has
   uncovered a good bit of the map before a placement is selected.

   The int gTCBuildPlanID is used to simplify passing of the build plan ID from
   init().
*/
//==============================================================================

rule tcBuildPlanDelay
inactive
minInterval 1
{
   if (xsGetTime() < gTCStartTime)
      return; // Do nothing until game time is beyond 10 seconds

   aiPlanSetActive(gTCBuildPlanID);
   aiEcho("Activating TC build plan " + gTCBuildPlanID + ".");
   xsDisableSelf();
}

//==============================================================================
/* transportArrive()

   This function is called when it is time for the AI to come to life.

   In Scenario/Campaign games, it means the aiStart object has been placed.

   In RM/GC games, it means that the player has all the starting units.  This may
   mean that the initial boat has been unloaded, or the player has started
   with a TC and units, or the player has initial units and a covered wagon
   and must choose a TC location.

   This function activates "initRule" if everything is OK for a start...
*/
//==============================================================================
void transportArrive(int techID = -1) // Event handler
{
   static bool firstTime = true;

   if (gSPC == true)
   {
      // Verify aiStart object, return if it isn't there
      if (kbUnitCount(cMyID, cUnitTypeAIStart, cUnitStateAlive) < 1)
      {
         xsEnableRule("waitForStartup");
         return ();
      }
   }

   if (firstTime == true)
   {
      // Do init processing
      aiEcho("The transport has arrived.");
      firstTime = false;
      // No need for it, we're running
      xsDisableRule("transportArriveFailsafe");
      xsEnableRule("initRule");
   }

   if (techID >= 0)
   {
      transportShipmentArrive(techID);
   }
}

//==============================================================================
// transportShipmentArrive()
//==============================================================================
void transportShipmentArrive(int techID = -1)
{
   switch (techID)
   {
   case cTechDEHCREVDhimma:
   {
      cvOkToGatherFood = true;
      cvOkToGatherWood = true;
      cvOkToGatherGold = true;
      gRevolutionType = cRevolutionEconomic;
      break;
   }
   case cTechDEHCREVCitizenship:
   {
      cvOkToGatherFood = true;
      cvOkToGatherWood = true;
      cvOkToGatherGold = true;
      gRevolutionType = cRevolutionEconomic;
      break;
   }
   case cTechDEHCREVCitizenshipOutpost:
   {
      cvOkToGatherFood = true;
      cvOkToGatherWood = true;
      cvOkToGatherGold = true;
      gRevolutionType = cRevolutionEconomic;
      break;
   }
   case cTechDEHCREVNothernWilderness:
   {
      cvOkToGatherFood = true;
      cvOkToGatherGold = true;
      break;
   }
   case cTechDEHCREVAcehExports:
   {
      cvOkToGatherFood = true;
      cvOkToGatherWood = true;
      cvOkToGatherGold = true;
      gRevolutionType = cRevolutionEconomic;
      break;
   }
   case cTechDEHCREVMinasGerais:
   {
      cvOkToGatherFood = true;
      cvOkToGatherWood = true;
      cvOkToGatherGold = true;
      gRevolutionType = cRevolutionEconomic;
      break;
   }
   case cTechDEHCREVSalitrera:
   {
      cvOkToGatherFood = true;
      cvOkToGatherWood = true;
      cvOkToGatherGold = true;
      gRevolutionType = cRevolutionEconomic;
      break;
   }
   case cTechHCGermantownFarmers:
   {
      createSimpleMaintainPlan(cUnitTypeSettlerWagon, kbGetBuildLimit(cMyID, cUnitTypeSettlerWagon), true,
                               kbBaseGetMainID(cMyID), 1);
      break;
   }
	case cTechHCXPNewWaysSioux:  // Lakota New Ways card.
	{
		xsEnableRule("arsenalUpgradeMonitor");
	}
	case cTechHCXPNewWaysIroquois:  // Haudenosaunee New Ways card.
	{
		xsEnableRule("arsenalUpgradeMonitor");
	}
	case cTechHCAdvancedArsenalGerman:
	{
		xsEnableRule("advancedArsenalUpgradeMonitor");
		xsEnableRule("ArsenalUpgradeMonitor"); // In case we get this card in Age2 we need to enable this rule now since otherwise it won't be enabled until Age 3.
	}
	case cTechHCAdvancedArsenal:
	{
		xsEnableRule("advancedArsenalUpgradeMonitor");
		xsEnableRule("ArsenalUpgradeMonitor"); // In case we get this card in Age2 we need to enable this rule now since otherwise it won't be enabled until Age 3.
	}
   }
}

rule transportArriveFailsafe
inactive
minInterval 60
{                       // This rule is normally killed when transportArrive runs the first time.
   transportArrive(-1); // Call it if we're still running at 30 seconds, make sure the AI starts.
}

rule autoSave
inactive
minInterval 5
{
   int interval = 2; // Interval in minutes
   static int nextTime = 0;

   // First, do an auto save game if needed
   // Dont save if we are told not to.
   if (aiGetAutosaveOn() == true)
   {
      int firstCPPlayerID = -1;
      for (i = 0; < cNumberPlayers)
      {
         if (kbIsPlayerHuman(i) == true)
            continue;

         firstCPPlayerID = i;
      }
      if ((cMyID == firstCPPlayerID) && (xsGetTime() >= nextTime) && (cvDoAutoSaves == true))
      { // We're the first CP, it's our job to do the save, and it's time to do it.
         // Create the savegame name.
         static int psCount = 0;
         // Save it.
         if (cvDoAutoSaves == true)
         {
            aiQueueAutoSavegame(psCount);
            // Inc our count.
            psCount = psCount + interval; // Count roughly matches game time in minutes
            while (psCount < (xsGetTime() / 60000))
               psCount = psCount + interval; // Handle reloading of save games from machines that had saves off...
            nextTime = psCount * 60 * 1000;
         }
      }
   }
}

//==============================================================================
/* rule ageUpgradeMonitor

   This rule decides when it makes sense to work toward an age upgrade.  When that
   time comes, it shifts the normal escrow accounts to zero, sets the upgrade account
   to 100%, and reallocates everything.

   This causes the upgrade account to take everything it needs until the age upgrade
   is complete.  The escrows are restored in the next age's 'monitor' rule, i.e.
   the age2monitor, age3Monitor, etc.
*/
//==============================================================================
rule ageUpgradeMonitor
inactive
group tcComplete
minInterval 10
{
   int wonderToBuild = -1; // Used for Asian logic.
	int politician = -1;    // Used for non Asian logic.
   gAgeUpPriority = 49;
   float ageUpBias = 0.0;

   // Disable after revolting as well.
   if (kbGetAge() >= cAge5) // || gRevolutionType != 0)
   {
      xsDisableSelf();
      return;
   }

   if ((kbGetAge() >= cvMaxAge) || (gRevolutionType & cRevolutionMilitary) == cRevolutionMilitary)
      return; // Don't disable, this var could change later...

   // If we already have a plan let's see if we need to adjust it to account for the new situation in game.
   if (gAgeUpResearchPlan >= 0)
   {
      if (aiPlanGetState(gAgeUpResearchPlan) >= 0)
      {
   if (aiTreatyActive() == true)
   {
   
		      if ((xsGetTime() > 6 * 60 * 1000) && (kbGetAge() == cAge2))
		      {
			         gAgeUpPriority = 70;
		      }
		      if ((xsGetTime() > 10 * 60 * 1000) && (kbGetAge() == cAge3))
		      {
			         gAgeUpPriority = 60;
		      }
		      if ((xsGetTime() > 12 * 60 * 1000) && (kbGetAge() == cAge3))
		      {
			         gAgeUpPriority = 70;
		      }
		      if (kbGetAge() == cAge4)
		      {
			         gAgeUpPriority = 60;
		      }
		      if ((xsGetTime() > 16 * 60 * 1000) && (kbGetAge() == cAge4))
		      {
			         gAgeUpPriority = 70;
		      }
	}
	else 
	if (aiGetWorldDifficulty() >= cDifficultyExpert)
	{
		      if ((xsGetTime() > 8 * 60 * 1000) && (kbGetAge() == cAge2))
		      {
			         gAgeUpPriority = 60;
		      }
		      if ((xsGetTime() > 10 * 60 * 1000) && (kbGetAge() == cAge2))
		      {
			         gAgeUpPriority = 65;
		      }
		      if ((xsGetTime() > 14 * 60 * 1000) && (kbGetAge() == cAge3))
		      {
			         gAgeUpPriority = 60;
		      }
		      if ((xsGetTime() > 16 * 60 * 1000) && (kbGetAge() == cAge3))
		      {
			         gAgeUpPriority = 65;
		      }
			  if (gRevolutionType == 0 || (gRevolutionType & cRevolutionEconomic) == cRevolutionEconomic)
	  {
		      if ((kbGetAge() == cAge4) && (xsGetTime() < 20 * 60 * 1000))
		      {
			         gAgeUpPriority = 55;
		      }
			  else
		      if (kbGetAge() == cAge4)
		      {
			         gAgeUpPriority = 60;
		      }
		      if ((xsGetTime() > 24 * 60 * 1000) && (kbGetAge() == cAge4))
		      {
			         gAgeUpPriority = 65;
		      }
	  }
	}
	else
	{
		      if ((xsGetTime() > 12 * 60 * 1000) && (kbGetAge() == cAge2))
		      {
			         gAgeUpPriority = 60;
		      }
		      if ((xsGetTime() > 16 * 60 * 1000) && (kbGetAge() == cAge2))
		      {
			         gAgeUpPriority = 65;
		      }
		      if ((xsGetTime() > 20 * 60 * 1000) && (kbGetAge() == cAge3))
		      {
			         gAgeUpPriority = 60;
		      }
		      if ((xsGetTime() > 24 * 60 * 1000) && (kbGetAge() == cAge3))
		      {
			         gAgeUpPriority = 65;
		      }
			  if (gRevolutionType == 0 || (gRevolutionType & cRevolutionEconomic) == cRevolutionEconomic)
	  {
		      if ((kbGetAge() == cAge4) && (xsGetTime() < 26 * 60 * 1000))
		      {
			         gAgeUpPriority = 55;
		      }
			  else
		      if (kbGetAge() == cAge4)
		      {
			         gAgeUpPriority = 60;
		      }
		      if ((xsGetTime() > 30 * 60 * 1000) && (kbGetAge() == cAge4))
		      {
			         gAgeUpPriority = 65;
		      }
	  }
	}


         // Update age up choices, we don't do this for Africa because that logic requires no update.
         if ((aiPlanGetState(gAgeUpResearchPlan) != cPlanStateResearch) && (civIsAfrican() == false))
         {
            if (civIsAsian() == false)
            {
               if (civIsNative() == true)
                  politician = chooseNativeCouncilMember();
               else if (civIsEuropean() == true)
                  politician = chooseEuropeanPolitician();
						
               if (politician < 0)  // We somehow failed to get a valid politician so chose the one at index 0.
					{
						aiEcho("We failed to get a valid politician while updating our choice so try index 0");
                  politician = aiGetPoliticianListByIndex(kbGetAge() + 1, 0);
					}
               if (politician >= 0)  // Adjust the plan with the newly found politician.
					{	
						aiEcho("Adjusting age up plan to this: " + politician);
                  aiPlanSetVariableInt(gAgeUpResearchPlan, cResearchPlanTechID, 0, politician);
					}
					else
						aiEcho("We failed to pick a politician to adjust our age up plan with, how could this happen?");
            }
            else
            {
               wonderToBuild = chooseAsianWonder();
               if (wonderToBuild >= 0)
					{
						aiEcho("Adjusting age up plan to this: " + wonderToBuild);
                  aiPlanSetVariableInt(gAgeUpResearchPlan, cBuildPlanBuildingTypeID, 0, wonderToBuild);
					}
					else
						aiEcho("We failed to pick a wonder to update our age up plan with, how could this happen?");	
            }
         }
         aiPlanSetDesiredResourcePriority(gAgeUpResearchPlan, gAgeUpPriority);
         aiPlanSetEventHandler(gAgeUpResearchPlan, cPlanEventStateChange, "ageUpEventHandler");
         return;
      }
      else
      { // Plan variable is set, but plan is dead.
         aiPlanDestroy(gAgeUpResearchPlan);
         gAgeUpResearchPlan = -1;
         // OK to continue, as we don't have an active plan so we need to create one again.
      }
   }
	
	// We have no plan yet so create one.
	if (gAgeUpResearchPlan < 0)
	{
		// If we're not yet planning to go up and have no excess resources anyway we don't bother with the plan and return.
		if (gAgeUpPriority < 60)
		{
		if ((xsGetTime() < gAgeUpPlanTime) && (gExcessResources == false))
			return;
		}
		
		// Asians build Wonders so they don't use this logic.
		if (civIsAsian() == false)
		{
			// Try to research the preferred politician / council member / alliance.
			if (civIsNative() == true)
				politician = chooseNativeCouncilMember();
			else if (civIsAfrican() == true)
				politician = chooseAfricanAlliance();
			else
				politician = chooseEuropeanPolitician();

			if (politician < 0)                                            // We somehow failed to get a valid politician so chose the one at index 0.
				politician = aiGetPoliticianListByIndex(kbGetAge() + 1, 0); 

			// We have managed to pick a politician / council member / alliance (or got defaulted to index 0) so let's create the research plan. 
			// If we somehow still don't have one we just don't make a plan.
			if (politician >= 0)
			{
				// Sanity check.
				if (kbTechGetStatus(politician) == cTechStatusObtainable)
				{
					gAgeUpResearchPlan = createSimpleResearchPlan(politician, -1, cEmergencyEscrowID, 99);
					aiPlanSetDesiredResourcePriority(gAgeUpResearchPlan, gAgeUpPriority);
					aiPlanSetEventHandler(gAgeUpResearchPlan, cPlanEventStateChange, "ageUpEventHandler");
					aiEcho("Creating plan #" + gAgeUpResearchPlan + " to get age upgrade with tech " + kbGetTechName(politician));
					return;
				}
         }
			else
				aiEcho("We failed to pick a politician to make an age up plan for, how could this happen?");
		}
		else
		{  // We are Asian, time to build a Wonder.
			wonderToBuild = chooseAsianWonder();
			if (wonderToBuild >= 0)
			{
				gAgeUpResearchPlan = createSimpleBuildPlan(wonderToBuild, 1, 100, true, cEmergencyEscrowID, kbBaseGetMainID(cMyID), 4);
				aiPlanSetDesiredResourcePriority(gAgeUpResearchPlan, gAgeUpPriority);
				aiPlanSetEventHandler(gAgeUpResearchPlan, cPlanEventStateChange, "ageUpEventHandler");
				aiEcho("Wonder to build: " + kbGetProtoUnitName(wonderToBuild));
				aiEcho("Creating plan #" + gAgeUpResearchPlan + " to get age upgrade with wonder " + kbGetProtoUnitName(wonderToBuild));	
			}
			else
				aiEcho("We failed to pick a wonder to make an age up plan for, how could this happen?");
		}
	}
}
//==============================================================================
// ageTransitionManager
//
// Run military and building manager early to update resources we need.
//==============================================================================
rule ageTransitionManager
inactive
minInterval 1
{
   static int counter = 0;

   switch(counter)
   {
   case 0:
   {
      if (xsIsRuleEnabled("militaryManager") == false)
      {
         xsEnableRule("militaryManager");
         aiEcho("Enabling the military manager.");
         militaryManager(); // runImmediately doesn't work.
      }
      break;
   }
   case 1:
   {
      buildingMonitor();
      break;
   }
   case 2:
   {
      updateResourceDistribution(true);
      break;
   }
   }

   counter++;
   if (counter >= 3)
   {
      xsDisableSelf();
      counter = 0;
   }
}

//==============================================================================
// ageUpEventHandler()
//==============================================================================
void ageUpEventHandler(int planID = -1)
{
   // force an update of resource distribution to prepare for stuffs after aging up
   if (aiGetWorldDifficulty() <= cDifficultyHard)
      return;
   int state = aiPlanGetState(planID);
   if (state == cPlanStateResearch || state == cPlanStateBuild)
   {
      if (xsIsRuleEnabled("ageTransitionManager") == false)
      {
         xsEnableRule("ageTransitionManager");
         ageTransitionManager();
      }
   }
}

//==============================================================================
/* shipGrantedHandler()



   Update 02/10/2004:  New algorithm.
   1)  Clear the list
   2)  Get all the settlers you can.
   3)  If space remains, get the resource you're lowest on.

   Update on 04/22/2004:  New algorithm:
   1)  First year, get wood
   2)  Later years, get the resource that gives the largest bucket.
   3)  In a tie, coin > food > wood
   Note, in the early years, the resourceManager will sell food and buy wood as needed
   to drive early housing growth.

   Update on 4/27/2004:  Get wood for first TWO years.

   Scrapped on 5/12/2004.  Now, settlers have to be imported.  New logic:
   1)  Get settlers always, except:
   2)  If I can afford governor and I don't have him yet, get him
   3)  If I can afford viceroy and I don't have him yet and he's available, get him.
   4)  If settlers aren't available or less than 10 are available, get most needed resource.

   August:  Always get an age upgrade if you can.  Otherwise, compute the value for each bucket,
   and choose the best buy.

   November:  Adding multiplier for econ/mil units based on rush/boom emphasis
*/
//==============================================================================
void shipGrantedHandler(int parm = -1) // Event handler
{
   aiEcho(" ");
   aiEcho("SHIP GRANTED:");

   if (kbResourceGet(cResourceShips) < 1.0)
      return; // Early out if we don't have a ship...no point even checking.

   bool homeBaseUnderAttack = false;
   if (gDefenseReflexBaseID == kbBaseGetMainID(cMyID))
      homeBaseUnderAttack = true; // So don't send resources or settlers....

   aiEcho("Choosing contents for next transport");

   bool result = false;

   // Adjust for rush or boominess
   float econBias = 0.0; // How much to boost econ units or penalize mil units
   // Flip rushboom sign so boomer is +1 and rusher is -1.
   econBias = (btRushBoom * -1.0);
   // Set econBias as a percentage boost or penalty for resources and settlers
   econBias = (econBias / 4.0) + 1.0; // +/- up to 25%

   int bestCard = -1;
   float bestUnitScore = -1.0;
   bool bestCardIsExtended = false;
   int unitType = -1;       // The current unit's ID.
   int unitCount = -1;      // How many unit types are available?
   int qtyAvail = -1;       // How many of each are available
   int ageReq = -1;         // What age do you need to use this card.
   int tech = -1;           // The techID for this card.
   string techName = "";    // The techName for this card.
   int flags = 0;           // The flags for this card.
   float totalValue = -1.0; // What is this bucket worth to me?
   float woodValue = -1.0;
   float foodValue = -1.0;
   float goldValue = -1.0;
   float influenceValue = -1.0;
   bool isMilitaryUnit = false;
   float totalResources = kbResourceGet(cResourceFood) + kbResourceGet(cResourceWood) + kbResourceGet(cResourceGold);
   int landUnitPickPrimary = kbUnitPickGetResult(gLandUnitPicker, 0);
   int landUnitPickSecondary = kbUnitPickGetResult(gLandUnitPicker, 1);
   int planID = -1;

   for (deckIndex = 0; < 2)
   {
      int deck = -1;
      bool extended = false;

      if (deckIndex == 0)
      {
         deck = gDefaultDeck;
         extended = false;
      }
      else
      {
         deck = aiHCGetExtendedDeck();
         extended = true;
      }

      if (deck < 0)
         continue;

      int totalCards = aiHCDeckGetNumberCards(deck);

      aiEcho("**** Picking HC card to play, " + totalCards + " cards in deck");
      for (i = 0; < totalCards)
      {
         //-- Skip card if we can't play it.
         if (aiHCDeckCanPlayCard(i, extended) == false)
            continue;

         unitType = aiHCDeckGetCardUnitType(deck, i); // What is this unit?
         qtyAvail = aiHCDeckGetCardUnitCount(deck, i);
         ageReq = aiHCDeckGetCardAgePrereq(deck, i);
         tech = aiHCDeckGetCardTechID(deck, i);
         techName = kbGetTechName(tech);
         flags = aiHCDeckGetCardFlags(deck, i);
         totalValue = 0.0;

         // Calculate a value for this unit.  If not found, use its aiCost.
         switch (unitType)
         {
         case gGalleonUnit:
         {
            if ((gNavyMode == cNavyModeActive) && (kbUnitCount(cMyID, cUnitTypeHomeCityWaterSpawnFlag) > 0) &&
                (gGalleonMaintain >= 0 && aiPlanGetVariableInt(gGalleonMaintain, cTrainPlanNumberToMaintain, 0) >
                                              kbUnitCount(cMyID, gGalleonUnit, cUnitStateABQ)))
            {
               woodValue = aiHCDeckGetCardValuePerResource(deck, i, cResourceWood);
               foodValue = aiHCDeckGetCardValuePerResource(deck, i, cResourceFood);
               goldValue = aiHCDeckGetCardValuePerResource(deck, i, cResourceGold);
               totalValue = woodValue + foodValue + goldValue;
            }
            break;
         }
         case gCaravelUnit:
         {
            if ((gNavyMode == cNavyModeActive) && (kbUnitCount(cMyID, cUnitTypeHomeCityWaterSpawnFlag) > 0) &&
                (gCaravelMaintain >= 0 && aiPlanGetVariableInt(gCaravelMaintain, cTrainPlanNumberToMaintain, 0) >
                                              kbUnitCount(cMyID, gCaravelUnit, cUnitStateABQ)))
            {
               woodValue = aiHCDeckGetCardValuePerResource(deck, i, cResourceWood);
               foodValue = aiHCDeckGetCardValuePerResource(deck, i, cResourceFood);
               goldValue = aiHCDeckGetCardValuePerResource(deck, i, cResourceGold);
               totalValue = woodValue + foodValue + goldValue;
            }
            break;
         }
         case gFrigateUnit:
         {
            if ((gNavyMode == cNavyModeActive) && (kbUnitCount(cMyID, cUnitTypeHomeCityWaterSpawnFlag) > 0) &&
                (gFrigateMaintain >= 0 && aiPlanGetVariableInt(gFrigateMaintain, cTrainPlanNumberToMaintain, 0) >
                                              kbUnitCount(cMyID, gFrigateUnit, cUnitStateABQ)))
            {
               woodValue = aiHCDeckGetCardValuePerResource(deck, i, cResourceWood);
               foodValue = aiHCDeckGetCardValuePerResource(deck, i, cResourceFood);
               goldValue = aiHCDeckGetCardValuePerResource(deck, i, cResourceGold);
               totalValue = woodValue + foodValue + goldValue;
            }
            break;
         }
         case gMonitorUnit:
         {
            if ((gNavyMode == cNavyModeActive) && (kbUnitCount(cMyID, cUnitTypeHomeCityWaterSpawnFlag) > 0) &&
                (gMonitorMaintain >= 0 && aiPlanGetVariableInt(gMonitorMaintain, cTrainPlanNumberToMaintain, 0) >
                                              kbUnitCount(cMyID, gMonitorUnit, cUnitStateABQ)))
            {
               woodValue = aiHCDeckGetCardValuePerResource(deck, i, cResourceWood);
               foodValue = aiHCDeckGetCardValuePerResource(deck, i, cResourceFood);
               goldValue = aiHCDeckGetCardValuePerResource(deck, i, cResourceGold);
               totalValue = woodValue + foodValue + goldValue;
            }
            break;
         }
         case gFishingUnit:
         {
            if (gTimeToFish == false)
               totalValue = 0.0;
            else if ((cvOkToFish == true) && (kbUnitCount(cMyID, cUnitTypeHomeCityWaterSpawnFlag) > 0))
            {
               woodValue = aiHCDeckGetCardValuePerResource(deck, i, cResourceWood);
               foodValue = aiHCDeckGetCardValuePerResource(deck, i, cResourceFood);
               goldValue = aiHCDeckGetCardValuePerResource(deck, i, cResourceGold);
               totalValue = woodValue + foodValue + goldValue;
            }
            break;
         }
         case gCoveredWagonUnit:
         {
            int numberTCs = kbUnitCount(cMyID, cUnitTypeTownCenter, cUnitStateAlive);
            if (numberTCs < 1)
            {
               totalValue = 100000.0; // Trumps everything
            }
            else if (kbTechGetStatus(cTechDERevolutionBrazil) == cTechStatusActive)
            {
               if (numberTCs < 5)
                  totalValue = 2000.0;
            }
            else
            {
               int tcTarget = 1;
               if (kbGetAge() >= cAge3)
               {
                  tcTarget = 2;
                  if (cMyCiv == cCivOttomans)
                  {
                     tcTarget = 3;
                  }
               }
               if (tech == cTechDEHCHuankaSupport)
               {
                  tcTarget = tcTarget + 1;
                  qtyAvail = 1;
               }
               else if (tech == cTechDEHCResettlements)
                  qtyAvail = 1;
               // if (btRushBoom < 0.5)
               //   tcTarget = (-1.0 * btRushBoom) + 2.5;
               if ((kbUnitCount(cMyID, cUnitTypeTownCenter, cUnitStateAlive) < tcTarget) &&
                   (homeBaseUnderAttack == false))
                  totalValue = 1600.0 * qtyAvail;
               else if ((kbUnitCount(cMyID, cUnitTypeTownCenter, cUnitStateAlive) <
                         kbGetBuildLimit(cMyID, cUnitTypeTownCenter)) &&
                        (homeBaseUnderAttack == false))
                  totalValue = 400.0 * qtyAvail;
            }
            break;
         }
         case cUnitTypeOutpostWagon:
         {
            if ((kbUnitCount(cMyID, cUnitTypeOutpostWagon, cUnitStateABQ) +
                 kbUnitCount(cMyID, cUnitTypeOutpost, cUnitStateAlive)) < gNumTowers)
               totalValue = 600.0 * qtyAvail;
            if (homeBaseUnderAttack == true)
               totalValue = 0.0;
            break;
         }
         case cUnitTypeYPCastleWagon:
         {
            if ((kbUnitCount(cMyID, cUnitTypeYPCastleWagon, cUnitStateABQ) +
                 kbUnitCount(cMyID, cUnitTypeypCastle, cUnitStateAlive)) < gNumTowers)
               totalValue = 900.0 * qtyAvail;
            if (homeBaseUnderAttack == true)
               totalValue = 0.0;
            break;
         }
         case cUnitTypeFortWagon:
         {
            if ((cvOkToBuild == true) && (cvOkToBuildForts == true) && (homeBaseUnderAttack == false) &&
                (kbUnitCount(cMyID, cUnitTypeFortFrontier, cUnitStateABQ) +
                     kbUnitCount(cMyID, cUnitTypeFortWagon, cUnitStateAlive) <
                 1))
               totalValue = 5000.0; // Big, but smaller than TC wagon.
            break;
         }
         case cUnitTypeFactoryWagon:
         {
            if ((cvOkToBuild == true) && (homeBaseUnderAttack == false))
               totalValue = 2000.0 * qtyAvail; // Big, but smaller than TC wagon.
            break;
         }
         case cUnitTypeYPDojoWagon:
         {
            if ((cvOkToBuild == true) && (homeBaseUnderAttack == false))
               totalValue = 1500.0; // Big, but smaller than TC wagon.
            break;
         }
         case cUnitTypedeREVStarTrekWagon:
         {
            // Disable South Africa trek wagons, the AI doesn't know to handle them.
            totalValue = 1.0;
            break;
         }
         case cUnitTypexpMedicineManAztec:
         {
            // 3 warrior priests card should be lower than resource crates and villagers.
            totalValue = 200.0 * qtyAvail;
            if (homeBaseUnderAttack == true)
               totalValue = 1.0;
            break;
         }
         default:
         {
            woodValue =
                aiHCDeckGetCardValuePerResource(deck, i, cResourceWood) - kbTechCostPerResource(tech, cResourceWood);
            foodValue =
                aiHCDeckGetCardValuePerResource(deck, i, cResourceFood) - kbTechCostPerResource(tech, cResourceFood);
            goldValue =
                aiHCDeckGetCardValuePerResource(deck, i, cResourceGold) - kbTechCostPerResource(tech, cResourceGold);
            influenceValue = aiHCDeckGetCardValuePerResource(deck, i, cResourceInfluence) -
                             kbTechCostPerResource(tech, cResourceInfluence);
            totalValue = woodValue + foodValue + goldValue + influenceValue;

            if ((tech == cTechYPHCSpawnRefugees1) || (tech == cTechYPHCSpawnRefugees2) ||
                (tech == cTechYPHCSpawnMigrants1))
            { // Handle 'Northern Refugees' (Chinese).
               if ((homeBaseUnderAttack == false) && ((kbUnitCount(cMyID, cUnitTypeypVillage, cUnitStateAlive) >= 1) ||
                                                      (kbUnitCount(cMyID, cUnitTypeTownCenter, cUnitStateAlive) >= 1)))
               {
                  qtyAvail = (kbUnitCount(cMyID, cUnitTypeypVillage, cUnitStateAlive) +
                              kbUnitCount(cMyID, cUnitTypeTownCenter, cUnitStateAlive));
                  if (qtyAvail >= 2)
                     totalValue = 165 * qtyAvail;
                  if ((kbGetAge() >= cAge2) || (econBias > 1.0))
                     totalValue = totalValue * econBias; // Boomers prefer this, rushers rather skip.
                  if (homeBaseUnderAttack == true)
                     totalValue = 1.0;                  // Tiny...ANYTHING else is better
                  if (getSettlerShortfall() < qtyAvail) // We have enough settlers
                     totalValue = 190.0;
               }
               else
                  totalValue = 1.0; // Tiny...ANYTHING else is better
            }
            else if (((unitType == cUnitTypeypSettlerIndian) || (unitType == cUnitTypedeChasqui)) && (qtyAvail == 1) &&
                     (totalValue < 200.0))
               totalValue = 0.0; // Avoid rating upgrades too low because it'd base the value on the free unit instead.
            else if (((flags & cHCCardFlagVillager) == cHCCardFlagVillager) || (unitType == cUnitTypeSettler) ||
                     (unitType == cUnitTypeCoureur) || (unitType == cUnitTypeSettlerWagon) ||
                     (unitType == cUnitTypeSettlerNative) || (unitType == cUnitTypeypSettlerAsian))
            {                                  // Handle villagers.
               totalValue = totalValue * 1.65; // Make sure we send villagers early to get the most value out of them.
               if ((kbGetAge() >= cAge2) || (econBias > 1.0))
                  totalValue = totalValue * econBias; // Boomers prefer this, rushers rather skip (except in age 1).
               if (homeBaseUnderAttack == true)
                  totalValue = 1.0;                  // Tiny...ANYTHING else is better
               if (getSettlerShortfall() < qtyAvail) // We have enough settlers
                  totalValue = 190.0;
            }
            else if (tech == cTechDEHCFedPlymouthSettlers)
            {
               // food crates + 3 piligrims per TC.
               totalValue = 300.0 + 100.0 * 1.65 * 3.0 * kbUnitCount(cMyID, cUnitTypeTownCenter, cUnitStateAlive);
               if (homeBaseUnderAttack == true)
                  totalValue = 1.0;                            
            }
            else if (tech == cTechDEHCImmigrantsIrish)
            {
               totalValue = 165 * (2 + xsGetTime() / 300000);
               if (totalValue > 2310.0)
                  totalValue = 2310.0;
               if (homeBaseUnderAttack == true)
                  totalValue = 1.0;                       
            }
            if ((flags & cHCCardFlagResourceCrate) == cHCCardFlagResourceCrate)
            { // Handle resource crates.
               if ((foodValue > 0.0) && (kbGetAge() == cAge1) && (econBias <= 1.0) &&
                   (kbResourceGet(cResourceFood) < 800))
                  totalValue = totalValue / econBias; // Increase value for rusher in age 1 to age up faster.
               else if ((kbGetAge() == cAge1) || (totalResources >= 10000))
                  totalValue = totalValue / 2.0;
               /*if (woodValue > 0.0)
                  totalValue = totalValue * kbGetAICostWeight(cResourceWood);
               if (foodValue > 0.0)
                  totalValue = totalValue * kbGetAICostWeight(cResourceFood);
               if (goldValue > 0.0)
                  totalValue = totalValue * kbGetAICostWeight(cResourceGold);*/
               int mostResource = cResourceWood;
               if (influenceValue > 0.0)
               {
                  if (kbUnitCount(cMyID, cUnitTypeNativeEmbassy, cUnitStateAlive) +
                          kbUnitCount(cMyID, cUnitTypedePalace, cUnitStateAlive) >
                      0)
                     totalValue = totalValue - 0.2;
                  else
                     totalValue = 1.0;
               }
               else
               {
                  if (woodValue < foodValue || woodValue < goldValue)
                  {
                     if (foodValue < goldValue)
                        mostResource = cResourceGold;
                     else
                        mostResource = cResourceFood;
                  }
                  for (j = cResourceGold; <= cResourceFood)
                  {
                     // prioritize resources as appropriate
                     if (getCorrectedResourcePercentage(mostResource) < getCorrectedResourcePercentage(j))
                        totalValue = totalValue - 0.1;
                  }

                  if (gRevolutionType != 0)
                  {
                     if (xsArrayGetFloat(gResourceNeeds, mostResource) > 0.0)
                        totalValue = totalValue * 1.1;
                  }
               }
               if (homeBaseUnderAttack == true)
                  totalValue = 1.0; // Tiny...ANYTHING else is better
            }

            if ((homeBaseUnderAttack == false) &&
                ((tech == cTechHCXPAgrarianWays) || (tech == cTechDEHCTerraceFarming) ||
                 (tech == cTechHCSustainableAgriculture) || (tech == cTechHCSustainableAgricultureGerman) ||
                 (tech == cTechYPHCSustainableAgricultureIndians) || (tech == cTechHCXPLandGrab) ||
                 (tech == cTechYPHCLandGrabIndians)))
            { // Handle Farm/Plantation/Paddy upgrades.
               if ((aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, gPlantationUnit) >= 1) ||
                   (kbUnitCount(cMyID, gPlantationUnit, cUnitStateAlive) >= 1) || (gTimeToFarm == true) ||
                   (aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, gFarmUnit) >= 1) ||
                   (kbUnitCount(cMyID, gFarmUnit, cUnitStateAlive) >= 1))
                  totalValue = 1120.0;
            }
            else if ((homeBaseUnderAttack == false) &&
                     ((tech == cTechHCRumDistillery) || (tech == cTechHCRumDistilleryTeam) ||
                      (tech == cTechHCRumDistilleryGerman) || (tech == cTechYPHCRumDistilleryIndians)))
            { // Handle other Plantation/Paddy upgrades.
               if ((aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, gPlantationUnit) >= 1) ||
                   (kbUnitCount(cMyID, gPlantationUnit, cUnitStateAlive) >= 1))
                  totalValue = 1110.0;
               else if ((tech != cTechHCRumDistilleryTeam) || (getAllyCount() <= 0))
                  totalValue = 1.1;
            }

            /*if ((tech == cTechHCAdvancedTradingPost) ||
                (tech == cTechDEHCAdvancedTambos))
            {  // Handle 'Advanced Trading Post' and 'Advanced Tambos'.
               if ((homeBaseUnderAttack == false) && (kbUnitCount(cMyID, cUnitTypeTradingPost, cUnitStateAlive) >= 1))
                  totalValue = 1500.0;
               //else
               //   totalValue = 1.0;
            }*/
            if (((tech == cTechHCNativeTreaties) || (tech == cTechHCNativeTreatiesGerman) ||
                 (tech == cTechHCNativeWarriors) || (tech == cTechHCNativeWarriorsGerman) ||
                 (tech == cTechHCNativeCombat) || (tech == cTechHCNativeCombatTeam) ||
                 (tech == cTechYPHCNativeLearning) || (tech == cTechYPHCNativeLearningIndians) ||
                 (tech == cTechYPHCNativeDamage) || (tech == cTechYPHCNativeDamageIndians) ||
                 (tech == cTechYPHCNativeHitpoints) || (tech == cTechYPHCNativeHitpointsIndians) ||
                 (tech == cTechYPHCNativeIncorporation) || (tech == cTechYPHCNativeIncorporationIndians) ||
                 (tech == cTechHCWildernessWarfare) || (tech == cTechHCXPBlackArrow) ||
                 (tech == cTechHCNativeChampionsDutchTeam) || (tech == cTechHCNativeLore) ||
                 (tech == cTechHCNativeLoreGerman)) &&
                (xsArrayGetSize(kbVPSiteQuery(cVPNative, cMyID, cVPStateCompleted)) < 1))
               totalValue = 1.0; // Handle other shipments which rely on a Trading Post.
            if (((tech == cTechDEHCCequeSystem)) && (kbUnitCount(cMyID, cUnitTypeTradingPost, cUnitStateAlive) < 1))
               totalValue = 1.0;
            if (((tech == cTechYPHCNativeTradeTax) || (tech == cTechYPHCNativeTradeTaxIndians)) &&
                ((xsArrayGetSize(kbVPSiteQuery(cVPNative, cMyID, cVPStateCompleted)) < 1) ||
                 (kbUnitCount(cMyID, cUnitTypeypConsulate, cUnitStateAlive) < 1)))
               totalValue = 1.0; // Handle other shipments which rely on a Trading Post or Consulate.

            if (((tech == cTechHCSchooners) || (tech == cTechYPHCSchoonersIndians) ||
                 (tech == cTechYPHCSchoonersJapanese) || (tech == cTechHCRenderingPlant) ||
                 (tech == cTechHCRenderingPlantGerman) || (tech == cTechYPHCRenderingPlantIndians) ||
                 (tech == cTechHCFishMarket) || (tech == cTechHCFishMarketGerman) ||
                 (tech == cTechYPHCFishMarketIndians) || (tech == cTechypHCFishMarket) || (tech == cTechHCArmada) ||
                 (tech == cTechHCSpanishGalleons)) &&
                (kbUnitCount(cMyID, cUnitTypeDock, cUnitStateAlive) < 1))
               totalValue = 1.0; // Handle shipments which rely on a Dock.

            if ((tech == cTechHCRoyalDecreeBritish) || (tech == cTechHCRoyalDecreeDutch) ||
                (tech == cTechHCRoyalDecreeFrench) || (tech == cTechHCRoyalDecreeGerman) ||
                (tech == cTechHCRoyalDecreeOttoman) || (tech == cTechHCRoyalDecreePortuguese) ||
                (tech == cTechHCRoyalDecreeRussian) || (tech == cTechHCRoyalDecreeSpanish))
            { // Handle 'Royal Decree'.
               if ((homeBaseUnderAttack == true) || (kbUnitCount(cMyID, cUnitTypeChurch, cUnitStateAlive) < 1) ||
                   (kbGetAge() < cAge2))
               {
                  totalValue = 500.0;
               }
               else// if (kbGetAge() >= cAge4)
               {
                  totalValue = 1500.0; // High priority in age4, default otherwise.
                  if (cMyCiv == cCivGermans)
                     totalValue = 4500.0; // Necessary to cope with uhlans being included in calculation
               }
            }

            if ((tech == cTechHCAdvancedArsenal) || (tech == cTechHCAdvancedArsenalGerman))
            { // Handle 'Advanced Arsenal'.
               if ((homeBaseUnderAttack == true) || (kbGetAge() == cAge1))
                  totalValue = 1.0;
               else if (kbUnitCount(cMyID, cUnitTypeArsenal, cUnitStateAlive) < 1)
                  totalValue = 0.0;
               else if (kbGetAge() >= cAge4)
               {
                  totalValue = 1505.0; // High priority in age4, default otherwise.
                  if (cMyCiv == cCivGermans)
                     totalValue = 4515.0; // Necessary to cope with uhlans being included in calculation
               }
            }

            if (tech == cTechHCXPNewWaysIroquois)
            { // Handle 'New Ways' (Iroquois).
               if ((homeBaseUnderAttack == true) || (kbUnitCount(cMyID, cUnitTypeLonghouse, cUnitStateAlive) < 1) ||
                   (kbGetAge() < cAge2))
                  totalValue = 1.0;
               else if (kbGetAge() >= cAge4)
                  totalValue = 1500.0; // High priority in age4, default otherwise.
            }
            if (tech == cTechHCXPNewWaysSioux)
            { // Handle 'New Ways' (Sioux).
               if ((homeBaseUnderAttack == true) || (kbUnitCount(cMyID, cUnitTypeTeepee, cUnitStateAlive) < 1) ||
                   (kbGetAge() < cAge2))
                  totalValue = 1.0;
               else if (kbGetAge() >= cAge4)
                  totalValue = 1500.0; // High priority in age4, default otherwise.
            }

            if ((tech == cTechDEHCMachuPicchu) && (cvOkToBuild == true) && (cvOkToBuildForts == true) &&
                (homeBaseUnderAttack == false))
               totalValue = 2500.0; // Big, but smaller than fort wagon.


            if (tech == cTechHCXPAztecMining)
               totalValue = 2500.0; // Big, but smaller than fort wagon.
		   
            if (tech == cTechDEHCTemenyas)
               totalValue = 600.0; // Big, but smaller than fort wagon.
		   
            if (tech == cTechDEHCEarlyKallanka)
               totalValue = 2500.0; // Big, but smaller than fort wagon.
		   
            if (tech == cTechDEHCAutarky)
               totalValue = 2500.0; // Big, but smaller than fort wagon.
		   
            if (tech == cTechYPHCAdvancedConsulate)
               totalValue = 2500.0; // Big, but smaller than fort wagon.

            if (tech == cTechYPHCAdvancedConsulateIndians)
               totalValue = 2500.0; // Big, but smaller than fort wagon.
		   
            if ((tech == cTechHCMosqueConstruction) && (cMyCiv == cCivOttomans) &&
                (kbUnitCount(cMyID, cUnitTypeChurch, cUnitStateABQ) >= 1))
               totalValue = 1500.0; // High priority

            if (((tech == cTechHCBanks1) || (tech == cTechHCBanks2)) &&
                (kbUnitCount(cMyID, cUnitTypeBank, cUnitStateAlive) >= kbGetBuildLimit(cMyID, cUnitTypeBank)))
               totalValue = 1510.0;
            else if (((tech == cTechHCBanks1) || (tech == cTechHCBanks2)) &&
                     ((kbUnitCount(cMyID, cUnitTypeBank, cUnitStateAlive) < kbGetBuildLimit(cMyID, cUnitTypeBank)) &&
                      (kbUnitCount(cMyID, cUnitTypeBank, cUnitStateAlive) < 1)))
               totalValue = 1.0;

            if ((tech == cTechHCGermantownFarmers || tech == cTechDEHCImmigrantsGerman) && gTimeToFarm == false)
               totalValue = 1.0;

            if (tech == cTechHCShipBalloons && aiGetFallenExplorerID() >= 0)
               totalValue = 1.0;

            if (tech == cTechDEHCEngelsbergIronworks)
            {
               int torpQuery = createSimpleUnitQuery(cUnitTypedeTorp, cMyID, cUnitStateABQ);
               int numberTorps = kbUnitQueryExecute(torpQuery);
               int numberTorpsOnMine = 0;
               for (j = 0; < numberTorps)
               {
                  int torpID = kbUnitQueryGetResult(torpQuery, j);
                  if (getUnitCountByLocation(cUnitTypeAbstractMine, 0, cUnitStateAny, kbUnitGetPosition(torpID), 10.0) >
                      0)
                     numberTorpsOnMine = numberTorpsOnMine + 1;
               }
               totalValue = 90.0 * numberTorpsOnMine;
            }

            if (tech == cTechDEHCFedCulpeperMinutemen)
            {
               if (homeBaseUnderAttack == true)
                  totalValue = 80.0 * 1.5 * kbUnitCount(cMyID, cUnitTypeTownCenter, cUnitStateAlive);
               else
                  totalValue = 1.0;
            }
				
				if (tech == cTechDEHCGidanSarkin)
            {
               if (homeBaseUnderAttack == true)
                  totalValue = 1.0;
               else if (aiGetWorldDifficulty() < cDifficultyHard)
                  totalValue = 650.0;
					else
						totalValue = 1400.0;
            }
				
            if (tech == cTechDEHCFedBostonTeaParty)
               totalValue = 1.0;

            // Revolution cards.
            if (gRevolutionType != 0)
            {
               if ((gRevolutionType & cRevolutionMilitary) == cRevolutionMilitary)
               {
                  if (tech == cTechDEHCREVDhimma || tech == cTechDEHCREVCitizenship ||
                      tech == cTechDEHCREVCitizenshipOutpost || tech == cTechDEHCREVAcehExports ||
                      tech == cTechDEHCREVMinasGerais || tech == cTechDEHCREVSalitrera)
                  {
                     // we are running out of resources, send the citizenship shipment to restore our economy.
                     /*if (xsArrayGetFloat(gResourceNeeds, cResourceFood) > -1000.0 ||
                         xsArrayGetFloat(gResourceNeeds, cResourceWood) > -1000.0 ||
                         xsArrayGetFloat(gResourceNeeds, cResourceGold) > -1000.0)*/
                        totalValue = 3000.0;
                     //else
                     //   totalValue = 1.0;
                  }
               }
               if (tech == cTechDEHCREVNothernWilderness)
               {
                  // we are running out of resources, send the citizenship shipment to restore our economy.
                  if (xsArrayGetFloat(gResourceNeeds, cResourceFood) > -1000.0 ||
                      xsArrayGetFloat(gResourceNeeds, cResourceGold) > -1000.0)
                     totalValue = 3000.0;
                  else
                     totalValue = 1.0;
               }
               //if (tech == cTechDEHCREVTurkuAcademy)
               //   totalValue = 1.0;
               if (tech == cTechDEHCREVBlackberries)
                  totalValue = 115.0 * kbUnitCount(cMyID, gHouseUnit, cUnitStateAlive);
               if (tech == cTechDEHCREVShipXhosaFoods)
                  totalValue = 900.0; // exclude the herdables
               //if (tech == cTechDEHCREVHuguenots)
               //   totalValue = 1.0; // Allow coureurs to be trained
               if (tech == cTechDEHCREVShipHomesteadWagons)
               {
                  if ((aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, gFarmUnit) >= 0 ||
                       aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, gPlantationUnit) >= 0) &&
                      xsArrayGetFloat(gResourceNeeds, cResourceWood) >= 600.0)
                     totalValue = 2000.0;
               }
            }

            if ((totalValue < 1.0) && (ageReq >= cAge1))
            { // Set a min value based on age
               if (gRevolutionType == 0)
               {
                  switch (ageReq)
                  {
                  case cAge1:
                  {
                     totalValue = 200.0;
                     break;
                  }
                  case cAge2:
                  {
                     totalValue = 450.0;
                     break;
                  }
                  case cAge3:
                  {
                     totalValue = 750.0;
                     break;
                  }
                  case cAge4:
                  {
                     totalValue = 1100.0;
                     break;
                  }
                  case cAge5:
                  {
                     totalValue = 1100.0;
                     break;
                  }
                  }
               }
               else
               {
                  totalValue = 1500.0;
               }
            }

            break;
         }
         }

         if (((tech == cTechHCXPLandGrab) || (tech == cTechYPHCLandGrabIndians)) &&
                 (((cMyCiv == cCivChinese) || (cMyCiv == cCivSPCChinese)) &&
                  (kbUnitCount(cMyID, cUnitTypeypVillage, cUnitStateAlive) <
                   kbGetBuildLimit(cMyID, cUnitTypeypVillage))) ||
             (((cMyCiv == cCivIndians) || (cMyCiv == cCivSPCIndians)) &&
              (kbUnitCount(cMyID, cUnitTypeypSacredField, cUnitStateAlive) <
               kbGetBuildLimit(cMyID, cUnitTypeypSacredField))))
            totalValue = totalValue * 1.1;

         int mainBaseID = kbBaseGetMainID(cMyID);
         float maxDistance = kbBaseGetMaximumResourceDistance(cMyID, mainBaseID);
         // Handle cards which ships resources to delay our time to start farming
         if ((gTimeToFarm == false) &&
             (kbProtoUnitIsType(cMyID, unitType, cUnitTypeHuntable) == true || unitType == cUnitTypeYPBerryWagon1))
         {
            int foodAmount = 0;
            if (cMyCiv == cCivJapanese || cMyCiv == cCivSPCJapanese || cMyCiv == cCivSPCJapaneseEnemy)
            {
               foodAmount = kbGetAmountValidResources(mainBaseID, cResourceFood, cAIResourceSubTypeEasy, maxDistance);
               foodAmount = foodAmount + (kbUnitCount(cMyID, cUnitTypeYPBerryWagon1, cUnitStateAlive) +
                                          kbUnitCount(cMyID, cUnitTypeypBerryBuilding, cUnitStateBuilding)) *
                                             5000.0;
            }
            else
               foodAmount = kbGetAmountValidResources(mainBaseID, cResourceFood, cAIResourceSubTypeHunt, maxDistance);
            float percentOnFood = getCorrectedResourcePercentage(cResourceFood);
            int numFoodGatherers = percentOnFood * kbUnitCount(cMyID, gEconUnit, cUnitStateAlive);
            if (numFoodGatherers < 1)
               numFoodGatherers = 1;
            int foodPerGatherer = foodAmount / numFoodGatherers;
            if (foodPerGatherer < 300)
               totalValue = totalValue * 1.2;
         }
         if ((gTimeForPlantations == false) &&
             (unitType == cUnitTypedeProspectorWagon || unitType == cUnitTypedeProspectorWagonGold ||
				  unitType == cUnitTypedeProspectorWagonSilver || unitType == cUnitTypedeProspectorWagonCoal ||
              unitType == cUnitTypedeREVProspectorWagon))
         {
            int goldAmount = kbGetAmountValidResources(mainBaseID, cResourceGold, cAIResourceSubTypeEasy, maxDistance);
            float percentOnGold = getCorrectedResourcePercentage(cResourceGold);
            int numGoldGatherers = percentOnGold * kbUnitCount(cMyID, gEconUnit, cUnitStateAlive);

            goldAmount = goldAmount + (kbUnitCount(cMyID, cUnitTypedeProspectorWagon, cUnitStateAlive) +
                                       kbUnitCount(cMyID, cUnitTypedeProspectorWagonGold, cUnitStateAlive) +
													kbUnitCount(cMyID, cUnitTypedeProspectorWagonSilver, cUnitStateAlive) +
                                       kbUnitCount(cMyID, cUnitTypedeProspectorWagonCoal, cUnitStateAlive)) *
                                          2000.0;
            goldAmount = goldAmount +  kbUnitCount(cMyID, cUnitTypedeREVProspectorWagon, cUnitStateAlive) * 																																		  
														100000.0;

            if (numGoldGatherers < 1)
               numGoldGatherers = 1;
            int goldPerGatherer = goldAmount / numGoldGatherers;
            if (goldPerGatherer < 300)
               totalValue = totalValue * 1.2;
         }
         if ((unitType == cUnitTypeYPGroveWagon) ||
             (tech == cTechDEHCREVTreeSpawn && (kbUnitCount(cMyID, cUnitTypeHouseEast, cUnitStateAlive) +
                                                kbUnitCount(cMyID, gHouseUnit, cUnitStateAlive) +
                                                kbUnitCount(cMyID, cUnitTypeBlockhouse, cUnitStateAlive)) > 15))
         {
            int woodAmount = kbGetAmountValidResources(mainBaseID, cResourceWood, cAIResourceSubTypeEasy, maxDistance);
            float percentOnWood = getCorrectedResourcePercentage(cResourceWood);
            int numWoodGatherers = percentOnWood * kbUnitCount(cMyID, gEconUnit, cUnitStateAlive);
            woodAmount = woodAmount + (kbUnitCount(cMyID, cUnitTypeYPGroveWagon, cUnitStateAlive) +
                                       kbUnitCount(cMyID, cUnitTypeypGroveBuilding, cUnitStateBuilding)) *
                                          5000.0;
            if (numWoodGatherers < 1)
               numWoodGatherers = 1;
            int woodPerGatherer = woodAmount / numWoodGatherers;
            if (woodPerGatherer < 300)
               totalValue = totalValue * 1.2;
         }

         if (tech == cTechDEHCDominions && (needMoreHouses() == true))
            totalValue = totalValue * 1.1;

         isMilitaryUnit = (((flags & cHCCardFlagMilitary) == cHCCardFlagMilitary) &&
                           ((flags & cHCCardFlagUnit) == cHCCardFlagUnit) && ((flags & cHCCardFlagWater) == 0)) ||
                          (kbProtoUnitIsType(cMyID, unitType, cUnitTypeLogicalTypeLandMilitary));
         if ((kbGetAge() < cAge3) && (isMilitaryUnit == true) && (homeBaseUnderAttack == false))
            totalValue = totalValue / econBias; // Decrease value of military unit for boomer.
         if ((kbGetAge() < cAge2) && (isMilitaryUnit == true) && (homeBaseUnderAttack == false) &&
             (cvOkToGatherNuggets == false))
            totalValue =
                0.1; // No military units before age 2, except if we're allowed to gather nuggets or are under attack.
         if ((aiTreatyGetEnd() > xsGetTime() + 10 * 60 * 1000) && (isMilitaryUnit == true))
            totalValue = 0.1;
         if ((landUnitPickPrimary >= 0) && (((unitType >= 0) && (unitType == landUnitPickPrimary)) ||
                                            (kbTechAffectsUnit(tech, landUnitPickPrimary) == true &&
                                             ((kbUnitCount(cMyID, landUnitPickPrimary, cUnitStateABQ) *
                                               (kbUnitCostPerResource(landUnitPickPrimary, cResourceGold) +
                                                kbUnitCostPerResource(landUnitPickPrimary, cResourceWood) +
                                                kbUnitCostPerResource(landUnitPickPrimary, cResourceFood))) > 1000.0) &&
                                             (flags & cHCCardFlagTrainPoints) == 0)))
            totalValue = totalValue * 1.4; // It's affecting what we're trying to train with highest priority
         else if ((landUnitPickSecondary >= 0) &&
                  (((unitType >= 0) && (unitType == landUnitPickSecondary)) ||
                   (kbTechAffectsUnit(tech, landUnitPickSecondary) == true &&
                    ((kbUnitCount(cMyID, landUnitPickSecondary, cUnitStateABQ) *
                      (kbUnitCostPerResource(landUnitPickSecondary, cResourceGold) +
                       kbUnitCostPerResource(landUnitPickSecondary, cResourceWood) +
                       kbUnitCostPerResource(landUnitPickSecondary, cResourceFood))) > 1000.0) &&
                    (flags & cHCCardFlagTrainPoints) == 0)))
            totalValue = totalValue * 1.2; // It's affecting what we're trying to train with 2nd highest priority
         if (((flags & cHCCardFlagTrickleGold) == cHCCardFlagTrickleGold) ||
             ((flags & cHCCardFlagTrickleWood) == cHCCardFlagTrickleWood) ||
             ((flags & cHCCardFlagTrickleFood) == cHCCardFlagTrickleFood) ||
             ((flags & cHCCardFlagTrickleXP) == cHCCardFlagTrickleXP) ||
             ((flags & cHCCardFlagTrickleTrade) == cHCCardFlagTrickleTrade) || (tech == cTechYPHCIncreasedTribute) ||
             (tech == cTechDEHCCequeSystem) || (tech == cTechDEHCChichaBrewing) || (tech == cTechHCXPBankWagon) ||
             (tech == cTechHCBetterBanks) || (tech == cTechHCCheaperManors) || (tech == cTechHCXPAdoption) ||
             //(tech == cTechHCSilkRoadTeam) ||
             (tech == cTechHCXPSpanishGold) || (tech == cTechHCXPOldWaysIroquois) || (tech == cTechHCXPOldWaysSioux) ||
             (tech == cTechHCXPOldWaysAztec) ||
             (tech == cTechDEHCOldWaysInca)) // Cards which should be sent early for best value
            totalValue = totalValue * 2.3; // Priority slightly lower than 3 villagers (age1) but higher than most cards
                                           // of the next higher age
         // Handle cards which changes gather rate, slightly lower than age1 villagers card
         if (((flags & cHCCardFlagGatherRate) == cHCCardFlagGatherRate) &&
             (kbTechAffectsUnit(tech, cUnitTypeAbstractVillager) == true))
         {
            static int resourceTypes = -1;
            static int resourceSubTypes = -1;
            if (resourceTypes < 0)
            {
               resourceTypes = xsArrayCreateInt(9, 0, "Resource Types");
               resourceSubTypes = xsArrayCreateInt(9, 0, "Resource Sub Types");

               xsArraySetInt(resourceTypes, 0, cResourceFood);
               xsArraySetInt(resourceSubTypes, 0, cAIResourceSubTypeEasy);
               xsArraySetInt(resourceTypes, 1, cResourceFood);
               xsArraySetInt(resourceSubTypes, 1, cAIResourceSubTypeHunt);
               xsArraySetInt(resourceTypes, 2, cResourceFood);
               xsArraySetInt(resourceSubTypes, 2, cAIResourceSubTypeHerdable);
               xsArraySetInt(resourceTypes, 3, cResourceFood);
               xsArraySetInt(resourceSubTypes, 3, cAIResourceSubTypeFarm);
               xsArraySetInt(resourceTypes, 4, cResourceFood);
               xsArraySetInt(resourceSubTypes, 4, cAIResourceSubTypeFish);
               xsArraySetInt(resourceTypes, 5, cResourceWood);
               xsArraySetInt(resourceSubTypes, 5, cAIResourceSubTypeEasy);
               xsArraySetInt(resourceTypes, 6, cResourceGold);
               xsArraySetInt(resourceSubTypes, 6, cAIResourceSubTypeEasy);
               xsArraySetInt(resourceTypes, 7, cResourceGold);
               xsArraySetInt(resourceSubTypes, 7, cAIResourceSubTypeFarm);
               xsArraySetInt(resourceTypes, 8, cResourceGold);
               xsArraySetInt(resourceSubTypes, 8, cAIResourceSubTypeFish);
            }

            int resourceType = -1;
            int resourceSubType = -1;
            float numResourceGatherers = 0;
            float numGatherers = kbUnitCount(cMyID, cUnitTypeAbstractVillager, cUnitStateAlive);
            for (j = 0; < 9)
            {
               resourceType = xsArrayGetInt(resourceTypes, j);
               resourceSubType = xsArrayGetInt(resourceSubTypes, j);
               numResourceGatherers = aiGetNumberGatherers(cUnitTypeAbstractVillager, resourceType, resourceSubType);
               if (kbTechAffectsWorkRate(tech, resourceType, resourceSubType) == true)
               {
                  if ((numResourceGatherers / numGatherers) >= 0.35)
                     totalValue = totalValue * 2.3;
                  else
                     totalValue = totalValue * 1.1;
                  break;
               }
            }
         }

         // Don't send navy shipments when navy mode isn't active.
         if (((flags & cHCCardFlagTeam) == cHCCardFlagMilitary) && ((flags & cHCCardFlagTeam) == cHCCardFlagWater) &&
             gNavyMode != cNavyModeActive)
            totalValue = 0.1;
         if ((flags & cHCCardFlagTeam) == cHCCardFlagTeam)
            totalValue =
                totalValue *
                (1.0 + 0.1 * getAllyCount()); // Slight prefererence for team cards when we have at least one ally

         // Don't send cards we can't recognize in age1.
         if (((flags & (cHCCardFlagVillager |
         cHCCardFlagResourceCrate |
         cHCCardFlagTrickleGold |
         cHCCardFlagTrickleWood |
         cHCCardFlagTrickleFood |
         cHCCardFlagTrickleXP |
         cHCCardFlagGatherRate)) == 0) &&
          (kbGetAge() == cAge1))
            totalValue = 0.1;

         if ((homeBaseUnderAttack == true) && (isMilitaryUnit == true))
            totalValue = totalValue * 1.5; // Prioritize military units when under attack.
         else if ((isMilitaryUnit == true) && (aiHCDeckGetCardCount(deck, i) >= 0) && (aiTreatyActive() == false))
            totalValue =
                totalValue * 1.1; // Higher preference on limited military unit shipments when fighting is possible.
         else if ((aiHCDeckGetCardCount(deck, i) < 0) && (totalValue >= 200.0) && (gRevolutionType == 0))
         { // Otherwise prefer to get limited shipments before infinite ones.
            totalValue = 2.0 + ageReq;
            if ((flags & cHCCardFlagResourceCrate) == cHCCardFlagResourceCrate)
            { // Prioritize inf resource crates vs inf unit shipments.
               if ((totalResources >= 1600.0) && ((econBias < 1.0) || (totalResources >= 3200.0)))
                  totalValue = totalValue - 3.5;
               else
                  totalValue = totalValue + 3.5;
            }
         }

         aiEcho("    " + i + " " + kbGetProtoUnitName(unitType) + " (" + kbGetTechName(tech) + "): " + qtyAvail +
                " total value: " + totalValue);

         if (totalValue > bestUnitScore)
         {
            bestUnitScore = totalValue;
            bestCard = i;
            bestCardIsExtended = extended;
         }
      }
   }

   if ((agingUp() == true) && (homeBaseUnderAttack == false) && (bestUnitScore <= 450.0))
   { // We're aging up, are not under attack and are not missing any important shipment. Save this shipment for next
     // age.
      aiEcho("We're aging up, delaying this shipment until then.");
      return;
   }

   // Don't send more than 1 cards in age 1 on harder difficulties.
   if (aiGetWorldDifficulty() >= cDifficultyHard)
   {
      static int numberCardsSentDuringAge1 = 0;
      if (kbGetAge() == cAge1)
      {
         if (numberCardsSentDuringAge1 >= 1)
         {
            aiEcho("We only want 1 cards at most during the first age.");
            return;
         }
         numberCardsSentDuringAge1 = numberCardsSentDuringAge1 + 1;
      }
   }

   if (bestCard >= 0)
   {
      // Where to drop shipment.
      if (aiGetWorldDifficulty() >= cDifficultyExpert)
      {
         int gatherUnitID = -1;

         if (bestCardIsExtended == false)
            deck = gDefaultDeck;
         else
            deck = aiHCGetExtendedDeck();
         flags = aiHCDeckGetCardFlags(deck, bestCard);

         isMilitaryUnit = (((flags & cHCCardFlagMilitary) == cHCCardFlagMilitary) &&
                     ((flags & cHCCardFlagUnit) == cHCCardFlagUnit) && ((flags & cHCCardFlagWater) == 0)) ||
                     (kbProtoUnitIsType(cMyID, unitType, cUnitTypeLogicalTypeLandMilitary));

         if (isMilitaryUnit == true)
         {
            planID = aiPlanGetIDByTypeAndVariableType(cPlanAttack, cAttackPlanBaseAttackMode, cAttackPlanBaseAttackModeExplicit);
            if (planID >= 0 && aiPlanGetVariableBool(planID, cAttackPlanAllowMoreUnitsDuringAttack, 0) == true)
            {
               if (cMyCiv == cCivJapanese)
               {
                  int daimyoQuery = createSimpleUnitQuery(cUnitTypeAbstractDaimyo, cMyID, cUnitStateAlive);
                  int numDaimyos = kbUnitQueryExecute(daimyoQuery);
                  for (i = 0; < numDaimyos)
                  {
                     int daimyoID = kbUnitQueryGetResult(daimyoQuery, i);
                     if (kbUnitGetPlanID(daimyoID) != planID)
                        continue;
                     gatherUnitID = daimyoID;
                  }
               }
               if (gatherUnitID < 0 && gForwardBaseID >= 0)
               {
                  gatherUnitID = findBestHCGatherUnit(gForwardBaseID);
               }
            }
         }

         if (gatherUnitID < 0)
            gatherUnitID = findBestHCGatherUnit(kbBaseGetMainID(cMyID));

         aiSetHCGatherUnit(gatherUnitID);
      }

      aiEcho("  Choosing card " + bestCard);
      aiHCDeckPlayCard(bestCard, bestCardIsExtended);
   }
}

//==============================================================================
// extraShipMonitor
// Watches for extra ships...granted in bulk via scenario, or
// due to oversight in shipGrantedHandler()?
//==============================================================================
rule extraShipMonitor
inactive
group tcComplete
minInterval 20
{
   if (kbResourceGet(cResourceShips) > 0)
      shipGrantedHandler(); // Spend the surplus
}

void getHCTech(string name = "", int techID = -1, int pri = 50)
{ // Make a simple plan to research a HC tech.
   int planID = aiPlanCreate(name, cPlanResearch);
   aiPlanSetVariableInt(planID, cResearchPlanTechID, 0, techID);
   aiPlanSetEscrowID(planID, cRootEscrowID);
   aiPlanSetDesiredPriority(planID, pri);
   aiPlanSetActive(planID);
}

//==============================================================================
// ShouldIResign
//==============================================================================
rule ShouldIResign
minInterval 7
active
{
   static bool hadHumanAlly = false;

   if (gSPC == true)
   {
      xsDisableSelf();
      return;
   }

   if (cvOkToResign == false)
   {
      return; // Early out if we're not allowed to think about this.
   }

   // Don't resign if you have a human ally that's still in the game
   int i = 0;
   bool humanAlly = false; // Set true if we have a surviving human ally.
   int humanAllyID = -1;
   bool complained = false;     // Set flag true if I've already whined to my ally.
   bool wasHumanInGame = false; // Set true if any human players were in the game
   bool isHumanInGame = false;  // Set true if a human survives.  If one existed but none survive, resign.

   // Look for humans
   for (i = 1; <= cNumberPlayers)
   {
      if (kbIsPlayerHuman(i) == true)
      {
         wasHumanInGame = true;
         if (kbHasPlayerLost(i) == false)
            isHumanInGame = true;
      }
      if ((kbIsPlayerAlly(i) == true) && (kbHasPlayerLost(i) == false) && (kbIsPlayerHuman(i) == true))
      {
         humanAlly = true;    // Don't return just yet, let's see if we should chat.
         hadHumanAlly = true; // Set flag to indicate that we once had a human ally.
         humanAllyID = i;     // Player ID of lowest-numbered surviving human ally.
      }
   }

   // We do not have to resign when all of our human allies quit, there's still a chance...
   //   if ( (wasHumanInGame == true) && (isHumanInGame == false) )
   /*if ((hadHumanAlly == true) && (humanAlly == false)) // Resign if my human allies have quit.
   {
      //aiResign(); // If there are no humans left, and this wasn't a bot battle from the start, quit.
      aiEcho("Resigning because I had a human ally, and he's gone...");
      aiResign(); // I had a human ally or allies, but do not any more.  Our team loses.
      return;  // Probably not necessary, but whatever...
   }
   // Check for MP with human allies gone.  This trumps the OkToResign setting, below.
   if ((aiIsMultiplayer() == true) && (hadHumanAlly == true) && (humanAlly == false))
   {  // In a multiplayer game...we had a human ally earlier, but none remain.  Resign immediately
      aiEcho("Resign because my human ally is no longer in the game.");
      aiResign();    // Don't ask, just quit.
      xsEnableRule("resignRetry");
      xsDisableSelf();
      return;
   }*/

   // Don't resign too soon.
   if (xsGetTime() < 600000) // 600K = 10 min
      return;

   // Don't resign if we have over 30 active pop slots.
   if (kbGetPop() >= 30)
      return;

   // Resign if the known enemy pop is > 10x mine

   int enemyPopTotal = 0.0;
   int enemyCount = 0;
   int myPopTotal = 0.0;

   for (i = 1; < cNumberPlayers)
   {
      if (kbHasPlayerLost(i) == false)
      {
         if (i == cMyID)
            myPopTotal = myPopTotal + kbUnitCount(i, cUnitTypeUnit, cUnitStateAlive);
         if ((kbIsPlayerEnemy(i) == true) && (kbHasPlayerLost(i) == false))
         {
            enemyPopTotal = enemyPopTotal + kbUnitCount(i, cUnitTypeUnit, cUnitStateAlive);
            enemyCount = enemyCount + 1;
         }
      }
   }

   if (enemyCount < 1)
      enemyCount = 1; // Avoid div 0

   float enemyRatio = (enemyPopTotal / enemyCount) / myPopTotal;

   if (enemyRatio > 10) // My pop is 1/10 the average known pop of enemies
   {
      if (humanAlly == false)
      {
         aiEcho("Resign at 10:1 pop: EP Total(" + enemyPopTotal + "), MP Total(" + myPopTotal + ")");
         aiAttemptResign(cAICommPromptToEnemyMayIResign);
         xsEnableRule("resignRetry");
         xsDisableSelf();
         return;
      }
      if ((humanAlly == true) && (complained == false))
      { // Whine to your partner
         sendStatement(humanAllyID, cAICommPromptToAllyImReadyToQuit);
         xsEnableRule("resignRetry");
         xsDisableSelf();
         complained = true;
      }
   }
   if ((enemyRatio > 4) && (kbUnitCount(cMyID, cUnitTypeTownCenter, cUnitStateAlive) <
                            1)) // My pop is 1/4 the average known pop of enemies, and I have no TC
   {
      if (humanAlly == false)
      {
         aiEcho("Resign with no 4:1 pop and no TC: EP Total(" + enemyPopTotal + "), MP Total(" + myPopTotal + ")");
         // sendStatement(aiGetMostHatedPlayerID(), cAICommPromptAIResignActiveEnemies, -1);
         aiAttemptResign(cAICommPromptToEnemyMayIResign);
         // breakpoint;
         xsEnableRule("resignRetry");
         xsDisableSelf();
         return;
      }
   }
}

rule resignRetry
inactive
minInterval 240
{
   xsEnableRule("ShouldIResign");
   xsDisableSelf();
}

//==============================================================================
// resignHandler
//==============================================================================
void resignHandler(int result = -1)
{
   aiEcho("***************** Resign handler running with result " + result);
   if (result == 0)
   {

      xsEnableRule("resignRetry");
      return;
   }
   aiEcho("Resign handler returned " + result);

   aiResign();
   return;
}

int createTechProgression(int techID = -1, int escrowID = -1, int pri = 50)
{
   int planID = -1;
   if ((techID < 0) || (escrowID < 0))
      return (-1);

   planID = aiPlanCreate("Tech Progression " + techID, cPlanProgression);
   if (planID < 0)
      return (-1);

   aiPlanSetVariableInt(planID, cProgressionPlanGoalTechID, 0, techID);
   aiPlanSetDesiredPriority(planID, pri);
   aiPlanSetEscrowID(planID, escrowID);
   aiPlanSetBaseID(planID, kbBaseGetMainID(cMyID));
   aiPlanSetActive(planID);

   return (planID);
}

rule bigTechManager
group tcComplete
inactive
minInterval 120
{
   if (civIsNative() == false)
   {
      xsDisableSelf();
      return;
   }
   if ((xsGetTime() < 18 * 60 * 1000) &&
       ((kbGetAge() <= cAge1) || (kbUnitCount(cMyID, gEconUnit, cUnitStateAlive) < 20)))
      return; // Avoid getting researches here with a weak economy.

   if (kbUnitCount(cMyID, cUnitTypeTownCenter, cUnitStateAlive) < 1)
      return;

   int bigTechPlanID = -1;
   int armySize = aiPlanGetNumberUnits(gLandDefendPlan0, cUnitTypeLogicalTypeLandMilitary) +
                  aiPlanGetNumberUnits(gLandReservePlan, cUnitTypeLogicalTypeLandMilitary);

   if (cMyCiv == cCivXPAztec)
   {
      if (xsGetTime() < 30 * 60 * 1000)
      {
         if ((kbTechGetStatus(cTechBigAztecScoutingParty) == cTechStatusObtainable) &&
             (kbUnitCount(cMyID, cUnitTypeTownCenter, cUnitStateAlive) >= 1) &&
             ((armySize <= 1) || (agingUp() == true) || (kbGetAge() >= cAge3) ||
              (kbResourceGet(cResourceFood) >= 1800.0)) &&
             (kbGetAge() >= cAge2))
         {
            if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechBigAztecScoutingParty) >= 0)
               return;
            bigTechPlanID = createSimpleResearchPlan(cTechBigAztecScoutingParty, -1, cMilitaryEscrowID, 60);
            aiPlanSetDesiredResourcePriority(bigTechPlanID, 40);
         }
         if ((kbTechGetStatus(cTechBigAztecRaidingParty) == cTechStatusObtainable) &&
             (kbUnitCount(cMyID, cUnitTypeTownCenter, cUnitStateAlive) >= 1) && (kbGetAge() >= cAge3))
         {
            if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechBigAztecRaidingParty) >= 0)
               return;
            bigTechPlanID = createSimpleResearchPlan(cTechBigAztecRaidingParty, -1, cMilitaryEscrowID, 60);
            aiPlanSetDesiredResourcePriority(bigTechPlanID, 40);
         }
         if ((kbTechGetStatus(cTechBigAztecWarParty) == cTechStatusObtainable) &&
             (kbUnitCount(cMyID, cUnitTypeTownCenter, cUnitStateAlive) >= 1) && (kbGetAge() >= cAge3))
         {
            if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechBigAztecWarParty) >= 0)
               return;
            bigTechPlanID = createSimpleResearchPlan(cTechBigAztecWarParty, -1, cMilitaryEscrowID, 60);
            aiPlanSetDesiredResourcePriority(bigTechPlanID, 40);
         }
      }
      else
      {
         if ((kbTechGetStatus(cTechBigWarHutBarometz) == cTechStatusObtainable) &&
             (kbUnitCount(cMyID, cUnitTypeWarHut, cUnitStateAlive) >= 1) && (kbGetAge() >= cAge2))
         {
            if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechBigWarHutBarometz) >= 0)
               return;
            createSimpleResearchPlan(cTechBigWarHutBarometz, -1, cMilitaryEscrowID, 60);
         }
         if ((kbTechGetStatus(cTechBigFarmCinteotl) == cTechStatusObtainable) &&
             (kbUnitCount(cMyID, cUnitTypeFarm, cUnitStateAlive) >= 1) && (kbGetAge() >= cAge3))
         {
            if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechBigFarmCinteotl) >= 0)
               return;
            createSimpleResearchPlan(cTechBigFarmCinteotl, -1, cMilitaryEscrowID, 60);
         }
         if ((kbTechGetStatus(cTechBigHouseCoatlicue) == cTechStatusObtainable) &&
             (kbUnitCount(cMyID, cUnitTypeHouse, cUnitStateAlive) >= 1) && (kbGetAge() >= cAge2))
         {
            if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechBigHouseCoatlicue) >= 0)
               return;
            createSimpleResearchPlan(cTechBigHouseCoatlicue, -1, cMilitaryEscrowID, 60);
         }
         if ((kbTechGetStatus(cTechBigNoblesHutWarSong) == cTechStatusObtainable) &&
             (kbUnitCount(cMyID, cUnitTypeNoblesHut, cUnitStateAlive) >= 1) && (kbGetAge() >= cAge3))
         {
            if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechBigNoblesHutWarSong) >= 0)
               return;
            createSimpleResearchPlan(cTechBigNoblesHutWarSong, -1, cMilitaryEscrowID, 60);
         }
      }
      if (xsGetTime() >= 28 * 60 * 1000)
      {
         if ((kbTechGetStatus(cTechBigPlantationTezcatlipoca) == cTechStatusObtainable) &&
             (kbUnitCount(cMyID, cUnitTypePlantation, cUnitStateAlive) >= 1) && (kbGetAge() >= cAge3))
         {
            if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechBigPlantationTezcatlipoca) >=
                0)
               return;
            createSimpleResearchPlan(cTechBigPlantationTezcatlipoca, -1, cMilitaryEscrowID, 60);
         }
      }
      if ((kbTechGetStatus(cTechBigFirepitFounder) == cTechStatusObtainable) &&
          (kbUnitCount(cMyID, cUnitTypeCommunityPlaza, cUnitStateAlive) >= 1))
      {
         if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechBigFirepitFounder) >= 0)
            return;
         createSimpleResearchPlan(cTechBigFirepitFounder, -1, cMilitaryEscrowID, 60);
      }
      if (gNavyMap == true)
      {
         if ((kbTechGetStatus(cTechBigDockCipactli) == cTechStatusObtainable) &&
             (kbUnitCount(cMyID, cUnitTypeDock, cUnitStateAlive) >= 1) && (kbGetAge() >= cAge3))
         {
            if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechBigDockCipactli) >= 0)
               return;
            createSimpleResearchPlan(cTechBigDockCipactli, -1, cMilitaryEscrowID, 60);
         }
      }
   }
   else if (cMyCiv == cCivXPIroquois)
   {
      if (xsGetTime() < 30 * 60 * 1000)
      {
         if ((kbTechGetStatus(cTechBigIroquoisScoutingParty) == cTechStatusObtainable) &&
             (kbUnitCount(cMyID, cUnitTypeTownCenter, cUnitStateAlive) >= 1) &&
             ((armySize <= 1) || (agingUp() == true) || (kbGetAge() >= cAge3) ||
              (kbResourceGet(cResourceFood) >= 1800.0)) &&
             (kbGetAge() >= cAge2))
         {
            if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechBigIroquoisScoutingParty) >=
                0)
               return;
            bigTechPlanID = createSimpleResearchPlan(cTechBigIroquoisScoutingParty, -1, cMilitaryEscrowID, 60);
            aiPlanSetDesiredResourcePriority(bigTechPlanID, 40);
         }
         if ((kbTechGetStatus(cTechBigIroquoisRaidingParty) == cTechStatusObtainable) &&
             (kbUnitCount(cMyID, cUnitTypeTownCenter, cUnitStateAlive) >= 1) && (kbGetAge() >= cAge3))
         {
            if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechBigIroquoisRaidingParty) >= 0)
               return;
            bigTechPlanID = createSimpleResearchPlan(cTechBigIroquoisRaidingParty, -1, cMilitaryEscrowID, 60);
            aiPlanSetDesiredResourcePriority(bigTechPlanID, 40);
         }
         if ((kbTechGetStatus(cTechBigIroquoisWarParty) == cTechStatusObtainable) &&
             (kbUnitCount(cMyID, cUnitTypeTownCenter, cUnitStateAlive) >= 1) && (kbGetAge() >= cAge3))
         {
            if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechBigIroquoisWarParty) >= 0)
               return;
            bigTechPlanID = createSimpleResearchPlan(cTechBigIroquoisWarParty, -1, cMilitaryEscrowID, 60);
            aiPlanSetDesiredResourcePriority(bigTechPlanID, 40);
         }
      }
      else
      {
         if ((kbTechGetStatus(cTechBigFarmStrawberry) == cTechStatusObtainable) &&
             (kbUnitCount(cMyID, cUnitTypeFarm, cUnitStateAlive) >= 1))
         {
            if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechBigFarmStrawberry) >= 0)
               return;
            createSimpleResearchPlan(cTechBigFarmStrawberry, -1, cEconomyEscrowID, 60);
         }
         if ((kbTechGetStatus(cTechBigPlantationMapleFestival) == cTechStatusObtainable) &&
             (kbUnitCount(cMyID, cUnitTypePlantation, cUnitStateAlive) >= 1) && (kbGetAge() >= cAge3))
         {
            if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechBigPlantationMapleFestival) >=
                0)
               return;
            createSimpleResearchPlan(cTechBigPlantationMapleFestival, -1, cEconomyEscrowID, 60);
         }
         if ((kbTechGetStatus(cTechBigLonghouseWoodlandDwellers) == cTechStatusObtainable) &&
             (kbUnitCount(cMyID, cUnitTypeLonghouse, cUnitStateAlive) >= 1))
         {
            if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID,
                                                 cTechBigLonghouseWoodlandDwellers) >= 0)
               return;
            createSimpleResearchPlan(cTechBigLonghouseWoodlandDwellers, -1, cEconomyEscrowID, 60);
         }
      }
      if ((kbTechGetStatus(cTechBigWarHutLacrosse) == cTechStatusObtainable) &&
          (kbUnitCount(cMyID, cUnitTypeWarHut, cUnitStateAlive) >= 1) && (kbGetAge() >= cAge2))
      {
         if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechBigWarHutLacrosse) >= 0)
            return;
         createSimpleResearchPlan(cTechBigWarHutLacrosse, -1, cMilitaryEscrowID, 60);
      }
      if ((kbTechGetStatus(cTechBigSiegeshopSiegeDrill) == cTechStatusObtainable) &&
          (kbUnitCount(cMyID, cUnitTypeArtilleryDepot, cUnitStateAlive) >= 1))
      {
         if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechBigSiegeshopSiegeDrill) >= 0)
            return;
         createSimpleResearchPlan(cTechBigSiegeshopSiegeDrill, -1, cMilitaryEscrowID, 60);
      }
      if ((kbTechGetStatus(cTechBigCorralHorseSecrets) == cTechStatusObtainable) &&
          (kbUnitCount(cMyID, cUnitTypeCorral, cUnitStateAlive) >= 1))
      {
         if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechBigCorralHorseSecrets) >= 0)
            return;
         createSimpleResearchPlan(cTechBigCorralHorseSecrets, -1, cMilitaryEscrowID, 60);
      }
      if ((kbTechGetStatus(cTechBigFirepitSecretSociety) == cTechStatusObtainable) &&
          (kbUnitCount(cMyID, cUnitTypeCommunityPlaza, cUnitStateAlive) >= 1))
      {
         if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechBigFirepitSecretSociety) >= 0)
            return;
         createSimpleResearchPlan(cTechBigFirepitSecretSociety, -1, cMilitaryEscrowID, 60);
      }
      if (gNavyMap == true)
      {
         if ((kbTechGetStatus(cTechBigDockRawhideCovers) == cTechStatusObtainable) &&
             (kbUnitCount(cMyID, cUnitTypeDock, cUnitStateAlive) >= 1) &&
             (kbUnitCount(cMyID, cUnitTypeLogicalTypeNavalMilitary, cUnitStateAlive) >= 3) && (kbGetAge() >= cAge2))
         {
            if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechBigDockRawhideCovers) >= 0)
               return;
            createSimpleResearchPlan(cTechBigDockRawhideCovers, -1, cMilitaryEscrowID, 60);
         }
      }
   }
   else if (cMyCiv == cCivXPSioux)
   {
      if (xsGetTime() >= 30 * 60 * 1000)
      {
         if ((kbTechGetStatus(cTechBigSiouxDogSoldiers) == cTechStatusObtainable) &&
             (kbUnitCount(cMyID, cUnitTypeTownCenter, cUnitStateAlive) >= 1) && (kbGetAge() >= cAge2))
         {
            if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechBigSiouxDogSoldiers) >= 0)
               return;
            createSimpleResearchPlan(cTechBigSiouxDogSoldiers, -1, cMilitaryEscrowID, 60);
         }
      }
      if ((kbTechGetStatus(cTechBigPlantationGunTrade) == cTechStatusObtainable) &&
          (kbUnitCount(cMyID, cUnitTypePlantation, cUnitStateAlive) >= 1) && (kbGetAge() >= cAge3))
      {
         if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechBigPlantationGunTrade) >= 0)
            return;
         createSimpleResearchPlan(cTechBigPlantationGunTrade, -1, cMilitaryEscrowID, 60);
      }
      if ((kbTechGetStatus(cTechBigFarmHorsemanship) == cTechStatusObtainable) &&
          (kbUnitCount(cMyID, cUnitTypeFarm, cUnitStateAlive) >= 1) &&
          (kbUnitCount(cMyID, cUnitTypeCorral, cUnitStateAlive) >= 1))
      {
         if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechBigFarmHorsemanship) >= 0)
            return;
         createSimpleResearchPlan(cTechBigFarmHorsemanship, -1, cMilitaryEscrowID, 60);
      }
      if ((kbTechGetStatus(cTechBigCorralBonepipeArmor) == cTechStatusObtainable) &&
          (kbUnitCount(cMyID, cUnitTypeCorral, cUnitStateAlive) >= 1) && (kbGetAge() >= cAge2))
      {
         if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechBigCorralBonepipeArmor) >= 0)
            return;
         createSimpleResearchPlan(cTechBigCorralBonepipeArmor, -1, cMilitaryEscrowID, 60);
      }
      if ((kbTechGetStatus(cTechBigWarHutWarDrums) == cTechStatusObtainable) &&
          (kbUnitCount(cMyID, cUnitTypeWarHut, cUnitStateAlive) >= 1) && (kbGetAge() >= cAge2))
      {
         if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechBigWarHutWarDrums) >= 0)
            return;
         createSimpleResearchPlan(cTechBigWarHutWarDrums, -1, cMilitaryEscrowID, 60);
      }
      if (gNavyMap == true)
      {
         if ((kbTechGetStatus(cTechBigDockFlamingArrows) == cTechStatusObtainable) &&
             (kbUnitCount(cMyID, cUnitTypeDock, cUnitStateAlive) >= 1) &&
             (kbUnitCount(cMyID, cUnitTypeLogicalTypeNavalMilitary, cUnitStateAlive) >= 3) && (kbGetAge() >= cAge2))
         {
            if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechBigDockFlamingArrows) >= 0)
               return;
            createSimpleResearchPlan(cTechBigDockFlamingArrows, -1, cMilitaryEscrowID, 60);
         }
      }
   }
   else if (cMyCiv == cCivDEInca)
   {
      if (xsGetTime() < 30 * 60 * 1000)
      {
         if ((kbTechGetStatus(cTechdeBigIncaScoutingParty) == cTechStatusObtainable) &&
             (kbUnitCount(cMyID, cUnitTypeTownCenter, cUnitStateAlive) >= 1) &&
             ((armySize <= 1) || (agingUp() == true) || (kbGetAge() >= cAge3) ||
              (kbResourceGet(cResourceFood) >= 1800.0)) &&
             (kbGetAge() >= cAge2))
         {
            if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechdeBigIncaScoutingParty) >= 0)
               return;
            bigTechPlanID = createSimpleResearchPlan(cTechdeBigIncaScoutingParty, -1, cMilitaryEscrowID, 60);
            aiPlanSetDesiredResourcePriority(bigTechPlanID, 40);
         }
         if ((kbTechGetStatus(cTechdeBigIncaRaidingParty) == cTechStatusObtainable) &&
             (kbUnitCount(cMyID, cUnitTypeTownCenter, cUnitStateAlive) >= 1) && (kbGetAge() >= cAge3))
         {
            if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechdeBigIncaRaidingParty) >= 0)
               return;
            bigTechPlanID = createSimpleResearchPlan(cTechdeBigIncaRaidingParty, -1, cMilitaryEscrowID, 60);
            aiPlanSetDesiredResourcePriority(bigTechPlanID, 40);
         }
         if ((kbTechGetStatus(cTechdeBigIncaWarParty) == cTechStatusObtainable) &&
             (kbUnitCount(cMyID, cUnitTypeTownCenter, cUnitStateAlive) >= 1) && (kbGetAge() >= cAge4))
         {
            if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechdeBigIncaWarParty) >= 0)
               return;
            bigTechPlanID = createSimpleResearchPlan(cTechdeBigIncaWarParty, -1, cMilitaryEscrowID, 60);
            aiPlanSetDesiredResourcePriority(bigTechPlanID, 40);
         }
      }
      else
      {
         if ((kbTechGetStatus(cTechdeBigFirePitRoyalFestival) == cTechStatusObtainable) &&
             (kbUnitCount(cMyID, cUnitTypeCommunityPlaza, cUnitStateAlive) >= 1) && (kbGetAge() >= cAge3))
         {
            if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechdeBigFirePitRoyalFestival) >=
                0)
               return;
            createSimpleResearchPlan(cTechdeBigFirePitRoyalFestival, -1, cEconomyEscrowID, 60);
         }
         if ((kbTechGetStatus(cTechdeBigFarmUrcuchillay) == cTechStatusObtainable) &&
             (kbUnitCount(cMyID, cUnitTypeFarm, cUnitStateAlive) >= 1))
         {
            if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechdeBigFarmUrcuchillay) >= 0)
               return;
            createSimpleResearchPlan(cTechdeBigFarmUrcuchillay, -1, cEconomyEscrowID, 60);
         }
      }
      if ((kbTechGetStatus(cTechdeBigHouseQueensFestival) == cTechStatusObtainable) &&
          (kbUnitCount(cMyID, cUnitTypeHouse, cUnitStateAlive) >= 1) && (kbGetAge() >= cAge2))
      {
         if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechdeBigHouseQueensFestival) >= 0)
            return;
         createSimpleResearchPlan(cTechdeBigHouseQueensFestival, -1, cEconomyEscrowID, 60);
      }
      if ((kbTechGetStatus(cTechdeBigKallankaViracocha) == cTechStatusObtainable) &&
          (kbUnitCount(cMyID, cUnitTypedeKallanka, cUnitStateAlive) >= 1) && (kbGetAge() >= cAge4))
      {
         if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechdeBigKallankaViracocha) >= 0)
            return;
         createSimpleResearchPlan(cTechdeBigKallankaViracocha, -1, cEconomyEscrowID, 60);
      }
      if ((kbTechGetStatus(cTechdeBigPlantationCoca) == cTechStatusObtainable) &&
          (kbUnitCount(cMyID, cUnitTypePlantation, cUnitStateAlive) >= 1) && (kbGetAge() >= cAge4))
      {
         if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechdeBigPlantationCoca) >= 0)
            return;
         createSimpleResearchPlan(cTechdeBigPlantationCoca, -1, cEconomyEscrowID, 60);
      }
      if ((kbTechGetStatus(cTechdeBigMarketIntiFestival) == cTechStatusObtainable) &&
          (kbUnitCount(cMyID, cUnitTypeMarket, cUnitStateAlive) >= 1) && (kbResourceGet(cResourceShips) < 1.0) &&
          ((kbResourceGet(cResourceGold) >= 2000) || (kbGetAge() >= cAge4)))
      {
         if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechdeBigMarketIntiFestival) >= 0)
            return;
         createSimpleResearchPlan(cTechdeBigMarketIntiFestival, -1, cMilitaryEscrowID, 60);
      }
      if ((kbTechGetStatus(cTechdeBigWarHutHualcana) == cTechStatusObtainable) &&
          (kbUnitCount(cMyID, cUnitTypeWarHut, cUnitStateAlive) >= 1) && (kbGetAge() >= cAge3))
      {
         if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechdeBigWarHutHualcana) >= 0)
            return;
         createSimpleResearchPlan(cTechdeBigWarHutHualcana, -1, cMilitaryEscrowID, 60);
      }
      if ((kbTechGetStatus(cTechdeBigStrongholdThunderbolts) == cTechStatusObtainable) &&
          (kbUnitCount(cMyID, cUnitTypedeIncaStronghold, cUnitStateAlive) >= 1))
      {
         if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechdeBigStrongholdThunderbolts) >=
             0)
            return;
         createSimpleResearchPlan(cTechdeBigStrongholdThunderbolts, -1, cMilitaryEscrowID, 60);
      }
      if (gNavyMap == true)
      {
         if ((kbTechGetStatus(cTechdeBigDockTotora) == cTechStatusObtainable) &&
             (kbUnitCount(cMyID, cUnitTypeDock, cUnitStateAlive) >= 1) && (xsGetTime() >= 16 * 60 * 1000))
         {
            if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechdeBigDockTotora) >= 0)
               return;
            createSimpleResearchPlan(cTechdeBigDockTotora, -1, cEconomyEscrowID, 60);
         }
      }
   }
}

//==============================================================================
// rule lateInAge
//==============================================================================
extern int gLateInAgePlayerID = -1;
extern int gLateInAgeAge = -1;
rule lateInAge
minInterval 120
inactive
{
   // This rule is used to taunt a player who is behind in the age race, but only if
   // he is still in the previous age some time (see minInterval) after the other
   // players have all advanced.  Before activating this rule, the calling function
   // (ageUpHandler) must set the global variables for playerID and age,
   // gLateInAgePlayerID and gLateInAgeAge.  When the rule finally fires minInterval
   // seconds later, it checks to see if that player is still behind, and taunts accordingly.
   if (gLateInAgePlayerID < 0)
      return;

   if (kbGetAgeForPlayer(gLateInAgePlayerID) == gLateInAgeAge)
   {
      if (gLateInAgeAge == cAge1)
      {
         if ((kbIsPlayerAlly(gLateInAgePlayerID) == true) && (gLateInAgePlayerID != cMyID))
            sendStatement(gLateInAgePlayerID, cAICommPromptToAllyHeIsAge1Late);
         if ((kbIsPlayerEnemy(gLateInAgePlayerID) == true))
            sendStatement(gLateInAgePlayerID, cAICommPromptToEnemyHeIsAge1Late);
      }
      else
      {
         if ((kbIsPlayerAlly(gLateInAgePlayerID) == true) && (gLateInAgePlayerID != cMyID))
            sendStatement(gLateInAgePlayerID, cAICommPromptToAllyHeIsStillAgeBehind);
         if ((kbIsPlayerEnemy(gLateInAgePlayerID) == true))
            sendStatement(gLateInAgePlayerID, cAICommPromptToEnemyHeIsStillAgeBehind);
      }
   }
   gLateInAgePlayerID = -1;
   gLateInAgeAge = -1;
   xsDisableSelf();
}

//==============================================================================
// ageUpHandler
//==============================================================================
void ageUpHandler(int playerID = -1)
{
   int age = kbGetAgeForPlayer(playerID);
   bool firstToAge = true; // Set true if this player is the first to reach that age, false otherwise
   bool lastToAge = true;  // Set true if this player is the last to reach this age, false otherwise
   int index = 0;
   int slowestPlayer = -1;
   int lowestAge = 100000;
   int lowestCount = 0; // How many players are still in the lowest age?
	
	if (playerID == cMyID)
		aiPopulatePoliticianList(); // Update the list of possible age-up choices we have now.
   // aiEcho("AGE HANDLER:  Player "+playerID+" is now in age "+age);

   for (index = 1; < cNumberPlayers)
   {
      if (index != playerID)
      {
         // See if this player is already at the age playerID just reached.
         if (kbGetAgeForPlayer(index) >= age)
            firstToAge = false; // playerID isn't the first
         if (kbGetAgeForPlayer(index) < age)
            lastToAge = false; // Someone is still behind playerID.
      }
      if (kbGetAgeForPlayer(index) < lowestAge)
      {
         lowestAge = kbGetAgeForPlayer(index);
         slowestPlayer = index;
         lowestCount = 1;
      }
      else
      {
         if (kbGetAgeForPlayer(index) == lowestAge)
            lowestCount = lowestCount + 1;
      }
   }

   if ((firstToAge == true) && (age == cAge2))
   { // This player was first to age 2
      if ((kbIsPlayerAlly(playerID) == true) && (playerID != cMyID))
         sendStatement(playerID, cAICommPromptToAllyHeReachesAge2First);
      if ((kbIsPlayerEnemy(playerID) == true))
         sendStatement(playerID, cAICommPromptToEnemyHeReachesAge2First);
      return ();
   }
   if ((lastToAge == true) && (age == cAge2))
   { // This player was last to age 2
      if ((kbIsPlayerAlly(playerID) == true) && (playerID != cMyID))
         sendStatement(playerID, cAICommPromptToAllyHeReachesAge2Last);
      if ((kbIsPlayerEnemy(playerID) == true))
         sendStatement(playerID, cAICommPromptToEnemyHeReachesAge2Last);
      return ();
   }

   // Check to see if there is a lone player that is behind everyone else
   if ((lowestCount == 1) && (slowestPlayer != cMyID))
   {
      // This player is slowest, nobody else is still in that age, and it's not me,
      // so set the globals and activate the rule...unless it's already active.
      // This will cause a chat to fire later (currently 120 sec mininterval) if
      // this player is still lagging technologically.
      if (gLateInAgePlayerID < 0)
      {
         if (xsIsRuleEnabled("lateInAge") == false)
         {
            gLateInAgePlayerID = slowestPlayer;
            gLateInAgeAge = lowestAge;
            xsEnableRule("lateInAge");
            return ();
         }
      }
   }

   // Check to see if ally advanced before me
   if ((kbIsPlayerAlly(playerID) == true) && (age > kbGetAgeForPlayer(cMyID)))
   {
      sendStatement(playerID, cAICommPromptToAllyHeAdvancesAhead);
      return ();
   }

   // Check to see if ally advanced before me
   if ((kbIsPlayerEnemy(playerID) == true) && (age > kbGetAgeForPlayer(cMyID)))
   {
      sendStatement(playerID, cAICommPromptToEnemyHeAdvancesAhead);
      return ();
   }
}

/*
   getNuggetChatID()

   Called from the nugget event handler.  Given the player ID, determine what
   type of nugget was just claimed, and return a specific appropriate chat ID, if any.

   If none apply, return the general 'got nugget' chat ID.
*/
int getNuggetChatID(int playerID = -1)
{
   int retVal = cAICommPromptToEnemyWhenHeGathersNugget;
   int type = aiGetLastCollectedNuggetType(playerID);
   int effect = aiGetLastCollectedNuggetEffect(playerID);

   switch (type)
   {
   case cNuggetTypeAdjustResource:
   {
      switch (effect)
      {
      case cResourceGold:
      {
         retVal = cAICommPromptToEnemyWhenHeGathersNuggetCoin;
         break;
      }
      case cResourceFood:
      {
         retVal = cAICommPromptToEnemyWhenHeGathersNuggetFood;
         break;
      }
      case cResourceWood:
      {
         retVal = cAICommPromptToEnemyWhenHeGathersNuggetWood;
         break;
      }
      }
      break;
   }
   case cNuggetTypeSpawnUnit:
   {
      if ((effect == cUnitTypeNatMedicineMan) || (effect == cUnitTypeNatClubman) || (effect == cUnitTypeNatRifleman) ||
          (effect == cUnitTypeNatHuaminca) || (effect == cUnitTypeNatTomahawk) || (effect == cUnitTypeNativeScout) ||
          (effect == cUnitTypeNatEagleWarrior))
      {
         retVal = cAICommPromptToEnemyWhenHeGathersNuggetNatives;
      }
      if ((effect == cUnitTypeSettler) || (effect == cUnitTypeCoureur) || (effect == cUnitTypeSettlerNative) ||
          (effect == cUnitTypeypSettlerAsian) || (effect == cUnitTypeypSettlerIndian))
         retVal = cAICommPromptToEnemyWhenHeGathersNuggetSettlers;
      break;
   }
   case cNuggetTypeGiveLOS:
   {
      break;
   }
   case cNuggetTypeAdjustSpeed:
   {
      break;
   }
   case cNuggetTypeAdjustHP:
   {
      break;
   }
   case cNuggetTypeConvertUnit:
   {
      if ((effect == cUnitTypeNatMedicineMan) || (effect == cUnitTypeNatClubman) || (effect == cUnitTypeNatRifleman) ||
          (effect == cUnitTypeNatHuaminca) || (effect == cUnitTypeNatTomahawk) || (effect == cUnitTypeNativeScout) ||
          (effect == cUnitTypeNatEagleWarrior))
      {
         retVal = cAICommPromptToEnemyWhenHeGathersNuggetNatives;
      }
      if ((effect == cUnitTypeSettler) || (effect == cUnitTypeCoureur) || (effect == cUnitTypeSettlerNative) ||
          (effect == cUnitTypeypSettlerAsian) || (effect == cUnitTypeypSettlerIndian))
         retVal = cAICommPromptToEnemyWhenHeGathersNuggetSettlers;
      break;
   }
   }

   return (retVal);
}

//==============================================================================
// nuggetHandler
//==============================================================================
void nuggetHandler(int playerID = -1)
{
   if (kbGetAge() > cAge2)
      return; // Do not send these chats (or even bother keeping count) after age 2 ends.
   // aiEcho("***************** Nugget handler running with playerID"+playerID);
   static int nuggetCounts = -1; // Array handle.  nuggetCounts[i] will track how many nuggets each player has claimed
   static int totalNuggets = 0;
   const int cNuggetRange = 100; // Nuggets within this many meters of a TC are "owned".
   int defaultChatID = getNuggetChatID(playerID);

   if ((playerID < 1) || (playerID > cNumberPlayers))
      return;

   // Initialize the array if we haven't done this before.
   if (nuggetCounts < 0)
   {
      nuggetCounts = xsArrayCreateInt(cNumberPlayers, 0, "Nugget Counts");
   }

   // Score this nugget
   totalNuggets = totalNuggets + 1;
   xsArraySetInt(nuggetCounts, playerID, xsArrayGetInt(nuggetCounts, playerID) + 1);

   // Check to see if one of the special-case chats might be appropriate.
   // If so, use it, otherwise, fall through to the generic ones.
   // First, some bookkeeping
   int i = 0;
   int count = 0;
   int lowestPlayer = -1;
   int lowestCount = 100000; // Insanely high start value, first pass will reset it.
   int totalCount = 0;
   int averageCount = 0;
   int highestPlayer = -1;
   int highestCount = 0;
   for (i = 1; < cNumberPlayers)
   {
      count = xsArrayGetInt(nuggetCounts, i, ); // How many nuggets has player i gathered?
      if (count < lowestCount)
      {
         lowestCount = count;
         lowestPlayer = i;
      }
      if (count > highestCount)
      {
         highestCount = count;
         highestPlayer = i;
      }
      totalCount = totalCount + count;
   }
   averageCount = totalCount / (cNumberPlayers - 1);

   if (totalCount == 1) // This is the first nugget in the game
   {
      if (playerID != cMyID)
      {
         if (kbIsPlayerAlly(playerID) == true)
         {
            sendStatement(playerID, cAICommPromptToAllyWhenHeGathersFirstNugget);
            return;
         }
         else
         {
            sendStatement(playerID, cAICommPromptToEnemyWhenHeGathersFirstNugget);
            return;
         }
      }
   }

   int playersCount = 0;
   int myCount = 0;
   myCount = xsArrayGetInt(nuggetCounts, cMyID);
   playersCount = xsArrayGetInt(nuggetCounts, playerID);
   // Check if this player is way ahead of me, i.e. 2x my total and ahead by at least 2
   if (((playersCount - myCount) >= 2) && (playersCount >= (myCount * 2)))
   {
      if (kbIsPlayerAlly(playerID) == true)
      {
         sendStatement(playerID, cAICommPromptToAllyWhenHeGathersNuggetHeIsAhead);
         return;
      }
      else
      {
         sendStatement(playerID, cAICommPromptToEnemyWhenHeGathersNuggetHeIsAhead);
         return;
      }
   }

   // Check if I'm way ahead of any other players
   int player = 0; // Loop counter...who might I send a message to
   bool messageSent = false;
   if (playerID == cMyID)
   {
      for (player = 1; < cNumberPlayers)
      {
         playersCount = xsArrayGetInt(nuggetCounts, player);
         if (((myCount - playersCount) >= 2) && (myCount >= (playersCount * 2)))
         {
            if (kbIsPlayerAlly(player) == true)
            {
               sendStatement(player, cAICommPromptToAllyWhenIGatherNuggetIAmAhead);
               messageSent = true;
            }
            else
            {
               sendStatement(player, cAICommPromptToEnemyWhenIGatherNuggetIAmAhead);
               messageSent = true;
            }
         }
      }
   }
   if (messageSent == true)
      return;

   // Check to see if the nugget was gathered near a main base.
   // For now, check playerID's explorer location, assume nugget was gathered there.
   // Later, we may add location info to the event handler.
   vector explorerPos = cInvalidVector;
   int explorerID = -1;
   int tcID = -1;

   explorerID = getUnit(cUnitTypeExplorer, playerID, cUnitStateAlive);
   if (explorerID >= 0) // We know of an explorer for this player
   {
      if (kbUnitVisible(explorerID) == true)
      { // And we can see him.
         explorerPos = kbUnitGetPosition(explorerID);
         if (playerID == cMyID)
         { // I gathered the nugget
            // Get nearest ally TC distance
            tcID =
                getUnitByLocation(cUnitTypeTownCenter, cPlayerRelationAlly, cUnitStateAlive, explorerPos, cNuggetRange);
            if ((tcID > 0) && (kbUnitGetPlayerID(tcID) != cMyID))
            { // A TC is near, owned by an ally, and it's not mine...
               sendStatement(kbUnitGetPlayerID(tcID),
                             cAICommPromptToAllyWhenIGatherNuggetHisBase); // I got a nugget near his TC
               return;
            }
            // Get nearest enemy TC distance
            tcID = getUnitByLocation(cUnitTypeTownCenter, cPlayerRelationEnemy, cUnitStateAlive, explorerPos,
                                     cNuggetRange);
            if (tcID > 0)
            { // A TC is near, owned by an enemy...
               sendStatement(kbUnitGetPlayerID(tcID),
                             cAICommPromptToEnemyWhenIGatherNuggetHisBase); // I got a nugget near his TC
               return;
            }
         }
         else
         {
            if (kbIsPlayerAlly(playerID) == true)
            { // An ally has found a nugget, see if it's close to my TC
               tcID = getUnitByLocation(cUnitTypeTownCenter, cMyID, cUnitStateAlive, explorerPos, cNuggetRange);
               if (tcID > 0)
               {                                                                         // That jerk took my nugget!
                  sendStatement(playerID, cAICommPromptToAllyWhenHeGathersNuggetMyBase); // He got one in my zone
                  return;
               }
            }
            else
            { // An enemy has found a nugget, see if it's in my zone
               tcID = getUnitByLocation(cUnitTypeTownCenter, cMyID, cUnitStateAlive, explorerPos, cNuggetRange);
               if (tcID > 0)
               {                                                                          // That jerk took my nugget!
                  sendStatement(playerID, cAICommPromptToEnemyWhenHeGathersNuggetMyBase); // He got one in my zone
                  return;
               }
            }
         } // if me else
      }    // If explorer is visible to me
   }       // If explorer known

   // No special events fired, so go with generic messages
   // defaultChatID has the appropriate chat if an enemy gathered the nugget...send it.
   // Otherwise, convert to the appropriate case.
   if (playerID != cMyID)
   {
      if (kbIsPlayerEnemy(playerID) == true)
      {
         sendStatement(playerID, defaultChatID);
      }
      else
      { // Find out what was returned, send the equivalent ally version
         switch (defaultChatID)
         {
         case cAICommPromptToEnemyWhenHeGathersNugget:
         {
            sendStatement(playerID, cAICommPromptToAllyWhenHeGathersNugget);
            break;
         }
         case cAICommPromptToEnemyWhenHeGathersNuggetCoin:
         {
            sendStatement(playerID, cAICommPromptToAllyWhenHeGathersNuggetCoin);
            break;
         }
         case cAICommPromptToEnemyWhenHeGathersNuggetFood:
         {
            sendStatement(playerID, cAICommPromptToAllyWhenHeGathersNuggetFood);
            break;
         }
         case cAICommPromptToEnemyWhenHeGathersNuggetWood:
         {
            sendStatement(playerID, cAICommPromptToAllyWhenHeGathersNuggetWood);
            break;
         }
         case cAICommPromptToEnemyWhenHeGathersNuggetNatives:
         {
            sendStatement(playerID, cAICommPromptToAllyWhenHeGathersNuggetNatives);
            break;
         }
         case cAICommPromptToEnemyWhenHeGathersNuggetSettlers:
         {
            sendStatement(playerID, cAICommPromptToAllyWhenHeGathersNuggetSettlers);
            break;
         }
         }
      }
   }
   else
   {
      //-- I gathered the nugget.  Figure out what kind it is based on the defaultChatID enemy version.
      // Substitute appropriate ally and enemy chats.
      switch (defaultChatID)
      {
      case cAICommPromptToEnemyWhenHeGathersNugget:
      {
         sendStatement(cPlayerRelationAlly, cAICommPromptToAllyWhenIGatherNugget);
         sendStatement(cPlayerRelationEnemy, cAICommPromptToEnemyWhenIGatherNugget);
         break;
      }
      case cAICommPromptToEnemyWhenHeGathersNuggetCoin:
      {
         sendStatement(cPlayerRelationAlly, cAICommPromptToAllyWhenIGatherNuggetCoin);
         sendStatement(cPlayerRelationEnemy, cAICommPromptToEnemyWhenIGatherNuggetCoin);
         break;
      }
      case cAICommPromptToEnemyWhenHeGathersNuggetFood:
      {
         sendStatement(cPlayerRelationAlly, cAICommPromptToAllyWhenIGatherNuggetFood);
         sendStatement(cPlayerRelationEnemy, cAICommPromptToEnemyWhenIGatherNuggetFood);
         break;
      }
      case cAICommPromptToEnemyWhenHeGathersNuggetWood:
      {
         sendStatement(cPlayerRelationAlly, cAICommPromptToAllyWhenIGatherNuggetWood);
         sendStatement(cPlayerRelationEnemy, cAICommPromptToEnemyWhenIGatherNuggetWood);
         break;
      }
      case cAICommPromptToEnemyWhenHeGathersNuggetNatives:
      {
         sendStatement(cPlayerRelationAlly, cAICommPromptToAllyWhenIGatherNuggetNatives);
         sendStatement(cPlayerRelationEnemy, cAICommPromptToEnemyWhenIGatherNuggetNatives);
         break;
      }
      case cAICommPromptToEnemyWhenHeGathersNuggetSettlers:
      {
         sendStatement(cPlayerRelationAlly, cAICommPromptToAllyWhenIGatherNuggetSettlers);
         sendStatement(cPlayerRelationEnemy, cAICommPromptToEnemyWhenIGatherNuggetSettlers);
         break;
      }
      }
   }

   return;
}

rule monitorFeeding
inactive
minInterval 60
{
   // Once a minute, check the global vars to see if there is somebody we need
   // to be sending resources to.  If so, send whatever we have in root.  If not,
   // go to sleep.
   bool stayAwake = false; // Set true if we have orders to feed anything, keeps rule active.
   float toSend = 0.0;
   bool goldSent = false; // Used for choosing chat at end.
   bool woodSent = false;
   bool foodSent = false;
   bool failure = false;
   int failPlayerID = -1;

   // Ignore already eliminated players
   if (kbHasPlayerLost(gFeedGoldTo) == true)
      gFeedGoldTo = 0;
   if (kbHasPlayerLost(gFeedWoodTo) == true)
      gFeedWoodTo = 0;
   if (kbHasPlayerLost(gFeedFoodTo) == true)
      gFeedFoodTo = 0;

   if (gFeedGoldTo > 0)
   {
      stayAwake = true; // There is work to do, stay active.
      toSend = 0.0;
      if (aiResourceIsLocked(cResourceGold) == false)
      {
         kbEscrowFlush(cEconomyEscrowID, cResourceGold, false);
         kbEscrowFlush(cMilitaryEscrowID, cResourceGold, false);
         toSend = kbEscrowGetAmount(cRootEscrowID, cResourceGold) * .85; // Round down for trib penalty
      }
      if (toSend > 100.0)
      { // can send something
         goldSent = true;
         gLastTribSentTime = xsGetTime();
         if ((toSend > 200.0) || (kbGetAge() == cAge1))
            aiTribute(gFeedGoldTo, cResourceGold, toSend / 2);
         else
            aiTribute(gFeedGoldTo, cResourceGold, 100.0);
      }
      else
      {
         failure = true;
         failPlayerID = gFeedGoldTo;
      }
      stayAwake = true; // There is work to do, stay active.
   }

   if (gFeedWoodTo > 0)
   {
      stayAwake = true; // There is work to do, stay active.
      toSend = 0.0;
      if (aiResourceIsLocked(cResourceWood) == false)
      {
         kbEscrowFlush(cEconomyEscrowID, cResourceWood, false);
         kbEscrowFlush(cMilitaryEscrowID, cResourceWood, false);
         toSend = kbEscrowGetAmount(cRootEscrowID, cResourceWood) * .85; // Round down for trib penalty
      }
      if (toSend > 100.0)
      { // can send something
         gLastTribSentTime = xsGetTime();
         woodSent = true;
         if ((toSend > 200.0) || (kbGetAge() == cAge1))
            aiTribute(gFeedWoodTo, cResourceWood, toSend / 2);
         else
            aiTribute(gFeedWoodTo, cResourceWood, 100.0);
      }
      else
      {
         failure = true;
         failPlayerID = gFeedWoodTo;
      }
      stayAwake = true; // There is work to do, stay active.
   }

   if (gFeedFoodTo > 0)
   {
      stayAwake = true; // There is work to do, stay active.
      toSend = 0.0;
      if (aiResourceIsLocked(cResourceFood) == false)
      {
         kbEscrowFlush(cEconomyEscrowID, cResourceFood, false);
         kbEscrowFlush(cMilitaryEscrowID, cResourceFood, false);
         toSend = kbEscrowGetAmount(cRootEscrowID, cResourceFood) * .85; // Round down for trib penalty
      }
      if (toSend > 100.0)
      { // can send something
         gLastTribSentTime = xsGetTime();
         foodSent = true;
         if ((toSend > 200.0) || (kbGetAge() == cAge1))
            aiTribute(gFeedFoodTo, cResourceFood, toSend / 2);
         else
            aiTribute(gFeedFoodTo, cResourceFood, 100.0);
      }
      else
      {
         failure = true;
         failPlayerID = gFeedFoodTo;
      }
      stayAwake = true; // There is work to do, stay active.
   }

   int tributes = 0;
   if (goldSent == true)
      tributes = tributes + 1;
   if (woodSent == true)
      tributes = tributes + 1;
   if (foodSent == true)
      tributes = tributes + 1;
   if ((tributes == 0) && (failure == true))
   { // I sent no tribute, but I should have.  Apologize
     // sendStatement(failPlayerID, cAICommPromptToAllyDeclineCantAfford);
   }
   else
   { /*   Turning off annoying repeated chats
       if (goldSent == true)  // Sent gold, chat about it
          sendStatement(gFeedGoldTo, cAICommPromptToAllyITributedCoin);
       if (foodSent == true)
          sendStatement(gFeedFoodTo, cAICommPromptToAllyITributedFood);
       if (woodSent == true)
          sendStatement(gFeedWoodTo, cAICommPromptToAllyITributedWood);
       */
   }

   if (stayAwake == false)
   {
      aiEcho("Disabling monitorFeeding rule.");
      xsDisableSelf(); // No work to do, go to sleep.
   }
}

extern int gMissionToCancel =
    -1; // Function returns # of units available, sets global var so commhandler can kill the mission if needed.
int unitCountFromCancelledMission(int oppSource = cOpportunitySourceAllyRequest)
{
   int retVal = 0; // Number of military units available
   gMissionToCancel = -1;

   if (oppSource == cOpportunitySourceTrigger)
      return (0); // DO NOT mess with scenario triggers

   int planCount = aiPlanGetNumber(cPlanMission, cPlanStateWorking, true);
   int plan = -1;
   int childPlan = -1;
   int oppID = -1;
   int pri = -1;

   aiEcho(planCount + " missions found");
   for (i = 0; < planCount)
   {
      plan = aiPlanGetIDByIndex(cPlanMission, cPlanStateWorking, true, i);
      if (plan < 0)
         continue;
      childPlan = aiPlanGetVariableInt(plan, cMissionPlanPlanID, 0);
      oppID = aiPlanGetVariableInt(plan, cMissionPlanOpportunityID, 0);
      aiEcho("  Examining mission " + plan);
      aiEcho("    Child plan is " + childPlan);
      aiEcho("    Opp ID is " + oppID);
      pri = aiGetOpportunitySourceType(oppID);
      aiEcho("    Opp priority is " + pri + ", incoming command is " + oppSource);
      if ((pri > cOpportunitySourceAutoGenerated) &&
          (pri <= oppSource)) // This isn't an auto-generated opp, and the incoming command has sufficient rank.
      {
         aiEcho("  This is valid to cancel.");
         gMissionToCancel = plan; // Store this so commHandler can kill it.
         aiEcho("    Child plan has " + aiPlanGetNumberUnits(childPlan, cUnitTypeLogicalTypeLandMilitary) + " units.");
         retVal = aiPlanGetNumberUnits(childPlan, cUnitTypeLogicalTypeLandMilitary);
      }
      else
      {
         aiEcho("Cannot cancel mission " + plan);
         retVal = 0;
      }
   }
   return (retVal);
}

//==============================================================================
// commHandler
//==============================================================================
void commHandler(int chatID = -1)
{
   // Set up our parameters in a convenient format...
   int fromID = aiCommsGetSendingPlayer(chatID); // Which player sent this?
   int verb = aiCommsGetChatVerb(chatID);        // Verb, like cPlayerChatVerbAttack or cPlayerChatVerbDefend
   int targetType = aiCommsGetChatTargetType(
       chatID); // Target type, like cPlayerChatTargetTypePlayers or cPlayerChatTargetTypeLocation
   int targetCount = aiCommsGetTargetListCount(chatID); // How many targets?
   static int targets = -1;                             // Array handle for target array.
   vector location = aiCommsGetTargetLocation(chatID);  // Target location
   int firstTarget = -1;
   static int targetList = -1;
   int opportunitySource = cOpportunitySourceAllyRequest; // Assume it's from a player unless we find out it's player 0,
                                                          // Gaia, indicating a trigger
   int newOppID = -1;

   if (fromID == 0) // Gaia sent this
      opportunitySource = cOpportunitySourceTrigger;

   if (fromID == cMyID)
      return; // DO NOT react to echoes of my own commands/requests.

   if ((kbIsPlayerEnemy(fromID) == true) && (fromID != 0))
      return; // DO NOT accept messages from enemies.

   if (targets < 0)
   {
      aiEcho("Creating comm handler target array.");
      targets = xsArrayCreateInt(30, -1, "Chat targets");
      aiEcho("Create array int returns " + targets);
   }

   // Clear, then fill targets array
   int i = 0;
   for (i = 0; < 30)
      xsArraySetInt(targets, i, -1);

   if (targetCount > 30)
      targetCount = 30; // Stay within array bounds
   for (i = 0; < targetCount)
      xsArraySetInt(targets, i, aiCommsGetTargetListItem(chatID, i));

   if (targetCount > 0)
      firstTarget = xsArrayGetInt(targets, 0);

   // Spew
   aiEcho(" ");
   aiEcho(" ");
   aiEcho("***** Incoming communication *****");
   aiEcho("From: " + fromID + ",  verb: " + verb + ",  targetType: " + targetType + ",  targetCount: " + targetCount);
   for (i = 0; < targetCount)
      aiEcho("        " + xsArrayGetInt(targets, i));
   aiEcho("Vector: " + location);
   aiEcho(" ");
   aiEcho("***** End of communication *****");

   switch (verb) // Parse this message starting with the verb
   {
   case cPlayerChatVerbAttack:
   { // "Attack" from an ally player could mean attack enemy base, defend my base, or claim empty VP Site.
     // Attack from a trigger means attack unit list.
     // Permission checks need to be done inside the inner switch statement, as cvOkToAttack only affects true attack
     // commands.
      int militaryAvail = unitCountFromCancelledMission(opportunitySource);
      int reserveAvail = aiPlanGetNumberUnits(gLandReservePlan, cUnitTypeLogicalTypeLandMilitary);
      int totalAvail = militaryAvail + reserveAvail;
      aiEcho("Plan units available: " + militaryAvail + ", reserve =" + reserveAvail + ", good army size is " +
             gGoodArmyPop);
      if (opportunitySource == cOpportunitySourceAllyRequest)
      { // Don't mess with triggers this late in development
         if (totalAvail < 3)
         {
            aiEcho("Sorry, no units available.");
            // chat "no units" and bail
            sendStatement(fromID, cAICommPromptToAllyDeclineNoArmy);
            return;
         }
         if (aiTreatyActive() == true)
         {
            aiEcho("Can't attack under treaty.");
            sendStatement(fromID, cAICommPromptToAllyDeclineProhibited);
            return;
         }
         else
         {
            if (totalAvail < (gGoodArmyPop / 2))
            {
               aiEcho("Sorry, not enough units.");
               // chat "not enough army units" and bail
               sendStatement(fromID, cAICommPromptToAllyDeclineSmallArmy);
               return;
            }
         }
         // If we get here, it's not a trigger, but we do have enough units to go ahead.
         // See if cancelling an active mission is really necessary.
         if ((reserveAvail > gGoodArmyPop) || (gMissionToCancel < 0))
         {
            aiEcho("Plenty in reserve, no need to cancel...or no mission to cancel.");
         }
         else
         {
            aiEcho("Not enough military units, need to destroy mission " + gMissionToCancel);
            aiPlanDestroy(gMissionToCancel); // Cancel the active mission.
         }
      }
      switch (targetType)
      {
      case cPlayerChatTargetTypeLocation:
      {
         //-- Figure out what is in the this area, and do the correct thing.
         //-- Find nearest base and vpSite, and attack/defend/claim as appropriate.
         int closestBaseID =
             kbFindClosestBase(cPlayerRelationAny, location); // If base is ally, attack point/radius to help out
         int closestVPSite = getClosestVPSite(location, cVPAll, cVPStateAny, -1);

         if ((closestVPSite >= 0) && (distance(location, kbVPSiteGetLocation(closestVPSite)) < 20.0))
         { // Near a VP site...this is a claim opportunity
            newOppID = createOpportunity(cOpportunityTypeClaim, cOpportunityTargetTypeVPSite, closestVPSite, -1,
                                         opportunitySource);
            sendStatement(fromID, cAICommPromptToAllyConfirm);
            aiActivateOpportunity(newOppID, true);
            break; // We've created an Opp, we're done.
         }
         if ((closestBaseID != -1) &&
             (distance(location, kbBaseGetLocation(kbBaseGetOwner(closestBaseID), closestBaseID)) < 50.0))
         { // Command is inside a base.  If enemy, base attack.  If ally, point/radius attack.  TODO:  Make the ally
           // case a defend opportunity.
            if (kbIsPlayerAlly(kbBaseGetOwner(closestBaseID)) == false)
            { // This is an enemy base, create a base attack opportunity
               if ((cvOkToAttack == false) &&
                   (opportunitySource == cOpportunitySourceAllyRequest)) // Attacks prohibited unless it's a trigger
               {
                  // bail out, we're not allowed to do this.
                  sendStatement(fromID, cAICommPromptToAllyDeclineProhibited);
                  aiEcho("ERROR:  We're not allowed to attack.");
                  return ();
                  break;
               }
               newOppID = createOpportunity(cOpportunityTypeDestroy, cOpportunityTargetTypeBase, closestBaseID,
                                            kbBaseGetOwner(closestBaseID), opportunitySource);
               gCommAttackDefendBaseID = closestBaseID;
               sendStatement(fromID, cAICommPromptToAllyConfirm,
                             kbBaseGetLocation(kbBaseGetOwner(closestBaseID), closestBaseID));
            }
            else
            { // Ally base, so do attack point/radius here.  TODO:  Make this a defend opportunity.
               // newOppID = createOpportunity(cOpportunityTypeDestroy, cOpportunityTargetTypePointRadius, -1,
               // chooseAttackPlayerID(location, 50.0), opportunitySource);
               newOppID = createOpportunity(cOpportunityTypeDefend, cOpportunityTargetTypeBase, closestBaseID,
                                            kbBaseGetOwner(closestBaseID), opportunitySource);
               aiSetOpportunityLocation(newOppID, kbBaseGetLocation(kbBaseGetOwner(closestBaseID), closestBaseID));
               aiSetOpportunityRadius(newOppID, 50.0);
               gCommAttackDefendBaseID = closestBaseID;
               sendStatement(fromID, cAICommPromptToAllyIWillHelpDefend, location);
               // createOpportunity(int type, int targettype, int targetID, int targetPlayerID, int source ):
            }
            aiActivateOpportunity(newOppID, true);
            break; // We've created an Opp, we're done.
         }

         // If we're here, it's not a VP site, and not an enemy or ally base - basically open map.
         // Create a point/radius destroy opportunity.   TODO:  Make this a defend opportunity.
         newOppID = createOpportunity(cOpportunityTypeDestroy, cOpportunityTargetTypePointRadius, -1,
                                      chooseAttackPlayerID(location, 50.0), opportunitySource);
         //                     newOppID = createOpportunity(cOpportunityTypeDefend, cOpportunityTargetTypePointRadius,
         //                     -1, chooseAttackPlayerID(location, 50.0), opportunitySource);
         aiSetOpportunityLocation(newOppID, location);
         aiSetOpportunityRadius(newOppID, 50.0);
         aiActivateOpportunity(newOppID, true);
         sendStatement(fromID, cAICommPromptToAllyConfirm);
         break;
      } // case targetType location
      case cPlayerChatTargetTypeUnits:
      { // This is a trigger command to attack a unit list.  TODO:  Make this a unit list attack.
         // newOppID = createOpportunity(cOpportunityTypeDestroy, cOpportunityTargetTypePointRadius, -1,
         // chooseAttackPlayerID(location, 50.0), opportunitySource);
         newOppID = createOpportunity(cOpportunityTypeDestroy, cOpportunityTargetTypeUnitList, targets,
                                      chooseAttackPlayerID(location, 50.0), opportunitySource);
         aiSetOpportunityLocation(newOppID, location);
         aiSetOpportunityRadius(newOppID, 50.0);
         aiActivateOpportunity(newOppID, true);
         sendStatement(fromID, cAICommPromptToAllyConfirm);
         break;
      }
      default:
      { // Not recognized
         sendStatement(fromID, cAICommPromptToAllyDeclineGeneral);
         aiEcho("ERROR!  Target type " + targetType + " not recognized.");
         return (); // Don't risk sending another chat...
         break;
      }
      } // end switch targetType
      break;
   } // end verb attack

   case cPlayerChatVerbTribute:
   {
      if (opportunitySource == cOpportunitySourceAllyRequest)
      {
         aiEcho("    Command was to tribute to player " + fromID + ".  Resource list:");
         bool alreadyChatted = false;
         for (i = 0; < targetCount)
         {
            float amountAvailable = 0.0;
            if (xsArrayGetInt(targets, i) == cResourceGold)
            {
               // kbEscrowFlush(cEconomyEscrowID, cResourceGold, false);
               // kbEscrowFlush(cMilitaryEscrowID, cResourceGold, false);
               amountAvailable = xsArrayGetFloat(gResourceNeeds, cResourceGold) * -0.85; // Leave room for tribute penalty
               if (aiResourceIsLocked(cResourceGold) == true)
                  amountAvailable = 0.0;
               if (amountAvailable > 100.0)
               { // We will tribute something
                  if (alreadyChatted == false)
                  {
                     sendStatement(fromID, cAICommPromptToAllyITributedCoin);
                     alreadyChatted = true;
                  }
                  gLastTribSentTime = xsGetTime();
                  if (amountAvailable > 200.0)
                     aiTribute(fromID, cResourceGold, amountAvailable / 2);
                  else
                     aiTribute(fromID, cResourceGold, 100.0);
               }
               else
               {
                  if (alreadyChatted == false)
                  {
                     sendStatement(fromID, cAICommPromptToAllyDeclineCantAfford);
                     alreadyChatted = true;
                  }
               }
               aiEcho("        Tribute gold");
            }
            if (xsArrayGetInt(targets, i) == cResourceFood)
            {
               // kbEscrowFlush(cEconomyEscrowID, cResourceFood, false);
               // kbEscrowFlush(cMilitaryEscrowID, cResourceFood, false);
               amountAvailable = xsArrayGetFloat(gResourceNeeds, cResourceFood) * -0.85; // Leave room for tribute penalty
               if (aiResourceIsLocked(cResourceFood) == true)
                  amountAvailable = 0.0;
               if (amountAvailable > 100.0)
               { // We will tribute something
                  if (alreadyChatted == false)
                  {
                     sendStatement(fromID, cAICommPromptToAllyITributedFood);
                     alreadyChatted = true;
                  }
                  gLastTribSentTime = xsGetTime();
                  if (amountAvailable > 200.0)
                     aiTribute(fromID, cResourceFood, amountAvailable / 2);
                  else
                     aiTribute(fromID, cResourceFood, 100.0);
               }
               else
               {
                  if (alreadyChatted == false)
                  {
                     sendStatement(fromID, cAICommPromptToAllyDeclineCantAfford);
                     alreadyChatted = true;
                  }
               }
               aiEcho("        Tribute food");
            }
            if (xsArrayGetInt(targets, i) == cResourceWood)
            {
               // kbEscrowFlush(cEconomyEscrowID, cResourceWood, false);
               // kbEscrowFlush(cMilitaryEscrowID, cResourceWood, false);
               amountAvailable = xsArrayGetFloat(gResourceNeeds, cResourceWood) * -0.85; // Leave room for tribute penalty
               if (aiResourceIsLocked(cResourceWood) == true)
                  amountAvailable = 0.0;
               if (amountAvailable > 100.0)
               { // We will tribute something
                  if (alreadyChatted == false)
                  {
                     sendStatement(fromID, cAICommPromptToAllyITributedWood);
                     alreadyChatted = true;
                  }
                  gLastTribSentTime = xsGetTime();
                  if (amountAvailable > 200.0)
                     aiTribute(fromID, cResourceWood, amountAvailable / 2);
                  else
                     aiTribute(fromID, cResourceWood, 100.0);
                  // kbEscrowAllocateCurrentResources();
               }
               else
               {
                  if (alreadyChatted == false)
                  {
                     sendStatement(fromID, cAICommPromptToAllyDeclineCantAfford);
                     alreadyChatted = true;
                  }
               }
               aiEcho("        Tribute wood");
            }
         }
      } // end source allyRequest
      else
      { // Tribute trigger...send it to player 1
         aiEcho("    Command was a trigger to tribute to player 1.  Resource list:");
         for (i = 0; <= 2) // Target[x] is the amount of resource type X to send
         {
            float avail = kbEscrowGetAmount(cRootEscrowID, i) * .85;
            int qty = xsArrayGetInt(targets, i);
            if (qty > 0)
            {
               aiEcho("        Resource # " + i + ", amount: " + qty + " requested.");
               if (avail >= qty) // we can afford it
               {
                  aiTribute(1, i, qty);
                  aiEcho("            Sending full amount.");
               }
               else
               {
                  aiTribute(1, i, avail); // Can't afford it, send what we have.
                  aiEcho("            Sending all I have, " + avail + ".");
               }
            }
         }
      }
      break;
   } // End verb tribute

   case cPlayerChatVerbFeed: // Ongoing tribute.  Once a minute, send whatever you have in root.
   {
      aiEcho("    Command was to feed resources to a player.");
      bool alreadyResponded = false;
      for (i = 0; < targetCount)
      {
         switch (xsArrayGetInt(targets, i))
         {
         case cResourceGold:
         {
            gFeedGoldTo = fromID;
            if (xsIsRuleEnabled("monitorFeeding") == false)
            {
               xsEnableRule("monitorFeeding");
               monitorFeeding();
            }
            if (alreadyResponded == false)
            {
               sendStatement(fromID, cAICommPromptToAllyIWillFeedCoin);
               alreadyResponded = true;
            }
            break;
         }
         case cResourceWood:
         {
            gFeedWoodTo = fromID;
            if (xsIsRuleEnabled("monitorFeeding") == false)
            {
               xsEnableRule("monitorFeeding");
               monitorFeeding();
            }
            if (alreadyResponded == false)
            {
               sendStatement(fromID, cAICommPromptToAllyIWillFeedWood);
               alreadyResponded = true;
            }
            break;
         }
         case cResourceFood:
         {
            gFeedFoodTo = fromID;
            if (xsIsRuleEnabled("monitorFeeding") == false)
            {
               xsEnableRule("monitorFeeding");
               monitorFeeding();
            }
            if (alreadyResponded == false)
            {
               sendStatement(fromID, cAICommPromptToAllyIWillFeedFood);
               alreadyResponded = true;
            }
            break;
         }
         }
      }
      break;
   } // End verb feed

   case cPlayerChatVerbTrain:
   {
      aiEcho("    Command was to train units starting with " + firstTarget + ", unit type " +
             kbGetProtoUnitName(firstTarget));
      // See if we have authority to change the settings
      bool okToChange = false;
      if (opportunitySource == cOpportunitySourceTrigger)
         okToChange = true; // Triggers always rule
      if (opportunitySource == cOpportunitySourceAllyRequest)
      {
         if ((gUnitPickSource == cOpportunitySourceAllyRequest) || (gUnitPickSource == cOpportunitySourceAutoGenerated))
            okToChange = true;
      }
      if (okToChange == true)
      {
         aiEcho("    Permission granted, changing units.");
         gUnitPickSource = opportunitySource; // Record who made this change
         gUnitPickPlayerID = fromID;

         cvPrimaryArmyUnit = firstTarget;
         cvSecondaryArmyUnit = -1;
         aiEcho("        Primary unit is " + firstTarget + " " + kbGetProtoUnitName(firstTarget));
         setUnitPickerPreference(gLandUnitPicker);
         // [TMTODO] (pbaulch) The chatsets do include unit-type-specific responses, it would be nice to
         // test abstract type and use them (although they may never have appeared before, so they might
         // have to be evaluated for cultural acceptability)
         // i.e. cUnitTypeAbstractArtillery -> cAICommPromptToAllyConfirmArt
         //      cUnitTypeAbstractInfantry -> cAICommPromptToAllyConfirmInf
         //      cUnitTypeAbstractCavalry -> cAICommPromptToAllyConfirmCav
         sendStatement(fromID, cAICommPromptToAllyConfirm);
      }
      else
      {
         sendStatement(fromID, cAICommPromptToAllyDeclineProhibited);
         aiEcho("    Cannot override existing settings.");
      }
      break;
   }
   case cPlayerChatVerbDefend:
   { // Currently, defend is only available via the aiCommsDefend trigger, it is not in the UI.
      // An "implicit" defend can be done when a human player issues an attack command on a location
      // that does not have enemy units nearby.
      // Currently, all defend verbs will be point/radius
      newOppID = createOpportunity(cOpportunityTypeDefend, cOpportunityTargetTypePointRadius, -1,
                                   chooseAttackPlayerID(location, 50.0), opportunitySource);
      aiSetOpportunityLocation(newOppID, location);
      aiSetOpportunityRadius(newOppID, 50.0);
      aiActivateOpportunity(newOppID, true);
      break;
   }
   case cPlayerChatVerbClaim:
   { // Available only from trigger, sends a vector.  Humans can send implicit claim commands
      // by sending "attack" with a point that is near an unclaimed VP site.
      closestVPSite = getClosestVPSite(location, cVPAll, cVPStateAny, -1);
      bool permitted = true;
      if ((cvOkToClaimTrade == false) && (kbVPSiteGetType(closestVPSite) == cVPTrade))
         permitted = false;
      if ((cvOkToAllyNatives == false) && (kbVPSiteGetType(closestVPSite) == cVPNative))
         permitted = false;

      if (permitted = false)
      {
         sendStatement(fromID, cAICommPromptToAllyDeclineProhibited);
         aiEcho("    Not allowed to claim this type of site.");
      }
      else
      {
         newOppID = createOpportunity(cOpportunityTypeClaim, cOpportunityTargetTypeVPSite, closestVPSite, -1,
                                      opportunitySource);
         aiActivateOpportunity(newOppID, true);
      }
      break;
   }
   case cPlayerChatVerbStrategy:
   {
      if (xsArrayGetInt(targets, 0) == cPlayerChatTargetStrategyRush)
      {
         btRushBoom = 1.0;
         xsEnableRule("turtleUp");
         gPrevNumTowers = gNumTowers;
         gNumTowers = 0;
      }
      else if (xsArrayGetInt(targets, 0) == cPlayerChatTargetStrategyBoom)
      {
         btRushBoom = -1.0;
      }
      else if (xsArrayGetInt(targets, 0) == cPlayerChatTargetStrategyTurtle)
      {

         btOffenseDefense = -1.0;
         xsEnableRule("turtleUp");
         gPrevNumTowers = gNumTowers;
         gNumTowers = kbGetBuildLimit(cMyID, gTowerUnit);
      }
      sendStatement(fromID, cAICommPromptToAllyConfirm);
      break;
   }
   case cPlayerChatVerbCancel:
   {
      // Clear training (unit line bias) settings
      if ((gUnitPickSource == cOpportunitySourceAllyRequest) || (opportunitySource == cOpportunitySourceTrigger))
      { // We have an ally-generated unit line choice, destroy it
         gUnitPickSource = cOpportunitySourceAutoGenerated;
         gUnitPickPlayerID = -1;
         cvPrimaryArmyUnit = -1;
         cvSecondaryArmyUnit = -1;
         setUnitPickerPreference(gLandUnitPicker);
      }

      // Clear Feeding (ongoing tribute) settings
      gFeedGoldTo = -1;
      gFeedWoodTo = -1;
      gFeedFoodTo = -1;

      // Cancel any active attack, defend or claim missions from allies or triggers
      if ((opportunitySource == cOpportunitySourceTrigger) || (opportunitySource == cOpportunitySourceAllyRequest))
      {
         if (gMostRecentAllyOpportunityID >= 0)
         {
            aiDestroyOpportunity(gMostRecentAllyOpportunityID);
            aiEcho("Destroying opportunity " + gMostRecentAllyOpportunityID + " because of cancel command.");
            gMostRecentAllyOpportunityID = -1;
         }
      }
      if (opportunitySource == cOpportunitySourceTrigger)
      {
         if (gMostRecentTriggerOpportunityID >= 0)
         {
            aiDestroyOpportunity(gMostRecentTriggerOpportunityID);
            aiEcho("Destroying opportunity " + gMostRecentTriggerOpportunityID + " because of cancel command.");
            gMostRecentTriggerOpportunityID = -1;
         }
         // Also, a trigger cancel must kill any active auto-generated attack or defend plans
         int numPlans = aiPlanGetNumber(cPlanMission, -1, true);
         int index = 0;
         int plan = -1;
         int planOpp = -1;
         for (index = 0; < numPlans)
         {
            plan = aiPlanGetIDByIndex(cPlanMission, -1, true, index);
            planOpp = aiPlanGetVariableInt(plan, cMissionPlanOpportunityID, 0);
            if (planOpp >= 0)
            {
               if (aiGetOpportunitySourceType(planOpp) == cOpportunitySourceAutoGenerated)
               {
                  aiEcho("--------DESTROYING MISSION " + plan + " " + aiPlanGetName(plan));
                  aiPlanDestroy(plan);
               }
            }
         }
      }
      // Reset number of towers
      if (gPrevNumTowers >= 0)
         gNumTowers = gPrevNumTowers;
      break;
   }
   default:
   {
      aiEcho("    Command verb not found, verb value is: " + verb);
      break;
   }
   }
   aiEcho("********************************************");
}

rule delayAttackMonitor
inactive
group tcComplete
minInterval 10
{
   // If this rule is active, it means that gDelayAttacks has been set true,
   // and we're on a diffuclty level where we can't attack until AFTER someone
   // has attacked us, or until we've reached age 4.

   if (kbGetAge() >= cAge4)
   {
      if ((gDelayAttacks == true) && (aiGetWorldDifficulty() >= cDifficultyEasy))
      {
         aiEcho(" ");
         aiEcho("    OK, THE GLOVES COME OFF NOW!");
         aiEcho(" ");
         gDelayAttacks = false;
      }
      xsDisableSelf();
      return;
   }

   // See if we're under attack.
   if (gDefenseReflexBaseID == kbBaseGetMainID(cMyID))
   { // Main base is under attack
      if ((gDelayAttacks == true) && (aiGetWorldDifficulty() >= cDifficultyEasy))
      {
         aiEcho(" ");
         aiEcho("    OK, THE GLOVES COME OFF NOW!");
         aiEcho(" ");
         gDelayAttacks = false;
      }
      xsDisableSelf(); // If sandbox, just turn off.
   }
}

//==============================================================================
// exploreMonitor
/*
   Used to correctly implement changes in cvOkToExplore.
   If it's off, make sure the explore plan is killed.
   If it's on, make sure the explore plan is active.

   Initially, the explore plan gets an explorer plus 5/15/20 military units,
   so that it can effectively gather nuggets.  We switch out of this mode 3 minutes
   after reaching age 2, unless the explore plan is in nugget gathering mode.
*/
//==============================================================================
rule exploreMonitor
inactive
minInterval 10
{
   const int cExploreModeStart = 0;   // Initial setting, when first starting out
   const int cExploreModeNugget = 1;  // Explore and gather nuggets.  Heavy staffing, OK to recruit more units.
   const int cExploreModeStaff = 2;   // Restaffing the plan, active for 10 seconds to let the plan grab 1 more unit.
   const int cExploreModeExplore = 3; // Normal...explore until this unit dies, check again in 5 minutes.

   static int exploreMode = cExploreModeStart;
   static int age2Time = -1;
   static int nextStaffTime = -1; // Prevent the explore plan from constantly sucking in units.

   if ((age2Time < 0) && (kbGetAge() >= cAge2))
      age2Time = xsGetTime();

   // Check for a failed plan
   if ((gLandExplorePlan >= 0) && (aiPlanGetState(gLandExplorePlan) < 0))
   {
      // Somehow, the plan has died.  Reset it to start up again if allowed.
      gLandExplorePlan = -1;
      exploreMode = cExploreModeStart;
      nextStaffTime = -1;
   }

   // First, check the control variable and react appropriately

   if (cvOkToExplore == true)
   {
      if (aiPlanGetActive(gLandExplorePlan) == false)
         if (gLandExplorePlan >= 0)
            aiPlanSetActive(gLandExplorePlan); // Reactivate if we were shut off
      switch (exploreMode)
      {
      case cExploreModeStart:
      {
         if (aiPlanGetState(gLandExplorePlan) < 0)
         { // Need to create it.
            gLandExplorePlan = aiPlanCreate("Land Explore", cPlanExplore);
            aiPlanSetDesiredPriority(gLandExplorePlan, 75);
            if (cvOkToGatherNuggets == true)
            {
               switch (cMyCiv)
               {
               case cCivDEInca:
               {
                  aiPlanAddUnitType(gLandExplorePlan, cUnitTypedeIncaWarChief, 1, 1, 1);
                  break;
               }
               case cCivXPAztec:
               {
                  aiPlanAddUnitType(gLandExplorePlan, cUnitTypexpAztecWarchief, 1, 1, 1);
                  break;
               }
               case cCivXPIroquois:
               {
                  aiPlanAddUnitType(gLandExplorePlan, cUnitTypexpIroquoisWarChief, 1, 1, 1);
                  break;
               }
               case cCivXPSioux:
               {
                  aiPlanAddUnitType(gLandExplorePlan, cUnitTypexpLakotaWarchief, 1, 1, 1);
                  break;
               }
               case cCivChinese:
               {
                  aiPlanAddUnitType(gLandExplorePlan, cUnitTypeypMonkChinese, 1, 1, 1);
                  break;
               }
               case cCivIndians:
               {
                  aiPlanAddUnitType(gLandExplorePlan, cUnitTypeypMonkIndian, 1, 1, 1);
                  aiPlanAddUnitType(gLandExplorePlan, cUnitTypeypMonkIndian2, 1, 1, 1);
                  break;
               }
               case cCivJapanese:
               {
                  aiPlanAddUnitType(gLandExplorePlan, cUnitTypeypMonkJapanese, 1, 1, 1);
                  aiPlanAddUnitType(gLandExplorePlan, cUnitTypeypMonkJapanese2, 1, 1, 1);
                  break;
               }
               default:
               {
                  aiPlanAddUnitType(gLandExplorePlan, cUnitTypeExplorer, 1, 1, 1);
                  break;
               }
               }
               aiPlanAddUnitType(gLandExplorePlan, cUnitTypeLogicalTypeScout, 1, 6, 10);
               aiPlanSetVariableBool(gLandExplorePlan, cExplorePlanOkToGatherNuggets, 0, true);
               if (btRushBoom > 0.0)
                  aiPlanAddWaypoint(gLandExplorePlan, guessEnemyLocation());
               exploreMode = cExploreModeNugget;
            }
            else
            {
               if (cMyCiv == cCivDutch) // Dutch will only use envoys (mainly handled in envoyMonitor rule)
               {
                  aiPlanAddUnitType(gLandExplorePlan, cUnitTypeEnvoy, 1, 1, 1);
               }
               else
               {
                  aiPlanAddUnitType(gLandExplorePlan, findBestScoutType(), 1, 1, 1);
               }
               aiPlanAddUnitType(gLandExplorePlan, cUnitTypeExplorer, 0, 0, 0);
               aiPlanAddUnitType(gLandExplorePlan, cUnitTypedeIncaWarChief, 0, 0, 0);
               aiPlanAddUnitType(gLandExplorePlan, cUnitTypexpAztecWarchief, 0, 0, 0);
               aiPlanAddUnitType(gLandExplorePlan, cUnitTypexpIroquoisWarChief, 0, 0, 0);
               aiPlanAddUnitType(gLandExplorePlan, cUnitTypexpLakotaWarchief, 0, 0, 0);
               aiPlanAddUnitType(gLandExplorePlan, cUnitTypeypMonkChinese, 0, 0, 0);
               aiPlanAddUnitType(gLandExplorePlan, cUnitTypeypMonkIndian, 0, 0, 0);
               aiPlanAddUnitType(gLandExplorePlan, cUnitTypeypMonkIndian2, 0, 0, 0);
               aiPlanAddUnitType(gLandExplorePlan, cUnitTypeypMonkJapanese, 0, 0, 0);
               aiPlanAddUnitType(gLandExplorePlan, cUnitTypeypMonkJapanese2, 0, 0, 0);
               aiPlanSetVariableBool(gLandExplorePlan, cExplorePlanOkToGatherNuggets, 0, false);
               exploreMode = cExploreModeStaff;
               nextStaffTime =
                   xsGetTime() + 120000; // Two minutes from now, let it get another soldier if it loses this one.
               if (gExplorerControlPlan < 0)
               {
                  gExplorerControlPlan = aiPlanCreate("Explorer control plan", cPlanDefend);
                  switch (cMyCiv)
                  {
                  case cCivDEInca:
                  {
                     aiPlanAddUnitType(gExplorerControlPlan, cUnitTypedeIncaWarChief, 1, 1, 1);
                     break;
                  }
                  case cCivXPAztec:
                  {
                     aiPlanAddUnitType(gExplorerControlPlan, cUnitTypexpAztecWarchief, 1, 1, 1);
                     break;
                  }
                  case cCivXPIroquois:
                  {
                     aiPlanAddUnitType(gExplorerControlPlan, cUnitTypexpIroquoisWarChief, 1, 1, 1);
                     break;
                  }
                  case cCivXPSioux:
                  {
                     aiPlanAddUnitType(gExplorerControlPlan, cUnitTypexpLakotaWarchief, 1, 1, 1);
                     break;
                  }
                  case cCivChinese:
                  {
                     aiPlanAddUnitType(gExplorerControlPlan, cUnitTypeypMonkChinese, 1, 1, 1);
                     break;
                  }
                  case cCivIndians:
                  {
                     aiPlanAddUnitType(gExplorerControlPlan, cUnitTypeypMonkIndian, 1, 1, 1);
                     aiPlanAddUnitType(gExplorerControlPlan, cUnitTypeypMonkIndian2, 1, 1, 1);
                     break;
                  }
                  case cCivJapanese:
                  {
                     aiPlanAddUnitType(gExplorerControlPlan, cUnitTypeypMonkJapanese, 1, 1, 1);
                     aiPlanAddUnitType(gExplorerControlPlan, cUnitTypeypMonkJapanese2, 1, 1, 1);
                     break;
                  }
                  default:
                  {
                     aiPlanAddUnitType(gExplorerControlPlan, cUnitTypeExplorer, 1, 1, 1);
                     break;
                  }
                  }
                  aiPlanSetVariableVector(gExplorerControlPlan, cDefendPlanDefendPoint, 0,
                                          kbBaseGetMilitaryGatherPoint(cMyID, kbBaseGetMainID(cMyID)));
                  aiPlanSetVariableInt(gExplorerControlPlan, cDefendPlanDefendBaseID, 0, kbBaseGetMainID(cMyID));
                  aiPlanSetVariableFloat(gExplorerControlPlan, cDefendPlanEngageRange, 0, 20.0); // Tight
                  aiPlanSetVariableBool(gExplorerControlPlan, cDefendPlanPatrol, 0, false);
                  aiPlanSetVariableFloat(gExplorerControlPlan, cDefendPlanGatherDistance, 0, 20.0);
                  aiPlanSetInitialPosition(gExplorerControlPlan, kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)));
                  aiPlanSetUnitStance(gExplorerControlPlan, cUnitStanceDefensive);
                  aiPlanSetVariableInt(gExplorerControlPlan, cDefendPlanRefreshFrequency, 0, 30);
                  aiPlanSetVariableInt(gExplorerControlPlan, cDefendPlanAttackTypeID, 0, cUnitTypeUnit); // Only units
                  if (civIsNative() == false)
                     aiPlanSetDesiredPriority(gExplorerControlPlan,
                                              90); // Quite high, don't suck him into routine attack plans, etc.
                  else
                     aiPlanSetDesiredPriority(gExplorerControlPlan,
                                              40); // Above default, we do want war chiefs in attacks for the aura.
                  aiPlanSetActive(gExplorerControlPlan);
               }
            }
            aiPlanSetEscrowID(gLandExplorePlan, cEconomyEscrowID);
            aiPlanSetBaseID(gLandExplorePlan, kbBaseGetMainID(cMyID));
            aiPlanSetVariableBool(gLandExplorePlan, cExplorePlanDoLoops, 0, true);
            aiPlanSetVariableInt(gLandExplorePlan, cExplorePlanNumberOfLoops, 0, 1);
            if (btRushBoom > 0.0)
               aiPlanAddWaypoint(gLandExplorePlan, guessEnemyLocation());
            aiPlanSetActive(gLandExplorePlan);
         }
         else
         {
            exploreMode = cExploreModeNugget;
         }
         break;
      }
      case cExploreModeNugget:
      {
         // Check to see if we're out of time, and switch to single-unit exploring if we are.
         if (age2Time >= 0)
         {
            if ((aiGetFallenExplorerID() >= 0) ||
                (/*((xsGetTime() - age2Time) > 180000)*/ (age2Time >= 0) &&
                 ((aiPlanGetState(gLandExplorePlan) != cPlanStateClaimNugget) ||
                  ((xsGetTime() - age2Time) >
                   300000)))) // Our explorer is unconscious or we've been in age 2 for a long time already.
            {                 // Switch to a normal explore plan, create explorer control plan
               if (gExplorerControlPlan < 0)
               {
                  gExplorerControlPlan = aiPlanCreate("Explorer control plan", cPlanDefend);
                  switch (cMyCiv)
                  {
                  case cCivDEInca:
                  {
                     aiPlanAddUnitType(gExplorerControlPlan, cUnitTypedeIncaWarChief, 1, 1, 1);
                     break;
                  }
                  case cCivXPAztec:
                  {
                     aiPlanAddUnitType(gExplorerControlPlan, cUnitTypexpAztecWarchief, 1, 1, 1);
                     break;
                  }
                  case cCivXPIroquois:
                  {
                     aiPlanAddUnitType(gExplorerControlPlan, cUnitTypexpIroquoisWarChief, 1, 1, 1);
                     break;
                  }
                  case cCivXPSioux:
                  {
                     aiPlanAddUnitType(gExplorerControlPlan, cUnitTypexpLakotaWarchief, 1, 1, 1);
                     break;
                  }
                  case cCivChinese:
                  {
                     aiPlanAddUnitType(gExplorerControlPlan, cUnitTypeypMonkChinese, 1, 1, 1);
                     break;
                  }
                  case cCivIndians:
                  {
                     aiPlanAddUnitType(gExplorerControlPlan, cUnitTypeypMonkIndian, 1, 1, 1);
                     aiPlanAddUnitType(gExplorerControlPlan, cUnitTypeypMonkIndian2, 1, 1, 1);
                     break;
                  }
                  case cCivJapanese:
                  {
                     aiPlanAddUnitType(gExplorerControlPlan, cUnitTypeypMonkJapanese, 1, 1, 1);
                     aiPlanAddUnitType(gExplorerControlPlan, cUnitTypeypMonkJapanese2, 1, 1, 1);
                     break;
                  }
                  default:
                  {
                     aiPlanAddUnitType(gExplorerControlPlan, cUnitTypeExplorer, 1, 1, 1);
                     break;
                  }
                  }
                  aiPlanSetVariableVector(gExplorerControlPlan, cDefendPlanDefendPoint, 0,
                                          kbBaseGetMilitaryGatherPoint(cMyID, kbBaseGetMainID(cMyID)));
                  aiPlanSetVariableInt(gExplorerControlPlan, cDefendPlanDefendBaseID, 0, kbBaseGetMainID(cMyID));
                  aiPlanSetVariableFloat(gExplorerControlPlan, cDefendPlanEngageRange, 0, 20.0); // Tight
                  aiPlanSetVariableBool(gExplorerControlPlan, cDefendPlanPatrol, 0, false);
                  aiPlanSetVariableFloat(gExplorerControlPlan, cDefendPlanGatherDistance, 0, 20.0);
                  aiPlanSetInitialPosition(gExplorerControlPlan, kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)));
                  aiPlanSetUnitStance(gExplorerControlPlan, cUnitStanceDefensive);
                  aiPlanSetVariableInt(gExplorerControlPlan, cDefendPlanRefreshFrequency, 0, 30);
                  aiPlanSetVariableInt(gExplorerControlPlan, cDefendPlanAttackTypeID, 0, cUnitTypeUnit); // Only units
                  aiPlanSetDesiredPriority(gExplorerControlPlan,
                                           90); // Quite high, don't suck him into routine attack plans, etc.
                  aiPlanSetActive(gExplorerControlPlan);
               }

               // Destroy and re-create plan for single scout
               aiPlanDestroy(gLandExplorePlan);
               gLandExplorePlan = aiPlanCreate("Land Explore", cPlanExplore);
               aiPlanSetDesiredPriority(gLandExplorePlan, 75);
               if (cMyCiv == cCivDutch) // Dutch will only use envoys (mainly handled in envoyMonitor rule)
               {
                  aiPlanAddUnitType(gLandExplorePlan, cUnitTypeEnvoy, 1, 1, 1);
               }
               else
               {
                  aiPlanAddUnitType(gLandExplorePlan, findBestScoutType(), 1, 1, 1);
               }
               aiPlanSetNoMoreUnits(gLandExplorePlan, false);
               aiPlanSetVariableInt(gLandExplorePlan, cExplorePlanNumberOfLoops, 0, 0);
               aiPlanSetVariableBool(gLandExplorePlan, cExplorePlanDoLoops, 0, false);
               exploreMode = cExploreModeStaff;
               nextStaffTime = xsGetTime() + 120000; // Two minutes from now, let it get another soldier.
               aiEcho("Allowing the explore plan to grab a unit.");
            }
         }
         if (cvOkToGatherNuggets == false)
         {
            aiPlanAddUnitType(gLandExplorePlan, cUnitTypeExplorer, 0, 0, 0);
            aiPlanAddUnitType(gLandExplorePlan, cUnitTypedeIncaWarChief, 0, 0, 0);
            aiPlanAddUnitType(gLandExplorePlan, cUnitTypexpAztecWarchief, 0, 0, 0);
            aiPlanAddUnitType(gLandExplorePlan, cUnitTypexpIroquoisWarChief, 0, 0, 0);
            aiPlanAddUnitType(gLandExplorePlan, cUnitTypexpLakotaWarchief, 0, 0, 0);
            aiPlanAddUnitType(gLandExplorePlan, cUnitTypeypMonkChinese, 0, 0, 0);
            aiPlanAddUnitType(gLandExplorePlan, cUnitTypeypMonkIndian, 0, 0, 0);
            aiPlanAddUnitType(gLandExplorePlan, cUnitTypeypMonkIndian2, 0, 0, 0);
            aiPlanAddUnitType(gLandExplorePlan, cUnitTypeypMonkJapanese, 0, 0, 0);
            aiPlanAddUnitType(gLandExplorePlan, cUnitTypeypMonkJapanese2, 0, 0, 0);
            aiPlanAddUnitType(gLandExplorePlan, findBestScoutType(), 1, 1, 1);
            aiPlanSetNoMoreUnits(gLandExplorePlan, false);
            aiPlanSetVariableInt(gLandExplorePlan, cExplorePlanNumberOfLoops, 0, 0);
            aiPlanSetVariableBool(gLandExplorePlan, cExplorePlanDoLoops, 0, false);
            exploreMode = cExploreModeStaff;
            nextStaffTime = xsGetTime() + 120000; // Two minutes from now, let it get another soldier.
            aiEcho("Allowing the explore plan to grab a unit.");
         }
         break;
      }
      case cExploreModeStaff:
      {
         // We've been staffing for 10 seconds, set no more units to true
         aiPlanSetNoMoreUnits(gLandExplorePlan, true);
         exploreMode = cExploreModeExplore;
         aiEcho("Setting the explore plan to 'noMoreUnits'");
         break;
      }
      case cExploreModeExplore:
      { // See if we're allowed to add another unit
         if (xsGetTime() > nextStaffTime)
         {
            aiPlanSetNoMoreUnits(gLandExplorePlan, false); // Let it grab a unit
            aiEcho("Setting the explore plan to grab a unit if needed.");
            nextStaffTime = xsGetTime() + 120000;
            exploreMode = cExploreModeStaff;
         }
         break;
      }
      }
   }
   else // cvOkToExplore = false
   {
      aiPlanSetActive(gLandExplorePlan, false);
   }
}

//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
// Opportunities and Missions
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================

void missionStartHandler(int missionID = -1)
{  // Track times for mission starts, so we can tell how long its been since
   // we had a mission of a given type.
   if (missionID < 0)
      return;
   
   int oppID = aiPlanGetVariableInt(missionID, cMissionPlanOpportunityID, 0);
   int oppType = aiGetOpportunityType(oppID);
   int source = aiGetOpportunitySourceType(oppID);
   int targetPlayer = aiGetOpportunityTargetPlayerID(oppID);
   vector location = aiGetOpportunityLocation(oppID);
   
   if (source < 0) 
      source = cOpportunitySourceAutoGenerated;
   if (source > cOpportunitySourceTrigger)
      source = cOpportunitySourceTrigger;
	  
	  
   aiPlanSetVariableInt(missionID, cMissionPlanStartTime, 0, xsGetTime()); // Set the start time in ms.
   
   switch(oppType)
   {
      case cOpportunityTypeDestroy:
      {
         gLastAttackMissionTime = xsGetTime();
         aiEcho("-------- ATTACK MISSION ACTIVATION: Mission "+missionID+", Opp "+oppID);
		 if (source > cOpportunitySourceTrigger)
		 {
		 sendStatement(cPlayerRelationAlly, cAICommPromptToAllyIWillAttackWithYou, kbBaseGetLocation(targetPlayer, kbBaseGetMainID(targetPlayer)));
		 }
		 else
		 {
	     sendStatement(cPlayerRelationAlly, cAICommPromptToAllyIWillAttackEnemyTown, kbBaseGetLocation(targetPlayer, kbBaseGetMainID(targetPlayer)));
		 }
		 aiSetMostHatedPlayerID(targetPlayer);
		 //kbUnitPickResetAll(gLandUnitPicker);
		 kbUnitPickSetEnemyPlayerID(gLandUnitPicker, targetPlayer);
		 break;
      }
      case cOpportunityTypeDefend:
      {
         gLastDefendMissionTime = xsGetTime();
         aiEcho("-------- DEFEND MISSION ACTIVATION: Mission "+missionID+", Opp "+oppID);
         sendStatement(cPlayerRelationAlly, cAICommPromptToAllyIWillHelpDefend, kbBaseGetLocation(targetPlayer, kbBaseGetMainID(targetPlayer)));
         break;
      }
	  case cOpportunityTypeRaid:
	  {
		sendStatement(cPlayerRelationAlly, cAICommPromptToAllyIWillAttackEnemySettlers, kbBaseGetLocation(targetPlayer, kbBaseGetMainID(targetPlayer)));
	 	break;
	  }
      case cOpportunityTypeClaim:
      {
         gLastClaimMissionTime = xsGetTime();
         aiEcho("-------- CLAIM MISSION ACTIVATION: Mission "+missionID+", Opp "+oppID);
		 break;
      }
      default:
      {
         aiEcho("-------- UNKNOWN MISSION ACTIVATION: Mission "+missionID+", Opp "+oppID);
         break;
      }
   }
}


void missionEndHandler(int missionID = -1)
{
   aiEcho("-------- MISSION TERMINATION:  Mission "+missionID+", Opp "+aiGetOpportunityType(aiPlanGetVariableInt(missionID, cMissionPlanOpportunityID, 0)));
}


// Get a class rating, 0.0 to 1.0, for this type of opportunity.
// Scores zero when an opportunity of this type was just launched.
// Scores 1.0 when it has been 'gXXXMissionInterval' time since the last one.
float getClassRating(int oppType = -1, int target = -1)
{
   float retVal = 1.0;
   float timeElapsed = 0.0;
   int targetType = -1;
   
 
   switch(oppType)
   {
      case cOpportunityTypeDestroy:
      {
         timeElapsed = xsGetTime() - gLastAttackMissionTime;         
         retVal = 1.0 * (timeElapsed / gAttackMissionInterval);
         break;
      }
      case cOpportunityTypeDefend:
      {
         timeElapsed = xsGetTime() - gLastDefendMissionTime;
         retVal = 1.0 * (timeElapsed / gDefendMissionInterval);
         break;
      }
      case cOpportunityTypeRaid:
      {
         timeElapsed = xsGetTime() - gLastAttackMissionTime;         
         retVal = 1.0 * (timeElapsed / gAttackMissionInterval);
         break;
      }
      case cOpportunityTypeClaim:
      {
         timeElapsed = xsGetTime() - gLastClaimMissionTime;
         if (kbVPSiteGetType(target) == cVPTrade)
         {
            //if ( btBiasTrade > 0.0)
			retVal = 1.0;
               //timeElapsed = timeElapsed * (1.0 + btBiasTrade);   // Multiply by at least one, up to 2, i.e. btBiasTrade of 1.0 will double elapsed time.
            //else
            //   timeElapsed = timeElapsed / ((-1.0 * btBiasTrade) + 1.0);  // Divide by 1.00 up to 2.00, i.e. cut it in half if btBiasTrade = -1.0
           // retVal = 1.0 * (timeElapsed / gClaimMissionInterval);
         }
         else  // VPNative
         {
			 if ((kbGetAge() > cAge2) || (gSPC == true))
			 {
            if ( btBiasNative > 0.0)
               timeElapsed = timeElapsed * (1.0 + btBiasNative);   // Multiply by at least one, up to 2, i.e. btBiasNative of 1.0 will double elapsed time.
            else
               timeElapsed = timeElapsed / ((-1.0 * btBiasNative) + 1.0);  // Divide by 1.00 up to 2.00, i.e. cut it in half if btBiasNative = -1.0
            retVal = 1.0 * (timeElapsed / gClaimMissionInterval);
			 }
			 else
			 retVal = 0.0;
         }
         break;
      }
   }
   if (retVal > 1.0)
      retVal = 1.0;
   if (retVal < 0.0)
      retVal = 0.0;
   return(retVal);
}


// Calculate an approximate rating for enemy strength in/near this base.
float getBaseEnemyStrength(int baseID = -1)
{
   
   float retVal = 0.0;
   int owner = kbBaseGetOwner(baseID);
   static int allyBaseQuery = -1;
  
   if (allyBaseQuery < 0)
   {
      allyBaseQuery = kbUnitQueryCreate("Ally Base query");
      kbUnitQuerySetIgnoreKnockedOutUnits(allyBaseQuery, true);
      kbUnitQuerySetPlayerRelation(allyBaseQuery, cPlayerRelationEnemyNotGaia);
      kbUnitQuerySetState(allyBaseQuery, cUnitStateABQ);
      kbUnitQuerySetUnitType(allyBaseQuery, cUnitTypeLogicalTypeLandMilitary);
   }

   
   if (baseID < 0)
      return(-1.0);
   
   if (owner <= 0)
      return(-1.0);
   
   if (kbIsPlayerEnemy(owner) == true)  
   {  // Enemy base, add up military factors normally
      retVal = retVal + (10.0 * kbBaseGetNumberUnits(owner, baseID, cPlayerRelationEnemyNotGaia, cUnitTypeTownCenter));  // 5 points per TC
      retVal = retVal + (10.0 * kbBaseGetNumberUnits(owner, baseID, cPlayerRelationEnemy, cUnitTypeFortFrontier));  // 10 points per fort
      retVal = retVal + (1.0 * kbBaseGetNumberUnits(owner, baseID, cPlayerRelationEnemyNotGaia, cUnitTypeLogicalTypeLandMilitary)); // 1 point per soldier
      retVal = retVal + (3.0 * kbBaseGetNumberUnits(owner, baseID, cPlayerRelationEnemyNotGaia, cUnitTypeOutpost));  // 3 points per outpost
      retVal = retVal + (3.0 * kbBaseGetNumberUnits(owner, baseID, cPlayerRelationEnemyNotGaia, cUnitTypeBlockhouse));  // 3 points per blockhouse
      retVal = retVal + (3.0 * kbBaseGetNumberUnits(owner, baseID, cPlayerRelationEnemyNotGaia, cUnitTypeWarHut));  // 3 points per war hut
      retVal = retVal + (3.0 * kbBaseGetNumberUnits(owner, baseID, cPlayerRelationEnemyNotGaia, cUnitTypeYPOutpostAsian));  // 3 points per Asian outpost
      retVal = retVal + (1.0 * kbBaseGetNumberUnits(owner, baseID, cPlayerRelationEnemyNotGaia, cUnitTypeTradingPost));  // 5 points per trading post (Advanced TP suspected!)
      retVal = retVal + (4.0 * kbBaseGetNumberUnits(owner, baseID, cPlayerRelationEnemyNotGaia, cUnitTypeNoblesHut));  // 5 points per nobles hut
      retVal = retVal + (7.0 * kbBaseGetNumberUnits(owner, baseID, cPlayerRelationEnemyNotGaia, cUnitTypeypWIAgraFort2));  // 5 points per agra fort
      retVal = retVal + (7.0 * kbBaseGetNumberUnits(owner, baseID, cPlayerRelationEnemyNotGaia, cUnitTypeypWIAgraFort3));
      retVal = retVal + (7.0 * kbBaseGetNumberUnits(owner, baseID, cPlayerRelationEnemyNotGaia, cUnitTypeypWIAgraFort4));
      retVal = retVal + (7.0 * kbBaseGetNumberUnits(owner, baseID, cPlayerRelationEnemyNotGaia, cUnitTypeypWIAgraFort5));
      retVal = retVal + (4.0 * kbBaseGetNumberUnits(owner, baseID, cPlayerRelationEnemyNotGaia, cUnitTypeypCastle));  // 5 points per castle
      retVal = retVal + (4.0 * kbBaseGetNumberUnits(owner, baseID, cPlayerRelationEnemyNotGaia, cUnitTypedeKallanka));  // 5 points per castle
      retVal = retVal + (7.0 * kbBaseGetNumberUnits(owner, baseID, cPlayerRelationEnemyNotGaia, cUnitTypedeIncaStronghold));  // 5 points per castle		
   }
   else 
   {  // Ally base, we're considering defending.  Count enemy units present
      kbUnitQuerySetUnitType(allyBaseQuery, cUnitTypeLogicalTypeLandMilitary);
      kbUnitQuerySetPosition(allyBaseQuery, kbBaseGetLocation(owner, baseID));
      kbUnitQuerySetMaximumDistance(allyBaseQuery, 50.0);
      kbUnitQueryResetResults(allyBaseQuery);
      retVal = kbUnitQueryExecute(allyBaseQuery);
   }
   if (retVal < 1.0)
      retVal = 1.0;  // Return at least 1.
   return(retVal);
}


// Calculate an approximate strength rating for the enemy units/buildings near this point.
float getPointEnemyStrength(vector loc = cInvalidVector)
{
   float retVal = 0.0;
   static int enemyPointQuery = -1;
  
   if (enemyPointQuery < 0)
   {
      enemyPointQuery = kbUnitQueryCreate("Enemy Point query");
      kbUnitQuerySetIgnoreKnockedOutUnits(enemyPointQuery, true);
      kbUnitQuerySetPlayerRelation(enemyPointQuery, cPlayerRelationEnemyNotGaia);
      kbUnitQuerySetState(enemyPointQuery, cUnitStateABQ);
      kbUnitQuerySetUnitType(enemyPointQuery, cUnitTypeLogicalTypeLandMilitary);
   }

   kbUnitQuerySetUnitType(enemyPointQuery, cUnitTypeLogicalTypeLandMilitary);
   kbUnitQuerySetPosition(enemyPointQuery, loc);
   kbUnitQuerySetMaximumDistance(enemyPointQuery, 50.0);
   kbUnitQueryResetResults(enemyPointQuery);
   retVal = kbUnitQueryExecute(enemyPointQuery);

   kbUnitQuerySetUnitType(enemyPointQuery, cUnitTypeTownCenter);
   kbUnitQueryResetResults(enemyPointQuery);
   retVal = retVal + 10.0 * kbUnitQueryExecute(enemyPointQuery);  // Each TC counts as 5 units
   
   kbUnitQuerySetUnitType(enemyPointQuery, cUnitTypeFortFrontier);
   kbUnitQueryResetResults(enemyPointQuery);
   retVal = retVal + 10.0 * kbUnitQueryExecute(enemyPointQuery);  // Each fort counts as 10 units
   
   kbUnitQuerySetUnitType(enemyPointQuery, cUnitTypeOutpost);
   kbUnitQueryResetResults(enemyPointQuery);
   retVal = retVal + 3.0 * kbUnitQueryExecute(enemyPointQuery);  // Each tower counts as 3 units
   
   kbUnitQuerySetUnitType(enemyPointQuery, cUnitTypeBlockhouse);
   kbUnitQueryResetResults(enemyPointQuery);
   retVal = retVal + 3.0 * kbUnitQueryExecute(enemyPointQuery);  // Each blockhouse counts as 3 units 
   
   kbUnitQuerySetUnitType(enemyPointQuery, cUnitTypeWarHut);
   kbUnitQueryResetResults(enemyPointQuery);
   retVal = retVal + 3.0 * kbUnitQueryExecute(enemyPointQuery);  // Each war hut counts as 3 units 
   
   kbUnitQuerySetUnitType(enemyPointQuery, cUnitTypeYPOutpostAsian);
   kbUnitQueryResetResults(enemyPointQuery);
   retVal = retVal + 1.0 * kbUnitQueryExecute(enemyPointQuery);  // Each Asian outpost counts as 3 units
   
   kbUnitQuerySetUnitType(enemyPointQuery, cUnitTypeTradingPost);
   kbUnitQueryResetResults(enemyPointQuery);
   retVal = retVal + 1.0 * kbUnitQueryExecute(enemyPointQuery);  // Each trading post counts as 5 units (Advanced TP suspected!)
   
   kbUnitQuerySetUnitType(enemyPointQuery, cUnitTypeNoblesHut);
   kbUnitQueryResetResults(enemyPointQuery);
   retVal = retVal + 4.0 * kbUnitQueryExecute(enemyPointQuery);  // Each nobles hut counts as 5 units 
   
   kbUnitQuerySetUnitType(enemyPointQuery, cUnitTypeypWIAgraFort2);
   kbUnitQueryResetResults(enemyPointQuery);
   retVal = retVal + 7.0 * kbUnitQueryExecute(enemyPointQuery);  // An agra fort counts as 5 units 
   
   kbUnitQuerySetUnitType(enemyPointQuery, cUnitTypeypWIAgraFort3);
   kbUnitQueryResetResults(enemyPointQuery);
   retVal = retVal + 7.0 * kbUnitQueryExecute(enemyPointQuery);  // An agra fort counts as 5 units 
   
   kbUnitQuerySetUnitType(enemyPointQuery, cUnitTypeypWIAgraFort4);
   kbUnitQueryResetResults(enemyPointQuery);
   retVal = retVal + 7.0 * kbUnitQueryExecute(enemyPointQuery);  // An agra fort counts as 5 units 
   
   kbUnitQuerySetUnitType(enemyPointQuery, cUnitTypeypWIAgraFort5);
   kbUnitQueryResetResults(enemyPointQuery);
   retVal = retVal + 7.0 * kbUnitQueryExecute(enemyPointQuery);  // An agra fort counts as 5 units 
   
   kbUnitQuerySetUnitType(enemyPointQuery, cUnitTypeypCastle);
   kbUnitQueryResetResults(enemyPointQuery);
   retVal = retVal + 5.0 * kbUnitQueryExecute(enemyPointQuery);  // Each castle counts as 5 units 
   
   kbUnitQuerySetUnitType(enemyPointQuery, cUnitTypedeKallanka);
   kbUnitQueryResetResults(enemyPointQuery);
   retVal = retVal + 5.0 * kbUnitQueryExecute(enemyPointQuery);  // Each castle counts as 5 units 
   
   kbUnitQuerySetUnitType(enemyPointQuery, cUnitTypedeIncaStronghold);
   kbUnitQueryResetResults(enemyPointQuery);
   retVal = retVal + 7.0 * kbUnitQueryExecute(enemyPointQuery);  // Each castle counts as 5 units 
   
   kbUnitQuerySetUnitType(enemyPointQuery, cUnitTypeLogicalTypeLandMilitary);
   kbUnitQueryResetResults(enemyPointQuery);
   retVal = retVal + 1.0 * kbUnitQueryExecute(enemyPointQuery);  // Each castle counts as 5 units 
   
     
   if (retVal < 1.0)
      retVal = 1.0;  // Return at least 1.
   return(retVal);
}

// Calculate an approximate strength rating for the allied units/buildings near this point.
float getPointAllyStrength(vector loc = cInvalidVector)
{
   float retVal = 0.0;
   static int allyPointQuery = -1;
  
   if (allyPointQuery < 0)
   {
      allyPointQuery = kbUnitQueryCreate("Ally Point query 2");
      kbUnitQuerySetIgnoreKnockedOutUnits(allyPointQuery, true);
      kbUnitQuerySetPlayerRelation(allyPointQuery, cPlayerRelationAlly);
      kbUnitQuerySetState(allyPointQuery, cUnitStateABQ);
      kbUnitQuerySetUnitType(allyPointQuery, cUnitTypeLogicalTypeLandMilitary);
   }
   
   kbUnitQuerySetUnitType(allyPointQuery, cUnitTypeLogicalTypeLandMilitary);
   kbUnitQuerySetPosition(allyPointQuery, loc);
   kbUnitQuerySetMaximumDistance(allyPointQuery, 50.0);
   kbUnitQueryResetResults(allyPointQuery);
   retVal = kbUnitQueryExecute(allyPointQuery);

   kbUnitQuerySetUnitType(allyPointQuery, cUnitTypeTownCenter);
   kbUnitQueryResetResults(allyPointQuery);
   retVal = retVal + 10.0 * kbUnitQueryExecute(allyPointQuery);  // Each TC counts as 5 units
   
   kbUnitQuerySetUnitType(allyPointQuery, cUnitTypeFortFrontier);
   kbUnitQueryResetResults(allyPointQuery);
   retVal = retVal + 10.0 * kbUnitQueryExecute(allyPointQuery);  // Each fort counts as 10 units

   kbUnitQuerySetUnitType(allyPointQuery, cUnitTypeOutpost);
   kbUnitQueryResetResults(allyPointQuery);
   retVal = retVal + 3.0 * kbUnitQueryExecute(allyPointQuery);  // Each tower counts as 3 units 
   
   kbUnitQuerySetUnitType(allyPointQuery, cUnitTypeBlockhouse);
   kbUnitQueryResetResults(allyPointQuery);
   retVal = retVal + 3.0 * kbUnitQueryExecute(allyPointQuery);  // Each blockhouse counts as 3 units 

   kbUnitQuerySetUnitType(allyPointQuery, cUnitTypeWarHut);
   kbUnitQueryResetResults(allyPointQuery);
   retVal = retVal + 3.0 * kbUnitQueryExecute(allyPointQuery);  // Each war hut counts as 3 units 

   kbUnitQuerySetUnitType(allyPointQuery, cUnitTypeNoblesHut);
   kbUnitQueryResetResults(allyPointQuery);
   retVal = retVal + 4.0 * kbUnitQueryExecute(allyPointQuery);  // Each nobles hut counts as 5 units 

   kbUnitQuerySetUnitType(allyPointQuery, cUnitTypeypWIAgraFort2);
   kbUnitQueryResetResults(allyPointQuery);
   retVal = retVal + 7.0 * kbUnitQueryExecute(allyPointQuery);  // An agra fort counts as 5 units 
   
   kbUnitQuerySetUnitType(allyPointQuery, cUnitTypeypWIAgraFort3);
   kbUnitQueryResetResults(allyPointQuery);
   retVal = retVal + 7.0 * kbUnitQueryExecute(allyPointQuery);  // An agra fort counts as 5 units 
   
   kbUnitQuerySetUnitType(allyPointQuery, cUnitTypeypWIAgraFort4);
   kbUnitQueryResetResults(allyPointQuery);
   retVal = retVal + 7.0 * kbUnitQueryExecute(allyPointQuery);  // An agra fort counts as 5 units 
   
   kbUnitQuerySetUnitType(allyPointQuery, cUnitTypeypWIAgraFort5);
   kbUnitQueryResetResults(allyPointQuery);
   retVal = retVal + 7.0 * kbUnitQueryExecute(allyPointQuery);  // An agra fort counts as 5 units 
   
   kbUnitQuerySetUnitType(allyPointQuery, cUnitTypeypCastle);
   kbUnitQueryResetResults(allyPointQuery);
   retVal = retVal + 4.0 * kbUnitQueryExecute(allyPointQuery);  // Each castle counts as 5 units 
   
   kbUnitQuerySetUnitType(allyPointQuery, cUnitTypeYPOutpostAsian);
   kbUnitQueryResetResults(allyPointQuery);
   retVal = retVal + 1.0 * kbUnitQueryExecute(allyPointQuery);  // Each Asian outpost counts as 3 units

   kbUnitQuerySetUnitType(allyPointQuery, cUnitTypeTradingPost);
   kbUnitQueryResetResults(allyPointQuery);
   retVal = retVal + 1.0 * kbUnitQueryExecute(allyPointQuery);  // Each trading post counts as 5 units (Advanced TP suspected!)
   
   if (retVal < 1.0)
      retVal = 1.0;  // Return at least 1.
   return(retVal);
}



// Calculate an approximate value for this base.
float getBaseValue(int baseID = -1)
{
   float retVal = 0.0;
   int owner = kbBaseGetOwner(baseID);
   int relation = -1;
   
   if (baseID < 0)
      return(-1.0);
   
   if (owner <= 0)
      return(-1.0);
   
   if (kbIsPlayerAlly(owner) == true)
      relation = cPlayerRelationAlly;
   else
      relation = cPlayerRelationEnemyNotGaia;
   
   //retVal = retVal + (100.0 * kbBaseGetNumberUnits(owner, baseID, relation, cUnitTypeLogicalTypeBuildingsNotWalls));
   //retVal = retVal + (2.0 * kbBaseGetNumberUnits(owner, baseID, relation, gWallnonp));
   retVal = retVal + (500.0 * kbBaseGetNumberUnits(owner, baseID, relation, cUnitTypeTownCenter));  // 1000 points extra per TC
   retVal = retVal + (200.0 * kbBaseGetNumberUnits(owner, baseID, relation, cUnitTypeFortFrontier));  // 2000 points extra per fort
   retVal = retVal + (100.0 * kbBaseGetNumberUnits(owner, baseID, relation, cUnitTypeLogicalTypeLandMilitary)); // 150 points per soldier
   retVal = retVal + (625.0 * kbBaseGetNumberUnits(owner, baseID, relation, cUnitTypeCoureur));  // 200 points per coureur
   retVal = retVal + (625.0 * kbBaseGetNumberUnits(owner, baseID, relation, cUnitTypeCoureurCree));  // 200 points per cree coureur
   retVal = retVal + (500.0 * kbBaseGetNumberUnits(owner, baseID, relation, cUnitTypeSettler));  // 200 points per settler
   retVal = retVal + (500.0 * kbBaseGetNumberUnits(owner, baseID, relation, cUnitTypeSettlerNative));  // 200 points per native settler
   retVal = retVal + (500.0 * kbBaseGetNumberUnits(owner, baseID, relation, cUnitTypeypSettlerAsian));  // 200 points per Asian settler
   retVal = retVal + (500.0 * kbBaseGetNumberUnits(owner, baseID, relation, cUnitTypeypSettlerIndian));  // 200 points per Indian settler
   retVal = retVal + (500.0 * kbBaseGetNumberUnits(owner, baseID, relation, cUnitTypeypSettlerJapanese));  // 200 points per Japanese settler
   retVal = retVal + (1000.0 * kbBaseGetNumberUnits(owner, baseID, relation, cUnitTypeSettlerWagon));  // 300 points per settler wagon
   retVal = retVal + (10000.0 * kbBaseGetNumberUnits(owner, baseID, relation, cUnitTypeTradingPost));  // 1000 points per trading post
   retVal = retVal + (2000.0 * kbBaseGetNumberUnits(owner, baseID, relation, cUnitTypeFactory));  // 3000 points extra per factory
   retVal = retVal + (2000.0 * kbBaseGetNumberUnits(owner, baseID, relation, cUnitTypeBank));  // 1000 points extra per bank
   
   retVal = retVal + (200.0 * kbBaseGetNumberUnits(owner, baseID, relation, gBarracksUnit));
   retVal = retVal + (200.0 * kbBaseGetNumberUnits(owner, baseID, relation, gStableUnit));
   retVal = retVal + (200.0 * kbBaseGetNumberUnits(owner, baseID, relation, gArtilleryDepotUnit));
   retVal = retVal + (200.0 * kbBaseGetNumberUnits(owner, baseID, relation, cUnitTypeNoblesHut));
   retVal = retVal + (200.0 * kbBaseGetNumberUnits(owner, baseID, relation, cUnitTypedeKallanka));
   retVal = retVal + (200.0 * kbBaseGetNumberUnits(owner, baseID, relation, cUnitTypedeIncaStronghold));
   retVal = retVal + (1000.0 * kbBaseGetNumberUnits(owner, baseID, relation, cUnitTypeypShrineJapanese));
   retVal = retVal + (1000.0 * kbBaseGetNumberUnits(owner, baseID, relation, cUnitTypedeHouseInca)); 
   retVal = retVal + (1000.0 * kbBaseGetNumberUnits(owner, baseID, relation, cUnitTypedeTorp));   // 300 points extra per Shrine
   retVal = retVal + (2000.0 * kbBaseGetNumberUnits(owner, baseID, relation, cUnitTypeAbstractWonder));  // 3000 points extra per wonder
   retVal = retVal + (200.0 * kbBaseGetNumberUnits(owner, baseID, relation, cUnitTypeypDojo));  // 300 points extra per dojo
   
   retVal = retVal + (200.0 * kbBaseGetNumberUnits(owner, baseID, relation, cUnitTypeMill));  // 200 points extra per mill
   retVal = retVal + (200.0 * kbBaseGetNumberUnits(owner, baseID, relation, cUnitTypeFarm));  // 200 points extra per farm
   retVal = retVal + (200.0 * kbBaseGetNumberUnits(owner, baseID, relation, cUnitTypeypRicePaddy));  // 200 points extra per rice paddy
   retVal = retVal + (200.0 * kbBaseGetNumberUnits(owner, baseID, relation, cUnitTypePlantation));  // 600 points extra per plantation

   if (retVal < 1.0)
      retVal = 1.0;  // Return at least 1.
   return(retVal);
}


// Calculate an approximate value for the playerRelation units/buildings near this point.
// I.e. if playerRelation is enemy, calculate strength of enemy units and buildings.
float getPointValue(vector loc = cInvalidVector, int relation = cPlayerRelationEnemyNotGaia)
{
   float retVal = 0.0;
   static int allyQuery = -1;
   static int enemyQuery = -1;
   int queryID = -1; // Use either enemy or ally query as needed.
   
   if (allyQuery < 0)
   {
      allyQuery = kbUnitQueryCreate("Ally point value query");
      kbUnitQuerySetIgnoreKnockedOutUnits(allyQuery, true);
      kbUnitQuerySetPlayerRelation(allyQuery, cPlayerRelationAlly);
      kbUnitQuerySetState(allyQuery, cUnitStateABQ);
   }

   if (enemyQuery < 0)
   {
      enemyQuery = kbUnitQueryCreate("Enemy point value query");
      kbUnitQuerySetIgnoreKnockedOutUnits(enemyQuery, true);
      kbUnitQuerySetPlayerRelation(enemyQuery, cPlayerRelationEnemyNotGaia);
      kbUnitQuerySetSeeableOnly(enemyQuery, true);
      kbUnitQuerySetState(enemyQuery, cUnitStateAlive);
   }   
   
   if ( (relation == cPlayerRelationEnemy) || (relation == cPlayerRelationEnemyNotGaia) )
      queryID = enemyQuery;
   else
      queryID = allyQuery;
   
   kbUnitQueryResetResults(queryID);
   /*
   kbUnitQuerySetUnitType(queryID, cUnitTypeLogicalTypeBuildingsNotWalls);
   kbUnitQueryResetResults(queryID);
   retVal = 100.0 * kbUnitQueryExecute(queryID);   // 200 points per building
   
   kbUnitQuerySetUnitType(queryID, gWallnonp);
   kbUnitQueryResetResults(queryID);
   retVal = 2.0 * kbUnitQueryExecute(queryID);   // 200 points per building
   */
   kbUnitQuerySetUnitType(queryID, cUnitTypeTownCenter);
   kbUnitQueryResetResults(queryID);
   retVal = retVal + 500.0 * kbUnitQueryExecute(queryID);  // Extra 1000 per TC
   
   kbUnitQuerySetUnitType(queryID, cUnitTypeFortFrontier);
   kbUnitQueryResetResults(queryID);
   retVal = retVal + 200.0 * kbUnitQueryExecute(queryID);  // Extra 1000 per TC
   
   kbUnitQuerySetUnitType(queryID, cUnitTypeTradingPost);
   kbUnitQueryResetResults(queryID);
   retVal = retVal + 10000.0 * kbUnitQueryExecute(queryID);  // Extra 1000 per trading post
   
   kbUnitQuerySetUnitType(queryID, cUnitTypeFactory);
   kbUnitQueryResetResults(queryID);
   retVal = retVal + 2000.0 * kbUnitQueryExecute(queryID);  // Extra 800 per factory

   kbUnitQuerySetUnitType(queryID, cUnitTypePlantation);
   kbUnitQueryResetResults(queryID);
   retVal = retVal + 100.0 * kbUnitQueryExecute(queryID);  // Extra 600 per plantation

   kbUnitQuerySetUnitType(queryID, cUnitTypeBank);
   kbUnitQueryResetResults(queryID);
   retVal = retVal + 2000.0 * kbUnitQueryExecute(queryID);  // Extra 300 per bank
   
   kbUnitQuerySetUnitType(queryID, cUnitTypeMill);
   kbUnitQueryResetResults(queryID);
   retVal = retVal + 200.0 * kbUnitQueryExecute(queryID);  // Extra 200 per mill
   
   kbUnitQuerySetUnitType(queryID, cUnitTypeFarm);
   kbUnitQueryResetResults(queryID);
   retVal = retVal + 200.0 * kbUnitQueryExecute(queryID);  // Extra 200 per farm
   
   kbUnitQuerySetUnitType(queryID, cUnitTypeypRicePaddy);
   kbUnitQueryResetResults(queryID);
   retVal = retVal + 200.0 * kbUnitQueryExecute(queryID);  // Extra 200 per rice paddy
   
   kbUnitQuerySetUnitType(queryID, cUnitTypeSPCXPMiningCamp);
   kbUnitQueryResetResults(queryID);
   retVal = retVal + 5000.0 * kbUnitQueryExecute(queryID);  // Extra 1000 per SPC mining camp for XPack scenario
      
   kbUnitQuerySetUnitType(queryID, cUnitTypeLogicalTypeLandMilitary);
   kbUnitQueryResetResults(queryID);
   retVal = retVal + 100.0 * kbUnitQueryExecute(queryID);  // 200 per unit.
   
   
   kbUnitQuerySetUnitType(queryID, cUnitTypeSettler);
   kbUnitQueryResetResults(queryID);
   retVal = retVal + 500.0 * kbUnitQueryExecute(queryID); 
   
   kbUnitQuerySetUnitType(queryID, cUnitTypeSettlerNative);
   kbUnitQueryResetResults(queryID);
   retVal = retVal + 500.0 * kbUnitQueryExecute(queryID); 
   
   kbUnitQuerySetUnitType(queryID, cUnitTypeypSettlerAsian);
   kbUnitQueryResetResults(queryID);
   retVal = retVal + 500.0 * kbUnitQueryExecute(queryID); 
   
   kbUnitQuerySetUnitType(queryID, cUnitTypeypSettlerJapanese);
   kbUnitQueryResetResults(queryID);
   retVal = retVal + 500.0 * kbUnitQueryExecute(queryID); 
   
   kbUnitQuerySetUnitType(queryID, cUnitTypeypSettlerIndian);
   kbUnitQueryResetResults(queryID);
   retVal = retVal + 500.0 * kbUnitQueryExecute(queryID); 
   
   kbUnitQuerySetUnitType(queryID, cUnitTypeSettlerWagon);
   kbUnitQueryResetResults(queryID);
   retVal = retVal + 1000.0 * kbUnitQueryExecute(queryID); 
   
   kbUnitQuerySetUnitType(queryID, cUnitTypeCoureur);
   kbUnitQueryResetResults(queryID);
   retVal = retVal + 625.0 * kbUnitQueryExecute(queryID); 
   
   kbUnitQuerySetUnitType(queryID, cUnitTypeCoureurCree);
   kbUnitQueryResetResults(queryID);
   retVal = retVal + 625.0 * kbUnitQueryExecute(queryID); 
   
   kbUnitQuerySetUnitType(queryID, cUnitTypeypShrineJapanese);
   kbUnitQueryResetResults(queryID);
   retVal = retVal + 1000.0 * kbUnitQueryExecute(queryID); 
   
   kbUnitQuerySetUnitType(queryID, cUnitTypedeHouseInca);
   kbUnitQueryResetResults(queryID);
   retVal = retVal + 1000.0 * kbUnitQueryExecute(queryID); 
   
   kbUnitQuerySetUnitType(queryID, cUnitTypedeTorp);
   kbUnitQueryResetResults(queryID);
   retVal = retVal + 1000.0 * kbUnitQueryExecute(queryID); 
   
   kbUnitQuerySetUnitType(queryID, cUnitTypeypDojo);
   kbUnitQueryResetResults(queryID);
   retVal = retVal + 200.0 * kbUnitQueryExecute(queryID); 
   
   kbUnitQuerySetUnitType(queryID, gBarracksUnit);
   kbUnitQueryResetResults(queryID);
   retVal = retVal + 200.0 * kbUnitQueryExecute(queryID); 
   
   kbUnitQuerySetUnitType(queryID, gStableUnit);
   kbUnitQueryResetResults(queryID);
   retVal = retVal + 200.0 * kbUnitQueryExecute(queryID); 
   
   kbUnitQuerySetUnitType(queryID, gArtilleryDepotUnit);
   kbUnitQueryResetResults(queryID);
   retVal = retVal + 200.0 * kbUnitQueryExecute(queryID); 
   
   kbUnitQuerySetUnitType(queryID, cUnitTypeNoblesHut);
   kbUnitQueryResetResults(queryID);
   retVal = retVal + 200.0 * kbUnitQueryExecute(queryID); 
   
   kbUnitQuerySetUnitType(queryID, cUnitTypedeKallanka);
   kbUnitQueryResetResults(queryID);
   retVal = retVal + 200.0 * kbUnitQueryExecute(queryID); 
   
   kbUnitQuerySetUnitType(queryID, cUnitTypedeIncaStronghold);
   kbUnitQueryResetResults(queryID);
   retVal = retVal + 200.0 * kbUnitQueryExecute(queryID); 
   
   kbUnitQuerySetUnitType(queryID, cUnitTypeAbstractWonder);
   kbUnitQueryResetResults(queryID);
   retVal = retVal + 2000.0 * kbUnitQueryExecute(queryID); 
	

   if (retVal < 1.0)
      retVal = 1.0;
      
   return(retVal);
}

//==============================================================================
// Called for each opportunity that needs to be scored.
//==============================================================================
void scoreOpportunity(int oppID = -1)
{
   /*
   
   Sets all the scoring components for the opportunity, and a final score.  The scoring
   components and their meanings are:
   
   int PERMISSION  What level of permission is needed to do this?  
      cOpportunitySourceAutoGenerated is the lowest...go ahead and do it.
      cOpportunitySourceAllyRequest...the AI may not do it on its own, i.e. it may be against the rules for this difficulty.
      cOpportunitySourceTrigger...even ally requests are denied, as when prevented by control variables, but a trigger (gaia request) may do it.
      cOpportunitySourceTrigger+1...not allowed at all.
   
   float AFFORDABLE  Do I have what it takes to do this?  This includes appropriate army sizes, resources to pay for things (like trading posts)
      and required units like explorers.  0.80 indicates a neutral, good-to-go position.  1.0 means overstock, i.e. an army of 20 would be good, 
      and I have 35 units available.  0.5 means extreme shortfall, like the minimum you could possibly imagine.  0.0 means you simply can't do it,
      like no units at all.  Budget issues like amount of wood should never score below 0.5, scores below 0.5 mean deep, profound problems.
   
   int SOURCE  Who asked for this mission?  Uses the cOpportunitySource... constants above.
   
   float CLASS  How much do we want to do this type of mission?   Based on personality, how long it's been since the last mission of this type, etc.
      0.8 is a neutral, "this is a good mission" rating.  1.0 is extremely good, I really, really want to do this next.  0.5 is a poor score.  0.0 means 
      I just flat can't do it.  This class score will creep up over time for most classes, to make sure they get done once in a while.
   
   float INSTANCE  How good is this particular target?  Includes asset value (is it important to attack or defend this?) and distance.  Defense values
      are incorporated in the AFFORDABLE calculation above.  0.0 is no value, this target can't be attacked.  0.8 is a good solid target.  1.0 is a dream target.
   
   float TOTAL  Incorporates AFFORDABLE, CLASS and INSTANCE by multiplying them together, so a zero in any one sets total to zero.  Source is added as an int
      IF AND ONLY IF SOURCE >= PERMISSION.  If SOURCE < PERMISSION, the total is set to -1.  Otherwise, all ally source opportunities will outrank all self generated
      opportunities, and all trigger-generated opportunities will outrank both of those.  Since AFFORDABLE, CLASS and INSTANCE all aim for 0.8 as a good, solid
      par value, a total score of .5 is rougly "pretty good".  A score of 1.0 is nearly impossible and should be quite rare...a high-value target, weakly defended,
      while I have a huge army and the target is close to me and we haven't done one of those for a long, long time.  
   
   Total of 0.0 is an opportunity that should not be serviced.  >0 up to 1 indicates a self-generated opportunity, with 0.5 being decent, 1.0 a dream, and 0.2 kind
   of marginal.  Ally commands are in the range 1.0 to 2.0 (unless illegal), and triggers score 2.0 to 3.0.
   
   */
   	
   // Interim values for the scoring components:
   int  permission = 0; 
   float instance = 0.0;
   float classRating = 0.0;
   float total = 0.0;
   float affordable = 0.0;
   float score = 0.0;
   
   // Info about this opportunity
   int source = aiGetOpportunitySourceType(oppID);
   if (source < 0) 
      source = cOpportunitySourceAutoGenerated;
   if (source > cOpportunitySourceTrigger)
      source = cOpportunitySourceTrigger;
   int target = aiGetOpportunityTargetID(oppID);
   int targetType = aiGetOpportunityTargetType(oppID);
   int oppType = aiGetOpportunityType(oppID);
   int targetPlayer = aiGetOpportunityTargetPlayerID(oppID);
   int mostHatedPlayerID = aiGetMostHatedPlayerID(); // Get to the most hated player to attack
   vector location = aiGetOpportunityLocation(oppID);
   float radius = aiGetOpportunityRadius(oppID);
   if (radius < 50.0)
      radius = 50.0;
   int baseOwner = -1;
   float baseEnemyPower = 0.0;   // Used to measure troop and building strength.  Units roughly equal to unit count of army.
   float baseAllyPower = 0.0;    // Strength of allied buildings and units, roughly equal to unit count.
   float netEnemyPower = 0.0;    // Basically enemy minus ally, but the ally effect can, at most, cut 80% of enemy strength
   float baseAssets = 0.0;    // Rough estimate of base value, in aiCost.  
   float affordRatio = 0.0;
   bool  errorFound = false;  // Set true if we can't do a good score.  Ends up setting score to -1.

   // Variables for available number of units and plan to kill if any
   float armySizeAuto = 0.0;  // For source cOpportunitySourceAutoGenerated
   float armySizeAlly = 0.0;  // For ally-generated commands, how many units could we scrounge up?
   int missionToKillAlly = -1;   // Mission to cancel in order to provide the armySizeAlly number of units.  
   float armySizeTrigger = 0.0;  // For trigger-generated commands, how many units could we scrounge up?
   int missionToKillTrigger = -1;   // Mission to cancel in order to provide the armySizeTrigger number of units.
   float armySize = 0.0;      // The actual army size we'll use for calcs, depending on how big the target is.
   float missionToKill = -1;  // The actual mission to kill based on the army size we've selected.
   
   float oppDistance = 0.0;      // Distance to target location or base.
   bool  sameAreaGroup = true;   // Set false if opp is on another areagroup.

   bool defendingMonopoly = false;
   bool attackingMonopoly = false;
   int  tradePostID = -1;     // Set to trade post ID if this is a base target, and a trade post is nearby.
   
   bool defendingKOTH = false;
   bool attackingKOTH = false;
   int  KOTHID = -1;     // Set to the hill ID if this is a base target, and the hill is nearby.

   if (gIsMonopolyRunning == true)
   {
      //if (gMonopolyTeam == kbGetPlayerTeam(cMyID))
      //   defendingMonopoly = true;  // We're defending, let's not go launching any attacks
      //else
         attackingMonopoly = true;  // We're attacking, focus on trade posts
   }
   
   if (gIsKOTHRunning == true)
   {
      if (gKOTHTeam == kbGetPlayerTeam(cMyID))
         defendingKOTH = true;  // We're defending, let's not go launching any attacks
      else
         attackingKOTH = true;  // We're attacking, focus on the hill
   }

   //-- get the number of units in our reserve.
   armySizeAuto = aiPlanGetNumberUnits(gLandReservePlan, cUnitTypeLogicalTypeLandMilitary);
   armySizeAlly = armySizeAuto;
   armySizeTrigger = armySizeAlly;
   
//   aiEcho(" ");
//   aiEcho("Scoring opportunity "+oppID+", targetID "+target+", location "+location);
   
   // Get target info
  switch(targetType)
   {
      case cOpportunityTargetTypeBase:
      {
         location = kbBaseGetLocation(kbBaseGetOwner(target),target);
         //loc = kbBaseGetLocation(mostHatedPlayerID, kbBaseGetMainID(mostHatedPlayerID));
         tradePostID = getUnitByLocation(cUnitTypeTradingPost, kbBaseGetOwner(target), cUnitStateAlive, location, 40.0);   
         KOTHID = getUnitByLocation(cUnitTypeypKingsHill, kbBaseGetOwner(target), cUnitStateAlive);//, location, 40.0);   
         radius = 50.0;
         baseOwner = kbBaseGetOwner(target);
         baseEnemyPower = getBaseEnemyStrength(target);  // Calculate "defenses" as enemy units present
         baseAllyPower = getPointAllyStrength(kbBaseGetLocation(kbBaseGetOwner(target),target));
         if ( (baseEnemyPower*0.8) > baseAllyPower)   
            netEnemyPower = baseEnemyPower - baseAllyPower;   // Ally power is less than 80% of enemy
         else
            netEnemyPower = baseEnemyPower * 0.2;  // Ally power is more then 80%, but leave a token enemy rating anyway.
          /*  
         baseAssets = getBaseValue(target);  //  Rough value of target
         if ( (gIsMonopolyRunning == true) && (tradePostID >= 0) )
            baseAssets = baseAssets + 10000; // Huge bump if this is a trade post (enemy or ally) and a monopoly is running            
         if ( (gIsKOTHRunning == true) && (KOTHID >= 0) )
            baseAssets = baseAssets + 10000; // Huge bump if this is the hill (enemy or ally) and a timer is running 
         if (mostHatedPlayerID >= 0) 
            baseAssets = baseAssets + 4000; 
         break;				
		  */
         baseAssets = getBaseValue(target);  //  Rough value of target
         if ( (gIsMonopolyRunning == true) && (tradePostID >= 0) )
            baseAssets = baseAssets + 100000; // Huge bump if this is a trade post (enemy or ally) and a monopoly is running            
         if ( (gIsKOTHRunning == true) && (KOTHID >= 0) )
            baseAssets = baseAssets + 100000; // Huge bump if this is the hill (enemy or ally) and a timer is running 
         if ((mostHatedPlayerID >= 0) && (baseAssets >= 100))
            baseAssets = baseAssets + 4000;         		
         break;
      }
      case cOpportunityTargetTypePointRadius:
      {
         baseEnemyPower = getPointEnemyStrength(location);
         baseAllyPower = getPointAllyStrength(location);
         if ( (baseEnemyPower*0.8) > baseAllyPower)   
            netEnemyPower = baseEnemyPower - baseAllyPower;   // Ally power is less than 80% of enemy
         else
            netEnemyPower = baseEnemyPower * 0.2;  // Ally power is more then 80%, but leave a token enemy rating anyway.
            
         baseAssets = getPointValue(location);  //  Rough value of target
         break;
      }
      case cOpportunityTargetTypeVPSite:     // This is only for CLAIM missions.  A VP site that is owned will be a 
                                             // defend or destroy opportunity.
      {
         location = kbVPSiteGetLocation(target);
         radius = 50.0;
         
         baseEnemyPower = getPointEnemyStrength(location);
         baseAllyPower = getPointAllyStrength(location);
         if ( (baseEnemyPower*0.8) > baseAllyPower)   
            netEnemyPower = baseEnemyPower - baseAllyPower;   // Ally power is less than 80% of enemy
         else
            netEnemyPower = baseEnemyPower * 0.2;  // Ally power is more then 80%, but leave a token enemy rating anyway.
        
         baseAssets = 10000.0;    // Arbitrary...consider a claimable VP Site as worth 2000 resources.
         break;
      }
   }
   
   if (netEnemyPower < 1.0)
      netEnemyPower = 1.0;   // Avoid div 0
   
   oppDistance = distance(location, kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)));
   if (oppDistance <= 0.0)
      oppDistance = 1.0;
   if ( kbAreaGroupGetIDByPosition(location) != kbAreaGroupGetIDByPosition(kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID))) )
      sameAreaGroup = false;
   
   
   // Figure which armySize to use.  This currently is a placeholder, we may not need to mess with it.
   armySize = armySizeAuto;   // Default

//   aiEcho("    EnemyPower "+baseEnemyPower+", AllyPower "+baseAllyPower+", NetEnemyPower "+netEnemyPower);
//   aiEcho("    BaseAssets "+baseAssets+", myArmySize "+armySize);
   
   switch(oppType)
   {
      case cOpportunityTypeDestroy:
      {
         // Check permissions required.
         if(cvOkToAttack == false)
            permission = cOpportunitySourceTrigger;   // Only triggers can make us attack.
         
         if (gDelayAttacks == true)
            permission = cOpportunitySourceTrigger;   // Only triggers can override this difficulty setting.
         
         // Check affordability
         
         if (netEnemyPower < 0.0)
         {
            errorFound = true;
            affordable = 0.0;
         }
         else
         {
            // Set affordability.  Roughly armySize / baseEnemyPower, but broken into ranges.
            // 0.0 is no-can-do, i.e. no troops.  0.8 is "good", i.e. armySize is double baseEnemyPower.  
            // Above a 2.0 ratio, to 5.0, scale this into the 0.8 to 1.0 range.
            // Above 5.0, score it 1.0
            affordRatio = armySize / netEnemyPower;
            if (affordRatio < 2.0)
               affordable = affordRatio / 2.5;  // 0 -> 0.0,  2.0 -> 0.8
            else
               affordable = 0.8 + ((affordRatio - 2.0) / 15.0); // 2.0 -> 0.8 and 5.0 -> 1.0
            if (affordable > 1.0)
               affordable = 1.0;
			   
			if ((kbGetAge() >= cvMaxAge) || (gRevolutionType != 0))
				affordable = 1.0;
			//{
				// we maxed out our military pop
			//if ((armySize >= 50) && (xsGetTime() - gLastAttackMissionTime) >= gAttackMissionInterval)
				//affordable = 1.0;
			//}
            //if (mostHatedPlayerID > 0)
               //affordable = 1.0;
         }  // Affordability is done
            
         // Check target value, calculate INSTANCE score.
         if (baseAssets < 0.0)
         {
            errorFound = true;
         }
         // Clip base value to range of 100 to 10K for scoring
         if (baseAssets < 100.0)
            baseAssets = 100.0;
         if (baseAssets > 10000.0)
            baseAssets = 10000.0;
         // Start with an "instance" score of 0 to .8 for bases under 2K value.
         instance = (0.8 * baseAssets) / 2000.0;
         // Over 2000, adjust so 2K = 0.8, 30K = 1.0
         if (baseAssets > 2000.0)
            instance = 1.0;
            //instance = 0.8 + ( (0.2 * (baseAssets - 2000.0)) / 8000.0);
         
		 if (baseAssets >= 100.0)
            instance = 1.0;
            //instance = ( (0.2 * (baseAssets)) / 2000.0);
			if ((baseAssets > 1.0) && (baseAssets < 100.0))// && (instance < 0.1))
			instance = 0.5;
         // Instance is now 0..1, adjust for distance. If < 100m, leave as is.  Over 100m to 400m, penalize 10% per 100m.
         float penalty = 0.0;
         /*if (oppDistance > 100.0)
            penalty = (0.1 * (oppDistance - 100.0)) / 100.0;
         if (penalty > 0.6)
            penalty = 0.6;
         instance = instance * (1.0 - penalty); // Apply distance penalty, INSTANCE score is done.
         */
         if (sameAreaGroup = false)
            instance = instance / 2.0;         
         if (targetType == cOpportunityTargetTypeBase)
         {   
            if (kbHasPlayerLost(baseOwner) == true)
               instance = -1.0;
         }
         // Illegal if it's over water, i.e. a lone dock
         if (kbAreaGetType(kbAreaGetIDByPosition(location)) == cAreaTypeWater)
            instance = -1.0;
         
         // Check for weak target blocks, which means the content designer is telling us that this target needs its instance score bumped up
         int weakBlockCount = 0;
         int strongBlockCount = 0;
         
         if ( targetType == cOpportunityTargetTypeBase)
         {
            weakBlockCount = getUnitCountByLocation(cUnitTypeAITargetBlockWeak, cMyID, cUnitStateAlive, kbBaseGetLocation(baseOwner, target), 2000.0); 
            strongBlockCount = getUnitCountByLocation(cUnitTypeAITargetBlockStrong, cMyID, cUnitStateAlive, kbBaseGetLocation(baseOwner, target), 2000.0);
         }
         if ( (targetType == cOpportunityTargetTypeBase) || (weakBlockCount > 0) || (instance >= 0.0) )
         {  // We have a valid instance score, and there is at least one weak block in the area.  For each weak block, move the instance score halfway to 1.0.
            while (weakBlockCount > 0)
            {
               instance = instance + ((1.0-instance) / 2.0);   // halfway up to 1.0
               weakBlockCount--;
            }
         }        

         classRating = 1; // getClassRating(cOpportunityTypeDestroy);   // 0 to 1.0 depending on how long it's been.
         if ( (gIsMonopolyRunning == true) && (tradePostID < 0) ) // Monopoly, and this is not a trade post site
            classRating = 0.25;
         
         if ( defendingMonopoly == true )
            classRating = 1.0;      // If defending, don't attack other targets
         
         if ( ( attackingMonopoly == true) && (tradePostID >= 0) )  // We're attacking, and this is an enemy trade post...go get it
            classRating = 1.0;
            
         if ( (gIsKOTHRunning == true) && (KOTHID < 0) ) // KOTH, and this is the hill
            classRating = 0.0;
         
         if ( defendingKOTH == true )
            classRating = 0.0;      // If defending, don't attack other targets
         
         if ( ( attackingKOTH == true) && (KOTHID >= 0) )  // We're attacking, and this is an enemy hill...go get it
            classRating = 1.0;

         if (mostHatedPlayerID > 0) // this is an enemy.....go get it
            classRating = 1.0;

         if ( (targetType == cOpportunityTargetTypeBase) || (strongBlockCount > 0) || (classRating >= 0.0) )
         {  // We have a valid instance score, and there is at least one strong block in the area.  For each weak block, move the classRating score halfway to 1.0.
            while (strongBlockCount > 0)
            {
               classRating = 1.0;   // 1.0 is perfect
               strongBlockCount--;               
            }
         }
         
         if (aiTreatyActive() == true)
            classRating = 0.0;   // Do not attack anything if under treaty
 
         break;
      }
      case cOpportunityTypeClaim:
	{
		// Check permissions required.
		if ((cvOkToClaimTrade == false) && (kbVPSiteGetType(target) == cVPTrade))
			permission = cOpportunitySourceTrigger;   // Only triggers can let us override this.
		if ((cvOkToAllyNatives == false) && (kbVPSiteGetType(target) == cVPNative))
			permission = cOpportunitySourceTrigger;   // Only triggers can let us override this.
		if (gDelayAttacks == true)     // Taking trade sites and natives is sort of aggressive, turn it off on easy/sandbox.
			permission = cOpportunitySourceTrigger;   // Only triggers can override this difficulty setting.

		 // Check affordability.  50-50 weight on military affordability and econ affordability
		float milAfford = 0.0;
		float econAfford = 0.0;
		affordRatio = armySize / netEnemyPower;
		if (kbGetAge() < cAge3)
		{
			if (affordRatio < 2.0)
				milAfford = affordRatio / 2.5;  // 0 -> 0.0,  2.0 -> 0.8
			else
				milAfford = 0.8 + ((affordRatio - 2.0) / 15.0); // 1.0 -> 0.8 and 5.0 -> 1.0
		}
		else if (kbGetAge() == cAge3)
		{
			if (affordRatio < 1.5)
				milAfford = affordRatio / 1.875;  // 0 -> 0.0,  1.5 -> 0.8
			else
				milAfford = 0.8 + ((affordRatio - 1.5) / 7.5); // 1.0 -> 0.8 and 3.0 -> 1.0        
		}
		else
		{
			if (affordRatio < 1.0)
				milAfford = affordRatio / 1.25;  // 0 -> 0.0,  1.0 -> 0.8
			else
				milAfford = 0.8 + ((affordRatio - 1.0) / 5.0); // 1.0 -> 0.8 and 2.0 -> 1.0             
		}
		if (milAfford > 1.0)
			milAfford = 1.0;
		affordRatio = kbResourceGet(cResourceWood) / (1.0 + kbUnitCostPerResource(cUnitTypeTradingPost, cResourceWood));
		if (affordRatio < 1.0)
			econAfford = affordRatio;
		else
			econAfford = 1.0;
		if (econAfford > 1.0)
			econAfford = 1.0;
		if (econAfford < 0.0)
			econAfford = 0.0;
		affordable = (econAfford + milAfford) / 2.0; // Simple average

		// Instance
		instance = 0.8;   // Same for all, unless I prefer to do one type over other (personality)
		penalty = 0.0;
		/*if (oppDistance > 100.0)
			penalty = (0.1 * (oppDistance - 100.0)) / 100.0;
		if (penalty > 0.4)
			penalty = 0.4;
		instance = instance * (1.0 - penalty); // Apply distance penalty, INSTANCE score is done.         
		*/
		if (sameAreaGroup = false)
			instance = instance / 2.0;
		classRating = getClassRating(cOpportunityTypeClaim, target);   // 0 to 1.0 depending on how long it's been.
		break;
	}
      case cOpportunityTypeRaid:
      {
         break;
      }
      case cOpportunityTypeDefend:
      {  
        
         // Check affordability
 
         if (netEnemyPower < 0.0)
         {
            errorFound = true;
            affordable = 0.0;
         }
         else
         {
            // Set affordability.  Roughly armySize / netEnemyPower, but broken into ranges.
            // Very different than attack calculations.  Score high affordability if the ally is really 
            // in trouble, especially if my army is large.  Basically...does he need help?  Can I help?
            if (baseAllyPower < 1.0)
               baseAllyPower = 1.0;
            float enemyRatio = baseEnemyPower / baseAllyPower;
            float enemySurplus = baseEnemyPower - baseAllyPower;
            if (enemyRatio < 0.5)   // Enemy very weak, not a good opp.
            {
               affordRatio = enemyRatio;  // Low score, 0 to .5
               if (enemyRatio < 0.2)
                  affordRatio = 0.0;
            }
            else
               affordRatio = 0.5 + ( (enemyRatio - 0.5) / 5.0);   // ratio 0.5 scores 0.5, ratio 3.0 scores 1.0
            if ( (affordRatio * 10.0) > enemySurplus )
               affordRatio = enemySurplus / 10.0;  // Cap the afford ratio at 1/10 the enemy surplus, i.e. don't respond if he's just outnumbered 6:5 or something trivial.
            if (enemySurplus < 0)
               affordRatio = 0.0;
            if (affordRatio > 1.0)
               affordRatio = 1.0;
            // AffordRatio now represents how badly I'm needed...now, can I make a difference
            if (armySize < enemySurplus)  // I'm gonna get my butt handed to me
               affordRatio = affordRatio * (armySize / enemySurplus);   // If I'm outnumbered 3:1, divide by 3.
            // otherwise, leave it alone.
            
            affordable = affordRatio;
			
			if ((kbGetAge() >= cvMaxAge) || (gRevolutionType != 0))
				affordable = 1.0;
         }  // Affordability is done
            
         // Check target value, calculate INSTANCE score.
         if (baseAssets < 0.0)
         {
            errorFound = true;
         }
         // Clip base value to range of 100 to 30K for scoring
         if (baseAssets < 100.0)
            baseAssets = 100.0;
         if (baseAssets > 30000.0)
            baseAssets = 30000.0;
         // Start with an "instance" score of 0 to .8 for bases under 2K value.
         instance = (0.8 * baseAssets) / 1000.0;
         // Over 1000, adjust so 1K = 0.8, 30K = 1.0
         if (baseAssets > 1000.0)
            instance = 0.8 + ( (0.2 * (baseAssets - 1000.0)) / 29000.0);
                  
			if (baseAssets > 1)// 1000.0)
            instance = 1.0;
         /*
		 // Instance is now 0..1, adjust for distance. If < 200m, leave as is.  Over 200m to 400m, penalize 10% per 100m.
         penalty = 0.0;
         if (oppDistance > 200.0)
            penalty = (0.1 * (oppDistance - 200.0)) / 100.0;
         if (penalty > 0.6)
            penalty = 0.6;
         instance = instance * (1.0 - penalty); // Apply distance penalty, INSTANCE score is done.
         */
		 if (sameAreaGroup == false)
            instance = 0.0;
         if (targetType == cOpportunityTargetTypeBase)
         {   
            if (kbHasPlayerLost(baseOwner) == true)
              instance = -1.0;
         }       
         if ( (defendingMonopoly == true) && (tradePostID >= 0) && (instance > 0.0))
            instance = instance + ((1.0 - instance)/1.2);   // Bump it almost up to 1.0 if we're defending monopoly and this is a trade site.
         if ( (defendingKOTH == true) && (KOTHID >= 0) && (instance > 0.0))
            instance = instance + ((1.0 - instance)/1.2);   // Bump it almost up to 1.0 if we're defending the hill
         classRating = 1; //getClassRating(cOpportunityTypeDefend);   // 0 to 1.0 depending on how long it's been.
         if ( (defendingMonopoly == true) && (tradePostID >= 0) ) 
            classRating = 1.0;      // No time delay for 2nd defend mission if we're defending trading posts during monopoly.
         if (attackingMonopoly == true) 
            classRating = 0.0;   // Don't defend anything if we should be attacking a monopoly!
         if ( (defendingKOTH == true) && (KOTHID >= 0) ) 
            classRating = 1.0;      // No time delay for 2nd defend mission if we're defending the hill.
         if (attackingKOTH == true) 
            classRating = 0.0;   // Don't defend anything if we should be attacking the hill!
         break;    
      }
      case cOpportunityTypeRescueExplorer:
      {
         break;
      }
      default:
      {
         aiEcho("ERROR ERROR ERROR ERROR");
         aiEcho("scoreOpportunity() failed on opportunity "+oppID);
         aiEcho("Opportunity Type is "+oppType+" (invalid)");
         break;
      }
   }
   
   score = classRating * instance * affordable;
// aiEcho("Class "+classRating+", Instance "+instance+", affordable "+affordable);
// aiEcho("Final Score: "+score);
   
   if (score > 1.0)
      score = 1.0;
   if (score < 0.0)
      score = 0.0;
      
   score = score + source; // Add 1 if from ally, 2 if from trigger.
   
   if (permission > source)
      score = -1.0;
   if (errorFound == true)
      score = -1.0;
   if (cvOkToSelectMissions == false)
      score = -1.0;
   aiSetOpportunityScore(oppID, permission, affordable, classRating, instance, score);
}

//==============================================================================
// attackManager
//==============================================================================
rule attackManager
inactive
minInterval 15
{
   static int baseQuery = -1;
   static int baseEnemyQuery = -1;
   bool defendingMonopoly = false;
   bool attackingMonopoly = false;
   bool defendingKOTH = false;
   bool attackingKOTH = false;
   int currentTime = xsGetTime();
   int numberUnits = 0;
   int numberFound = 0;
   int numberEnemyFound = 0;
   int numberBases = 0;
   int baseID = -1;
   int mainBaseID = kbBaseGetMainID(cMyID);
   vector mainBaseLocation = kbBaseGetLocation(cMyID, mainBaseID);
   int mainAreaGroup = kbAreaGroupGetIDByPosition(mainBaseLocation);
   int baseAreaGroup = -1;
   vector baseLocation = cInvalidVector;
   vector location = cInvalidVector;
   float baseDistance = 0.0;
   float armyPower = 0.0;
   float buildingPower = 0.0;
   float militaryPower = 0.0;
   float enemyMilitaryPower = 0.0;
   float affordable = 0.0;
   float baseAssets = 0.0;
   float distancePenalty = 0.0;
   float score = 0.0;
   bool isEnemy = false;
   bool isKOTH = false;
   bool isTradingPost = false;
   bool shouldAttack = false;
   int availableMilitaryPop = aiGetAvailableMilitaryPop();
   int unitID = -1;
   int puid = -1;
   float unitPower = 0.0;
   int targetBaseID = -1;
   int targetPlayer = 2;
   bool targetIsEnemy = true;
   bool targetShouldAttack = false;
   float targetAffordable = 0.0;
   float targetBaseAssets = 0.0;
   float targetDistancePenalty = 0.0;
   float targetScore = 0.0;
   float maxBaseAssets = 100.0;
   int planID = -1;


   static int enemyPointQuery = -1;  
   static int enemyPointQueryB = -1;  
   int targetID = -1;
    int targetPlayerID = -1;
    vector targetLocation = cInvalidVector;
    vector targetBaseLocation = cInvalidVector; 
    int militaryCount = kbUnitCount(cMyID, cUnitTypeLogicalTypeLandMilitary, cUnitStateAlive)-kbUnitCount(cMyID, cUnitTypexpMedicineManAztec, cUnitStateAlive)-kbUnitCount(cMyID, gSiegeWeaponUnit, cUnitStateAlive);
    float militaryEquivalence = militaryCount;
   
	enemyPointQuery = createSimpleQuery(cPlayerRelationEnemyNotGaia, cUnitTypeValidIdleVillager, cUnitStateAlive);
    kbUnitQueryResetResults(enemyPointQuery);
    int enemyVillagerCount = kbUnitQueryExecute(enemyPointQuery);
	
   	enemyPointQueryB = createSimpleQuery(cPlayerRelationEnemyNotGaia, cUnitTypeLogicalTypeBuildingsNotWalls, cUnitStateAlive);
    kbUnitQueryResetResults(enemyPointQuery);
    int enemyBuildingCount = kbUnitQueryExecute(enemyPointQuery);
   
   if (baseQuery < 0)
   {
      baseQuery = kbUnitQueryCreate("attackBaseQuery");
      kbUnitQuerySetIgnoreKnockedOutUnits(baseQuery, true);
      baseEnemyQuery = kbUnitQueryCreate("attackBaseEnemyQuery");
      kbUnitQuerySetIgnoreKnockedOutUnits(baseEnemyQuery, true);
   }

   // Don't attack under treaty or main base is under attack.
   if (aiTreatyActive() == true || gDefenseReflexBaseID == mainBaseID)
      return;

   planID = aiPlanGetIDByTypeAndVariableType(cPlanAttack, cAttackPlanBaseAttackMode, cAttackPlanBaseAttackModeExplicit);

   if (gIsMonopolyRunning == true)
   {
      if (gMonopolyTeam == kbGetPlayerTeam(cMyID))
         defendingMonopoly = true; // We're defending, let's not go launching any attacks
      else
         attackingMonopoly = true; // We're attacking, focus on trade posts
   }

   if (gIsKOTHRunning == true)
   {
      if (gKOTHTeam == kbGetPlayerTeam(cMyID))
         defendingKOTH = true; // We're defending, let's not go launching any attacks
      else
         attackingKOTH = true; // We're attacking, focus on the hill
   }

   numberUnits = aiPlanGetNumberUnits(gLandReservePlan, cUnitTypeLogicalTypeLandMilitary);

   for (i = 0; < numberUnits)
   {
      unitID = aiPlanGetUnitByIndex(gLandReservePlan, i);
      puid = kbUnitGetProtoUnitID(unitID);
      armyPower = armyPower + getMilitaryUnitStrength(puid);
   }

   // Go through all players' bases and calculate values for comparison.
   for (player = 1; < cNumberPlayers)
   {
      if (player == cMyID || kbHasPlayerLost(player) == true)
         continue;

      numberBases = kbBaseGetNumber(player);
      isEnemy = kbIsPlayerEnemy(player);

      if (isEnemy == true &&
          (cvPlayerToAttack > 0 && cvPlayerToAttack != player && kbHasPlayerLost(cvPlayerToAttack) == false))
         continue;

      for (baseIndex = 0; < numberBases)
      {
         baseID = kbBaseGetIDByIndex(player, baseIndex);
         baseLocation = kbBaseGetLocation(player, baseID);
         baseDistance = kbBaseGetDistance(player, baseID);

         kbUnitQuerySetPlayerID(baseQuery, player);
         kbUnitQuerySetState(baseQuery, cUnitStateABQ);
         kbUnitQuerySetPosition(baseQuery, baseLocation);
         kbUnitQuerySetMaximumDistance(baseQuery, baseDistance);

         kbUnitQuerySetUnitType(baseQuery, cUnitTypeHasBountyValue);
         kbUnitQueryResetResults(baseQuery);
         numberFound = kbUnitQueryExecute(baseQuery);

         buildingPower = 0.0;
         militaryPower = 0.0;
         enemyMilitaryPower = 0.0;
         baseAssets = 0.0;
         isKOTH = false;
         isTradingPost = false;
         shouldAttack = true;

         if (isEnemy == true)
         {
            if (currentTime - gLastAttackMissionTime < gAttackMissionInterval)
               shouldAttack = false;
         }
         else
         {
            if (currentTime - gLastDefendMissionTime < gDefendMissionInterval)
               shouldAttack = false;
         }

         for (i = 0; < numberFound)
         {
            unitID = kbUnitQueryGetResult(baseQuery, i);
            puid = kbUnitGetProtoUnitID(unitID);
            switch (puid)
            {
            case cUnitTypeypKingsHill:
            {
               isKOTH = true;
               break;
            }         
            case cUnitTypeTownCenter:
            {
               baseAssets = baseAssets + 50.0;
               break;
            }
            case cUnitTypeTradingPost:
            {
               location = kbUnitGetPosition(unitID);
               if (getUnitByLocation(cUnitTypeNativeSocket, 0, cUnitStateAlive, location, 10.0) >= 0)
                  baseAssets = baseAssets + 50.0;
               else // trade route trading post
                  baseAssets = baseAssets + 100.0;
               isTradingPost = true;
               break;
            }         
            // buildings generating resources
            case cUnitTypeBank:
            {
               baseAssets = baseAssets + 50.0;
               break;
            }
            case cUnitTypeFactory:
            {
               baseAssets = baseAssets + 50.0;
               break;
            }
            case cUnitTypeypWCPorcelainTower2:
            {
               baseAssets = baseAssets + 50.0;
               break;
            }   
            case cUnitTypeypWCPorcelainTower3:
            {
               baseAssets = baseAssets + 50.0;
               break;
            } 
            case cUnitTypeypWCPorcelainTower4:
            {
               baseAssets = baseAssets + 50.0;
               break;
            }             
            case cUnitTypeypWCPorcelainTower5:
            {
               baseAssets = baseAssets + 50.0;
               break;
            }    
            case cUnitTypeypShrineJapanese:
            {
               baseAssets = baseAssets + 25.0;
               break;
            }
            case cUnitTypeypWJToshoguShrine2:
            {
               baseAssets = baseAssets + 50.0;
               break;
            }
            case cUnitTypeypWJToshoguShrine3:
            {
               baseAssets = baseAssets + 50.0;
               break;
            }          
            case cUnitTypeypWJToshoguShrine4:
            {
               baseAssets = baseAssets + 50.0;
               break;
            }        
            case cUnitTypeypWJToshoguShrine5:
            {
               baseAssets = baseAssets + 50.0;
               break;
            }
            case cUnitTypedeHouseInca:
            {
               baseAssets = baseAssets + 25.0;
               break;
            }           
            case cUnitTypedeTorp:
            {
               baseAssets = baseAssets + 25.0;
               break;
            }
            case cUnitTypedeMountainMonastery:
            {
               baseAssets = baseAssets + 25.0;
               break;
            }
            case cUnitTypedeUniversity:
            {
               baseAssets = baseAssets + 25.0;
               break;
            }
            // buildings automatically creating military units
            case cUnitTypeypWCSummerPalace2:
            {
               baseAssets = baseAssets + 25.0;
               break;
            } 
            case cUnitTypeypWCSummerPalace3:
            {
               baseAssets = baseAssets + 25.0;
               break;
            }   
            case cUnitTypeypWCSummerPalace4:
            {
               baseAssets = baseAssets + 25.0;
               break;
            }          
            case cUnitTypeypWCSummerPalace5:
            {
               baseAssets = baseAssets + 25.0;
               break;
            } 
            case cUnitTypeypDojo:
            {
               baseAssets = baseAssets + 25.0;
               break;
            } 
            // buildings with HC drop off point
            case cUnitTypeFortFrontier:
            {
               baseAssets = baseAssets + 25.0;
               break;
            }
            case cUnitTypeOutpost:
            {
               baseAssets = baseAssets + 5.0;
               break;
            }
            case cUnitTypeBlockhouse:
            {
               baseAssets = baseAssets + 5.0;
               break;
            }
            case cUnitTypeNoblesHut:
            {
               baseAssets = baseAssets + 5.0;
               break;
            }
            case cUnitTypeypWIAgraFort2:
            {
               baseAssets = baseAssets + 25.0;
               break;
            }
            case cUnitTypeypWIAgraFort3:
            {
               baseAssets = baseAssets + 25.0;
               break;
            }
            case cUnitTypeypWIAgraFort4:
            {
               baseAssets = baseAssets + 25.0;
               break;
            }
            case cUnitTypeypWIAgraFort5:
            {
               baseAssets = baseAssets + 25.0;
               break;
            }
            case cUnitTypeypCastle:
            {
               baseAssets = baseAssets + 5.0;
               break;
            }
            case cUnitTypeYPOutpostAsian:
            {
               baseAssets = baseAssets + 5.0;
               break;
            }
            case cUnitTypedeIncaStronghold:
            {
               baseAssets = baseAssets + 5.0;
               break;
            }
            case cUnitTypedeTower:
            {
               baseAssets = baseAssets + 5.0;
               break;
            }
            // military buildings
            case cUnitTypeBarracks:
            {
               baseAssets = baseAssets + 10.0;               
               break;
            }
            case cUnitTypeStable:
            {
               baseAssets = baseAssets + 10.0;               
               break;
            }
            case cUnitTypeArtilleryDepot:
            {
               baseAssets = baseAssets + 10.0;    
               break;
            }
            case cUnitTypeCorral:
            {
               baseAssets = baseAssets + 10.0;                   
               break;
            }      
            case cUnitTypeypWarAcademy:
            {
               baseAssets = baseAssets + 10.0;                   
               break;
            } 
            case cUnitTypeYPBarracksIndian:
            {
               baseAssets = baseAssets + 10.0;                   
               break;
            }
            case cUnitTypeypCaravanserai:
            {
               baseAssets = baseAssets + 10.0;                   
               break;
            }      
            case cUnitTypeypBarracksJapanese:
            {
               baseAssets = baseAssets + 10.0;                   
               break;
            }      
            case cUnitTypeypStableJapanese:
            {
               baseAssets = baseAssets + 10.0;                   
               break;
            }
            case cUnitTypedeKallanka:
            {
               baseAssets = baseAssets + 10.0;                   
               break;
            }       
            case cUnitTypedeWarCamp:
            {
               baseAssets = baseAssets + 10.0;
               break;
            }
            case cUnitTypedePalace:
            {
               baseAssets = baseAssets + 10.0;
               break;
            }
            // villagers
            case cUnitTypeSettler:
            {
               baseAssets = baseAssets + 10.0;
               break;         
            }
            case cUnitTypeSettlerWagon:
            {
               baseAssets = baseAssets + 20.0;
               break;         
            }
            case cUnitTypeCoureur:
            {
               baseAssets = baseAssets + 15.0;
               break;         
            }
            case cUnitTypeCoureurCree:
            {
               baseAssets = baseAssets + 15.0;
               break;         
            }
            case cUnitTypeSettlerNative:
            {
               baseAssets = baseAssets + 10.0;
               break;         
            }
            case cUnitTypeypSettlerAsian:
            {
               baseAssets = baseAssets + 10.0;
               break;         
            }
            case cUnitTypeypSettlerIndian:
            {
               baseAssets = baseAssets + 10.0;
               break;         
            }
            case cUnitTypeypSettlerJapanese:
            {
               baseAssets = baseAssets + 10.0;
               break;         
            }
            case cUnitTypedeSettlerAfrican:
            {
               baseAssets = baseAssets + 10.0;
               break;
            }
            }
         }

         // ignore base when we have no good targets to attack
         if (baseAssets == 0.0)
            continue;

         // prioritize trade monopoly and king's hill when active.
         if ((attackingMonopoly == true || defendingMonopoly == true) && isTradingPost == false)
            shouldAttack = false;
         if ((attackingKOTH == true || defendingKOTH == true) && isKOTH == false)
            shouldAttack = false;

         if (isEnemy == false)
         {
            kbUnitQuerySetPlayerRelation(baseEnemyQuery, cPlayerRelationEnemyNotGaia);
            kbUnitQuerySetState(baseEnemyQuery, cUnitStateABQ);
            kbUnitQuerySetPosition(baseEnemyQuery, baseLocation);
            kbUnitQuerySetMaximumDistance(baseEnemyQuery, baseDistance + 10.0);

            kbUnitQuerySetUnitType(baseEnemyQuery, cUnitTypeLogicalTypeLandMilitary);
            kbUnitQueryResetResults(baseEnemyQuery);
            numberEnemyFound = kbUnitQueryExecute(baseEnemyQuery);

            for (i = 0; < numberEnemyFound)
            {
               unitID = kbUnitQueryGetResult(baseQuery, i);
               puid = kbUnitGetProtoUnitID(unitID);
               enemyMilitaryPower = enemyMilitaryPower + getMilitaryUnitStrength(puid);
            }

            if (enemyMilitaryPower == 0.0)
               continue;
         }

         for (i = 0; < numberFound)
         {
            unitID = kbUnitQueryGetResult(baseQuery, i);
            puid = kbUnitGetProtoUnitID(unitID);

            switch (puid)
            {
            case cUnitTypeTownCenter:
            {
				if ((kbGetAge() >= cvMaxAge) || (gRevolutionType != 0))
               buildingPower = buildingPower + 5.0;
		       else
               buildingPower = buildingPower + 25.0;
               break;
            }
            case cUnitTypeFortFrontier:
            {
				if ((kbGetAge() >= cvMaxAge) || (gRevolutionType != 0))
               buildingPower = buildingPower + 5.0;
		       else
               buildingPower = buildingPower + 25.0;
               break;
            }
            case cUnitTypeOutpost:
            {
				if ((kbGetAge() >= cvMaxAge) || (gRevolutionType != 0))
               buildingPower = buildingPower + 5.0;
		       else
               buildingPower = buildingPower + 5.0;
               break;
            }
            case cUnitTypeBlockhouse:
            {
				if ((kbGetAge() >= cvMaxAge) || (gRevolutionType != 0))
               buildingPower = buildingPower + 5.0;
		       else
               buildingPower = buildingPower + 5.0;
               break;
            }
            case cUnitTypeNoblesHut:
            {
				if ((kbGetAge() >= cvMaxAge) || (gRevolutionType != 0))
               buildingPower = buildingPower + 5.0;
		       else
               buildingPower = buildingPower + 8.0;
               break;
            }
            case cUnitTypeypWIAgraFort2:
            {
				if ((kbGetAge() >= cvMaxAge) || (gRevolutionType != 0))
               buildingPower = buildingPower + 5.0;
		       else
               buildingPower = buildingPower + 15.0;
               break;
            }
            case cUnitTypeypWIAgraFort3:
            {
				if ((kbGetAge() >= cvMaxAge) || (gRevolutionType != 0))
               buildingPower = buildingPower + 5.0;
		       else
               buildingPower = buildingPower + 15.0;
               break;
            }
            case cUnitTypeypWIAgraFort4:
            {
				if ((kbGetAge() >= cvMaxAge) || (gRevolutionType != 0))
               buildingPower = buildingPower + 5.0;
		       else
               buildingPower = buildingPower + 15.0;
               break;
            }
            case cUnitTypeypWIAgraFort5:
            {
				if ((kbGetAge() >= cvMaxAge) || (gRevolutionType != 0))
               buildingPower = buildingPower + 5.0;
		       else
               buildingPower = buildingPower + 15.0;
               break;
            }
            case cUnitTypeypCastle:
            {
				if ((kbGetAge() >= cvMaxAge) || (gRevolutionType != 0))
               buildingPower = buildingPower + 5.0;
		       else
               buildingPower = buildingPower + 12.0;
               break;
            }
            case cUnitTypeYPOutpostAsian:
            {
				if ((kbGetAge() >= cvMaxAge) || (gRevolutionType != 0))
               buildingPower = buildingPower + 5.0;
		       else
               buildingPower = buildingPower + 5.0;
               break;
            }
            case cUnitTypedeIncaStronghold:
            {
				if ((kbGetAge() >= cvMaxAge) || (gRevolutionType != 0))
               buildingPower = buildingPower + 5.0;
		       else
               buildingPower = buildingPower + 20.0;
               break;
            }
            case cUnitTypedePalace:
            {
				if ((kbGetAge() >= cvMaxAge) || (gRevolutionType != 0))
               buildingPower = buildingPower + 5.0;
		       else
               buildingPower = buildingPower + 15.0;
               break;
            }
            }

            if (kbProtoUnitIsType(cMyID, puid, cUnitTypeLogicalTypeLandMilitary) == true)
               militaryPower = militaryPower + getMilitaryUnitStrength(puid);
         }

         // avoid division by 0.
         if ((militaryPower + buildingPower) < 1.0)
         {
            militaryPower = 1.0;
            buildingPower = 0.0;
         }

         if (isEnemy == true)
         {
            // If the ally requested us, be a little more eager to help.
            if (gCommAttackDefendBaseID == baseID)
               armyPower = armyPower * 1.2;

            // do we have enough power to defeat the target base?
            if (armyPower < militaryPower && availableMilitaryPop > 0)
               shouldAttack = false;
         }
         else
         {
            // If the ally requested us, be a little more eager to help.
            if (gCommAttackDefendBaseID == baseID)
               enemyMilitaryPower = enemyMilitaryPower * 0.8;

            // is my ally really in trouble and can I handle the attack?
            if ((militaryPower + buildingPower > enemyMilitaryPower) ||
                (armyPower + militaryPower + buildingPower < enemyMilitaryPower * 0.8))
               shouldAttack = false;
         }

         // prioritize defending allies.
         if (isEnemy == true && targetIsEnemy == false)
            shouldAttack = false;

         /*if (aiGetWorldDifficulty() >= gDifficultyExpert)
         {
            // Avoid attacking until 5 minutes passed after aging up.
            if ((btRushBoom <= -0.5 && kbGetAge() < cAge4) || (btRushBoom <= 0.0 && kbGetAge() < cAge3))
            {
               if (xsGetTime() - gAgeUpTime < 300000)
                  shouldAttack = false;
            }
         }*/

         if (baseAssets > maxBaseAssets)
         {
            maxBaseAssets = baseAssets;
            targetScore = (targetBaseAssets / maxBaseAssets) * targetAffordable * targetDistancePenalty;
         }

         if (isEnemy == true)
            affordable = armyPower / (militaryPower + buildingPower);
         else
            affordable = (armyPower + militaryPower + buildingPower) / enemyMilitaryPower;

         // Adjust for distance. If < 100m, leave as is.  Over 100m to 400m, penalize 10% per 100m.
         distancePenalty = distance(mainBaseLocation, baseLocation) / 1000.0;
         if (distancePenalty > 0.4)
            distancePenalty = 0.4;
         // Increase penalty by 40% if transporting is required.
         baseAreaGroup = kbAreaGroupGetIDByPosition(baseLocation);
         if (mainAreaGroup != baseAreaGroup)
            distancePenalty = distancePenalty + 0.4;
         distancePenalty = 1.0 - distancePenalty;
		 
		 if (kbGetAge() == cvMaxAge)
		 {
         affordable = 1;
		 distancePenalty = 1;
		 }
		 
         score = (baseAssets / maxBaseAssets) * affordable * distancePenalty;
         if (score > targetScore || (shouldAttack == true && targetShouldAttack == false))
         {
            targetBaseID = baseID;
            targetPlayer = player;
            targetIsEnemy = isEnemy;
            targetBaseAssets = baseAssets;
            targetAffordable = affordable;
            targetDistancePenalty = distancePenalty;
            targetScore = score;
            targetShouldAttack = shouldAttack;
         }
      }
   }

   // update target player.
   if (targetIsEnemy == true)
      aiSetMostHatedPlayerID(targetPlayer);

   if (targetBaseID < 0 || targetShouldAttack == false)
      return;

   vector gatherPoint = kbBaseGetMilitaryGatherPoint(cMyID, mainBaseID);
   if (targetIsEnemy == true)
   {
      planID = aiPlanCreate("Attack Player " + targetPlayer + " Base " + targetBaseID, cPlanAttack);

      aiPlanSetVariableInt(planID, cAttackPlanPlayerID, 0, targetPlayer);
      aiPlanSetVariableInt(planID, cAttackPlanRefreshFrequency, 0, 1);
      //aiPlanSetNumberVariableValues(planID, cAttackPlanTargetTypeID, 2, true);
      //aiPlanSetVariableInt(planID, cAttackPlanTargetTypeID, 0, cUnitTypeLogicalTypeLandMilitary);
      //aiPlanSetVariableInt(planID, cAttackPlanTargetTypeID, 1, cUnitTypeValidIdleVillager);
      aiPlanSetVariableVector(planID, cAttackPlanGatherPoint, 0, gatherPoint);
      aiPlanSetVariableInt(planID, cAttackPlanBaseAttackMode, 0, cAttackPlanBaseAttackModeExplicit);
      aiPlanSetVariableInt(planID, cAttackPlanAttackExplicitBaseID, 0, targetBaseID);
      aiPlanSetVariableFloat(planID, cAttackPlanGatherDistance, 0, 40.0);

      baseLocation = kbBaseGetLocation(targetPlayer, targetBaseID);
      baseAreaGroup = kbAreaGroupGetIDByPosition(baseLocation);
	  
      if (kbGetAge() < cAge5)
	  {
	  if  (gRevolutionType != 0)
	  {
	  if (mainAreaGroup == baseAreaGroup)
      {
         aiPlanSetVariableInt(planID, cAttackPlanAttackRoutePattern, 0, cAttackPlanAttackRoutePatternBest);
         aiPlanSetVariableInt(planID, cAttackPlanRetreatMode, 0, cAttackPlanRetreatModeOutnumbered);
      }
      else
      {
         aiPlanSetVariableInt(planID, cAttackPlanAttackRoutePattern, 0, cAttackPlanAttackRoutePatternRandom);
         aiPlanSetNumberVariableValues(planID, cAttackPlanTargetAreaGroups, 2, true);
         aiPlanSetVariableInt(planID, cAttackPlanTargetAreaGroups, 0, mainAreaGroup);
         aiPlanSetVariableInt(planID, cAttackPlanTargetAreaGroups, 0, baseAreaGroup);
         aiPlanSetVariableInt(planID, cAttackPlanRetreatMode, 0, cAttackPlanRetreatModeNone);
      }
	  }
	  }
	  
      //if (aiGetWorldDifficulty() >= cDifficultyModerate)
      //{
         aiPlanSetVariableBool(planID, cAttackPlanAllowMoreUnitsDuringAttack, 0, true);
         updateMilitaryTrainPlanBuildings(gForwardBaseID);
      //}
	  
      aiPlanSetBaseID(planID, mainBaseID);
      aiPlanSetInitialPosition(planID, gatherPoint);
      aiPlanSetOrphan(planID, true);

      addUnitsToMilitaryPlan(planID);

      aiPlanSetActive(planID);

      gLastAttackMissionTime = xsGetTime();
      aiEcho("***** LAUNCHING ATTACK on player " + targetPlayer + " base " + targetBaseID);
   }
   else
   {
      if (distance(baseLocation, mainBaseLocation) < kbBaseGetDistance(cMyID, mainBaseID) + 50.0)
      {
         // TODO: temporary workaround for defend plans not aware of enemy units when moving units from a location to another.
         // Too far away? create an attack plan instead.
         planID = aiPlanCreate("Attack Location " + baseLocation, cPlanAttack);

         aiPlanSetVariableInt(planID, cAttackPlanPlayerID, 0, targetPlayer);
         aiPlanSetVariableInt(planID, cAttackPlanRefreshFrequency, 0, 1);
         //aiPlanSetNumberVariableValues(planID, cAttackPlanTargetTypeID, 3, true);
         //aiPlanSetVariableInt(planID, cAttackPlanTargetTypeID, 0, cUnitTypeLogicalTypeLandMilitary);
         //aiPlanSetVariableInt(planID, cAttackPlanTargetTypeID, 1, cUnitTypeValidIdleVillager);
         aiPlanSetVariableVector(planID, cAttackPlanGatherPoint, 0, mainBaseLocation);
         aiPlanSetVariableVector(planID, cAttackPlanAttackPoint, 0, baseLocation);
		 
         
         //aiPlanSetUnitStance(planID, cUnitStanceAggressive);
		
		 aiPlanSetVariableFloat(planID, cAttackPlanAttackPointEngageRange, 0, kbBaseGetDistance(targetPlayer, targetBaseID));
         aiPlanSetVariableFloat(planID, cAttackPlanGatherDistance, 0, 40.0);

         baseAreaGroup = kbAreaGroupGetIDByPosition(baseLocation);
         
		 if (kbGetAge() < cAge5)
	  {
	  if  (gRevolutionType != 0)
	  {
		 if (mainAreaGroup == baseAreaGroup)
         {
            aiPlanSetVariableInt(planID, cAttackPlanAttackRoutePattern, 0, cAttackPlanAttackRoutePatternBest);
            aiPlanSetVariableInt(planID, cAttackPlanRetreatMode, 0, cAttackPlanRetreatModeOutnumbered);
         }
         else
         {
            aiPlanSetVariableInt(planID, cAttackPlanAttackRoutePattern, 0, cAttackPlanAttackRoutePatternRandom);
            aiPlanSetNumberVariableValues(planID, cAttackPlanTargetAreaGroups, 2, true);
            aiPlanSetVariableInt(planID, cAttackPlanTargetAreaGroups, 0, mainAreaGroup);
            aiPlanSetVariableInt(planID, cAttackPlanTargetAreaGroups, 0, baseAreaGroup);
            aiPlanSetVariableInt(planID, cAttackPlanRetreatMode, 0, cAttackPlanRetreatModeNone);
         }
	  }
	  }
		 
         //if (aiGetWorldDifficulty() >= cDifficultyModerate)
         aiPlanSetVariableBool(planID, cAttackPlanAllowMoreUnitsDuringAttack, 0, true);
         aiPlanSetBaseID(planID, mainBaseID);
         aiPlanSetInitialPosition(planID, mainBaseLocation);
         aiPlanSetOrphan(planID, true);

         addUnitsToMilitaryPlan(planID);

         aiPlanSetActive(planID);

         gLastDefendMissionTime = xsGetTime();
         aiEcho("***** LAUNCHING ATTACK on location "+baseLocation); 
         return;
      }

      planID = aiPlanCreate("Defend Player " + targetPlayer + " Base " + targetBaseID, cPlanDefend);

      aiPlanSetVariableInt(planID, cDefendPlanNoTargetTimeout, 0, 1*60*1000);
      aiPlanSetVariableFloat(planID, cDefendPlanEngageRange, 0, kbBaseGetDistance(targetPlayer, targetBaseID));
      aiPlanSetVariableVector(planID, cDefendPlanDefendPoint, 0, baseLocation);
      //aiPlanSetNumberVariableValues(planID, cDefendPlanAttackTypeID, 2, true);
      //aiPlanSetVariableInt(planID, cDefendPlanAttackTypeID, 0, cUnitTypeUnit);
      //aiPlanSetVariableInt(planID, cDefendPlanAttackTypeID, 1, cUnitTypeLogicalTypeBuildingsNotWallsOrGroves);
      aiPlanSetVariableInt(planID, cDefendPlanRefreshFrequency, 0, 10);
      //aiPlanSetUnitStance(planID, cUnitStanceAggressive);
	  aiPlanSetVariableBool(planID, cDefendPlanStopTakingUnits, 0, true);
      aiPlanSetOrphan(planID, true);

      addUnitsToMilitaryPlan(planID);

      aiPlanSetActive(planID);

      gLastDefendMissionTime = xsGetTime();
      aiEcho("***** DEFENDING player " + targetPlayer + " base " + targetBaseID);
   }
}

//==============================================================================
// encounterHandler
//
// Called when we encounter enemies in an attack plan but haven't reached our goal.
// Returns true if we want to engage.
//==============================================================================
bool encounterHandler(int planID = -1, int enemyList = -1)
{
   float enemyPower = 0.0; // Used to measure troop and building strength.  Units roughly equal to unit count of army.
   float allyPower = 0.0;  // Strength of allied buildings and units, roughly equal to unit count.
   float assets = 0.0;     // Rough estimate of base value, in aiCost.
   float affordRatio = 0.0;

   enemyPower = getUnitListStrength(enemyList);
   allyPower = getPlanStrength(planID);
   assets = getUnitListValue(enemyList); //  Rough value of target

   // aiEcho("encounterHandler: enemyPower="+enemyPower+", allyPower="+allyPower+",assets="+assets);

   // Check affordability
   if (enemyPower < 0.0)
   {
      return (false);
   }
   else
   {
      affordRatio = allyPower / enemyPower;
   } // Affordability is done

   if (affordRatio < 1.0)
   {
      return (false);
   }

   // Check target value.
   if (assets <= 0.0)
   {
      return (false);
   }

   return (true);
}

//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
// Personality and chats
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================

rule introChat    // Send a greeting to allies and enemies
inactive
group startup
minInterval 1
{
   xsDisableSelf();
   sendStatement(cPlayerRelationAlly, cAICommPromptToAllyIntro);
   sendStatement(cPlayerRelationEnemy, cAICommPromptToEnemyIntro);
}

rule IKnowWhereYouLive // Send a menacing chat when we discover the enemy player's location
    inactive group startup minInterval 5
{
   static int targetPlayer = -1;

   if (targetPlayer < 0)
   {
      targetPlayer = getEnemyPlayerByTeamPosition(getTeamPosition(cMyID)); // Corresponding player on other team
      if (targetPlayer < 0)
      {
         xsDisableSelf();
         aiEcho("No corresponding player on other team, IKnowWhereYouLive is deactivating.");
         aiEcho("    My team position is " + getTeamPosition(cMyID));
         return;
      }
      aiEcho("Rule IKnowWhereYouLive will threaten player #" + targetPlayer);
   }

   if (kbUnitCount(targetPlayer, cUnitTypeTownCenter, cUnitStateAlive) > 0)
   { // We see his TC for the first time
      int tc = getUnit(cUnitTypeTownCenter, targetPlayer, cUnitStateAlive);
      if (tc >= 0)
      {
         if (getUnitByLocation(cUnitTypeUnit, cMyID, cUnitStateAlive, kbUnitGetPosition(tc), 50.0) >= 0)
         { // I have a unit nearby, presumably I have LOS.
            sendStatement(targetPlayer, cAICommPromptToEnemyISpotHisTC, kbUnitGetPosition(tc));
            aiEcho("Rule IKnowWhereYouLive is threatening player #" + targetPlayer);
         }
      }
      xsDisableSelf();
   }
}

rule tcChats
inactive
group tcComplete
minInterval 10
{                          // Send chats about enemy TC placement
   static int tcID1 = -1;  // First enemy TC
   static int tcID2 = -1;  // Second
   static int enemy1 = -1; // ID of owner of first enemy TC.
   static int enemy2 = -1; // Second.
   static int secondTCQuery = -1;

   if (tcID1 < 0)
   { // Look for first enemy TC
      tcID1 = getUnit(cUnitTypeTownCenter, cPlayerRelationEnemy, cUnitStateAlive);
      if (tcID1 >= 0)
         enemy1 = kbUnitGetPlayerID(tcID1);
      return; // Done for now
   }

   // If we get here, we already know about one enemy TC.  Now, find the next closest enemy TC.
   if (secondTCQuery < 0)
   { // init - find all enemy TC's within 200 meters of first one.
      secondTCQuery = kbUnitQueryCreate("Second enemy TC");
   }
   kbUnitQuerySetPlayerRelation(secondTCQuery, cPlayerRelationEnemy);
   kbUnitQuerySetUnitType(secondTCQuery, cUnitTypeTownCenter);
   kbUnitQuerySetState(secondTCQuery, cUnitStateAlive);
   kbUnitQuerySetPosition(secondTCQuery, kbUnitGetPosition(tcID1));
   kbUnitQuerySetMaximumDistance(secondTCQuery, 500.0);

   kbUnitQueryResetResults(secondTCQuery);
   int tcCount = kbUnitQueryExecute(secondTCQuery);
   if (tcCount > 1) // Found another enemy TC
   {
      tcID2 = kbUnitQueryGetResult(secondTCQuery, 1); // Second unit in list
      enemy2 = kbUnitGetPlayerID(tcID2);
   }

   if (tcID2 < 0)
      return;

   // We have two TCs.  See if we have a unit in range.  If so, send a taunt if appropriate.  Either way, shut the rule
   // off.
   xsDisableSelf();

   if (enemy1 == enemy2)
      return; // Makes no sense to taunt if the same player owns both...

   bool haveLOS = false;
   if (getUnitByLocation(cUnitTypeUnit, cMyID, cUnitStateAlive, kbUnitGetPosition(tcID1), 50.0) >= 0)
      haveLOS = true;
   if (getUnitByLocation(cUnitTypeUnit, cMyID, cUnitStateAlive, kbUnitGetPosition(tcID2), 50.0) >= 0)
      haveLOS = true;

   if (haveLOS == true)
   {
      float d = distance(kbUnitGetPosition(tcID1), kbUnitGetPosition(tcID2));
      if (d < 100.0)
      { // Close together.  Taunt the two, flaring the other's bases.
         aiEcho("Enemy TCs are " + d + " meters apart.  Taunting for closeness.");
         sendStatement(enemy1, cAICommPromptToEnemyHisTCNearAlly,
                       kbUnitGetPosition(tcID2)); // Taunt enemy 1 about enemy 2's TC
         sendStatement(enemy2, cAICommPromptToEnemyHisTCNearAlly,
                       kbUnitGetPosition(tcID1)); // Taunt enemy 2 about enemy 1's TC
      }
      if (d > 200.0)
      { // Far apart.  Taunt.
         aiEcho("Enemy TCs are " + d + " meters apart.  Taunting for isolation.");
         sendStatement(enemy1, cAICommPromptToEnemyHisTCIsolated,
                       kbUnitGetPosition(tcID2)); // Taunt enemy 1 about enemy 2's TC
         sendStatement(enemy2, cAICommPromptToEnemyHisTCIsolated,
                       kbUnitGetPosition(tcID1)); // Taunt enemy 2 about enemy 1's TC
      }
      aiEcho("Enemy TCs are " + d + " meters apart.");
   } // Otherwise, rule is turned off, we missed our chance.
   else
   {
      aiEcho("Had no LOS to enemy TCs");
   }
}

rule monitorScores
inactive
minInterval 60
group tcComplete
{
   static int startingScores = -1; // Array holding initial scores for each player
   static int highScores = -1;     // Array, each player's high-score mark
   static int teamScores = -1;
   int player = -1;
   int teamSize = 0;
   int myTeam = kbGetPlayerTeam(cMyID);
   int enemyTeam = -1;
   int highAllyScore = -1;
   int highAllyPlayer = -1;
   int highEnemyScore = -1;
   int highEnemyPlayer = -1;
   int score = -1;
   int firstHumanAlly = -1;

   if (aiGetGameType() != cGameTypeRandom) // TODO:  Check for DM if/when we have a DM type.
   {
      xsDisableSelf();
      return;
   }

   if (highScores < 0)
   {
      highScores = xsArrayCreateInt(cNumberPlayers, 1, "High Scores"); // create array, init below.
   }
   if (startingScores < 0)
   {
      if (aiGetNumberTeams() != 3) // Gaia, plus two
      {
         // Only do this if there are two teams with the same number of players on each team.
         xsDisableSelf();
         return;
      }
      startingScores = xsArrayCreateInt(cNumberPlayers, 1, "Starting Scores"); // init array
      for (player = 1; < cNumberPlayers)
      {
         score = aiGetScore(player);
         aiEcho("Starting score for player " + player + " is " + score);
         xsArraySetInt(startingScores, player, score);
         xsArraySetInt(highScores, player,
                       0); // High scores will track score actual - starting score, to handle deathmatch better.
      }
   }

   teamSize = 0;
   for (player = 1; < cNumberPlayers)
   {
      if (kbGetPlayerTeam(player) == myTeam)
      {
         teamSize = teamSize + 1;
         if ((kbIsPlayerHuman(player) == true) && (firstHumanAlly < 1))
            firstHumanAlly = player;
      }
      else
         enemyTeam = kbGetPlayerTeam(player); // Don't know if team numbers are 0..1 or 1..2, this works either way.
   }

   if ((2 * teamSize) != (cNumberPlayers - 1)) // Teams aren't equal size
   {
      xsDisableSelf();
      return;
   }

   // If we got this far, there are two teams and each has 'teamSize' players.  Otherwise, rule turns off.
   if (teamScores < 0)
   {
      teamScores = xsArrayCreateInt(3, 0, "Team total scores");
   }

   if (firstHumanAlly < 0) // No point if we don't have a human ally.
   {
      xsDisableSelf();
      return;
   }

   // Update team totals, check for new high scores
   xsArraySetInt(teamScores, myTeam, 0);
   xsArraySetInt(teamScores, enemyTeam, 0);
   highAllyScore = -1;
   highEnemyScore = -1;
   highAllyPlayer = -1;
   highEnemyPlayer = -1;
   int lowestRemainingScore = 100000; // Very high, will be reset by first real score
   int lowestRemainingPlayer = -1;
   int highestScore = -1;
   int highestPlayer = -1;

   for (player = 1; < cNumberPlayers)
   {
      score = aiGetScore(player) - xsArrayGetInt(startingScores, player); // Actual score relative to initial score
      if (kbHasPlayerLost(player) == true)
         continue;
      if (score < lowestRemainingScore)
      {
         lowestRemainingScore = score;
         lowestRemainingPlayer = player;
      }
      if (score > highestScore)
      {
         highestScore = score;
         highestPlayer = player;
      }
      if (score > xsArrayGetInt(highScores, player))
         xsArraySetInt(highScores, player, score); // Set personal high score
      if (kbGetPlayerTeam(player) == myTeam)       // Update team scores, check for highs
      {
         xsArraySetInt(teamScores, myTeam, xsArrayGetInt(teamScores, myTeam) + score);
         if (score > highAllyScore)
         {
            highAllyScore = score;
            highAllyPlayer = player;
         }
      }
      else
      {
         xsArraySetInt(teamScores, enemyTeam, xsArrayGetInt(teamScores, enemyTeam) + score);
         if (score > highEnemyScore)
         {
            highEnemyScore = score;
            highEnemyPlayer = player;
         }
      }
   }

   // Bools used to indicate chat usage, prevent re-use.
   static bool enemyNearlyDead = false;
   static bool enemyStrong = false;
   static bool losingEnemyStrong = false;
   static bool losingEnemyWeak = false;
   static bool losingAllyStrong = false;
   static bool losingAllyWeak = false;
   static bool winningNormal = false;
   static bool winningAllyStrong = false;
   static bool winningAllyWeak = false;

   static int shouldResignCount = 0;         // Set to 1, 2 and 3 as chats are used.
   static int shouldResignLastTime = 420000; // When did I last suggest resigning?  Consider it again 3 min later.
                                             // Defaults to 7 min, so first suggestion won't be until 10 minutes.

   // Attempt to fire chats, from most specific to most general.
   // When we chat, mark that one used and exit for now, i.e no more than one chat per rule execution.

   // First, check the winning / losing / tie situations.
   // Bail if earlier than 12 minutes
   if (xsGetTime() < 60 * 1000 * 12)
      return;

   if (aiTreatyActive() == true)
      return;

   bool winning = false;
   bool losing = false;
   float ourAverageScore = (aiGetScore(cMyID) + aiGetScore(firstHumanAlly)) / 2.0;

   if (xsArrayGetInt(teamScores, myTeam) > (1.20 * xsArrayGetInt(teamScores, enemyTeam)))
   { // We are winning
      winning = true;

      // Are we winning because my ally rocks?
      if ((winningAllyStrong == false) && (firstHumanAlly == highestPlayer))
      {
         winningAllyStrong = true;
         sendStatement(firstHumanAlly, cAICommPromptToAllyWeAreWinningHeIsStronger);
         return;
      }

      // Are we winning in spite of my weak ally?
      if ((winningAllyWeak == false) && (cMyID == highestPlayer))
      {
         winningAllyWeak = true;
         sendStatement(firstHumanAlly, cAICommPromptToAllyWeAreWinningHeIsWeaker);
         return;
      }

      // OK, we're winning, but neither of us has high score.
      if (winningNormal == false)
      {
         winningNormal = true;
         sendStatement(firstHumanAlly, cAICommPromptToAllyWeAreWinning);
         return;
      }
   } // End chats while we're winning.

   if (xsArrayGetInt(teamScores, myTeam) < (0.70 * xsArrayGetInt(teamScores, enemyTeam)))
   { // We are losing
      losing = true;

      // Talk about resigning?
      if ((shouldResignCount < 3) &&
          ((xsGetTime() - shouldResignLastTime) > 3 * 60 * 1000)) // Haven't done it 3 times or within 3 minutes
      {
         switch (shouldResignCount)
         {
         case 0:
         {
            sendStatement(firstHumanAlly, cAICommPromptToAllyWeShouldResign1);
            break;
         }
         case 1:
         {
            sendStatement(firstHumanAlly, cAICommPromptToAllyWeShouldResign2);
            break;
         }
         case 2:
         {
            sendStatement(firstHumanAlly, cAICommPromptToAllyWeShouldResign3);
            break;
         }
         }
         shouldResignCount = shouldResignCount + 1;
         shouldResignLastTime = xsGetTime();
         return;
      } // End resign

      // Check for "we are losing but let's kill the weakling"
      if ((losingEnemyWeak == false) && (kbIsPlayerEnemy(lowestRemainingPlayer) == true))
      {
         switch (kbGetCivForPlayer(lowestRemainingPlayer))
         {
         case cCivRussians:
         {
            losingEnemyWeak = true; // chat used.
            sendStatement(firstHumanAlly, cAICommPromptToAllyWeAreLosingEnemyWeakRussian);
            return;
            break;
         }
         case cCivFrench:
         {
            losingEnemyWeak = true; // chat used.
            sendStatement(firstHumanAlly, cAICommPromptToAllyWeAreLosingEnemyWeakFrench);
            return;
            break;
         }
         case cCivGermans:
         {
            losingEnemyWeak = true; // chat used.
            sendStatement(firstHumanAlly, cAICommPromptToAllyWeAreLosingEnemyWeakGerman);
            return;
            break;
         }
         case cCivBritish:
         {
            losingEnemyWeak = true; // chat used.
            sendStatement(firstHumanAlly, cAICommPromptToAllyWeAreLosingEnemyWeakBritish);
            return;
            break;
         }
         case cCivSpanish:
         {
            losingEnemyWeak = true; // chat used.
            sendStatement(firstHumanAlly, cAICommPromptToAllyWeAreLosingEnemyWeakSpanish);
            return;
            break;
         }
         case cCivDESwedish:
         {
            losingEnemyWeak = true; // chat used.
            sendStatement(firstHumanAlly, cAICommPromptToAllyWeAreLosingEnemyWeakSwedes);
            return;
            break;
         }
         case cCivDutch:
         {
            losingEnemyWeak = true; // chat used.
            sendStatement(firstHumanAlly, cAICommPromptToAllyWeAreLosingEnemyWeakDutch);
            return;
            break;
         }
         case cCivPortuguese:
         {
            losingEnemyWeak = true; // chat used.
            sendStatement(firstHumanAlly, cAICommPromptToAllyWeAreLosingEnemyWeakPortuguese);
            return;
            break;
         }
         case cCivOttomans:
         {
            losingEnemyWeak = true; // chat used.
            sendStatement(firstHumanAlly, cAICommPromptToAllyWeAreLosingEnemyWeakOttoman);
            return;
            break;
         }
         case cCivDEInca:
         {
            losingEnemyWeak = true; // chat used.
            sendStatement(firstHumanAlly, cAICommPromptToAllyWeAreLosingEnemyWeakInca);
            return;
            break;
         }
         case cCivDEAmericans:
         {
            losingEnemyWeak = true; // chat used.
            sendStatement(firstHumanAlly, cAICommPromptToAllyWeAreLosingEnemyWeakAmerican);
            return;
            break;
         }
         case cCivDEEthiopians:
         {
            losingEnemyWeak = true; // chat used.
            sendStatement(firstHumanAlly, cAICommPromptToAllyWeAreLosingEnemyWeakEthiopian);
            return;
            break;
         }
         case cCivDEHausa:
         {
            losingEnemyWeak = true; // chat used.
            sendStatement(firstHumanAlly, cAICommPromptToAllyWeAreLosingEnemyWeakHausa);
            return;
            break;
         }
         case cCivJapanese:
         {
            if (civIsAsian() == true || civIsDEciv() == true)
            {
               losingEnemyWeak = true; // chat used.
               sendStatement(firstHumanAlly, cAICommPromptToAllyWeAreLosingEnemyWeakJapanese);
               return;
               break;
            }
         }
         case cCivChinese:
         {
            if (civIsAsian() == true || civIsDEciv() == true)
            {
               losingEnemyWeak = true; // chat used.
               sendStatement(firstHumanAlly, cAICommPromptToAllyWeAreLosingEnemyWeakChinese);
               return;
               break;
            }
         }
         case cCivIndians:
         {
            if (civIsAsian() == true || civIsDEciv() == true)
            {
               losingEnemyWeak = true; // chat used.
               sendStatement(firstHumanAlly, cAICommPromptToAllyWeAreLosingEnemyWeakIndian);
               return;
               break;
            }
         }
         }
      }

      // Check for losing while enemy player has high score.
      if ((losingEnemyStrong == false) && (kbIsPlayerEnemy(highestPlayer) == true))
      {
         switch (kbGetCivForPlayer(highestPlayer))
         {
         case cCivRussians:
         {
            losingEnemyStrong = true; // chat used.
            sendStatement(firstHumanAlly, cAICommPromptToAllyWeAreLosingEnemyStrongRussian);
            return;
            break;
         }
         case cCivFrench:
         {
            losingEnemyStrong = true; // chat used.
            sendStatement(firstHumanAlly, cAICommPromptToAllyWeAreLosingEnemyStrongFrench);
            return;
            break;
         }
         case cCivGermans:
         {
            losingEnemyStrong = true; // chat used.
            sendStatement(firstHumanAlly, cAICommPromptToAllyWeAreLosingEnemyStrongGerman);
            return;
            break;
         }
         case cCivBritish:
         {
            losingEnemyStrong = true; // chat used.
            sendStatement(firstHumanAlly, cAICommPromptToAllyWeAreLosingEnemyStrongBritish);
            return;
            break;
         }
         case cCivSpanish:
         {
            losingEnemyStrong = true; // chat used.
            sendStatement(firstHumanAlly, cAICommPromptToAllyWeAreLosingEnemyStrongSpanish);
            return;
            break;
         }
         case cCivDESwedish:
         {
            losingEnemyStrong = true; // chat used.
            sendStatement(firstHumanAlly, cAICommPromptToAllyWeAreLosingEnemyStrongSwedes);
            return;
            break;
         }
         case cCivDutch:
         {
            losingEnemyStrong = true; // chat used.
            sendStatement(firstHumanAlly, cAICommPromptToAllyWeAreLosingEnemyStrongDutch);
            return;
            break;
         }
         case cCivPortuguese:
         {
            losingEnemyStrong = true; // chat used.
            sendStatement(firstHumanAlly, cAICommPromptToAllyWeAreLosingEnemyStrongPortuguese);
            return;
            break;
         }
         case cCivOttomans:
         {
            losingEnemyStrong = true; // chat used.
            sendStatement(firstHumanAlly, cAICommPromptToAllyWeAreLosingEnemyStrongOttoman);
            return;
            break;
         }
         case cCivDEInca:
         {
            losingEnemyStrong = true; // chat used.
            sendStatement(firstHumanAlly, cAICommPromptToAllyWeAreLosingEnemyStrongInca);
            return;
            break;
         }
         case cCivDEAmericans:
         {
            losingEnemyStrong = true; // chat used.
            sendStatement(firstHumanAlly, cAICommPromptToAllyWeAreLosingEnemyStrongAmerican);
            return;
            break;
         }
         case cCivDEEthiopians:
         {
            losingEnemyStrong = true; // chat used.
            sendStatement(firstHumanAlly, cAICommPromptToAllyWeAreLosingEnemyStrongEthiopian);
            return;
            break;
         }
         case cCivDEHausa:
         {
            losingEnemyStrong = true; // chat used.
            sendStatement(firstHumanAlly, cAICommPromptToAllyWeAreLosingEnemyStrongHausa);
            return;
            break;
         }
         case cCivJapanese:
         {
            if (civIsAsian() == true || civIsDEciv() == true)
            {
               losingEnemyStrong = true; // chat used.
               sendStatement(firstHumanAlly, cAICommPromptToAllyWeAreLosingEnemyStrongJapanese);
               return;
               break;
            }
         }
         case cCivChinese:
         {
            if (civIsAsian() == true || civIsDEciv() == true)
            {
               losingEnemyStrong = true; // chat used.
               sendStatement(firstHumanAlly, cAICommPromptToAllyWeAreLosingEnemyStrongChinese);
               return;
               break;
            }
         }
         case cCivIndians:
         {
            if (civIsAsian() == true || civIsDEciv() == true)
            {
               losingEnemyStrong = true; // chat used.
               sendStatement(firstHumanAlly, cAICommPromptToAllyWeAreLosingEnemyStrongIndian);
               return;
               break;
            }
         }
         }
      }

      // If we're here, we're losing but our team has the high score.  If it's my ally, we're losing because I suck.
      if ((losingAllyStrong == false) && (firstHumanAlly == highestPlayer))
      {
         losingAllyStrong = true;
         sendStatement(firstHumanAlly, cAICommPromptToAllyWeAreLosingHeIsStronger);
         return;
      }
      if ((losingAllyWeak == false) && (cMyID == highestPlayer))
      {
         losingAllyWeak = true;
         sendStatement(firstHumanAlly, cAICommPromptToAllyWeAreLosingHeIsWeaker);
         return;
      }
   } // End chats while we're losing.

   if ((winning == false) && (losing == false))
   { // Close game

      // Check for a near-death enemy
      if ((enemyNearlyDead == false) && (kbIsPlayerEnemy(lowestRemainingPlayer) == true)) // Haven't used this chat yet
      {
         if ((lowestRemainingScore * 2) <
             xsArrayGetInt(highScores, lowestRemainingPlayer)) // He's down to half his high score.
         {
            switch (kbGetCivForPlayer(lowestRemainingPlayer))
            {
            case cCivRussians:
            {
               enemyNearlyDead = true; // chat used.
               sendStatement(firstHumanAlly, cAICommPromptToAllyEnemyNearlyDeadRussian);
               return;
               break;
            }
            case cCivFrench:
            {
               enemyNearlyDead = true; // chat used.
               sendStatement(firstHumanAlly, cAICommPromptToAllyEnemyNearlyDeadFrench);
               return;
               break;
            }
            case cCivBritish:
            {
               enemyNearlyDead = true; // chat used.
               sendStatement(firstHumanAlly, cAICommPromptToAllyEnemyNearlyDeadBritish);
               return;
               break;
            }
            case cCivSpanish:
            {
               enemyNearlyDead = true; // chat used.
               sendStatement(firstHumanAlly, cAICommPromptToAllyEnemyNearlyDeadSpanish);
               return;
               break;
            }
            case cCivDESwedish:
            {
               enemyNearlyDead = true; // chat used.
               sendStatement(firstHumanAlly, cAICommPromptToAllyEnemyNearlyDeadSwedes);
               return;
               break;
            }
            case cCivGermans:
            {
               enemyNearlyDead = true; // chat used.
               sendStatement(firstHumanAlly, cAICommPromptToAllyEnemyNearlyDeadGerman);
               return;
               break;
            }
            case cCivOttomans:
            {
               enemyNearlyDead = true; // chat used.
               sendStatement(firstHumanAlly, cAICommPromptToAllyEnemyNearlyDeadOttoman);
               return;
               break;
            }
            case cCivDutch:
            {
               enemyNearlyDead = true; // chat used.
               sendStatement(firstHumanAlly, cAICommPromptToAllyEnemyNearlyDeadDutch);
               return;
               break;
            }
            case cCivPortuguese:
            {
               enemyNearlyDead = true; // chat used.
               sendStatement(firstHumanAlly, cAICommPromptToAllyEnemyNearlyDeadPortuguese);
               return;
               break;
            }
            case cCivDEInca:
            {
               enemyNearlyDead = true; // chat used.
               sendStatement(firstHumanAlly, cAICommPromptToAllyEnemyNearlyDeadInca);
               return;
               break;
            }
            case cCivDEAmericans:
            {
               enemyNearlyDead = true; // chat used.
               sendStatement(firstHumanAlly, cAICommPromptToAllyEnemyNearlyDeadAmerican);
               return;
               break;
            }
            case cCivDEEthiopians:
            {
               enemyNearlyDead = true; // chat used.
               sendStatement(firstHumanAlly, cAICommPromptToAllyEnemyNearlyDeadEthiopian);
               return;
               break;
            }
            case cCivDEHausa:
            {
               enemyNearlyDead = true; // chat used.
               sendStatement(firstHumanAlly, cAICommPromptToAllyEnemyNearlyDeadHausa);
               return;
               break;
            }
            case cCivJapanese:
            {
               if (civIsAsian() == true || civIsDEciv() == true)
               {
                  enemyNearlyDead = true; // chat used.
                  sendStatement(firstHumanAlly, cAICommPromptToAllyEnemyNearlyDeadJapanese);
                  return;
                  break;
               }
            }
            case cCivChinese:
            {
               if (civIsAsian() == true || civIsDEciv() == true)
               {
                  enemyNearlyDead = true; // chat used.
                  sendStatement(firstHumanAlly, cAICommPromptToAllyEnemyNearlyDeadChinese);
                  return;
                  break;
               }
            }
            case cCivIndians:
            {
               if (civIsAsian() == true || civIsDEciv() == true)
               {
                  enemyNearlyDead = true; // chat used.
                  sendStatement(firstHumanAlly, cAICommPromptToAllyEnemyNearlyDeadIndian);
                  return;
                  break;
               }
            }
            }
         }
      }

      // Check for very strong enemy
      if ((enemyStrong == false) && (kbIsPlayerEnemy(highestPlayer) == true))
      {
         if ((ourAverageScore * 1.5) < highestScore)
         { // Enemy has high score, it's at least 50% above our average.
            switch (kbGetCivForPlayer(highestPlayer))
            {
            case cCivRussians:
            {
               enemyStrong = true; // chat used.
               sendStatement(firstHumanAlly, cAICommPromptToAllyEnemyStrongRussian);
               return;
               break;
            }
            case cCivFrench:
            {
               enemyStrong = true; // chat used.
               sendStatement(firstHumanAlly, cAICommPromptToAllyEnemyStrongFrench);
               return;
               break;
            }
            case cCivBritish:
            {
               enemyStrong = true; // chat used.
               sendStatement(firstHumanAlly, cAICommPromptToAllyEnemyStrongBritish);
               return;
               break;
            }
            case cCivSpanish:
            {
               enemyStrong = true; // chat used.
               sendStatement(firstHumanAlly, cAICommPromptToAllyEnemyStrongSpanish);
               return;
               break;
            }
            case cCivDESwedish:
            {
               enemyNearlyDead = true; // chat used.
               sendStatement(firstHumanAlly, cAICommPromptToAllyEnemyStrongSwedes);
               return;
               break;
            }
            case cCivGermans:
            {
               enemyStrong = true; // chat used.
               sendStatement(firstHumanAlly, cAICommPromptToAllyEnemyStrongGerman);
               return;
               break;
            }
            case cCivOttomans:
            {
               enemyStrong = true; // chat used.
               sendStatement(firstHumanAlly, cAICommPromptToAllyEnemyStrongOttoman);
               return;
               break;
            }
            case cCivDutch:
            {
               enemyStrong = true; // chat used.
               sendStatement(firstHumanAlly, cAICommPromptToAllyEnemyStrongDutch);
               return;
               break;
            }
            case cCivPortuguese:
            {
               enemyStrong = true; // chat used.
               sendStatement(firstHumanAlly, cAICommPromptToAllyEnemyStrongPortuguese);
               return;
               break;
            }
            case cCivDEInca:
            {
               enemyNearlyDead = true; // chat used.
               sendStatement(firstHumanAlly, cAICommPromptToAllyEnemyStrongInca);
               return;
               break;
            }
            case cCivDEAmericans:
            {
               enemyNearlyDead = true; // chat used.
               sendStatement(firstHumanAlly, cAICommPromptToAllyEnemyStrongAmerican);
               return;
               break;
            }
            case cCivDEEthiopians:
            {
               enemyNearlyDead = true; // chat used.
               sendStatement(firstHumanAlly, cAICommPromptToAllyEnemyStrongEthiopian);
               return;
               break;
            }
            case cCivDEHausa:
            {
               enemyNearlyDead = true; // chat used.
               sendStatement(firstHumanAlly, cAICommPromptToAllyEnemyStrongHausa);
               return;
               break;
            }
            case cCivJapanese:
            {
               if (civIsAsian() == true || civIsDEciv() == true)
               {
                  enemyStrong = true; // chat used.
                  sendStatement(firstHumanAlly, cAICommPromptToAllyEnemyStrongJapanese);
                  return;
                  break;
               }
            }
            case cCivChinese:
            {
               if (civIsAsian() == true || civIsDEciv() == true)
               {
                  enemyStrong = true; // chat used.
                  sendStatement(firstHumanAlly, cAICommPromptToAllyEnemyStrongChinese);
                  return;
                  break;
               }
            }
            case cCivIndians:
            {
               if (civIsAsian() == true || civIsDEciv() == true)
               {
                  enemyStrong = true; // chat used.
                  sendStatement(firstHumanAlly, cAICommPromptToAllyEnemyStrongIndian);
                  return;
                  break;
               }
            }
            }
         }
      }
   } // End chats for close game
}

rule firstEnemyUnitSpotted
inactive
group startup
minInterval 5
{
   static int targetPlayer = -1;

   if (targetPlayer < 0)
   {
      targetPlayer = getEnemyPlayerByTeamPosition(getTeamPosition(cMyID)); // Corresponding player on other team
      if (targetPlayer < 0)
      {
         xsDisableSelf();
         aiEcho("No corresponding player on other team, firstEnemyUnitSpotted is deactivating.");
         aiEcho("    My team position is " + getTeamPosition(cMyID));
         return;
      }
      aiEcho("Rule firstEnemyUnitSpotted will watch for player #" + targetPlayer);
   }

   if (kbUnitCount(targetPlayer, cUnitTypeLogicalTypeLandMilitary, cUnitStateAlive) > 0)
   { // We see one of this player's units for the first time...let's do some analysis on it
      int unitID = getUnit(cUnitTypeLogicalTypeLandMilitary, targetPlayer,
                           cUnitStateAlive); // Get the (or one of the) enemy units
      if (unitID < 0)
      {
         aiEcho("kbUnitCount said there are enemies, but getUnit finds nothing.");
         return;
      }

      aiEcho("Enemy unit spotted at " + kbUnitGetPosition(unitID));
      aiEcho("My base is at " + kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)));
      aiEcho("Distance is " + distance(kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)), kbUnitGetPosition(unitID)));
      aiEcho("Unit ID is " + unitID);
      // Three tests in priority order....anything near my town, an explorer anywhere, or default.
      // In my town?
      if (distance(kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)), kbUnitGetPosition(unitID)) < 60.0)
      {
         sendStatement(targetPlayer, cAICommPromptToEnemyISeeHisFirstMilitaryMyTown, kbUnitGetPosition(unitID));
         aiEcho("Spotted a unit near my town, so I'm threatening player #" + targetPlayer);
         xsDisableSelf();
         return;
      }
      // Is it an explorer?
      if (kbUnitIsType(unitID, cUnitTypeExplorer) == true)
      {
         sendStatement(targetPlayer, cAICommPromptToEnemyISeeHisExplorerFirstTime, kbUnitGetPosition(unitID));
         aiEcho("Spotted an enemy explorer, so I'm threatening player #" + targetPlayer);
         xsDisableSelf();
         return;
      }
      // Generic
      if (getUnitByLocation(cUnitTypeTownCenter, cPlayerRelationAny, cUnitStateAlive, kbUnitGetPosition(unitID), 70.0) <
          0)
      { // No TCs nearby
         sendStatement(targetPlayer, cAICommPromptToEnemyISeeHisFirstMilitary, kbUnitGetPosition(unitID));
         aiEcho("Spotted an enemy military unit for the first time, so I'm threatening player #" + targetPlayer);
      }
      xsDisableSelf();
      return;
   }
}

//==============================================================================
// main
//==============================================================================
void main(void)
{
   aiEcho("Main is starting.");
   aiEcho("Game type is " + aiGetGameType() + ", 0=Scn, 1=Saved, 2=Rand, 3=GC, 4=Cmpgn");
   aiEcho("Map name is " + cRandomMapName);
   initArrays();               // Create the global arrays
   aiRandSetSeed(-1);          // Set our random seed.  "-1" is a random init.
   kbAreaCalculate();          // Analyze the map, create area matrix
   aiPopulatePoliticianList(); // Fill out the PoliticanLists.
   // By turning on we let the engine automatically handle unit gather rate differences when allocating gatherers among resources.
   aiSetDistributeGatherersByResourcePercentage(true);
   // Instead of creating a fixed amount of gather plans, create a new gather plan for each resource that
   // is closest to the resource type gatherers being asked to gather.
   aiSetDistributeGatherersByClosestResource(true);
   aiSetEscrowsDisabled(true); // Disable escrows so we can have full control of our resources
   aiSetPlanResourcePriorityEnabled(true); // Enable resource priority for plans

   if ((aiGetGameType() == cGameTypeCampaign) || (aiGetGameType() == cGameTypeScenario))
      gSPC = true;
   else
      gSPC = false; // RM game
   aiEcho("gSPC is " + gSPC);

   int intDifficulty = -1;
   float difficulty = aiGetWorldDifficulty();
   float diffRemainder = -1.0;
   intDifficulty = difficulty;
   diffRemainder = difficulty - intDifficulty;

   // set the max age here - this can be overridden in preInit
   cvMaxAge = aiGetMaxAge();

   // Call the rule once as a function, to get all the pop limits set up.
   popManager();

   aiEcho("I see " + kbUnitCount(cMyID, cUnitTypeHomeCityWaterSpawnFlag) + " water flags.");

   //-- setup the handicaps.
   // baseLineHandicap is a global multiplier that we can use to adjust all up or down.  Probably will remain at 1.0.
   // startingHandicap is the handicap set at game launch in the UI, i.e. boost this player 10% == 1.10.  That needs to
   // be multiplied by the appropriate difficulty for each level.
   float startingHandicap = kbGetPlayerHandicap(cMyID);
   switch (intDifficulty)
   {
   case cDifficultySandbox: // Sandbox
   {
      kbSetPlayerHandicap(cMyID, startingHandicap * baselineHandicap *
                                     0.3); // Set handicap to a small fraction of baseline, i.e. minus 70%.
      gDelayAttacks = true;                // Prevent attacks...actually stays that way, never turns true.
      cvOkToBuildForts = false;
      break;
   }
   case cDifficultyEasy: // Easiest
   {
      if (gSPC == true)
         kbSetPlayerHandicap(cMyID, startingHandicap * baselineHandicap * 0.5); // minus 50 percent for scenarios
      else
         kbSetPlayerHandicap(cMyID, startingHandicap * baselineHandicap * 0.4); // minus 60 percent

      gDelayAttacks = true;
      cvOkToBuildForts = false;
      xsEnableRule("delayAttackMonitor"); // Wait until I am attacked, then let slip the hounds of war.
      break;
   }
   case cDifficultyModerate: // Moderate
   {
      if (gSPC == true)
         kbSetPlayerHandicap(cMyID, startingHandicap * baselineHandicap * 1.0); // minus 25% for scenarios
      else
         kbSetPlayerHandicap(cMyID, startingHandicap * baselineHandicap * 0.65); // minus 35%
      break;
   }
   case cDifficultyHard: // Hard
   {
      kbSetPlayerHandicap(cMyID, startingHandicap * baselineHandicap * 1.0); // 1.0 handicap at hard, i.e. no bonus
      if (gSPC == true)
	  {
         aiSetMicroFlags(cMicroLevelHigh);
		 kbSetPlayerHandicap(cMyID, startingHandicap * baselineHandicap * 1.5); // 1.0 handicap at hard, i.e. no bonus
	  }
      else
	  {
         aiSetMicroFlags(cMicroLevelNormal);
		 kbSetPlayerHandicap(cMyID, startingHandicap * baselineHandicap * 1.0); // 1.0 handicap at hard, i.e. no bonus     
	  }
      break;
   }
   case cDifficultyExpert: // Hardest
   {
      kbSetPlayerHandicap(cMyID, startingHandicap * baselineHandicap * 1.2); // +20% boost.
      aiSetMicroFlags(cMicroLevelHigh);
      break;
   }
   case cDifficultyExtreme: // Extreme
   {
      kbSetPlayerHandicap(cMyID, startingHandicap * baselineHandicap * 1.4); // +40% boost.
      aiSetMicroFlags(cMicroLevelHigh);
      break;
   }
   }

   if (gSPC == true)
      gDifficultyExpert = cDifficultyHard;

   aiEcho("Handicap is " + kbGetPlayerHandicap(cMyID));
   aiEcho("Difficulty is " + aiGetWorldDifficulty());

   // Create a temporary main base so the plans have something to deal with.
   // If there is a scenarioStart object, use it.  If not, use the TC, if any.
   // Failing that, use an explorer, a war chief, a monk, a settlerWagon, or a Settler.
   // Failing that, select any freakin' unit and use it.
   vector tempBaseVec = cInvalidVector;
   int unitID = -1;
   unitID = getUnit(cUnitTypeAIStart, cMyID, cUnitStateAlive);
   if (unitID < 0)
      unitID = getUnit(cUnitTypeTownCenter, cMyID, cUnitStateAlive);
   if (unitID < 0)
      unitID = getUnit(cUnitTypeExplorer, cMyID, cUnitStateAlive);
   if (unitID < 0)
      unitID = getUnit(cUnitTypexpAztecWarchief, cMyID, cUnitStateAlive);
   if (unitID < 0)
      unitID = getUnit(cUnitTypexpIroquoisWarChief, cMyID, cUnitStateAlive);
   if (unitID < 0)
      unitID = getUnit(cUnitTypexpLakotaWarchief, cMyID, cUnitStateAlive);
   if (unitID < 0)
      unitID = getUnit(cUnitTypedeIncaWarChief, cMyID, cUnitStateAlive);
   if (unitID < 0)
      unitID = getUnit(cUnitTypeypMonkChinese, cMyID, cUnitStateAlive);
   if (unitID < 0)
      unitID = getUnit(cUnitTypeypMonkIndian, cMyID, cUnitStateAlive);
   if (unitID < 0)
      unitID = getUnit(cUnitTypeypMonkIndian2, cMyID, cUnitStateAlive);
   if (unitID < 0)
      unitID = getUnit(cUnitTypeypMonkJapanese, cMyID, cUnitStateAlive);
   if (unitID < 0)
      unitID = getUnit(cUnitTypeypMonkJapanese2, cMyID, cUnitStateAlive);
   if (unitID < 0)
      unitID = getUnit(gCoveredWagonUnit, cMyID, cUnitStateAlive);
   if (unitID < 0)
      unitID = getUnit(cUnitTypeSettler, cMyID, cUnitStateAlive);
   if (unitID < 0)
      unitID = getUnit(gEconUnit, cMyID, cUnitStateAlive);

   if (unitID < 0)
      aiEcho(
          "**** I give up...I can't find an aiStart unit, TC, wagon, explorer or settler.  How do you expect me to play?!");
   else
      tempBaseVec = kbUnitGetPosition(unitID);

   // Check for island map and starting on different islands.
   vector tempPlayerVec = cInvalidVector;
   gIslandMap = kbGetIslandMap();
   for (player = 1; < cNumberPlayers)
   {
      if (player == cMyID)
         continue;
      tempPlayerVec = kbGetPlayerStartingPosition(player);
      if (tempPlayerVec == cInvalidVector)
         continue;
      if (kbAreAreaGroupsPassableByLand(kbAreaGroupGetIDByPosition(tempBaseVec),
                                        kbAreaGroupGetIDByPosition(tempPlayerVec)) == false)
      {
         gStartOnDifferentIslands = true;
         break;
      }
   }
   aiEcho("Island map is " + gIslandMap + ", players start on different islands is " + gStartOnDifferentIslands);

   // Do some overrides for the SPC/campaign games before the loader file wakes up.
   SPCInit();

   // Find out what our personality is, init variables from it.
   initPersonality();

   // Allow loader file to change default values before we start.
   preInit();
   if (cvInactiveAI == true)
   {
      cvOkToSelectMissions = false;
      cvOkToTrainArmy = false;
      cvOkToAllyNatives = false;
      cvOkToClaimTrade = false;
      cvOkToGatherFood = false;
      cvOkToGatherGold = false;
      cvOkToGatherWood = false;
      cvOkToExplore = false;
      cvOkToResign = false;
      cvOkToAttack = false;
   }

   // Figure out the starting conditions, and deal with them.
   if (gSPC == true)
   {
      aiEcho("Start mode:  Scenario, details TBD after aiStart object is found.");
      // Wait for the aiStart unit to appear, then figure out what to do.
      // That rule will have to set the start mode to ScenarioTC or ScenarioNoTC.
      xsEnableRule("waitForStartup");
   }
   else
   {
      // RM or GC game
      aiSetRandomMap(true);
      // Check for a TC.
      if (kbUnitCount(cMyID, cUnitTypeTownCenter, cUnitStateAlive) > 0)
      {
         // TC start
         aiEcho("Start mode:  Land TC");
         gStartMode = cStartModeLandTC;
         // Call init directly.
         init();
         // Setup shipment arrive handler.
         aiSetHandler("transportShipmentArrive", cXSHomeCityTransportArriveHandler);
      }
      else
      {
         // Check for a Boat.
         if (kbUnitCount(cMyID, cUnitTypeAbstractWarShip, cUnitStateAlive) > 0 && gSPC == true)
         {
            gStartMode = cStartModeBoat;
            aiEcho("Start mode: Boat");
            // Needed for first transport unloading
            aiSetHandler("transportArrive", cXSHomeCityTransportArriveHandler);

            // Rule that fires after 30 seconds in case
            // something goes wrong with unloading
            xsEnableRule("transportArriveFailsafe");
         }
         else
         {
            // This must be a land nomad start
            aiEcho("Start mode:  Land Wagon");
            gStartMode = cStartModeLandWagon;
            // Call the function that sets up explore plans, etc.
            transportArrive();
            // Setup shipment arrive handler.
            aiSetHandler("transportShipmentArrive", cXSHomeCityTransportArriveHandler);
         }
      }
   }

   //-- set the default Resource Selector factor.
   kbSetTargetSelectorFactor(cTSFactorDistance, gTSFactorDistance);
   kbSetTargetSelectorFactor(cTSFactorPoint, gTSFactorPoint);
   kbSetTargetSelectorFactor(cTSFactorTimeToDone, gTSFactorTimeToDone);
   kbSetTargetSelectorFactor(cTSFactorBase, gTSFactorBase);
   kbSetTargetSelectorFactor(cTSFactorDanger, gTSFactorDanger);

   xsEnableRule("autoSave");
   // Trigger first autosave immediately
   autoSave();

   // postInit() is called by transportArrive() or by the waitForStartup rule.
}

rule waitForStartup
inactive
minInterval 1
{
   if (kbUnitCount(cMyID, cUnitTypeAIStart, cUnitStateAny) < 1)
      return;
   xsDisableSelf();

   if (kbUnitCount(cMyID, cUnitTypeTownCenter, cUnitStateAlive) > 0)
   {
      aiEcho("Start mode:  Scenario TC.");
      gStartMode = cStartModeScenarioTC;
   }
   else
   {
      if (kbUnitCount(cMyID, gCoveredWagonUnit, cUnitStateAlive) > 0)
      {
         aiEcho("Start mode:  Scenario wagon.");
         gStartMode = cStartModeScenarioWagon;
      }
      else
      {
         aiEcho("Start mode:  Scenario, no TC.");
         gStartMode = cStartModeScenarioNoTC;
      }
   }
   if (cvInactiveAI == false)
      transportArrive();
}

/*void testHandler(int parm = -1)
{
   aiEcho("StateChanged EventHandlerCalled with PlanID " + parm);
}*/

//==============================================================================
// RULE fillInWallGaps
//==============================================================================
rule fillInWallGaps
minInterval 31
inactive
{
   // If we're not building walls, go away.
   if (gBuildWalls == false)
   {
      xsDisableSelf();
      return;
   }

   // If we already have a build wall plan, don't make another one.
   if (aiPlanGetIDByTypeAndVariableType(cPlanBuildWall, cBuildWallPlanWallType, cBuildWallPlanWallTypeRing, true) >= 0)
      return;

   int wallPlanID = aiPlanCreate("FillInWallGaps", cPlanBuildWall);
   if (wallPlanID != -1)
   {
      aiPlanSetVariableInt(wallPlanID, cBuildWallPlanWallType, 0, cBuildWallPlanWallTypeRing);
      aiPlanAddUnitType(wallPlanID, cUnitTypeSettler, 1, 1, 1);
      aiPlanSetVariableVector(wallPlanID, cBuildWallPlanWallRingCenterPoint, 0,
                              kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)));
      aiPlanSetVariableFloat(wallPlanID, cBuildWallPlanWallRingRadius, 0, 30.0);
      aiPlanSetVariableInt(wallPlanID, cBuildWallPlanNumberOfGates, 0, 2);
      aiPlanSetBaseID(wallPlanID, kbBaseGetMainID(cMyID));
      aiPlanSetEscrowID(wallPlanID, cEconomyEscrowID);
      aiPlanSetDesiredPriority(wallPlanID, 80);
      aiPlanSetActive(wallPlanID, true);
   }
}

void monopolyStartHandler(int teamID = -1)
{
   aiEcho("     ");
   aiEcho("     ");
   aiEcho("     ");
   aiEcho("MonopolyStartHandler:  Team " + teamID);
   if (teamID < 0)
      return;

   // If this is my team, congratulate teammates and taunt enemies
   if (kbGetPlayerTeam(cMyID) == teamID)
   {
      sendStatement(cPlayerRelationAlly, cAICommPromptToAllyWhenWeGetMonopoly, cInvalidVector);
      sendStatement(cPlayerRelationEnemyNotGaia, cAICommPromptToEnemyWhenWeGetMonopoly, cInvalidVector);
   }
   else // Otherwise, snide comment to enemies and condolences to partners
   {
      sendStatement(cPlayerRelationAlly, cAICommPromptToAllyWhenEnemiesGetMonopoly, cInvalidVector);
      sendStatement(cPlayerRelationEnemyNotGaia, cAICommPromptToEnemyWhenTheyGetMonopoly, cInvalidVector);
   }
   gIsMonopolyRunning = true;
   gMonopolyTeam = teamID;
   gMonopolyEndTime = xsGetTime() + 5 * 60 * 1000;
   xsEnableRule("monopolyTimer");
}

void monopolyEndHandler(int teamID = -1)
{
   aiEcho("     ");
   aiEcho("     ");
   aiEcho("     ");
   aiEcho("MonopolyEndHandler:  Team " + teamID);
   if (teamID < 0)
      return;
   // If this is my team, console partners, and send defiant message to enemies
   if (kbGetPlayerTeam(cMyID) == teamID)
   {
      sendStatement(cPlayerRelationAlly, cAICommPromptToAllyEnemyDestroyedMonopoly, cInvalidVector);
      sendStatement(cPlayerRelationEnemyNotGaia, cAICommPromptToEnemyTheyDestroyedMonopoly, cInvalidVector);
   }
   else // Otherwise, gloat at enemies
   {
      sendStatement(cPlayerRelationEnemyNotGaia, cAICommPromptToEnemyIDestroyedMonopoly, cInvalidVector);
   }
   gIsMonopolyRunning = false;
   gMonopolyTeam = -1;
   gMonopolyEndTime = -1;
   xsDisableRule("monopolyTimer");
}

rule monopolyTimer
inactive
minInterval 5
{
   if ((gIsMonopolyRunning == false) || (gMonopolyEndTime < 0))
   {
      xsDisableSelf();
      return;
   }
   if (xsGetTime() > gMonopolyEndTime)
   {
      // If this is my team, congratulate teammates and taunt enemies
      if (kbGetPlayerTeam(cMyID) == gMonopolyTeam)
      {
         sendStatement(cPlayerRelationAlly, cAICommPromptToAlly1MinuteLeftOurMonopoly, cInvalidVector);
         sendStatement(cPlayerRelationEnemyNotGaia, cAICommPromptToEnemy1MinuteLeftOurMonopoly, cInvalidVector);
      }
      else // Otherwise, snide comment to enemies and panic to partners
      {
         sendStatement(cPlayerRelationAlly, cAICommPromptToAlly1MinuteLeftEnemyMonopoly, cInvalidVector);
         sendStatement(cPlayerRelationEnemyNotGaia, cAICommPromptToEnemy1MinuteLeftEnemyMonopoly, cInvalidVector);
      }
      xsDisableSelf();
      return;
   }
}

rule monopolyManager
minInterval 21
inactive
group tcComplete
{
   if (aiTreatyActive() == true)
   {
      aiEcho("    Monopoly delayed because treaty is active.");
      return;
   }
   if (aiIsMonopolyAllowed() == false)
   {
      aiEcho("    Monopoly not allowed, terminating rule.");
      xsDisableSelf();
   }
   if (kbUnitCount(cMyID, cUnitTypeTradingPost, cUnitStateAlive) < 1)
      return; // Not allowed to research without a building...

   if (aiReadyForTradeMonopoly() == true)
   {
      aiEcho("      Trade monopoly is available.");
      if (kbResourceGet(cResourceGold) >= kbTechCostPerResource(cTechTradeMonopoly, cResourceGold) &&
          kbResourceGet(cResourceFood) >= kbTechCostPerResource(cTechTradeMonopoly, cResourceFood) &&
          kbResourceGet(cResourceWood) >= kbTechCostPerResource(cTechTradeMonopoly, cResourceWood))
      {
         aiEcho("    Attempting trade monopoly");
         if (aiDoTradeMonopoly() == true)
            kbEscrowAllocateCurrentResources();
      }
      else
      {
         aiEcho("    ....but I can't afford it.");
      }
   }
}

void KOTHVictoryStartHandler(int teamID = -1)
{
   int newOppID = -1;

   aiEcho("     ");
   aiEcho("     ");
   aiEcho("     ");
   aiEcho("KOTHStartHandler:  Team " + teamID);
   if (teamID < 0)
      return;

   gIsKOTHRunning = true;
   gKOTHTeam = teamID;
}

void KOTHVictoryEndHandler(int teamID = -1)
{
   aiEcho("     ");
   aiEcho("     ");
   aiEcho("     ");
   aiEcho("KOTHEndHandler:  Team " + teamID);
   if (teamID < 0)
      return;

   gIsKOTHRunning = false;
   gKOTHTeam = -1;
}

rule sacredFieldMonitor
inactive
minInterval 60
{

   static int cowPlan = -1;
   int numHerdables = 0;
   int numCows = 0;

   // Build a sacred field if there is none and we're either in age2, have herdables or excess wood
   if ((kbUnitCount(cMyID, cUnitTypeypSacredField, cUnitStateAlive) < 1) &&
           ((kbGetAge() >= cAge2) || (kbUnitCount(cMyID, cUnitTypeHerdable, cUnitStateAlive) +
                                          kbUnitCount(cMyID, cUnitTypeypSacredCow, cUnitStateAlive) >
                                      0)) ||
       (kbResourceGet(cResourceWood) > 650))
   { // Make sure we're not at the limit yet or are already trying to build one
      if ((kbGetBuildLimit(cMyID, cUnitTypeypSacredField) >
           kbUnitCount(cMyID, cUnitTypeypSacredField, cUnitStateAlive)) &&
          (aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeypSacredField) < 0))
      {
         createSimpleBuildPlan(cUnitTypeypSacredField, 1, 50, true, cEconomyEscrowID, kbBaseGetMainID(cMyID), 1);
         return;
      }
   }

   // Quit if there is no sacred field around or we're in age1 without excess food
   if ((kbUnitCount(cMyID, cUnitTypeypSacredField, cUnitStateAlive) < 1) && (kbGetAge() == cAge1) &&
       (kbResourceGet(cResourceFood) < 925))
   {
      return;
   }

   // Check number of captured herdables, add sacred cows as necessary to bring total number to 10
   numHerdables = kbUnitCount(cMyID, cUnitTypeHerdable, cUnitStateAlive) -
                  kbUnitCount(cMyID, cUnitTypeypSacredCow, cUnitStateAlive);
   if (numHerdables < 0)
      numHerdables = 0;
   numCows = 10 - numHerdables;
   if (numCows > 0)
   {
      // Create/update maintain plan
      if (cowPlan < 0)
      {
         cowPlan = createSimpleMaintainPlan(cUnitTypeypSacredCow, numCows, true, kbBaseGetMainID(cMyID), 1);
      }
      else
      {
         aiPlanSetVariableInt(cowPlan, cTrainPlanNumberToMaintain, 0, numCows);
      }
   }

   if (numHerdables > 0)
   {
      int upgradePlanID = -1;

      // Get XP upgrade
      if (kbTechGetStatus(cTechypLivestockHoliness) == cTechStatusObtainable)
      {
         if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypLivestockHoliness) >= 0)
            return;
         createSimpleResearchPlan(cTechypLivestockHoliness, getUnit(cUnitTypeypSacredField), cMilitaryEscrowID, 50);
         return;
      }
   }
}

rule factoryUpgradeMonitor
inactive
minInterval 45
{
   int upgradePlanID = -1;

   // Disable rule once all upgrades are available
   if ((kbTechGetStatus(cTechFactoryCannery) == cTechStatusActive) &&
       (kbTechGetStatus(cTechFactoryWaterPower) == cTechStatusActive) &&
       (kbTechGetStatus(cTechFactorySteamPower) == cTechStatusActive) &&
       (kbTechGetStatus(cTechFactoryMassProduction) == cTechStatusActive) &&
       ((kbTechGetStatus(cTechImperialBombard) == cTechStatusActive) ||
        (kbTechGetStatus(cTechImperialCannon) == cTechStatusActive) ||
        (kbTechGetStatus(cTechImperialRocket) == cTechStatusActive)))
   {
      xsDisableSelf();
      return;
   }

   // Define a query to get all matching units
   int factoryQueryID = -1;
   factoryQueryID = kbUnitQueryCreate("factoryGetUnitQuery");
   kbUnitQuerySetIgnoreKnockedOutUnits(factoryQueryID, true);
   if (factoryQueryID != -1)
   {
      kbUnitQuerySetPlayerRelation(factoryQueryID, -1);
      kbUnitQuerySetPlayerID(factoryQueryID, cMyID);
      kbUnitQuerySetUnitType(factoryQueryID, cUnitTypeFactory);
      kbUnitQuerySetState(factoryQueryID, cUnitStateAlive);
      kbUnitQueryResetResults(factoryQueryID);
      int numberFound = kbUnitQueryExecute(factoryQueryID);
      for (index = 0; < numberFound)
      {
         int factoryID = kbUnitQueryGetResult(factoryQueryID, index);
         // Get upgrades as they become useful
         if (kbTechGetStatus(cTechFactoryCannery) == cTechStatusObtainable && aiUnitGetTactic(factoryID) == cTacticFood)
         {
            if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechFactoryCannery) >= 0)
               return;
            createSimpleResearchPlan(cTechFactoryCannery, factoryID, cEconomyEscrowID, 85);
            return;
         }
         if (kbTechGetStatus(cTechFactoryWaterPower) == cTechStatusObtainable &&
             aiUnitGetTactic(factoryID) == cTacticWood)
         {
            if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechFactoryWaterPower) >= 0)
               return;
            createSimpleResearchPlan(cTechFactoryWaterPower, factoryID, cEconomyEscrowID, 85);
            return;
         }
         if (kbTechGetStatus(cTechFactorySteamPower) == cTechStatusObtainable &&
             aiUnitGetTactic(factoryID) == cTacticNormal)
         {
            if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechFactorySteamPower) >= 0)
               return;
            createSimpleResearchPlan(cTechFactorySteamPower, factoryID, cEconomyEscrowID, 85);
            return;
         }
         if (kbTechGetStatus(cTechFactoryMassProduction) == cTechStatusObtainable &&
             aiUnitGetTactic(factoryID) == cTacticCannon)
         {
            if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechFactoryMassProduction) >= 0)
               return;
            createSimpleResearchPlan(cTechFactoryMassProduction, factoryID, cMilitaryEscrowID, 85);
            return;
         }
         if ((kbTechGetStatus(cTechImperialBombard) == cTechStatusObtainable) &&
             (kbCanAffordTech(cTechImperialBombard, cMilitaryEscrowID) == true) &&
             (kbUnitCount(cMyID, cUnitTypeGreatBombard, cUnitStateAlive) >= 3))
         {
            if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImperialBombard) >= 0)
               return;
            createSimpleResearchPlan(cTechImperialBombard, factoryID, cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechImperialCannon) == cTechStatusObtainable) &&
             (kbCanAffordTech(cTechImperialCannon, cMilitaryEscrowID) == true) &&
             (kbUnitCount(cMyID, cUnitTypeCannon, cUnitStateAlive) >= 3))
         {
            if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImperialCannon) >= 0)
               return;
            createSimpleResearchPlan(cTechImperialCannon, factoryID, cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechImperialRocket) == cTechStatusObtainable) &&
             (kbCanAffordTech(cTechImperialRocket, cMilitaryEscrowID) == true) &&
             (kbUnitCount(cMyID, cUnitTypeRocket, cUnitStateAlive) >= 3))
         {
            if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImperialRocket) >= 0)
               return;
            createSimpleResearchPlan(cTechImperialRocket, factoryID, cMilitaryEscrowID, 50);
            return;
         }
      }
   }
}

rule fortUpgradeMonitor
inactive
minInterval 90
{
   int upgradePlanID = -1;

   // Disable rule once both upgrades are available
   if ((kbTechGetStatus(cTechRevetment) == cTechStatusActive) && (kbTechGetStatus(cTechStarFort) == cTechStatusActive))
   {
      xsDisableSelf();
      return;
   }

   // Quit if there is no fort
   if (kbUnitCount(cMyID, cUnitTypeFortFrontier, cUnitStateAlive) < 1)
   {
      return;
   }

   // Get upgrades one at a time as they become available
   if (kbTechGetStatus(cTechRevetment) == cTechStatusObtainable)
   {
      if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechRevetment) >= 0)
         return;
      createSimpleResearchPlan(cTechRevetment, getUnit(cUnitTypeFortFrontier), cMilitaryEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechStarFort) == cTechStatusObtainable)
   {
      if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechStarFort) >= 0)
         return;
      createSimpleResearchPlan(cTechStarFort, getUnit(cUnitTypeFortFrontier), cMilitaryEscrowID, 50);
      return;
   }
}

rule agraFortUpgradeMonitor
inactive
minInterval 90
{
   int upgradePlanID = -1;
   int agraFortType = -1;

   // Disable rule once both upgrades are available
   if ((kbTechGetStatus(cTechypFrontierAgra) == cTechStatusActive) &&
       (kbTechGetStatus(cTechypFortifiedAgra) == cTechStatusActive))
   {
      xsDisableSelf();
      return;
   }

   // Check for agra fort
   if (kbUnitCount(cMyID, cUnitTypeypWIAgraFort2, cUnitStateAlive) > 0)
   {
      agraFortType = cUnitTypeypWIAgraFort2;
   }
   else if (kbUnitCount(cMyID, cUnitTypeypWIAgraFort3, cUnitStateAlive) > 0)
   {
      agraFortType = cUnitTypeypWIAgraFort3;
   }
   else if (kbUnitCount(cMyID, cUnitTypeypWIAgraFort4, cUnitStateAlive) > 0)
   {
      agraFortType = cUnitTypeypWIAgraFort4;
   }
   else if (kbUnitCount(cMyID, cUnitTypeypWIAgraFort5, cUnitStateAlive) > 0)
   {
      agraFortType = cUnitTypeypWIAgraFort5;
   }

   // Quit if there is no agra fort
   if (agraFortType < 0)
   {
      return;
   }

   // Get upgrades one at a time as they become available
   if (kbTechGetStatus(cTechypFrontierAgra) == cTechStatusObtainable)
   {
      if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypFrontierAgra) >= 0)
         return;
      createSimpleResearchPlan(cTechypFrontierAgra, getUnit(agraFortType), cMilitaryEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechypFortifiedAgra) == cTechStatusObtainable)
   {
      if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypFortifiedAgra) >= 0)
         return;
      createSimpleResearchPlan(cTechypFortifiedAgra, getUnit(agraFortType), cMilitaryEscrowID, 50);
      return;
   }
}

rule shrineUpgradeMonitor
inactive
minInterval 89
{
   int upgradePlanID = -1;
   int limit = 0;

   // Disable rule once the upgrade is available
   if (kbTechGetStatus(cTechypShrineFortressUpgrade) == cTechStatusActive)
   {
      xsDisableSelf();
      return;
   }

   // Quit if there are not at least 15 shrines, or a toshogu shrine and at least 10 normal ones
   if ((kbUnitCount(cMyID, cUnitTypeypWJToshoguShrine2, cUnitStateAlive) > 0) ||
       (kbUnitCount(cMyID, cUnitTypeypWJToshoguShrine3, cUnitStateAlive) > 0) ||
       (kbUnitCount(cMyID, cUnitTypeypWJToshoguShrine4, cUnitStateAlive) > 0) ||
       (kbUnitCount(cMyID, cUnitTypeypWJToshoguShrine5, cUnitStateAlive) > 0))
   {
      limit = 10;
   }
   else
   {
      limit = 15;
   }
   if (kbUnitCount(cMyID, cUnitTypeypShrineJapanese, cUnitStateAlive) < limit)
   {
      return;
   }

   // Get upgrade
   if (kbTechGetStatus(cTechypShrineFortressUpgrade) == cTechStatusObtainable)
   {
      if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypShrineFortressUpgrade) >= 0)
         return;
      createSimpleResearchPlan(cTechypShrineFortressUpgrade, getUnit(cUnitTypeypShrineJapanese), cEconomyEscrowID, 50);
      return;
   }
}

rule dojoUpgradeMonitor
inactive
minInterval 60
{
   int upgradePlanID = -1;

   // Disable rule once the upgrade is available
   if (kbTechGetStatus(cTechypDojoUpgrade1) == cTechStatusActive)
   {
      xsDisableSelf();
      return;
   }

   // Quit if there is no dojo
   if (kbUnitCount(cMyID, cUnitTypeypDojo, cUnitStateAlive) < 1)
   {
      return;
   }

   // Get upgrade
   if (kbTechGetStatus(cTechypDojoUpgrade1) == cTechStatusObtainable)
   {
      if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypDojoUpgrade1) >= 0)
         return;
      createSimpleResearchPlan(cTechypDojoUpgrade1, getUnit(cUnitTypeypDojo), cMilitaryEscrowID, 50);
      return;
   }
}

rule factoryTacticMonitor
inactive
mininterval 10
{
  
   // Define a query to get all matching units
   int factoryQueryID=-1;
   factoryQueryID=kbUnitQueryCreate("factoryGetUnitQuery");
   kbUnitQuerySetIgnoreKnockedOutUnits(factoryQueryID, true);
   if (factoryQueryID != -1)
   {
      kbUnitQuerySetPlayerRelation(factoryQueryID, -1);
      kbUnitQuerySetPlayerID(factoryQueryID, cMyID);
      kbUnitQuerySetUnitType(factoryQueryID, cUnitTypeFactory);
      kbUnitQuerySetState(factoryQueryID, cUnitStateAlive);
      kbUnitQueryResetResults(factoryQueryID);
   }
   
   int numberFound=kbUnitQueryExecute(factoryQueryID);
   // wait until a factory is found.
   if (numberFound < 1)
     return;

   int index = 0;
   float percentOnFood = aiGetResourceGathererPercentage(cResourceFood, cRGPActual);
   float percentOnWood = aiGetResourceGathererPercentage(cResourceWood, cRGPActual);
   float percentOnGold = aiGetResourceGathererPercentage(cResourceGold, cRGPActual);
   float totalResources = kbResourceGet(cResourceFood) + kbResourceGet(cResourceWood) + kbResourceGet(cResourceGold);
   
   for (index = 0; < numberFound) 
   {
       if ((kbResourceGet(cResourceFood) < (totalResources / 10.0)) || (kbResourceGet(cResourceFood) < 4000))
          aiUnitSetTactic(kbUnitQueryGetResult(factoryQueryID, index), cTacticFood);
		else
       if ((kbResourceGet(cResourceGold) < (totalResources / 10.0)) || (kbResourceGet(cResourceGold) < 4000))
          aiUnitSetTactic(kbUnitQueryGetResult(factoryQueryID, index), cTacticNormal);
		else
       if ((kbResourceGet(cResourceWood) < (totalResources / 10.0)) || (kbResourceGet(cResourceWood) < 2000))
          aiUnitSetTactic(kbUnitQueryGetResult(factoryQueryID, index), cTacticWood);
		else
			if (kbUnitCount(cMyID, cUnitTypeAbstractArtillery, cUnitStateABQ) < 12)
	      aiUnitSetTactic(kbUnitQueryGetResult(factoryQueryID, index), cTacticCannon);
	  else
          aiUnitSetTactic(kbUnitQueryGetResult(factoryQueryID, index), cTacticWood);
   }
}

rule KanchaTacticMonitor
inactive
mininterval 10
{
  
  
      if (kbTechGetStatus(cTechDEHCAutarky) != cTechStatusActive)
	  return;
  
   // Define a query to get all matching units
   int KanchaQueryID=-1;
   KanchaQueryID=kbUnitQueryCreate("KanchaGetUnitQuery");
   kbUnitQuerySetIgnoreKnockedOutUnits(KanchaQueryID, true);
   if (KanchaQueryID != -1)
   {
      kbUnitQuerySetPlayerRelation(KanchaQueryID, -1);
      kbUnitQuerySetPlayerID(KanchaQueryID, cMyID);
      kbUnitQuerySetUnitType(KanchaQueryID, cUnitTypedeHouseInca);
      kbUnitQuerySetState(KanchaQueryID, cUnitStateAlive);
      kbUnitQueryResetResults(KanchaQueryID);
   }
   
   int numberFound=kbUnitQueryExecute(KanchaQueryID);
   // wait until a factory is found.
   if (numberFound < 1)
     return;

   int index = 0;
   float percentOnFood = aiGetResourceGathererPercentage(cResourceFood, cRGPActual);
   float percentOnWood = aiGetResourceGathererPercentage(cResourceWood, cRGPActual);
   float percentOnGold = aiGetResourceGathererPercentage(cResourceGold, cRGPActual);
   float totalResources = kbResourceGet(cResourceFood) + kbResourceGet(cResourceWood) + kbResourceGet(cResourceGold);
   
   if ((kbResourceGet(cResourceFood) < (totalResources / 10.0)) || (kbResourceGet(cResourceFood) < 1000))
   aiUnitSetTactic(kbUnitQueryGetResult(KanchaQueryID, index), cTacticKanchaFood);
   else
   aiUnitSetTactic(kbUnitQueryGetResult(KanchaQueryID, index), cTacticKanchaWood);
}

rule porcelainTowerTacticMonitor
inactive
group tcComplete
mininterval 60
{
   // Disable rule for anybody but Chinese
   if (cMyCiv != cCivChinese)
   {
      xsDisableSelf();
      return;
   }

   int porcelainTowerType = -1;
   static int resourceType = -1;

   // Check for porcelain tower
   if (kbUnitCount(cMyID, cUnitTypeypWCPorcelainTower2, cUnitStateAlive) > 0)
   {
      porcelainTowerType = cUnitTypeypWCPorcelainTower2;
   }
   else if (kbUnitCount(cMyID, cUnitTypeypWCPorcelainTower3, cUnitStateAlive) > 0)
   {
      porcelainTowerType = cUnitTypeypWCPorcelainTower3;
   }
   else if (kbUnitCount(cMyID, cUnitTypeypWCPorcelainTower4, cUnitStateAlive) > 0)
   {
      porcelainTowerType = cUnitTypeypWCPorcelainTower4;
   }
   else if (kbUnitCount(cMyID, cUnitTypeypWCPorcelainTower5, cUnitStateAlive) > 0)
   {
      porcelainTowerType = cUnitTypeypWCPorcelainTower5;
   }

   if (porcelainTowerType > 0)
   {
      int porcelainTowerQueryID = -1;
      porcelainTowerQueryID = kbUnitQueryCreate("porcelainTowerQueryID");
      kbUnitQuerySetIgnoreKnockedOutUnits(porcelainTowerQueryID, true);
      if (porcelainTowerQueryID != -1)
      {
         kbUnitQuerySetPlayerRelation(porcelainTowerQueryID, -1);
         kbUnitQuerySetPlayerID(porcelainTowerQueryID, cMyID);
         kbUnitQuerySetUnitType(porcelainTowerQueryID, porcelainTowerType);
         kbUnitQuerySetState(porcelainTowerQueryID, cUnitStateAlive);
         kbUnitQueryResetResults(porcelainTowerQueryID);
         int numberFound = kbUnitQueryExecute(porcelainTowerQueryID);

         if (numberFound > 0)
         {
            // Default to all, adjust as appropriate.
            int porcelainTowerTactic = cTacticWonderRainbow;
            // Focus on food before Age 3, any non-excess resource afterwards (focus on wood and gold).
            if (kbGetAge() < cAge3)
            {
               porcelainTowerTactic = cTacticWonderFood;
            }
            else if (kbResourceGet(cResourceGold) < 2000)
            {
               porcelainTowerTactic = cTacticWonderCoin;
            }
            else if (kbResourceGet(cResourceWood) < 2000)
            {
               porcelainTowerTactic = cTacticWonderWood;
            }
            else if (kbResourceGet(cResourceFood) < 2000)
            {
               porcelainTowerTactic = cTacticWonderFood;
            }
            float totalResources =
                kbResourceGet(cResourceFood) + kbResourceGet(cResourceWood) + kbResourceGet(cResourceGold);
            // Check for resource imbalances, except when we're short on everything.
            if (totalResources >= 900.0)
            {
               if (kbResourceGet(cResourceFood) < (totalResources / 9.0))
               {
                  porcelainTowerTactic = cTacticWonderFood;
               }
               if (kbResourceGet(cResourceGold) < (totalResources / 9.0))
               {
                  porcelainTowerTactic = cTacticWonderCoin;
               }
               if (kbResourceGet(cResourceWood) < (totalResources / 9.0))
               {
                  porcelainTowerTactic = cTacticWonderWood;
               }
            }
            aiUnitSetTactic(kbUnitQueryGetResult(porcelainTowerQueryID, 0), porcelainTowerTactic);
         }
      }
   }
}

rule summerPalaceTacticMonitor
inactive
mininterval 10
{
   // Disable rule for anybody but Chinese
   if (cMyCiv != cCivChinese)
   {
      xsDisableSelf();
      return;
   }

   // In Age 2, stay with standard army (default)
   if (kbGetAge() < cAge3)
   {
      return;
   }

   int summerPalaceType = -1;
   int randomizer = -1;

   // Check for summer palace
   if (kbUnitCount(cMyID, cUnitTypeypWCSummerPalace2, cUnitStateAlive) > 0)
   {
      summerPalaceType = cUnitTypeypWCSummerPalace2;
   }
   else if (kbUnitCount(cMyID, cUnitTypeypWCSummerPalace3, cUnitStateAlive) > 0)
   {
      summerPalaceType = cUnitTypeypWCSummerPalace3;
   }
   else if (kbUnitCount(cMyID, cUnitTypeypWCSummerPalace4, cUnitStateAlive) > 0)
   {
      summerPalaceType = cUnitTypeypWCSummerPalace4;
   }
   else if (kbUnitCount(cMyID, cUnitTypeypWCSummerPalace5, cUnitStateAlive) > 0)
   {
      summerPalaceType = cUnitTypeypWCSummerPalace5;
   }

   if (summerPalaceType > 0)
   {
      int summerPalaceQueryID = -1;
      summerPalaceQueryID = kbUnitQueryCreate("summerPalaceQueryID");
      kbUnitQuerySetIgnoreKnockedOutUnits(summerPalaceQueryID, true);
      if (summerPalaceQueryID != -1)
      {
         kbUnitQuerySetPlayerRelation(summerPalaceQueryID, -1);
         kbUnitQuerySetPlayerID(summerPalaceQueryID, cMyID);
         kbUnitQuerySetUnitType(summerPalaceQueryID, summerPalaceType);
         kbUnitQuerySetState(summerPalaceQueryID, cUnitStateAlive);
         kbUnitQueryResetResults(summerPalaceQueryID);
         int numberFound = kbUnitQueryExecute(summerPalaceQueryID);

         // In Age 3 and above, spawn either territorial, forbidden or imperial army
         if (numberFound > 0)
         {
            randomizer = aiRandInt(3);
            switch (randomizer)
            {
            case 0:
            {
               aiUnitSetTactic(kbUnitQueryGetResult(summerPalaceQueryID, 0), cTacticTerritorialArmy);
               break;
            }
            case 1:
            {
               aiUnitSetTactic(kbUnitQueryGetResult(summerPalaceQueryID, 0), cTacticForbiddenArmy);
               break;
            }
            default:
            {
               aiUnitSetTactic(kbUnitQueryGetResult(summerPalaceQueryID, 0), cTacticImperialArmy);
               break;
            }
            }

            // Disable rule once a new tactic has been set
            xsDisableSelf();
         }
      }
   }
}

rule goldenPavillionTacticMonitor
inactive
group tcComplete
mininterval 180
{
   // Disable rule for anybody but Japanese
   if (kbGetCiv() != cCivJapanese)
   {
      xsDisableSelf();
      return;
   }

   static bool goldenPavillionBuilt = false;
   static bool goldenPavillionBuiltConfirm = false;
   int goldenPavillionType = -1;

   // Check for golden pavillion
   if (kbUnitCount(cMyID, cUnitTypeypWJGoldenPavillion2, cUnitStateAlive) > 0)
   {
      goldenPavillionType = cUnitTypeypWJGoldenPavillion2;
   }
   else if (kbUnitCount(cMyID, cUnitTypeypWJGoldenPavillion3, cUnitStateAlive) > 0)
   {
      goldenPavillionType = cUnitTypeypWJGoldenPavillion3;
   }
   else if (kbUnitCount(cMyID, cUnitTypeypWJGoldenPavillion4, cUnitStateAlive) > 0)
   {
      goldenPavillionType = cUnitTypeypWJGoldenPavillion4;
   }
   else if (kbUnitCount(cMyID, cUnitTypeypWJGoldenPavillion5, cUnitStateAlive) > 0)
   {
      goldenPavillionType = cUnitTypeypWJGoldenPavillion5;
   }

   if (goldenPavillionType < 0)
   {
      if (goldenPavillionBuilt == false) // not built yet.
	 return;
      else // built and lost 
      {
 	 xsDisableSelf();
	 return;
      }
   }

   //when we're here, Golden Pavillion wonder has been built and still exists(goldenPavillionType >= 0).
   if (goldenPavillionBuiltConfirm == false)
   {
      goldenPavillionBuilt = true;
      goldenPavillionBuiltConfirm = true;
   }

   static int enemyPointQuery = -1;
   enemyPointQuery = createSimpleQuery(cPlayerRelationEnemyNotGaia, cUnitTypeLogicalTypeLandMilitary, cUnitStateABQ);
   kbUnitQueryResetResults(enemyPointQuery);
   int enemyCount = kbUnitQueryExecute(enemyPointQuery);

   if (enemyCount < 5) //don't bother if little enemy found.
      return;

   int enemyPointID = 0;
   vector enemyPointVector = cInvalidVector;
   int enemyPointCount = 0;
   int selfPointCount = 0;
   int selfRangedUnitCount = 0;
   int selfHandUnitCount = 0;
   bool rangedUnitDominating = false;
   int i = 0;
   for (i=0; <enemyCount)
   {
	enemyPointID = kbUnitQueryGetResult(enemyPointQuery, i);
	enemyPointVector = kbUnitGetPosition(enemyPointID);
	enemyPointCount = getUnitCountByLocation(cUnitTypeLogicalTypeLandMilitary, cPlayerRelationEnemyNotGaia, cUnitStateAlive, enemyPointVector, 30.0);
	selfPointCount = getUnitCountByLocation(cUnitTypeLogicalTypeLandMilitary, cMyID, cUnitStateAlive, enemyPointVector, 30.0);
	selfRangedUnitCount = getUnitCountByLocation(cUnitTypeAbstractRangedInfantry, cMyID, cUnitStateAlive, enemyPointVector, 30.0) + getUnitCountByLocation(cUnitTypeAbstractRangedCavalry, cMyID, cUnitStateAlive, enemyPointVector, 30.0);
	selfHandUnitCount = selfPointCount - selfRangedUnitCount;	   
	if ((enemyPointCount >= 5) && (selfRangedUnitCount > 10)&&(selfRangedUnitCount > selfHandUnitCount*2))
	{
	   rangedUnitDominating = true;
	   break;
	}
   }
   if (rangedUnitDominating == true)
      aiUnitSetTactic(goldenPavillionType, cTacticRangeDamage);
   else
      aiUnitSetTactic(goldenPavillionType, cTacticUnitHitpoints);
}

rule dojoTacticMonitor
inactive
minInterval 10
{
   int randomizer = -1;
   static int dojoTactic1 = -1;
   static int dojoTactic2 = -1;
/*
   switch (kbUnitPickGetResult(gLandUnitPicker, 0))
   {
   case cUnitTypeypYumi:
   {
      randomizer = aiRandInt(3);
      if (randomizer < 2)
      {
         dojoTactic1 = cTacticSamurai;
      }
      else
      {
         dojoTactic1 = cTacticAshigaru;
      }
      break;
   }
   case cUnitTypeypAshigaru:
   {
      randomizer = aiRandInt(10);
      if (randomizer < 7)
      {
         dojoTactic1 = cTacticNaginataRider;
      }
      else
      {
         dojoTactic1 = cTacticYumi;
      }
      break;
   }
   case cUnitTypeypKensei:
   {
      randomizer = aiRandInt(10);
      if (randomizer < 7)
      {
         dojoTactic1 = cTacticNaginataRider;
      }
      else
      {
         dojoTactic1 = cTacticYumi;
      }
      break;
   }
   case cUnitTypeypNaginataRider:
   {
      randomizer = aiRandInt(3);
      if (randomizer < 2)
      {
         dojoTactic1 = cTacticSamurai;
      }
      else
      {
         dojoTactic1 = cTacticAshigaru;
      }
      break;
   }
   case cUnitTypeypYabusame:
   {
      randomizer = aiRandInt(10);
      if (randomizer < 7)
      {
         dojoTactic1 = cTacticNaginataRider;
      }
      else
      {
         dojoTactic1 = cTacticYumi;
      }
      break;
   }
   default:
   {
      // Mercenary units? Go for randomize unit generation
      randomizer = aiRandInt(20);
      if (randomizer < 3)
      {
         dojoTactic1 = cTacticYumi;
      }
      else if (randomizer < 7)
      {
         dojoTactic1 = cTacticAshigaru;
      }
      else if (randomizer < 14)
      {
         dojoTactic1 = cTacticSamurai;
      }
      else if (randomizer < 19)
      {
         dojoTactic1 = cTacticNaginataRider;
      }
      else
      {
         dojoTactic1 = cTacticYabusame;
      }
      break;
   }
   }

   // Randomize unit generation option for second dojo
   switch (kbUnitPickGetResult(gLandUnitPicker, 1))
   {
   case cUnitTypeypYumi:
   {
      randomizer = aiRandInt(3);
      if (randomizer < 2)
      {
         dojoTactic2 = cTacticSamurai;
      }
      else
      {
         dojoTactic2 = cTacticAshigaru;
      }
      break;
   }
   case cUnitTypeypAshigaru:
   {
      randomizer = aiRandInt(10);
      if (randomizer < 7)
      {
         dojoTactic2 = cTacticNaginataRider;
      }
      else
      {
         dojoTactic2 = cTacticYumi;
      }
      break;
   }
   case cUnitTypeypKensei:
   {
      randomizer = aiRandInt(10);
      if (randomizer < 7)
      {
         dojoTactic2 = cTacticNaginataRider;
      }
      else
      {
         dojoTactic2 = cTacticYumi;
      }
      break;
   }
   case cUnitTypeypNaginataRider:
   {
      randomizer = aiRandInt(3);
      if (randomizer < 2)
      {
         dojoTactic2 = cTacticSamurai;
      }
      else
      {
         dojoTactic2 = cTacticAshigaru;
      }
      break;
   }
   case cUnitTypeypYabusame:
   {
      randomizer = aiRandInt(10);
      if (randomizer < 7)
      {
         dojoTactic2 = cTacticNaginataRider;
      }
      else
      {
         dojoTactic2 = cTacticYumi;
      }
      break;
   }
   default:
   {
      // Mercenary units? Go for randomize unit generation
      randomizer = aiRandInt(20);
      if (randomizer < 3)
      {
         dojoTactic2 = cTacticYumi;
      }
      else if (randomizer < 7)
      {
         dojoTactic2 = cTacticAshigaru;
      }
      else if (randomizer < 14)
      {
         dojoTactic2 = cTacticSamurai;
      }
      else if (randomizer < 19)
      {
         dojoTactic2 = cTacticNaginataRider;
      }
      else
      {
         dojoTactic2 = cTacticYabusame;
      }
      break;
   }
   }
   */
   dojoTactic1 = cTacticYumi;
   dojoTactic2 = cTacticYumi;

   // Define a query to get all matching units
   int dojoQueryID = -1;
   dojoQueryID = kbUnitQueryCreate("dojoGetUnitQuery");
   kbUnitQuerySetIgnoreKnockedOutUnits(dojoQueryID, true);
   if (dojoQueryID != -1)
   {
      kbUnitQuerySetPlayerRelation(dojoQueryID, -1);
      kbUnitQuerySetPlayerID(dojoQueryID, cMyID);
      kbUnitQuerySetUnitType(dojoQueryID, cUnitTypeypDojo);
      kbUnitQuerySetState(dojoQueryID, cUnitStateAlive);
      kbUnitQueryResetResults(dojoQueryID);
      int numberFound = kbUnitQueryExecute(dojoQueryID);
      if (numberFound == 1)
      {
         //aiUnitSetTactic(kbUnitQueryGetResult(dojoQueryID, 0), dojoTactic1);
         aiUnitSetTactic(kbUnitQueryGetResult(dojoQueryID, 0), cTacticYumi);
      }
      else if (numberFound == 2)
      {
         //aiUnitSetTactic(kbUnitQueryGetResult(dojoQueryID, 0), dojoTactic1);
         //aiUnitSetTactic(kbUnitQueryGetResult(dojoQueryID, 1), dojoTactic2);
         aiUnitSetTactic(kbUnitQueryGetResult(dojoQueryID, 0), cTacticYumi);
         aiUnitSetTactic(kbUnitQueryGetResult(dojoQueryID, 1), cTacticYumi);
         xsDisableSelf();
      }
   }
}

rule mansabdarMonitor
inactive
minInterval 30
{
   if ((kbUnitCount(cMyID, cUnitTypeypWICharminarGate2, cUnitStateAlive) < 0) &&
       (kbUnitCount(cMyID, cUnitTypeypWICharminarGate3, cUnitStateAlive) < 0) &&
       (kbUnitCount(cMyID, cUnitTypeypWICharminarGate4, cUnitStateAlive) < 0) &&
       (kbUnitCount(cMyID, cUnitTypeypWICharminarGate5, cUnitStateAlive) < 0))
   {
      return;
   }

   static int mansabdarRajputPlan = -1;
   static int mansabdarSepoyPlan = -1;
   static int mansabdarGurkhaPlan = -1;
   static int mansabdarSowarPlan = -1;
   static int mansabdarZamburakPlan = -1;
   static int mansabdarFlailElephantPlan = -1;
   static int mansabdarMahoutPlan = -1;
   static int mansabdarHowdahPlan = -1;
   static int mansabdarSiegeElephantPlan = -1;

   int numRajputs = -1;
   int numSepoys = -1;
   int numGurkhas = -1;
   int numSowars = -1;
   int numZamburaks = -1;
   int numFlailElephants = -1;
   int numMahouts = -1;
   int numHowdahs = -1;
   int numSiegeElephants = -1;

   // Check number of rajputs, maintain mansabdar rajput as long as there are at least 10
   numRajputs = kbUnitCount(cMyID, cUnitTypeypRajput, cUnitStateAlive);
   if (numRajputs >= 10)
   {
      // Create/update maintain plan
      if (mansabdarRajputPlan < 0)
      {
         mansabdarRajputPlan =
             createSimpleMaintainPlan(cUnitTypeypRajputMansabdar, 1, false, kbBaseGetMainID(cMyID), 1);
      }
      else
      {
         aiPlanSetVariableInt(mansabdarRajputPlan, cTrainPlanNumberToMaintain, 0, 1);
      }
   }
   else
   {
      // Update maintain plan, provided it exists
      if (mansabdarRajputPlan >= 0)
      {
         aiPlanSetVariableInt(mansabdarRajputPlan, cTrainPlanNumberToMaintain, 0, 0);
      }
   }
   // Check number of sepoys, maintain mansabdar sepoy as long as there are at least 10
   numSepoys = kbUnitCount(cMyID, cUnitTypeypSepoy, cUnitStateAlive);
   if (numSepoys >= 10)
   {
      // Create/update maintain plan
      if (mansabdarSepoyPlan < 0)
      {
         mansabdarSepoyPlan = createSimpleMaintainPlan(cUnitTypeypSepoyMansabdar, 1, false, kbBaseGetMainID(cMyID), 1);
      }
      else
      {
         aiPlanSetVariableInt(mansabdarSepoyPlan, cTrainPlanNumberToMaintain, 0, 1);
      }
   }
   else
   {
      // Update maintain plan, provided it exists
      if (mansabdarSepoyPlan >= 0)
      {
         aiPlanSetVariableInt(mansabdarSepoyPlan, cTrainPlanNumberToMaintain, 0, 0);
      }
   }
   // Check number of gurkhas, maintain mansabdar gurkha as long as there are at least 10
   numGurkhas = kbUnitCount(cMyID, cUnitTypeypNatMercGurkha, cUnitStateAlive);
   if (numGurkhas >= 10)
   {
      // Create/update maintain plan
      if (mansabdarGurkhaPlan < 0)
      {
         mansabdarGurkhaPlan =
             createSimpleMaintainPlan(cUnitTypeypNatMercGurkhaJemadar, 1, false, kbBaseGetMainID(cMyID), 1);
      }
      else
      {
         aiPlanSetVariableInt(mansabdarGurkhaPlan, cTrainPlanNumberToMaintain, 0, 1);
      }
   }
   else
   {
      // Update maintain plan, provided it exists
      if (mansabdarGurkhaPlan >= 0)
      {
         aiPlanSetVariableInt(mansabdarGurkhaPlan, cTrainPlanNumberToMaintain, 0, 0);
      }
   }
   // Check number of sowars, maintain mansabdar sowar as long as there are at least 7
   numSowars = kbUnitCount(cMyID, cUnitTypeypSowar, cUnitStateAlive);
   if (numSowars >= 7)
   {
      // Create/update maintain plan
      if (mansabdarSowarPlan < 0)
      {
         mansabdarSowarPlan = createSimpleMaintainPlan(cUnitTypeypSowarMansabdar, 1, false, kbBaseGetMainID(cMyID), 1);
      }
      else
      {
         aiPlanSetVariableInt(mansabdarSowarPlan, cTrainPlanNumberToMaintain, 0, 1);
      }
   }
   else
   {
      // Update maintain plan, provided it exists
      if (mansabdarSowarPlan >= 0)
      {
         aiPlanSetVariableInt(mansabdarSowarPlan, cTrainPlanNumberToMaintain, 0, 0);
      }
   }
   // Check number of zamburaks, maintain mansabdar zamburak as long as there are at least 10
   numZamburaks = kbUnitCount(cMyID, cUnitTypeypZamburak, cUnitStateAlive);
   if (numZamburaks >= 10)
   {
      // Create/update maintain plan
      if (mansabdarZamburakPlan < 0)
      {
         mansabdarZamburakPlan =
             createSimpleMaintainPlan(cUnitTypeypZamburakMansabdar, 1, false, kbBaseGetMainID(cMyID), 1);
      }
      else
      {
         aiPlanSetVariableInt(mansabdarZamburakPlan, cTrainPlanNumberToMaintain, 0, 1);
      }
   }
   else
   {
      // Update maintain plan, provided it exists
      if (mansabdarZamburakPlan >= 0)
      {
         aiPlanSetVariableInt(mansabdarZamburakPlan, cTrainPlanNumberToMaintain, 0, 0);
      }
   }
   // Check number of flail elephants, maintain mansabdar flail elephant as long as there are at least 6
   numFlailElephants = kbUnitCount(cMyID, cUnitTypeypMercFlailiphant, cUnitStateAlive);
   if (numFlailElephants >= 6)
   {
      // Create/update maintain plan
      if (mansabdarFlailElephantPlan < 0)
      {
         mansabdarFlailElephantPlan =
             createSimpleMaintainPlan(cUnitTypeypMercFlailiphantMansabdar, 1, false, kbBaseGetMainID(cMyID), 1);
      }
      else
      {
         aiPlanSetVariableInt(mansabdarFlailElephantPlan, cTrainPlanNumberToMaintain, 0, 1);
      }
   }
   else
   {
      // Update maintain plan, provided it exists
      if (mansabdarFlailElephantPlan >= 0)
      {
         aiPlanSetVariableInt(mansabdarFlailElephantPlan, cTrainPlanNumberToMaintain, 0, 0);
      }
   }
   // Check number of mahouts, maintain mansabdar mahout as long as there are at least 3
   numMahouts = kbUnitCount(cMyID, cUnitTypeypMahout, cUnitStateAlive);
   if (numMahouts >= 3)
   {
      // Create/update maintain plan
      if (mansabdarMahoutPlan < 0)
      {
         mansabdarMahoutPlan =
             createSimpleMaintainPlan(cUnitTypeypMahoutMansabdar, 1, false, kbBaseGetMainID(cMyID), 1);
      }
      else
      {
         aiPlanSetVariableInt(mansabdarMahoutPlan, cTrainPlanNumberToMaintain, 0, 1);
      }
   }
   else
   {
      // Update maintain plan, provided it exists
      if (mansabdarMahoutPlan >= 0)
      {
         aiPlanSetVariableInt(mansabdarMahoutPlan, cTrainPlanNumberToMaintain, 0, 0);
      }
   }
   // Check number of howdahs, maintain mansabdar howdah as long as there are at least 3
   numHowdahs = kbUnitCount(cMyID, cUnitTypeypHowdah, cUnitStateAlive);
   if (numHowdahs >= 3)
   {
      // Create/update maintain plan
      if (mansabdarHowdahPlan < 0)
      {
         mansabdarHowdahPlan =
             createSimpleMaintainPlan(cUnitTypeypHowdahMansabdar, 1, false, kbBaseGetMainID(cMyID), 1);
      }
      else
      {
         aiPlanSetVariableInt(mansabdarHowdahPlan, cTrainPlanNumberToMaintain, 0, 1);
      }
   }
   else
   {
      // Update maintain plan, provided it exists
      if (mansabdarHowdahPlan >= 0)
      {
         aiPlanSetVariableInt(mansabdarHowdahPlan, cTrainPlanNumberToMaintain, 0, 0);
      }
   }
   // Check number of siege elephants, maintain mansabdar siege elephant as long as there are at least 3
   numSiegeElephants = kbUnitCount(cMyID, cUnitTypeypSiegeElephant, cUnitStateAlive);
   if (numSiegeElephants >= 3)
   {
      // Create/update maintain plan
      if (mansabdarSiegeElephantPlan < 0)
      {
         mansabdarSiegeElephantPlan =
             createSimpleMaintainPlan(cUnitTypeypSiegeElephantMansabdar, 1, false, kbBaseGetMainID(cMyID), 1);
      }
      else
      {
         aiPlanSetVariableInt(mansabdarSiegeElephantPlan, cTrainPlanNumberToMaintain, 0, 1);
      }
   }
   else
   {
      // Update maintain plan, provided it exists
      if (mansabdarSiegeElephantPlan >= 0)
      {
         aiPlanSetVariableInt(mansabdarSiegeElephantPlan, cTrainPlanNumberToMaintain, 0, 0);
      }
   }
}


rule daimyoMonitor
inactive
minInterval 30
{
   if ((kbUnitCount(cMyID, cUnitTypeypWJShogunate2, cUnitStateAlive) < 0) &&
       (kbUnitCount(cMyID, cUnitTypeypWJShogunate3, cUnitStateAlive) < 0) &&
       (kbUnitCount(cMyID, cUnitTypeypWJShogunate4, cUnitStateAlive) < 0) &&
       (kbUnitCount(cMyID, cUnitTypeypWJShogunate5, cUnitStateAlive) < 0))
   {
      return;
   }

   static int daimyo1Plan = -1;
   static int daimyo2Plan = -1;
   static int daimyo3Plan = -1;
   static int shogunPlan = -1;
   int mainBaseID = kbBaseGetMainID(cMyID);
   int numberToMaintain = 0;

   if (daimyo1Plan < 0 && kbTechGetStatus(cTechYPHCShipDaimyoAizu) == cTechStatusActive)
      daimyo1Plan = createSimpleMaintainPlan(cUnitTypeypDaimyoKiyomasa, 1, false, mainBaseID, 1);
   if (daimyo2Plan < 0)
      daimyo2Plan = createSimpleMaintainPlan(cUnitTypeypDaimyoMasamune, 1, false, mainBaseID, 1);
   if (daimyo3Plan < 0 && kbTechGetStatus(cTechYPHCShipDaimyoSatsuma) == cTechStatusActive)
      daimyo3Plan = createSimpleMaintainPlan(cUnitTypeypDaimyoMototada, 1, false, mainBaseID, 1);
   if (shogunPlan < 0 && kbTechGetStatus(cTechYPHCShipShogunate) == cTechStatusActive)
      shogunPlan = createSimpleMaintainPlan(cUnitTypeypShogunTokugawa, 1, false, mainBaseID, 1);

   if (aiGetMilitaryPop() >= 15)
      numberToMaintain = 1;

   // 1 daimyo and 1 shogun.
   if (daimyo1Plan >= 0)
      aiPlanSetVariableInt(daimyo1Plan, cTrainPlanNumberToMaintain, 0, numberToMaintain);
   if (daimyo2Plan >= 0)
   {
      if (daimyo1Plan < 0)
         aiPlanSetVariableInt(daimyo2Plan, cTrainPlanNumberToMaintain, 0, numberToMaintain);
      else
         aiPlanSetVariableInt(daimyo2Plan, cTrainPlanNumberToMaintain, 0, 0);
   }   
   if (daimyo3Plan >= 0)
   {
      if (daimyo1Plan < 0 && daimyo2Plan < 0)
         aiPlanSetVariableInt(daimyo3Plan, cTrainPlanNumberToMaintain, 0, numberToMaintain);
      else
         aiPlanSetVariableInt(daimyo3Plan, cTrainPlanNumberToMaintain, 0, 0);   
   }

   if (shogunPlan >= 0)
      aiPlanSetVariableInt(shogunPlan, cTrainPlanNumberToMaintain, 0, numberToMaintain);
}

rule villageUpgradeMonitor
inactive
group tcComplete
minInterval 25
{
   int upgradePlanID = -1;

   // Disable rule for anybody but Chinese
   if ((cMyCiv != cCivChinese) && (cMyCiv != cCivSPCChinese))
   {
      xsDisableSelf();
      return;
   }

   // Disable rule once all upgrades are available
   if ((kbTechGetStatus(cTechypVillagePopCapIncrease) == cTechStatusActive) &&
       (kbTechGetStatus(cTechypVillagePopCapIncrease2) == cTechStatusActive) &&
       (kbTechGetStatus(cTechypVillagePopCapIncrease3) == cTechStatusActive) &&
       (kbTechGetStatus(cTechypVillagePopCapIncrease4) == cTechStatusActive))
   {
      xsDisableSelf();
      return;
   }

   // Pop increase techs only makes sense when we have at least 4 villages around
   if ((kbUnitCount(cMyID, cUnitTypeypVillage, cUnitStateAlive) < 4) || (needMoreHouses() == false))
      return;

   // Quit if we don't need headroom and don't have excess wood.
   if ((needMoreHouses() == false) && (kbResourceGet(cResourceWood) < 800))
      return;

   if ((kbTechGetStatus(cTechypVillagePopCapIncrease) == cTechStatusObtainable) &&
       (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypVillagePopCapIncrease) < 0))
      createSimpleResearchPlan(cTechypVillagePopCapIncrease, getUnit(cUnitTypeypVillage), cEconomyEscrowID, 85);
   else if ((kbTechGetStatus(cTechypVillagePopCapIncrease2) == cTechStatusObtainable) &&
            (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypVillagePopCapIncrease2) < 0))
      createSimpleResearchPlan(cTechypVillagePopCapIncrease2, getUnit(cUnitTypeypVillage), cEconomyEscrowID, 85);
   else if ((kbTechGetStatus(cTechypVillagePopCapIncrease3) == cTechStatusObtainable) &&
            (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypVillagePopCapIncrease3) < 0))
      createSimpleResearchPlan(cTechypVillagePopCapIncrease3, getUnit(cUnitTypeypVillage), cEconomyEscrowID, 85);
   else if ((kbTechGetStatus(cTechypVillagePopCapIncrease4) == cTechStatusObtainable) &&
            (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypVillagePopCapIncrease4) < 0))
      createSimpleResearchPlan(cTechypVillagePopCapIncrease4, getUnit(cUnitTypeypVillage), cEconomyEscrowID, 85);
}

//==============================================================================
/* rule abilityManager

   Use abilities when appropriate.
*/
//==============================================================================
rule abilityManager
active
minInterval 12
{
   vector myBaseLocation = kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID));
   int closestBaseID = kbFindClosestBase(cPlayerRelationEnemyNotGaia, myBaseLocation);
   vector targetLocation = cInvalidVector;
   // Inspiration
   if (cMyCiv == cCivIndians)
   {
      // Do a cheap check to see if we have any military.
      int unitIDInspiration = getUnit(cUnitTypeLogicalTypeLandMilitary, cMyID, cUnitStateAlive);
      // If we do, check if we're under attack somewhere.
      if ((unitIDInspiration >= 0) &&
          ((gDefenseReflexBaseID == kbBaseGetMainID(cMyID)) || (gDefenseReflexBaseID == gForwardBaseID)))
      {
         int towerOfVictoryType = -1;
         // Check if we have Tower of Victory.
         if (kbUnitCount(cMyID, cUnitTypeypWITowerOfVictory2, cUnitStateAlive) > 0)
         {
            towerOfVictoryType = cUnitTypeypWITowerOfVictory2;
         }
         else if (kbUnitCount(cMyID, cUnitTypeypWITowerOfVictory3, cUnitStateAlive) > 0)
         {
            towerOfVictoryType = cUnitTypeypWITowerOfVictory3;
         }
         else if (kbUnitCount(cMyID, cUnitTypeypWITowerOfVictory4, cUnitStateAlive) > 0)
         {
            towerOfVictoryType = cUnitTypeypWITowerOfVictory4;
         }
         else if (kbUnitCount(cMyID, cUnitTypeypWITowerOfVictory5, cUnitStateAlive) > 0)
         {
            towerOfVictoryType = cUnitTypeypWITowerOfVictory5;
         }
         if ((towerOfVictoryType >= 0) &&
             aiCanUseAbility(getUnit(towerOfVictoryType), cProtoPowerypPowerAttackBlessing))
         {
            aiTaskUnitSpecialPower(getUnit(towerOfVictoryType), cProtoPowerypPowerAttackBlessing, -1, cInvalidVector);
         }
      }
   }
   // Cease Fire
   if (cMyCiv == cCivIndians)
   {
      // Check if we're under attack.
      if (gDefenseReflexBaseID == kbBaseGetMainID(cMyID))
      {
         int tajMahalType = -1;
         // Check if we have Taj Mahal.
         if (kbUnitCount(cMyID, cUnitTypeypWITajMahal2, cUnitStateAlive) > 0)
         {
            tajMahalType = cUnitTypeypWITajMahal2;
         }
         else if (kbUnitCount(cMyID, cUnitTypeypWITajMahal3, cUnitStateAlive) > 0)
         {
            tajMahalType = cUnitTypeypWITajMahal3;
         }
         else if (kbUnitCount(cMyID, cUnitTypeypWITajMahal4, cUnitStateAlive) > 0)
         {
            tajMahalType = cUnitTypeypWITajMahal4;
         }
         else if (kbUnitCount(cMyID, cUnitTypeypWITajMahal5, cUnitStateAlive) > 0)
         {
            tajMahalType = cUnitTypeypWITajMahal5;
         }
         if ((tajMahalType >= 0) && aiCanUseAbility(getUnit(tajMahalType), cProtoPowerypPowerCeaseFire))
         {
            aiTaskUnitSpecialPower(getUnit(tajMahalType), cProtoPowerypPowerCeaseFire, -1, cInvalidVector);
         }
      }
   }
   // Transcendence
   if (cMyCiv == cCivChinese)
   {
      int templeOfHeavenType = -1;
      // Check if we have Temple of Heaven.
      if (kbUnitCount(cMyID, cUnitTypeypWCTempleOfHeaven2, cUnitStateAlive) > 0)
      {
         templeOfHeavenType = cUnitTypeypWCTempleOfHeaven2;
      }
      else if (kbUnitCount(cMyID, cUnitTypeypWCTempleOfHeaven3, cUnitStateAlive) > 0)
      {
         templeOfHeavenType = cUnitTypeypWCTempleOfHeaven3;
      }
      else if (kbUnitCount(cMyID, cUnitTypeypWCTempleOfHeaven4, cUnitStateAlive) > 0)
      {
         templeOfHeavenType = cUnitTypeypWCTempleOfHeaven4;
      }
      else if (kbUnitCount(cMyID, cUnitTypeypWCTempleOfHeaven5, cUnitStateAlive) > 0)
      {
         templeOfHeavenType = cUnitTypeypWCTempleOfHeaven5;
      }
      if ((templeOfHeavenType >= 0) && aiCanUseAbility(getUnit(templeOfHeavenType), cProtoPowerypPowerGoodFortune))
      { // Check if our land military is missing 20% of their HP or more.
         float armyMaxHP = getPlayerArmyHPs(cMyID, false);
         float armyCurrentHP = getPlayerArmyHPs(cMyID, true);
         float hpRatio = armyCurrentHP / armyMaxHP;
         if (hpRatio < 0.8)
         {
            aiTaskUnitSpecialPower(getUnit(templeOfHeavenType), cProtoPowerypPowerGoodFortune, -1, cInvalidVector);
         }
      }
   }
   // Informers
   if (cMyCiv == cCivJapanese)
   {
      int greatBuddhaType = -1;
      // Check if we have Great Buddha.
      if (kbUnitCount(cMyID, cUnitTypeypWJGiantBuddha2, cUnitStateAlive) > 0)
      {
         greatBuddhaType = cUnitTypeypWJGiantBuddha2;
      }
      else if (kbUnitCount(cMyID, cUnitTypeypWJGiantBuddha3, cUnitStateAlive) > 0)
      {
         greatBuddhaType = cUnitTypeypWJGiantBuddha3;
      }
      else if (kbUnitCount(cMyID, cUnitTypeypWJGiantBuddha4, cUnitStateAlive) > 0)
      {
         greatBuddhaType = cUnitTypeypWJGiantBuddha4;
      }
      else if (kbUnitCount(cMyID, cUnitTypeypWJGiantBuddha5, cUnitStateAlive) > 0)
      {
         greatBuddhaType = cUnitTypeypWJGiantBuddha5;
      }
      if ((greatBuddhaType >= 0) && aiCanUseAbility(getUnit(greatBuddhaType), cProtoPowerypPowerInformers))
      {
         aiTaskUnitSpecialPower(getUnit(greatBuddhaType), cProtoPowerypPowerInformers, -1, cInvalidVector);
      }
   }
   // Spyglass
   if (cMyCiv == cCivPortuguese)
   {
      int explorerIDSpyglass = -1;
      explorerIDSpyglass = getUnit(cUnitTypeExplorer, cMyID, cUnitStateAlive);
      if ((explorerIDSpyglass >= 0) && aiCanUseAbility(explorerIDSpyglass, cProtoPowerPowerLOS))
      {
         if (closestBaseID == -1)
         { // If not yet visible, search for the enemy on the mirror position of my base.
            targetLocation = guessEnemyLocation();
         }
         if ((targetLocation == cInvalidVector) || (kbLocationVisible(targetLocation) == true) || (closestBaseID != -1))
         { // Otherwise reveal the closest enemy base for new information.
            targetLocation = kbBaseGetLocation(kbBaseGetOwner(closestBaseID), closestBaseID);
         }
         if (targetLocation != cInvalidVector)
         {
            aiTaskUnitSpecialPower(explorerIDSpyglass, cProtoPowerPowerLOS, -1, targetLocation);
         }
      }
   }
   // Hot Air Balloon
   if (civIsEuropean() == true)
   {
      int explorerIDBalloon = -1;
      explorerIDBalloon = getUnit(cUnitTypeExplorer, cMyID, cUnitStateAlive);
      if ((explorerIDBalloon >= 0) && aiCanUseAbility(explorerIDBalloon, cProtoPowerPowerBalloon))
      {
         if (closestBaseID == -1)
         { // If not yet visible, search for the enemy on the mirror position of my base.
            targetLocation = guessEnemyLocation();
         }
         if ((targetLocation == cInvalidVector) || (kbLocationVisible(targetLocation) == true) || (closestBaseID != -1))
         { // Otherwise reveal the closest enemy base for new information.
            targetLocation = kbBaseGetLocation(kbBaseGetOwner(closestBaseID), closestBaseID);
         }
         if (targetLocation != cInvalidVector)
         {
            aiTaskUnitSpecialPower(explorerIDBalloon, cProtoPowerPowerBalloon, -1, targetLocation);
            int balloonExplore = aiPlanCreate("Balloon Explore", cPlanExplore);
            aiPlanSetDesiredPriority(balloonExplore, 75);
            aiPlanAddUnitType(balloonExplore, cUnitTypeHotAirBalloon, 0, 1, 1);
            aiPlanSetEscrowID(balloonExplore, cEconomyEscrowID);
            aiPlanSetBaseID(balloonExplore, kbBaseGetMainID(cMyID));
            aiPlanSetVariableBool(balloonExplore, cExplorePlanDoLoops, 0, false);
            aiPlanSetActive(balloonExplore);
         }
      }
   }
   // Sharpshooter Attack
   /*if ((civIsNative() == false) && (civIsAsian() == false))
   {
      int explorerIDSharpshooter = -1;
      explorerIDSharpshooter = getUnit(cUnitTypeExplorer, cMyID, cUnitStateAlive);
     if ((explorerIDSharpshooter >= 0) && aiCanUseAbility(explorerIDSharpshooter, cProtoPowerPowerSharpshooter))
     {
        vector explorerLocationSharpshooter = kbUnitGetPosition(explorerIDSharpshooter);
       int targetIDSharpshooter = getUnitByLocation(cUnitTypeGuardian, 0, cUnitStateAlive,
   explorerLocationSharpshooter, 20.0); if (targetIDSharpshooter != -1)
       {
          aiTaskUnitSpecialPower(explorerIDSharpshooter, cProtoPowerPowerSharpshooter, targetIDSharpshooter,
   cInvalidVector);
       }
     }
   }
   // Crackshot Attack
   if ((civIsNative() == false) && (civIsAsian() == false))
   {
      int explorerIDCrackshot = -1;
      explorerIDCrackshot = getUnit(cUnitTypeExplorer, cMyID, cUnitStateAlive);
     if ((explorerIDCrackshot >= 0) && aiCanUseAbility(explorerIDCrackshot, cProtoPowerPowerCrackshot))
     {
        vector explorerLocationCrackshot = kbUnitGetPosition(explorerIDCrackshot);
       int targetIDCrackshot = getUnitByLocation(cUnitTypeAbstractCavalry, cPlayerRelationEnemyNotGaia, cUnitStateAlive,
   explorerLocationCrackshot, 20.0); if (targetIDCrackshot == -1)
       {
       targetIDCrackshot = getUnitByLocation(cUnitTypeAbstractInfantry, cPlayerRelationEnemyNotGaia, cUnitStateAlive,
   explorerLocationCrackshot, 20.0);
       }
       if (targetIDCrackshot != -1)
       {
          aiTaskUnitSpecialPower(explorerIDCrackshot, cProtoPowerPowerCrackshot, targetIDCrackshot, cInvalidVector);
       }
     }
   }
   // Swashbuckler Attack
   if (((civIsNative() == false) && (civIsAsian() == false)) ||
       (cMyCiv == cCivXPAztec) || (cMyCiv == cCivXPSioux))
   {
      int explorerIDSwashbuckler = -1;
      switch (cMyCiv)
      {
      case cCivXPAztec:
      {
         explorerIDSwashbuckler = getUnit(cUnitTypexpAztecWarchief, cMyID, cUnitStateAlive);
         break;
      }
      case cCivXPSioux:
      {
         explorerIDSwashbuckler = getUnit(cUnitTypexpLakotaWarchief, cMyID, cUnitStateAlive);
         break;
      }
      default:
      {
         explorerIDSwashbuckler = getUnit(cUnitTypeExplorer, cMyID, cUnitStateAlive);
         break;
      }
      }
     if ((explorerIDSwashbuckler >= 0) && aiCanUseAbility(explorerIDSwashbuckler, cProtoPowerPowerSwashbuckler))
     {
        vector explorerLocationSwashbuckler = kbUnitGetPosition(explorerIDSwashbuckler);
       int targetIDSwashbuckler = getUnitByLocation(cUnitTypeUnit, cPlayerRelationEnemyNotGaia, cUnitStateAlive,
   explorerLocationSwashbuckler, 3.0); if (targetIDSwashbuckler != -1)
       {
          aiTaskUnitSpecialPower(explorerIDSwashbuckler, cProtoPowerPowerSwashbuckler, targetIDSwashbuckler,
   cInvalidVector);
       }
     }
   }*/
   // Long-range Bombardment Attack
   if (civIsNative() == false)
   {
      int monitorID = -1;
      monitorID = getUnit(gMonitorUnit, cMyID, cUnitStateAlive);
      if ((monitorID >= 0) && aiCanUseAbility(monitorID, cProtoPowerPowerLongRange))
      {
         vector monitorLocation = kbUnitGetPosition(monitorID);
         int targetIDmonitor =
             getUnitByLocation(cUnitTypeBuilding, cPlayerRelationEnemyNotGaia, cUnitStateAlive, monitorLocation, 100.0);
         if (targetIDmonitor != -1)
         {
            aiTaskUnitSpecialPower(monitorID, cProtoPowerPowerLongRange, targetIDmonitor, cInvalidVector);
         }
      }
   }
   // Heal
   if ((cMyCiv == cCivXPIroquois) && (kbTechGetStatus(cTechBigFirepitSecretSociety) == cTechStatusActive))
   {
      int warchiefIDHeal = -1;
      warchiefIDHeal = getUnit(cUnitTypexpIroquoisWarChief, cMyID, cUnitStateAlive);
      if ((warchiefIDHeal >= 0) && aiCanUseAbility(warchiefIDHeal, cProtoPowerPowerHeal) &&
          (kbUnitGetHealth(warchiefIDHeal) < 0.8))
      {
         vector warchiefLocation = kbUnitGetPosition(warchiefIDHeal);
         aiTaskUnitSpecialPower(warchiefIDHeal, cProtoPowerPowerHeal, -1, warchiefLocation);
      }
   }
}

rule transportMonitor
active
minInterval 10
{
   if (gIslandMap == false || gSPC == true)
   {
      xsDisableSelf();
      return;
   }

   if (aiPlanGetIDByIndex(cPlanTransport, -1, true, 0) >= 0)
      return;

   // find idle units away from our base
   int baseAreaGroupID = kbAreaGroupGetIDByPosition(kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)));
   int areaGroupID = -1;
   int unitQueryID = createSimpleUnitQuery(cUnitTypeLogicalTypeGarrisonInShips, cMyID, cUnitStateAlive);
   int numberFound = kbUnitQueryExecute(unitQueryID);
   int unitID = -1;
   int planID = -1;
   vector position = cInvalidVector;
   bool transportRequired = false;
   for (i = 0; < numberFound)
   {
      unitID = kbUnitQueryGetResult(unitQueryID, i);
      // avoid transporting island explore scout back to our base
      if (unitID == gIslandExploreTransportScoutID)
         continue;
      position = kbUnitGetPosition(unitID);
      areaGroupID = kbAreaGroupGetIDByPosition(position);
      if (areaGroupID == baseAreaGroupID)
         continue;
      if (kbAreaGroupGetType(areaGroupID) == cAreaGroupTypeWater)
      {
         // if units are inside a water area(likely on a shore), make sure it does not border our main base area group
         int areaID = kbAreaGetIDByPosition(position);
         int numberBorders = kbAreaGetNumberBorderAreas(areaID);
         bool inMainBase = false;
         for (j = 0; < numberBorders)
         {
            if (kbAreaGroupGetIDByPosition(kbAreaGetCenter(kbAreaGetBorderAreaID(areaID, j))) == baseAreaGroupID)
            {
               inMainBase = true;
               break;
            }
         }
         if (inMainBase == true)
            continue;
      }
      planID = kbUnitGetPlanID(unitID);
      if (planID >= 0 && aiPlanGetDesiredPriority(planID) >= 25)
         continue;
      transportRequired = true;
      aiEcho("Tranporting " + kbGetUnitTypeName(kbUnitGetProtoUnitID(unitID)) +
             " and its nearby units back to main base.");
      break;
   }

   if (transportRequired == false)
      return;

   // once we started transporting, make sure no one can steal units from us
   int transportPlanID =
       createTransportPlan(position, kbBaseGetMilitaryGatherPoint(cMyID, kbBaseGetMainID(cMyID)), 100);

   if (transportPlanID < 0)
      return;

   unitQueryID = createSimpleUnitQuery(cUnitTypeLogicalTypeGarrisonInShips, cMyID, cUnitStateAlive, position, 30.0);
   numberFound = kbUnitQueryExecute(unitQueryID);
   aiPlanAddUnitType(transportPlanID, cUnitTypeLogicalTypeGarrisonInShips, numberFound, numberFound, numberFound);
   for (i = 0; < numberFound)
   {
      unitID = kbUnitQueryGetResult(unitQueryID, i);
      if (aiPlanAddUnit(transportPlanID, unitID) == false)
      {
         aiPlanDestroy(transportPlanID);
         return;
      }
   }
   aiPlanSetNoMoreUnits(transportPlanID, true);
}

rule islandExploreMonitor
inactive
minInterval 30
{
   if (cvOkToExplore == false || gIslandMap == false || gSPC == true)
   {
      xsDisableSelf();
      return;
   }

   const int cIslandExploreModeSearch = 0;
   const int cIslandExploreModeStart = 1;
   const int cIslandExploreModeExplore = 2;
   static int islandExploreMode = cIslandExploreModeSearch;
   static int islandExplorePlan = -1;
   static vector islandExplorePosition = cInvalidVector;
   static bool exploreBlackTiles = true;
   static int exploreTimeout = 0;
   int i = 0;
   int j = 0;
   int k = 0;
   int areaGroupID = -1;
   int unitQueryID = -1;
   int numberFound = 0;
   int unitID = -1;
   int numberAreaGroups = 0;
   int numberAreas = 0;

   switch (islandExploreMode)
   {
   case cIslandExploreModeSearch:
   {
      static int areaGroupIDs = -1;
      static int areaIDs = -1;
      int numberBorderAreas = 0;
      int areaID = -1;
      int borderAreaID = -1;
      int baseAreaGroupID = kbAreaGroupGetIDByPosition(kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)));
      int enemyAreaGroupID = -1;
      vector location = cInvalidVector;

      if (areaGroupIDs < 0)
      {
         numberAreaGroups = kbAreaGroupGetNumber();
         numberAreas = kbAreaGetNumber();
         areaGroupIDs = xsArrayCreateInt(numberAreaGroups, -1, "Area Group IDs");
         areaIDs = xsArrayCreateInt(numberAreas, -1, "Area IDs");
         for (i = 0; < numberAreaGroups)
            xsArraySetInt(areaGroupIDs, i, i);
      }

      bool enemyBuildingFound = false;
      unitQueryID = createSimpleUnitQuery(cUnitTypeBuilding, cPlayerRelationEnemyNotGaia, cUnitStateABQ);
      numberFound = kbUnitQueryExecute(unitQueryID);

      for (i = 0; < numberFound)
      {
         unitID = kbUnitQueryGetResult(unitQueryID, i);
         if (kbHasPlayerLost(kbUnitGetPlayerID(unitID)) == true)
            continue;
         areaGroupID = kbAreaGroupGetIDByPosition(kbUnitGetPosition(unitID));
         if (areaGroupID == baseAreaGroupID)
            continue;
         enemyAreaGroupID = areaGroupID;
         break;
      }

      // If the enemy is not in sight for a long period, search on water.
      static bool isEnemyInSight = true;
      if (gStartOnDifferentIslands == false && isEnemyInSight == true)
         isEnemyInSight = enemyAreaGroupID < 0 &&
                          (kbGetAge() < cAge2 || (xsGetTime() - gLastAttackMissionTime >= gAttackMissionInterval));

      if (exploreBlackTiles == true && (gStartOnDifferentIslands == true || isEnemyInSight == false))
      {
         bool allAreaGroupsExplored = true;
         // find land areas near our discovered water areas
         numberAreaGroups = kbAreaGroupGetNumber();
         randomShuffleIntArray(areaGroupIDs, numberAreaGroups);
         for (i = 0; < numberAreaGroups)
         {
            areaGroupID = xsArrayGetInt(areaGroupIDs, i);
            if (areaGroupID == baseAreaGroupID || kbAreaGroupGetType(areaGroupID) != cAreaGroupTypeLand)
               continue;
            if (getAreaGroupTileTypePercentage(areaGroupID, cTileBlack) < 0.1)
               continue;
            allAreaGroupsExplored = false;
            // when we spotted an area group with enemy buildings, just explore that particular area group
            if (enemyAreaGroupID >= 0 && areaGroupID != enemyAreaGroupID && gLowOnResources == false)
               continue;
            numberAreas = kbAreaGroupGetNumberAreas(areaGroupID);
            for (j = 0; < numberAreas)
               xsArraySetInt(areaIDs, j, kbAreaGroupGetAreaID(areaGroupID, j));
            randomShuffleIntArray(areaIDs, numberAreas);
            for (j = 0; < numberAreas)
            {
               areaID = xsArrayGetInt(areaIDs, j);
               // must be partially seen
               if (kbAreaGetNumberTiles(areaID) == kbAreaGetNumberBlackTiles(areaID))
                  continue;
               numberBorderAreas = kbAreaGetNumberBorderAreas(areaID);
               for (k = 0; < numberBorderAreas)
               {
                  borderAreaID = kbAreaGetBorderAreaID(areaID, k);
                  if (kbAreaGetType(borderAreaID) == cAreaTypeWater)
                  {
                     location = kbAreaGetCenter(areaID);
                     if (getUnitCountByLocation(cUnitTypeAbstractFort, cPlayerRelationEnemyNotGaia, cUnitStateABQ,
                                                location, 30.0) == 0)
                     {
                        islandExploreMode = cIslandExploreModeStart;
                        islandExplorePosition = location;
                        aiEcho("Found good island explore location at " + location);
                        return;
                     }
                  }
               }
            }
         }
         if (allAreaGroupsExplored == true)
            exploreBlackTiles = false;
         return;
      }

      // only try to explore when we can't find anymore enemy buildings
      if (enemyAreaGroupID >= 0 && gLowOnResources == false)
         return;

      numberAreaGroups = kbAreaGroupGetNumber();
      randomShuffleIntArray(areaGroupIDs, numberAreaGroups);
      for (i = 0; < numberAreaGroups)
      {
         areaGroupID = xsArrayGetInt(areaGroupIDs, i);
         if (areaGroupID == baseAreaGroupID || areaGroupID == kbAreaGroupGetIDByPosition(islandExplorePosition) ||
             kbAreaGroupGetType(areaGroupID) != cAreaGroupTypeLand)
            continue;
         numberAreas = kbAreaGroupGetNumberAreas(areaGroupID);
         for (j = 0; < numberAreas)
            xsArraySetInt(areaIDs, j, kbAreaGroupGetAreaID(areaGroupID, j));
         randomShuffleIntArray(areaIDs, numberAreas);
         for (j = 0; < numberAreas)
         {
            areaID = xsArrayGetInt(areaIDs, j);
            numberBorderAreas = kbAreaGetNumberBorderAreas(areaID);
            for (k = 0; < numberBorderAreas)
            {
               borderAreaID = kbAreaGetBorderAreaID(areaID, k);
               if (kbAreaGetType(borderAreaID) == cAreaTypeWater)
               {
                  location = kbAreaGetCenter(areaID);
                  if (getUnitCountByLocation(cUnitTypeAbstractFort, cPlayerRelationEnemyNotGaia, cUnitStateABQ,
                                             location, 30.0) == 0)
                  {
                     islandExploreMode = cIslandExploreModeStart;
                     islandExplorePosition = location;
                     aiEcho("Found good island explore location at " + location);
                     return;
                  }
               }
            }
         }
      }
      break;
   }
   case cIslandExploreModeStart:
   {
      int scoutUnitID = -1;
      int scoutType = -1;
      int planID = -1;

      // Activate navy if we haven't yet, need ships to transport units for exploring.
      gNavyMode = cNavyModeActive;

      if (kbUnitCount(cMyID, cUnitTypeLogicalTypeScout, cUnitStateAlive) == 0)
         return;

      unitQueryID = createSimpleUnitQuery(cUnitTypeLogicalTypeScout, cMyID, cUnitStateAlive);
      kbUnitQuerySetAreaGroupID(unitQueryID, kbAreaGroupGetIDByPosition(islandExplorePosition));
      numberFound = kbUnitQueryExecute(unitQueryID);
      for (i = 0; < numberFound)
      {
         unitID = kbUnitQueryGetResult(unitQueryID, i);
         planID = kbUnitGetPlanID(unitID);
         if (planID > 0 && aiPlanGetDesiredPriority(planID) >= 75)
            continue;
         scoutUnitID = unitID;
         break;
      }

      // if we don't have any units available, take one from the main base
      if (scoutUnitID < 0)
      {
         if (aiPlanGetIDByIndex(cPlanTransport, -1, true, 0) < 0)
         {
            scoutType = findBestScoutType();
            scoutUnitID = getUnit(scoutType, cMyID, cUnitStateAlive);
            if (scoutUnitID >= 0)
            {
               planID = createTransportPlan(kbBaseGetMilitaryGatherPoint(cMyID, kbBaseGetMainID(cMyID)),
                                            islandExplorePosition, 100);
               if (planID >= 0)
               {
                  aiPlanAddUnitType(planID, scoutType, 1, 1, 1);
                  if (aiPlanAddUnit(planID, scoutUnitID) == false)
                  {
                     aiPlanDestroy(planID);
                     return;
                  }
                  aiPlanSetNoMoreUnits(planID, true);
               }
               gIslandExploreTransportScoutID = scoutUnitID;
               // change interval temporarily to avoid idling too long after transporting to the island
               xsSetRuleMinIntervalSelf(5);
            }
         }
         return;
      }

      islandExplorePlan = aiPlanCreate("Island Explore", cPlanExplore);
      aiPlanSetDesiredPriority(islandExplorePlan, 95); // higher than goal plan
      aiPlanAddUnitType(islandExplorePlan, cUnitTypeLogicalTypeScout, 1, 1, 1);
      aiPlanAddUnit(islandExplorePlan, scoutUnitID);
      aiPlanSetNoMoreUnits(islandExplorePlan, true);
      aiPlanSetVariableInt(islandExplorePlan, cExplorePlanNumberOfLoops, 0, 0);
      aiPlanSetVariableBool(islandExplorePlan, cExplorePlanDoLoops, 0, false);
      aiPlanSetVariableBool(islandExplorePlan, cExplorePlanOkToGatherNuggets, 0, false);

      // Add a waypoint if we are on the enemy player's island
      location = guessEnemyLocation();
      if (kbAreaGroupGetIDByPosition(location) == kbAreaGroupGetIDByPosition(kbUnitGetPosition(scoutUnitID)))
         aiPlanAddWaypoint(islandExplorePlan, location);

      aiPlanSetActive(islandExplorePlan);
      exploreTimeout = xsGetTime() + 180000;
      xsSetRuleMinIntervalSelf(30);
      islandExploreMode = cIslandExploreModeExplore;
      gIslandExploreTransportScoutID = -1;

      break;
   }
   case cIslandExploreModeExplore:
   {
      // our scout died?
      if (aiPlanGetState(islandExplorePlan) == -1)
      {
         islandExploreMode = cIslandExploreModeStart;
         return;
      }

      if (exploreBlackTiles == true)
      {
         if (getAreaGroupTileTypePercentage(kbAreaGroupGetIDByPosition(islandExplorePosition), cTileBlack) >= 0.1)
            return;
      }
      else
      {
         if (xsGetTime() < exploreTimeout)
            return;
      }

      // finished exploring, set priority to very low so transport plan can move the scout back
      aiPlanSetDesiredPriority(islandExplorePlan, 1);
      islandExplorePlan = -1;
      islandExploreMode = cIslandExploreModeSearch;
      break;
   }
   }
}

//==============================================================================
// addUnitsToMilitaryPlan
//==============================================================================
void addUnitsToMilitaryPlan(int planID = -1)
{
   // int numberLandMilitaryUnits = aiPlanGetNumberUnits(gLandReservePlan, cUnitTypeLogicalTypeLandMilitary);

   // TODO: don't always task the full army, leave some behind if the enemy is weak or we need more defense
   if ((gRevolutionType & cRevolutionFinland) == 0)
   {
      aiPlanAddUnitType(planID, cUnitTypeLogicalTypeLandMilitary, 0, 0, 200);
      return;
   }

   // For the finland revolution, keep some karelian jaegers around to sustain the economy
   int numberAvailableEconUnits = 0;
   int queryID = createSimpleUnitQuery(cUnitTypeLogicalTypeLandMilitary, cMyID, cUnitStateAlive);
   int numberFound = kbUnitQueryExecute(queryID);

   aiPlanAddUnitType(planID, cUnitTypeLogicalTypeLandMilitary, 0, 0, 0);

   // Add each unit type individually
   for (i = 0; < numberFound)
   {
      int unitID = kbUnitQueryGetResult(queryID, i);
      int puid = kbUnitGetProtoUnitID(unitID);
      if (puid == gEconUnit)
      {
         int unitPlanType = aiPlanGetType(kbUnitGetPlanID(unitID));
         if (unitPlanType == cPlanGather || unitPlanType == cPlanBuild)
            numberAvailableEconUnits = numberAvailableEconUnits + 1;
         continue;
      }
      aiPlanAddUnitType(planID, puid, 0, 0, 200);
   }

   // Keep at least 30 karelian jaegers around or the equivalent wood amount
   float numberEconUnits = (0.0 - xsArrayGetFloat(gResourceNeeds, cResourceWood) - 3000.0) / 100.0;
   if (numberEconUnits < 0.0)
   {
      numberEconUnits = numberAvailableEconUnits + numberEconUnits;
      if (numberEconUnits < 0.0)
         numberEconUnits = 0.0;
   }
   else
   {
      numberEconUnits = numberAvailableEconUnits;
   }
   aiPlanAddUnitType(planID, gEconUnit, 0, numberEconUnits, numberEconUnits);
}

//==============================================================================
// autoCreatePlanHandler()
//==============================================================================
void autoCreatePlanHandler(int planID = -1)
{
   int parentPlanID = aiPlanGetParentID(planID);
   int parentPlanType = aiPlanGetType(parentPlanID);
   int puid = -1;

   switch (aiPlanGetType(planID))
   {
   case cPlanBuild:
   {
      puid = aiPlanGetVariableInt(planID, cBuildPlanBuildingTypeID, 0);
      int wagonType = findWagonToBuild(puid);
      if (puid == gTowerUnit || puid == cUnitTypeWarHut || puid == cUnitTypeNoblesHut)
         selectTowerBuildPlanPosition(planID);
      if (wagonType >= 0)
         aiPlanAddUnitType(planID, wagonType, 1, 1, 1);
      if (parentPlanType == cPlanProgression || parentPlanType == cPlanGoal)
         aiPlanSetDesiredResourcePriority(planID,
                                          60); // slightly above normal because it is blocking our unit production
      break;
   }
   case cPlanAttack:
   {
      if (parentPlanType == cPlanMission)
      {
         addUnitsToMilitaryPlan(planID);
         //if (aiGetWorldDifficulty() >= gDifficultyExpert)
            aiPlanSetVariableBool(planID, cAttackPlanAllowMoreUnitsDuringAttack, 0, true);
      }
      break;
   }
   case cPlanDefend:
   {
      if (parentPlanType == cPlanMission)
         addUnitsToMilitaryPlan(planID);
      break;
   }
   case cPlanResearch:
   {
      if (parentPlanID == gEconUpgradePlan)// &&
          //((xsGetTime() > 12 * 60 * 1000) || (btRushBoom < 0.0) || (agingUp() == true) || (kbGetAge() >= cAge3)))
         aiPlanSetDesiredResourcePriority(planID, 60);
   }
   }
}

//==============================================================================
// revoltedHandler()
//==============================================================================
void revoltedHandler(int techID = -1)
{
   xsDisableRule("ageUpgradeMonitor");
   xsDisableRule("age5Monitor");

   if (techID == cTechDERevolutionSouthAfrica || techID == cTechDERevolutionCanadaBritish ||
       techID == cTechDERevolutionCanadaFrench)
      gRevolutionType = cRevolutionEconomic;
   else
      gRevolutionType = cRevolutionMilitary;

   if (gRevolutionType == cRevolutionMilitary)
   {
      int numPlans = aiPlanGetActiveCount();
      int planID = -1;

      if (techID == cTechDERevolutionFinland)
      {
         gRevolutionType = gRevolutionType | cRevolutionEconomic | cRevolutionFinland;
         cvOkToGatherWood = true;
         gEconUnit = cUnitTypeSkirmisher;
         aiPlanSetVariableInt(gSettlerMaintainPlan, cTrainPlanUnitType, 0, gEconUnit);
         // Skirmisher does not count as villager, inform the AI we can use it as villager
         aiAddGathererType(gEconUnit);
         gHouseUnit = cUnitTypedeTorp;
         gTowerUnit = cUnitTypeBlockhouse;
         gTimeToFarm = false;
         gTimeForPlantations = false;
         updateResourceDistribution();
      }

      // destroy all build and gather plans when our settlers transformed into military units
      for (i = 0; < numPlans)
      {
         planID = aiPlanGetIDByActiveIndex(i);
         switch (aiPlanGetType(planID))
         {
         case cPlanBuild:
         {
            // avoid destroying plans when it is built by wagons
            if (aiPlanGetNumberUnits(planID, cUnitTypeAbstractWagon) == 0 && (aiPlanGetState(planID) != cPlanStateBuild || (gRevolutionType & cRevolutionFinland) == 0))
               aiPlanDestroy(planID);
            break;
         }
         case cPlanGather:
         {
            aiPlanDestroy(planID);
            break;
         }
         }
      }

      // disable resource gathering
      if ((gRevolutionType & cRevolutionFinland) == 0)
      {
         cvOkToGatherFood = false;
         cvOkToGatherWood = false;
         cvOkToGatherGold = false;
      }
   }

   aiEcho("We revolted with " + kbGetTechName(techID));
}

//==============================================================================
// buildingPlacementFailedHandler()
//==============================================================================
void buildingPlacementFailedHandler(int baseID = -1, int puid = -1)
{
   if (puid == gDockUnit)
      return;
   if (puid == cUnitTypedeTorp && cMyCiv == cCivDESwedish)
   {
      int last = xsArrayGetSize(gTorpPositionsToAvoid);
      xsArrayResizeVector(gTorpPositionsToAvoid, last + 1);
      xsArraySetVector(gTorpPositionsToAvoid, last - 1, gTorpPosition);
      houseMonitor();
      return;
   }
   if (puid == cUnitTypedeField)
   {
      int numberFullGranaries = xsArrayGetSize(gFullGranaries);
      for (i = 0; < numberFullGranaries)
      {
         int granaryID = xsArrayGetInt(gFullGranaries, i);
         if (granaryID == gFieldGranaryID)
            break;
         if (granaryID >= 0 && kbUnitGetPlayerID(granaryID) == cMyID)
            continue;
         xsArraySetInt(gFullGranaries, i, gFieldGranaryID);
         break;
      }
   }
   if (baseID < 0)
   {
      // assuming main base
      baseID = kbBaseGetMainID(cMyID);
   }

   static int basesToAvoid = -1;
   static int lastExpansionTime = 0;
   bool expand = true;

   if (basesToAvoid < 0)
      basesToAvoid = xsArrayCreateInt(5, -1, "Bases to avoid expanding");

   for (i = 0; < 5)
   {
      if (xsArrayGetInt(basesToAvoid, i) == baseID)
      {
         expand = false;
         break;
      }
   }

   float newDistance = 0.0;
   if (expand == true)
   {
      vector baseLocation = kbBaseGetLocation(cMyID, baseID);
      int baseAreaGroup = kbAreaGroupGetIDByPosition(baseLocation);
      int numberAreas = kbAreaGetNumber();
      newDistance = kbBaseGetDistance(cMyID, baseID) + 10.0;
      // make sure new areas we cover are in the same area group
      for (i = 0; < numberAreas)
      {
         vector location = kbAreaGetCenter(i);
         if (distance(location, baseLocation) > newDistance)
            continue;
         if (kbAreaGroupGetIDByPosition(location) == baseAreaGroup)
            continue;
         for (j = 0; < 5)
         {
            if (xsArrayGetInt(basesToAvoid, j) == -1)
            {
               xsArraySetInt(basesToAvoid, baseID);
               break;
            }
         }
         expand = false;
         break;
      }
   }

   if (expand == false)
   {
      /*if (xsIsRuleEnabled("findNewBase") == false)
      {
         xsEnableRule("findNewBase");
         aiEcho("Started searching for a new base location because of not enough build space.");
      }
      int mainBaseID = kbBaseGetMainID(cMyID);
      if (baseID == mainBaseID && kbBaseGetSettlement(cMyID, baseID) == true)
      {
         // find a new base to set as main
         int numberBases = kbBaseGetNumber(cMyID);
         for (i = 0; < numberBases)
         {
             int newBaseID = kbBaseGetIDByIndex(cMyID, i);
             if (newBaseID == mainBaseID)
                continue;
             if (kbBaseGetSettlement(cMyID, newBaseID) == false)
                continue;
             kbBaseSetMain(cMyID, newBaseID, true);
             kbBaseSetMain(cMyID, mainBaseID, false);
             aiEcho("Setting base "+newBaseID+" to main.");
             break;
         }
      }*/
      return;
   }

   if ((xsGetTime() - lastExpansionTime) > 60000)
   {
      aiEcho("Expanding base " + baseID + " to " + newDistance);
      kbBaseSetPositionAndDistance(cMyID, baseID, baseLocation, newDistance);
      lastExpansionTime = xsGetTime();
   }
}

rule findNewBase
inactive
minInterval 10
{
   int numberBases = kbBaseGetNumber(cMyID);
   int mainBaseID = kbBaseGetMainID(cMyID);
   int baseID = -1;
   vector location = cInvalidVector;
   int newBaseID = -1;
   int numberPlans = 0;
   int planID = -1;

   // first go through existing bases.
   for (i = 0; < numberBases)
   {
      baseID = kbBaseGetIDByIndex(cMyID, i);
      location = kbBaseGetLocation(cMyID, baseID);
      if ((baseID == mainBaseID) || (kbBaseGetSettlement(cMyID, baseID) == false) ||
          (getAreaGroupNumberTiles(kbAreaGroupGetIDByPosition(location)) < 2000))
         continue;
      newBaseID = baseID;
      break;
   }

   if (newBaseID >= 0)
   {
      aiSwitchMainBase(newBaseID);
      // kill all existing build plans.
      numberPlans = aiPlanGetActiveCount();
      for (i = 0; < numberPlans)
      {
         planID = aiPlanGetIDByActiveIndex(i);
         if (aiPlanGetType(planID) == cPlanBuild && aiPlanGetState(planID) != cPlanStateBuild)
         {
            aiPlanDestroy(planID);
         }
      }
      xsDisableSelf();
   }
}

//==============================================================================
/* Influence Manager
//
// Train units and research techs with influence resource.
*/
//==============================================================================
rule influenceManager
inactive
minInterval 45
{
   // Maintain plans
   static int influenceUPID = -1;
   static int influenceMaintainPlans = -1;

   if (kbGetAge() >= cAge3 && kbTechGetStatus(cTechDEImportedCannons) == cTechStatusObtainable)
   {
      if (aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechDEImportedCannons) >= 0)
         return;
      createSimpleResearchPlan(cTechDEImportedCannons, getUnit(cUnitTypedePalace), cEconomyEscrowID, 50);
      return;
   }

   if (cvOkToTrainArmy == false)
      return;

   if (influenceUPID < 0)
   {
      // Create it.
      influenceUPID = kbUnitPickCreate("Influence military units");
      if (influenceUPID < 0)
         return;

      influenceMaintainPlans = xsArrayCreateInt(3, -1, "Influence maintain plans");
   }

   int numberResults = 0;
   int i = 0;
   int trainUnitID = -1;
   int planID = -1;
   int numberToMaintain = 0;
   int popCount = 0;
   int buildLimit = 0;
   float totalFactor = 0.0;
   float unitCost = 0.0;

   // Default init.
   kbUnitPickResetAll(influenceUPID);

   // Desired number units types, buildings.
   kbUnitPickSetDesiredNumberUnitTypes(influenceUPID, 2, 1, true);

   //setUnitPickerCommon(influenceUPID);
   
   kbUnitPickSetMinimumCounterModePop(influenceUPID, 15);
   kbUnitPickSetPreferenceFactor(influenceUPID, cUnitTypeMercenary, 1.0);
   kbUnitPickSetPreferenceFactor(influenceUPID, cUnitTypeAbstractNativeWarrior, 1.0);
   kbUnitPickSetPreferenceFactor(influenceUPID, cUnitTypedeMaigadi, 1.0);
   kbUnitPickSetPreferenceFactor(influenceUPID, cUnitTypedeSebastopolMortar, 1.0);
   kbUnitPickSetPreferenceFactor(influenceUPID, cUnitTypeFalconet, 1.0);
   kbUnitPickSetPreferenceFactor(influenceUPID, cUnitTypeOrganGun, 1.0);
   kbUnitPickSetPreferenceFactor(influenceUPID, cUnitTypeCulverin, 1.0);
   kbUnitPickSetPreferenceFactor(influenceUPID, cUnitTypeMortar, 1.0);
   kbUnitPickSetPreferenceFactor(influenceUPID, cUnitTypeypMahout, 1.0);
   kbUnitPickSetPreferenceFactor(influenceUPID, cUnitTypeypHowdah, 1.0);
   kbUnitPickRun(influenceUPID);

   for (i = 0; < 2)
      totalFactor = totalFactor + kbUnitPickGetResultFactor(influenceUPID, i);

   float influenceAmount = kbResourceGet(cResourceInfluence);

   for (i = 0; < 2)
   {
      trainUnitID = kbUnitPickGetResult(influenceUPID, i);
      planID = xsArrayGetInt(influenceMaintainPlans, i);

      if (planID >= 0)
      {
         if (trainUnitID != aiPlanGetVariableInt(planID, cTrainPlanUnitType, 0))
         {
            aiPlanDestroy(planID);
            planID = -1;
         }
      }
      if (trainUnitID < 0)
         continue;

      // if we do not have enough influence for this unit, don't plan training anymore.
      if (influenceAmount > 0.0)
      {
         popCount = kbGetProtoUnitPopCount(trainUnitID);
         unitCost = kbUnitCostPerResource(trainUnitID, cResourceInfluence);
         // hardcoded to at most half of our military pop.
         if (popCount > 0)
         {
            numberToMaintain =
                0.5 * (kbUnitPickGetResultFactor(influenceUPID, i) / totalFactor) * aiGetMilitaryPop() / popCount;
         }
         else
         {
            numberToMaintain = 0.5 * (kbUnitPickGetResultFactor(influenceUPID, i) / totalFactor) * aiGetMilitaryPop() /
                               (unitCost * 0.01);
         }
         buildLimit = kbGetBuildLimit(cMyID, trainUnitID);
         if (buildLimit > 0 && numberToMaintain > buildLimit)
            numberToMaintain = buildLimit;
         influenceAmount =
             influenceAmount - ((numberToMaintain - kbUnitCount(cMyID, trainUnitID, cUnitStateABQ)) * unitCost);
      }
      else
      {
         numberToMaintain = 0;
      }

      if (planID >= 0)
      {
         aiPlanSetVariableInt(planID, cTrainPlanNumberToMaintain, 0, numberToMaintain);
      }
      else
      {
         planID = createSimpleMaintainPlan(trainUnitID, numberToMaintain, false, kbBaseGetMainID(cMyID), 1);
         aiPlanSetDesiredResourcePriority(planID, 45 - i); // below research plans
         xsArraySetInt(influenceMaintainPlans, i, planID);
      }
   }
}

//==============================================================================
// allianceUpgradeMonitor
//
// Researches upgrades gained via alliances for the African civilizations.
// Also researches 2 upgrades which are baseline inside the University / Mountain Monastery.
//
//==============================================================================
rule allianceUpgradeMonitor
inactive
minInterval 45
{
	int upgradePlanID = -1;
	int currentAge = kbGetAge();
	
	if (cMyCiv == cCivDEHausa)
	{
		if (kbUnitCount(cMyID, cUnitTypedeUniversity, cUnitStateABQ) == 0)
			return;
			
		if (currentAge != cAge5)
		{
			if ((kbTechGetStatus(cTechDETimbuktuManuscripts) == cTechStatusObtainable) && (kbGetTechPercentComplete(gAgeUpResearchPlan) < 5)) // Give the AI some space to get it in time.
			{
				upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechDETimbuktuManuscripts);
				if (upgradePlanID < 0)
				{
					createSimpleResearchPlan(cTechDETimbuktuManuscripts, cUnitTypedeUniversity, cEconomyEscrowID, 50);
					return;
				}
			} 
		}
		
		if (xsArrayGetBool(gAfricanAlliancesUpgrades, cAllianceBerbersIndex) == false)
		{
			if (kbTechGetStatus(cTechDENatBerberDesertKings) == cTechStatusObtainable)
			{
				int villagerCount = kbUnitCount(cMyID, cUnitTypeAbstractVillager, cUnitStateABQ);
				upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechDENatBerberDesertKings);
				if ((upgradePlanID >= 0) && (villagerCount < 30))		// Too few Villagers left, destroy the plan.
					aiPlanDestroy(upgradePlanID);
				else if ((upgradePlanID < 0) && (villagerCount >= 30))
				{
					createSimpleResearchPlan(cTechDENatBerberDesertKings, cUnitTypedeUniversity, cEconomyEscrowID, 50);
					return;
				}
			} 
			else
				xsArraySetBool(gAfricanAlliancesUpgrades, cAllianceBerbersIndex, true);
		}
		
		if (xsArrayGetBool(gAfricanAlliancesUpgrades, cAllianceHausaIndex) == false)
		{
			if (kbTechGetStatus(cTechDEAllegianceHausaKanoChronicle) == cTechStatusObtainable)
			{
				upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechDEAllegianceHausaKanoChronicle);
				if (upgradePlanID < 0)
				{
					createSimpleResearchPlan(cTechDEAllegianceHausaKanoChronicle, cUnitTypedeUniversity, cEconomyEscrowID, 50);
					return;
				}
			} 
			else if (kbTechGetStatus(cTechDEAllegianceHausaArewa) == cTechStatusObtainable)
			{
				upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechDEAllegianceHausaArewa);
				if (upgradePlanID < 0)
				{
					createSimpleResearchPlan(cTechDEAllegianceHausaArewa, cUnitTypedeUniversity, cEconomyEscrowID, 50);
					return;
				}
			}
			else 
				xsArraySetBool(gAfricanAlliancesUpgrades, cAllianceHausaIndex, true);
		}
		
		if (xsArrayGetBool(gAfricanAlliancesUpgrades, cAllianceSonghaiIndex) == false)
		{
			if (kbTechGetStatus(cTechDEAllegianceSonghaiTimbuktuChronicle) == cTechStatusObtainable)
			{
				upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechDEAllegianceSonghaiTimbuktuChronicle);
				if (upgradePlanID < 0)
				{
					createSimpleResearchPlan(cTechDEAllegianceSonghaiTimbuktuChronicle, cUnitTypedeUniversity, cEconomyEscrowID, 50);
					return;
				}
			}
			else 
				xsArraySetBool(gAfricanAlliancesUpgrades, cAllianceSonghaiIndex, true);			
		}
	
		if (xsArrayGetBool(gAfricanAlliancesUpgrades, cAllianceAkanIndex) == false)
		{
			if (kbTechGetStatus(cTechDENatAkanGoldEconomy) == cTechStatusObtainable)
			{
				upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechDENatAkanGoldEconomy);
				if (upgradePlanID < 0)
				{
					createSimpleResearchPlan(cTechDENatAkanGoldEconomy, cUnitTypedeUniversity, cEconomyEscrowID, 50);
					return;
				}
			}
			else 
				xsArraySetBool(gAfricanAlliancesUpgrades, cAllianceAkanIndex, true);			
		}
	}
		
	// Ethiopia.
	else if (cMyCiv == cCivDEEthiopians)
	{
		if (kbUnitCount(cMyID, cUnitTypedeMountainMonastery, cUnitStateABQ) == 0)
			return;
			
		if (currentAge != cAge5)
		{
			if ((kbTechGetStatus(cTechDEAxumChronicle) == cTechStatusObtainable) && (kbGetTechPercentComplete(gAgeUpResearchPlan) < 5)) // Give the AI some space to get it in time.
			{
				upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechDEAxumChronicle);
				if (upgradePlanID < 0)
				{
					createSimpleResearchPlan(cTechDEAxumChronicle, cUnitTypedeMountainMonastery, cEconomyEscrowID, 50);
					return;
				}
			} 
		}
		
		if (currentAge >= cAge4)
		{
			if (kbTechGetStatus(cTechDESolomonicDynasty) == cTechStatusObtainable)
			{
				upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechDESolomonicDynasty);
				if (upgradePlanID < 0)
				{
					createSimpleResearchPlan(cTechDESolomonicDynasty, cUnitTypedeMountainMonastery, cEconomyEscrowID, 50);
					return;
				}
			} 
		}
		
		if (xsArrayGetBool(gAfricanAlliancesUpgrades, cAllianceSomalisIndex) == false)
		{
			if ((kbTechGetStatus(cTechDENatSomaliBerberaSeaport) == cTechStatusObtainable) && (getUnit(cUnitTypeHomeCityWaterSpawnFlag) > 0))
			{
				upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechDENatSomaliBerberaSeaport);
				if (upgradePlanID < 0)		
				{
					createSimpleResearchPlan(cTechDENatSomaliBerberaSeaport, cUnitTypedeMountainMonastery, cEconomyEscrowID, 50);
					return;
				}
			} 
			else
				xsArraySetBool(gAfricanAlliancesUpgrades, cAllianceSomalisIndex, true);
		}
		
		if (xsArrayGetBool(gAfricanAlliancesUpgrades, cAlliancePortugueseIndex) == false)
		{
			if (kbTechGetStatus(cTechDEAllegiancePortugueseCrusaders) == cTechStatusObtainable)
			{
				upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechDEAllegiancePortugueseCrusaders);
				if (upgradePlanID < 0)		
				{
					createSimpleResearchPlan(cTechDEAllegiancePortugueseCrusaders, cUnitTypedeMountainMonastery, cEconomyEscrowID, 50);
					return;
				}
			}
			else if (kbTechGetStatus(cTechDEAllegiancePortugueseOrgans) == cTechStatusObtainable)
			{
				if (kbUnitCount(cMyID, cUnitTypedeMountainMonastery, cUnitStateABQ) >= 3)
				{
					upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechDEAllegiancePortugueseOrgans);
					if (upgradePlanID < 0)		
					{
						createSimpleResearchPlan(cTechDEAllegiancePortugueseOrgans, cUnitTypedeMountainMonastery, cEconomyEscrowID, 45);
						return;
					}
				}
			}
			else if (currentAge >= cAge3)
				xsArraySetBool(gAfricanAlliancesUpgrades, cAlliancePortugueseIndex, true);
		}
		
		if (xsArrayGetBool(gAfricanAlliancesUpgrades, cAllianceSudaneseIndex) == false)
		{
			if (kbTechGetStatus(cTechDENatSudaneseRedSeaTrade) == cTechStatusObtainable)
			{
				upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechDENatSudaneseRedSeaTrade);
				if (upgradePlanID < 0)		
				{
					createSimpleResearchPlan(cTechDENatSudaneseRedSeaTrade, cUnitTypedeMountainMonastery, cEconomyEscrowID, 50);
					return;
				}
			}
			else if (kbTechGetStatus(cTechDENatSudaneseQuiltedArmor) == cTechStatusObtainable)
			{
				upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechDENatSudaneseQuiltedArmor);
				if (upgradePlanID < 0)		
				{
					createSimpleResearchPlan(cTechDENatSudaneseQuiltedArmor, cUnitTypedeMountainMonastery, cEconomyEscrowID, 50);
					return;
				}
			}
			else
				xsArraySetBool(gAfricanAlliancesUpgrades, cAllianceSudaneseIndex, true);
		}
		
		if (xsArrayGetBool(gAfricanAlliancesUpgrades, cAllianceJesuitIndex) == false)
		{
			if (kbTechGetStatus(cTechYPNatJesuitSchools) == cTechStatusObtainable)
			{
				upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPNatJesuitSchools);
				if (upgradePlanID < 0)		
				{
					createSimpleResearchPlan(cTechYPNatJesuitSchools, cUnitTypedeMountainMonastery, cEconomyEscrowID, 60);
					return;
				}
			}
			else if (kbTechGetStatus(cTechYPNatJesuitSmokelessPowder) == cTechStatusObtainable)
			{
				upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPNatJesuitSmokelessPowder);
				If ((upgradePlanID > 0) && 
				   (kbUnitCount(cMyID, cUnitTypeAbstractGunpowderTrooper, cUnitStateABQ) < 12) && 
					(kbUnitCount(cMyID, cUnitTypeAbstractArtillery, cUnitStateABQ) < 3))
					aiPlanDestroy(upgradePlanID);   // Too few units left who benefit so destroy the plan.
				else if ((upgradePlanID < 0) && 
				   ((kbUnitCount(cMyID, cUnitTypeAbstractGunpowderTrooper, cUnitStateABQ) >= 12) || (kbUnitCount(cMyID, cUnitTypeAbstractArtillery, cUnitStateABQ) >= 3)))		
				{
					createSimpleResearchPlan(cTechYPNatJesuitSmokelessPowder, cUnitTypedeMountainMonastery, cEconomyEscrowID, 50);
					return;
				}
			}
			else
				xsArraySetBool(gAfricanAlliancesUpgrades, cAllianceJesuitIndex, true);
		}
		
		if (xsArrayGetBool(gAfricanAlliancesUpgrades, cAllianceOromoIndex) == false)
		{
			if (kbTechGetStatus(cTechDEAllegianceOromoUnits) == cTechStatusObtainable)
			{
				upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechDEAllegianceOromoUnits);
				if (upgradePlanID < 0)		
				{
					createSimpleResearchPlan(cTechDEAllegianceOromoUnits, cUnitTypedeMountainMonastery, cEconomyEscrowID, 55);
					return;
				}
			}
			else
				xsArraySetBool(gAfricanAlliancesUpgrades, cAllianceOromoIndex, true);
		}
	}
	
	// If all the values in the bool array are set to true it means we can disable this rule, but first make sure we actually can't research any more Alliances.
	if (currentAge == cAge5)
	{
		bool canDisableSelf = true;
		for (i = 0; < 5)
		{
			if (xsArrayGetBool(gAfricanAlliancesUpgrades, i) == false)
				canDisableSelf = false;
		}
		if ((cMyCiv == cCivDEEthiopians) && (kbTechGetStatus(cTechDESolomonicDynasty) != cTechStatusActive))
			canDisableSelf = false;
		if (canDisableSelf == true)
		{	
			aiEcho("Disabling rule allianceUpgradeMonitor since we have all upgrades active");
			xsDisableSelf();
		}
	}
}

//==============================================================================
/* Livestock market monitor
//
// Manages selling livestock.
*/
//==============================================================================
rule livestockMarketMonitor
inactive
minInterval 20
{
   if (kbUnitCount(cMyID, cUnitTypedeLivestockMarket, cUnitStateAlive) == 0)
      return;

   static int herdableQuery = -1;
   static bool sellEarlyForWood = false;

   if (herdableQuery < 0)
   {
      herdableQuery = kbUnitQueryCreate("Herdable query for livestock selling");
      kbUnitQuerySetPlayerID(herdableQuery, cMyID);
      kbUnitQuerySetUnitType(herdableQuery, cUnitTypeHerdable);
      kbUnitQuerySetState(herdableQuery, cUnitStateAlive);
      if (gSPC == false && xsIsRuleEnabled("houseMonitor") == false)
         sellEarlyForWood = true;
   }

   kbUnitQueryResetResults(herdableQuery);

   int herdableCount = kbUnitQueryExecute(herdableQuery);
   int herdableID = -1;
   int bestHerdableID = -1;
   float bestAmount = 0.0;
   float amount = 0.0;
   int sellingResource = cResourceWood;

   if (sellEarlyForWood == false)
   {
      float maxRate = aiLivestockGetMaximumRate();
      if (xsArrayGetFloat(gResourceNeeds, cResourceGold) > xsArrayGetFloat(gResourceNeeds, cResourceWood))
         sellingResource = cResourceGold;
      if (aiLivestockGetExchangeRate(sellingResource) < maxRate)
         return;
   }
   else
   {
      if (xsGetTime() < 60000)
         return;
   }

   for (i = 0; < herdableCount)
   {
      herdableID = kbUnitQueryGetResult(herdableQuery, i);
      amount = kbUnitGetResourceAmount(herdableID, cResourceFood);
      if (bestAmount < amount)
      {
         bestHerdableID = herdableID;
         bestAmount = amount;
      }
   }

   // Just sell when we reached maximum exchange rate and the herdable's carry capacity.
   if (sellEarlyForWood == false)
   {
      if (bestAmount < kbUnitGetCarryCapacity(bestHerdableID, cResourceFood))
         return;
   }

   aiLivestockSell(sellingResource, bestHerdableID);

   if (sellEarlyForWood == true)
   {
      xsEnableRule("houseMonitor");
      houseMonitor();
      sellEarlyForWood = false;
   }
}

//==============================================================================
// hackGoldGatherPlanMountainMonastery
//==============================================================================
rule hackGoldGatherPlanMountainMonastery
inactive
minInterval 5
{
   int unitID = getUnit(cUnitTypedeMountainMonastery);
   if (unitID < 0)
      return;
   int planID = aiPlanGetIDByTypeAndVariableType(cPlanGather, cGatherPlanResourceType, cResourceGold);
   if (planID >= 0)
   {
      int numResources = kbResourceGetNumber();
      for (i = 0; < numResources)
      {
         int resourceID = kbResourceGetIDByIndex(i);
         if (kbResourceGetUnit(resourceID, 0) == unitID)
         {
            aiPlanSetVariableInt(planID, cGatherPlanKBResourceID, 0, resourceID);
            break;
         }
      }
   }
   xsDisableSelf();
}
rule brigadeMonitor
inactive
mininterval 10
{
   // Quit if there is no consulate
   if (kbUnitCount(cMyID, cUnitTypeypConsulate, cUnitStateAlive) < 1)
   {
      return;
   }

   // Research brigade technologies
   // Unavailable ones are simply ignored
   int brigadePlanID = -1;

   // British brigade
   if (kbTechGetStatus(cTechypConsulateBritishBrigade) == cTechStatusObtainable)
   {
      brigadePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypConsulateBritishBrigade);
      if (brigadePlanID >= 0)
         aiPlanDestroy(brigadePlanID);
      createSimpleResearchPlan(cTechypConsulateBritishBrigade, getUnit(cUnitTypeypConsulate), cMilitaryEscrowID, 50);
      return;
   }

   // Dutch brigade
   if (kbTechGetStatus(cTechypConsulateDutchBrigade) == cTechStatusObtainable)
   {
      brigadePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypConsulateDutchBrigade);
      if (brigadePlanID >= 0)
         aiPlanDestroy(brigadePlanID);
      createSimpleResearchPlan(cTechypConsulateDutchBrigade, getUnit(cUnitTypeypConsulate), cMilitaryEscrowID, 50);
      return;
   }

   // French brigade
   if (kbTechGetStatus(cTechypConsulateFrenchBrigade) == cTechStatusObtainable)
   {
      brigadePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypConsulateFrenchBrigade);
      if (brigadePlanID >= 0)
         aiPlanDestroy(brigadePlanID);
      createSimpleResearchPlan(cTechypConsulateFrenchBrigade, getUnit(cUnitTypeypConsulate), cMilitaryEscrowID, 50);
      return;
   }

   // German brigade
   if (kbTechGetStatus(cTechypConsulateGermansBrigade) == cTechStatusObtainable)
   {
      brigadePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypConsulateGermansBrigade);
      if (brigadePlanID >= 0)
         aiPlanDestroy(brigadePlanID);
      createSimpleResearchPlan(cTechypConsulateGermansBrigade, getUnit(cUnitTypeypConsulate), cMilitaryEscrowID, 50);
      return;
   }

   // Ottoman brigade
   if (kbTechGetStatus(cTechypConsulateOttomansBrigade) == cTechStatusObtainable)
   {
      brigadePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypConsulateOttomansBrigade);
      if (brigadePlanID >= 0)
         aiPlanDestroy(brigadePlanID);
      createSimpleResearchPlan(cTechypConsulateOttomansBrigade, getUnit(cUnitTypeypConsulate), cMilitaryEscrowID, 50);
      return;
   }

   // Portuguese brigade
   if (kbTechGetStatus(cTechypConsulatePortugueseBrigade) == cTechStatusObtainable)
   {
      brigadePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypConsulatePortugueseBrigade);
      if (brigadePlanID >= 0)
         aiPlanDestroy(brigadePlanID);
      createSimpleResearchPlan(cTechypConsulatePortugueseBrigade, getUnit(cUnitTypeypConsulate), cMilitaryEscrowID, 50);
      return;
   }

   // Russian brigade
   if (kbTechGetStatus(cTechypConsulateRussianBrigade) == cTechStatusObtainable)
   {
      brigadePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypConsulateRussianBrigade);
      if (brigadePlanID >= 0)
         aiPlanDestroy(brigadePlanID);
      createSimpleResearchPlan(cTechypConsulateRussianBrigade, getUnit(cUnitTypeypConsulate), cMilitaryEscrowID, 50);
      return;
   }

   // Spanish brigade
   if (kbTechGetStatus(cTechypConsulateSpanishBrigade) == cTechStatusObtainable)
   {
      brigadePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypConsulateSpanishBrigade);
      if (brigadePlanID >= 0)
         aiPlanDestroy(brigadePlanID);
      createSimpleResearchPlan(cTechypConsulateSpanishBrigade, getUnit(cUnitTypeypConsulate), cMilitaryEscrowID, 50);
      return;
   }
}

rule capitolUpgradeMonitor
inactive
minInterval 40
{
   int upgradePlanID = -1;

   // Disable rule for native or Asian civs
   if (civIsEuropean() == false)
   {
      xsDisableSelf();
      return;
   }

   // Disable rule once all upgrades are available
   if ((kbTechGetStatus(cTechImpKnighthood) == cTechStatusActive) &&
       (kbTechGetStatus(cTechImpPeerage) == cTechStatusActive) &&
       (kbTechGetStatus(cTechImpLargeScaleAgriculture) == cTechStatusActive) &&
       (kbTechGetStatus(cTechImpDeforestation) == cTechStatusActive) &&
       (kbTechGetStatus(cTechImpExcessiveTaxation) == cTechStatusActive) &&
       (kbTechGetStatus(cTechImpImmigrants) == cTechStatusActive) &&
       (kbTechGetStatus(cTechImpLegendaryNatives) == cTechStatusActive))
   {
      xsDisableSelf();
      return;
   }

   // Get upgrades one at a time as they become available
   if (kbTechGetStatus(cTechImpKnighthood) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImpKnighthood);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechImpKnighthood, getUnit(cUnitTypeCapitol), cMilitaryEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechImpPeerage) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImpPeerage);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechImpPeerage, getUnit(cUnitTypeCapitol), cMilitaryEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechImpLargeScaleAgriculture) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImpLargeScaleAgriculture);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechImpLargeScaleAgriculture, getUnit(cUnitTypeCapitol), cEconomyEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechImpDeforestation) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImpDeforestation);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechImpDeforestation, getUnit(cUnitTypeCapitol), cEconomyEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechImpExcessiveTaxation) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImpExcessiveTaxation);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechImpExcessiveTaxation, getUnit(cUnitTypeCapitol), cEconomyEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechImpImmigrants) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImpImmigrants);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechImpImmigrants, getUnit(cUnitTypeCapitol), cEconomyEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechImpLegendaryNatives) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImpLegendaryNatives);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechImpLegendaryNatives, getUnit(cUnitTypeCapitol), cMilitaryEscrowID, 50);
      return;
   }
}
rule autoFeedLowestAlly
inactive
mininterval 10
{  

	 
	 
	float goldAmount = 0.0;
	float woodAmount = 0.0;
	float foodAmount = 0.0;

	goldAmount = kbResourceGet(cResourceGold);
	woodAmount = kbResourceGet(cResourceWood);
	foodAmount = kbResourceGet(cResourceFood);
	
   //int lowestAgeAlly = cAge5;
   int totalScoreAlly = 0;
   int averageScoreAlly = 0;
   int player = 1;

   for (player=0; < cNumberPlayers)
   {
      if (kbIsPlayerAlly(player) == true)
      {
	 totalScoreAlly = totalScoreAlly + aiGetScore(player);

	 //if (kbGetAgeForPlayer(player) < lowestAgeAlly)
	  //lowestAgeAlly = kbGetAgeForPlayer(player); 
      }
   }
   averageScoreAlly = totalScoreAlly / (getAllyCount() + 1);
   
   
for (player=0; < cNumberPlayers)
   {
      if (player == cMyID)
	continue;      
      if (kbIsPlayerAlly(player) == true)
      {
         //if ((kbGetPopCap() - kbGetPop() < 20) && 
           if ((aiGetScore(player) < averageScoreAlly * 0.8) && 
              (kbHasPlayerLost(player) == false) ) 
	 {
            if (goldAmount > 12000)
            {
           aiTribute(player, cResourceFood, 4000);
               //sendStatement(cPlayerRelationAlly, cAICommPromptToAllyITributedFood);
            }
            if (woodAmount > 12000)
            {
	       aiTribute(player, cResourceWood, 4000);
               //sendStatement(cPlayerRelationAlly, cAICommPromptToAllyITributedWood);
            }
            if (goldAmount > 12000)
            {
	       aiTribute(player, cResourceGold, 4000);
               //sendStatement(cPlayerRelationAlly, cAICommPromptToAllyITributedCoin);
            }
	 }
      }
   }
} 
rule ShrineGoatMonitor
inactive
minInterval 15
{

   static int cowPlan = -1;
   int numHerdables = 0;
   int numCows = 0;

   // Quit if there is no sacred field around or we're in age1 without excess food
   if (kbResourceGet(cResourceFood) < 4000)
   {
      return;
   }

   // Check number of captured herdables, add sacred cows as necessary to bring total number to 10
   numHerdables = kbUnitCount(cMyID, cUnitTypeypGoat, cUnitStateAlive);
   numCows = (30 - numHerdables);
   if (numCows > 0)
   {
      // Create/update maintain plan
      if (cowPlan < 0)
      {
         cowPlan = createSimpleMaintainPlan(cUnitTypeypGoat, numCows, true, kbBaseGetMainID(cMyID), 1);
      }
      else
      {
         aiPlanSetVariableInt(cowPlan, cTrainPlanNumberToMaintain, 0, numCows);
      }
   }
}

rule sendChatToMyAllies
inactive
group tcComplete
mininterval 10
{
	if (gSPC == true)
	{
	xsDisableSelf();
	return;
	}
	
    static bool agingUpTo2ChatSent = false;
    static bool agingUpTo3ChatSent = false;
    static bool agingUpTo4ChatSent = false;
    static bool agingUpTo5ChatSent = false;

    if (agingUpTo2ChatSent == false)
    {
       if (agingUpTo(cAge2) == true)
       {
	   sendChatToAllies("Aging up to Colonial soon");          
	   econMaster();
	   xsEnableRule("age2Monitor");
	   agingUpTo2ChatSent = true;
       }       
    }
    if (agingUpTo3ChatSent == false)
    {
       if (agingUpTo(cAge3) == true)
       { 
	  sendChatToAllies("Aging up to Fortress soon");        
	  econMaster();
	  xsEnableRule("age3Monitor");
	  agingUpTo3ChatSent = true;
       }
     }
     if (agingUpTo4ChatSent == false)
     {
	if (agingUpTo(cAge4) == true) 
	{
	   sendChatToAllies("Aging up to Industrial soon");
	   econMaster();
	   xsEnableRule("age4Monitor");
	   agingUpTo4ChatSent = true;
	}
     }
     if (agingUpTo5ChatSent == false)
     {
	if (agingUpTo(cAge5) == true)
	{ 
	   sendChatToAllies("Aging up to Imperial soon");
	   econMaster();           
	   xsEnableRule("age5Monitor");
	   agingUpTo5ChatSent = true;
	}
    }

    static bool strategyChatSent = false;
    if (strategyChatSent == false)
    {
       if (xsGetTime() > 10000)
       {
	  strategyChatSent = true;
	  if (kbGetAge() >= cAge1)
	  {
	     if (gInitialStrategy == 0)
		sendChatToAllies("Target Strategy: FI");
	     if (gInitialStrategy == 1)
		sendChatToAllies("Target Strategy: Rush");
             if (gInitialStrategy == 2)	
                sendChatToAllies("Target Strategy: FF");
             if (gInitialStrategy == 3)
                sendChatToAllies("Target Strategy: Turtle");
          }
       }
    }

    static int lastTribSentTime = 0;
	
	/*
	int age = kbGetAge();
	if (age == cvMaxAge)
       xsDisableSelf();
       return;
    /////////Tell allies your military combination/////////
	
    int gLandUnit = kbUnitPickGetResult(gLandUnitPicker, 0);
    string namePrimary = kbGetUnitTypeName(gLandUnit);
    if (kbUnitPickGetResult(gLandUnitPicker, 0) < 1)
    namePrimary = kbGetUnitTypeName(gLandPrimaryArmyUnit);		
	   
       if ( ((xsGetTime() - lastTribSentTime) > 4*60*1000) && (kbUnitCount(cMyID, cUnitTypeLogicalTypeLandMilitary, cUnitStateAlive) > 1) && (gSPC == false) && (xsGetTime() > 5*60*1000) && (kbUnitPickGetResult(gLandUnitPicker, 0) < 1))
       {
          sendChatToAllies("Primary Army Unit: "+namePrimary+"");
          lastTribSentTime = xsGetTime();
       }
	   */
    /////////////////////////////////////////////////////////
}